[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Collection Ordering"}, {"type": "p", "text": "The order of elements is an important aspect of certain collection types.\nFor example, two lists of the same elements are not equal if their elements are ordered differently."}, {"type": "p", "text": "In Kotlin, the orders of objects can be defined in several ways."}, {"type": "p", "text": "First, there is natural order. It is defined for inheritors of the Comparable interface.\nNatural order is used for sorting them when no other order is specified."}, {"type": "em", "text": "natural"}, {"type": "a", "text": "Comparable"}, {"type": "code", "text": "Comparable"}, {"type": "p", "text": "Most built-in types are comparable:"}, {"type": "ul", "text": "\nNumeric types use the traditional numerical order: 1 is greater than 0; -3.4f is greater than -5f, and so on.\nChar and String use the lexicographical order: b is greater than a; world is greater than hello.\n"}, {"type": "li", "text": "Numeric types use the traditional numerical order: 1 is greater than 0; -3.4f is greater than -5f, and so on."}, {"type": "code", "text": "1"}, {"type": "code", "text": "0"}, {"type": "code", "text": "-3.4f"}, {"type": "code", "text": "-5f"}, {"type": "li", "text": "Char and String use the lexicographical order: b is greater than a; world is greater than hello."}, {"type": "code", "text": "Char"}, {"type": "code", "text": "String"}, {"type": "a", "text": "lexicographical order"}, {"type": "code", "text": "b"}, {"type": "code", "text": "a"}, {"type": "code", "text": "world"}, {"type": "code", "text": "hello"}, {"type": "p", "text": "To define a natural order for a user-defined type, make the type an inheritor of Comparable.\nThis requires implementing the compareTo() function. compareTo() must take another object of the same type as an argument and return an integer value showing which object is greater:"}, {"type": "code", "text": "Comparable"}, {"type": "code", "text": "compareTo()"}, {"type": "code", "text": "compareTo()"}, {"type": "ul", "text": "\nPositive values show that the receiver object is greater.\nNegative values show that it's less than the argument.\nZero shows that the objects are equal.\n"}, {"type": "li", "text": "Positive values show that the receiver object is greater."}, {"type": "li", "text": "Negative values show that it's less than the argument."}, {"type": "li", "text": "Zero shows that the objects are equal."}, {"type": "p", "text": "Below is a class that can be used for ordering versions that consist of the major and the minor part."}, {"type": "div", "text": "\nclass Version(val major: Int, val minor: Int): Comparable<Version> {\n    override fun compareTo(other: Version): Int {\n        if (this.major != other.major) {\n            return this.major - other.major\n        } else if (this.minor != other.minor) {\n            return this.minor - other.minor\n        } else return 0\n    }\n}\n\nfun main() {    \n    println(Version(1, 2) > Version(1, 3))\n    println(Version(2, 0) > Version(1, 5))\n}\n\n"}, {"type": "pre", "text": "class Version(val major: Int, val minor: Int): Comparable<Version> {\n    override fun compareTo(other: Version): Int {\n        if (this.major != other.major) {\n            return this.major - other.major\n        } else if (this.minor != other.minor) {\n            return this.minor - other.minor\n        } else return 0\n    }\n}\n\nfun main() {    \n    println(Version(1, 2) > Version(1, 3))\n    println(Version(2, 0) > Version(1, 5))\n}\n"}, {"type": "code", "text": "class Version(val major: Int, val minor: Int): Comparable<Version> {\n    override fun compareTo(other: Version): Int {\n        if (this.major != other.major) {\n            return this.major - other.major\n        } else if (this.minor != other.minor) {\n            return this.minor - other.minor\n        } else return 0\n    }\n}\n\nfun main() {    \n    println(Version(1, 2) > Version(1, 3))\n    println(Version(2, 0) > Version(1, 5))\n}\n"}, {"type": "p", "text": "Custom orders let you sort instances of any type in a way you like.\nParticularly, you can define an order for non-comparable objects or define an order other than natural for a comparable type.\nTo define a custom order for a type, create a Comparator for it.\nComparator contains the compare() function: it takes two instances of a class and returns the integer result of the comparison between them.\nThe result is interpreted in the same way as the result of a compareTo() as is described above."}, {"type": "em", "text": "Custom"}, {"type": "a", "text": "Comparator"}, {"type": "code", "text": "Comparator"}, {"type": "code", "text": "Comparator"}, {"type": "code", "text": "compare()"}, {"type": "code", "text": "compareTo()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val lengthComparator = Comparator { str1: String, str2: String -> str1.length - str2.length }\n    println(listOf(\"aaa\", \"bb\", \"c\").sortedWith(lengthComparator))\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val lengthComparator = Comparator { str1: String, str2: String -> str1.length - str2.length }\n    println(listOf(\"aaa\", \"bb\", \"c\").sortedWith(lengthComparator))\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val lengthComparator = Comparator { str1: String, str2: String -> str1.length - str2.length }\n    println(listOf(\"aaa\", \"bb\", \"c\").sortedWith(lengthComparator))\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "Having the lengthComparator, you are able to arrange strings by their length instead of the default lexicographical order."}, {"type": "code", "text": "lengthComparator"}, {"type": "p", "text": "A shorter way to define a Comparator is the compareBy() function from the standard library.\ncompareBy() takes a lambda function that produces a Comparable value from an instance and defines the custom order as the natural order of the produced values.\nWith compareBy(), the length comparator from the example above looks like this:"}, {"type": "code", "text": "Comparator"}, {"type": "a", "text": "compareBy()"}, {"type": "code", "text": "compareBy()"}, {"type": "code", "text": "compareBy()"}, {"type": "code", "text": "Comparable"}, {"type": "code", "text": "compareBy()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart    \nprintln(listOf(\"aaa\", \"bb\", \"c\").sortedWith(compareBy { it.length }))\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart    \nprintln(listOf(\"aaa\", \"bb\", \"c\").sortedWith(compareBy { it.length }))\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart    \nprintln(listOf(\"aaa\", \"bb\", \"c\").sortedWith(compareBy { it.length }))\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "The Kotlin collections package provides functions for sorting collections in natural, custom, and even random orders.\nOn this page, we'll describe sorting functions that apply to read-only collections.\nThese functions return their result as a new collection containing the elements of the original collection in the requested order.\nTo learn about functions for sorting mutable collections in place, see the List Specific Operations."}, {"type": "a", "text": "read-only"}, {"type": "a", "text": "mutable"}, {"type": "a", "text": "List Specific Operations"}, {"type": "h2", "text": "Natural order"}, {"type": "p", "text": "The basic functions sorted() and sortedDescending() return elements of a collection sorted into ascending and descending sequence according to their natural order.\nThese functions apply to collections of Comparable elements."}, {"type": "a", "text": "sorted()"}, {"type": "code", "text": "sorted()"}, {"type": "a", "text": "sortedDescending()"}, {"type": "code", "text": "sortedDescending()"}, {"type": "code", "text": "Comparable"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(\"Sorted ascending: ${numbers.sorted()}\")\n    println(\"Sorted descending: ${numbers.sortedDescending()}\")\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(\"Sorted ascending: ${numbers.sorted()}\")\n    println(\"Sorted descending: ${numbers.sortedDescending()}\")\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(\"Sorted ascending: ${numbers.sorted()}\")\n    println(\"Sorted descending: ${numbers.sortedDescending()}\")\n//sampleEnd\n}\n\n"}, {"type": "h2", "text": "Custom orders"}, {"type": "p", "text": "For sorting in custom orders or sorting non-comparable objects, there are the functions sortedBy() and sortedByDescending().\nThey take a selector function that maps collection elements to Comparable values and sort the collection in natural order of that values."}, {"type": "a", "text": "sortedBy()"}, {"type": "code", "text": "sortedBy()"}, {"type": "a", "text": "sortedByDescending()"}, {"type": "code", "text": "sortedByDescending()"}, {"type": "code", "text": "Comparable"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    val sortedNumbers = numbers.sortedBy { it.length }\n    println(\"Sorted by length ascending: $sortedNumbers\")\n    val sortedByLast = numbers.sortedByDescending { it.last() }\n    println(\"Sorted by the last letter descending: $sortedByLast\")\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    val sortedNumbers = numbers.sortedBy { it.length }\n    println(\"Sorted by length ascending: $sortedNumbers\")\n    val sortedByLast = numbers.sortedByDescending { it.last() }\n    println(\"Sorted by the last letter descending: $sortedByLast\")\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    val sortedNumbers = numbers.sortedBy { it.length }\n    println(\"Sorted by length ascending: $sortedNumbers\")\n    val sortedByLast = numbers.sortedByDescending { it.last() }\n    println(\"Sorted by the last letter descending: $sortedByLast\")\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "To define a custom order for the collection sorting, you can provide your own Comparator.\nTo do this, call the sortedWith() function passing in your Comparator.\nWith this function, sorting strings by their length looks like this:"}, {"type": "code", "text": "Comparator"}, {"type": "a", "text": "sortedWith()"}, {"type": "code", "text": "sortedWith()"}, {"type": "code", "text": "Comparator"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(\"Sorted by length ascending: ${numbers.sortedWith(compareBy { it.length })}\")\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(\"Sorted by length ascending: ${numbers.sortedWith(compareBy { it.length })}\")\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(\"Sorted by length ascending: ${numbers.sortedWith(compareBy { it.length })}\")\n//sampleEnd\n}\n\n"}, {"type": "h2", "text": "Reverse order"}, {"type": "p", "text": "You can retrieve the collection in the reversed order using the reversed() function."}, {"type": "a", "text": "reversed()"}, {"type": "code", "text": "reversed()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.reversed())\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.reversed())\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.reversed())\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "reversed() returns a new collection with the copies of the elements.\nSo, if you change the original collection later, this won't affect the previously obtained results of reversed()."}, {"type": "code", "text": "reversed()"}, {"type": "code", "text": "reversed()"}, {"type": "p", "text": "Another reversing function - asReversed() - returns a reversed view of the same collection instance, so it may be more lightweight and preferable than reversed() if the original list is not going to change."}, {"type": "a", "text": "asReversed()"}, {"type": "code", "text": "asReversed()"}, {"type": "code", "text": "reversed()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val reversedNumbers = numbers.asReversed()\n    println(reversedNumbers)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val reversedNumbers = numbers.asReversed()\n    println(reversedNumbers)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val reversedNumbers = numbers.asReversed()\n    println(reversedNumbers)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "If the original list is mutable, all its changes reflect in its reversed views and vice versa."}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n    val reversedNumbers = numbers.asReversed()\n    println(reversedNumbers)\n    numbers.add(\"five\")\n    println(reversedNumbers)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n    val reversedNumbers = numbers.asReversed()\n    println(reversedNumbers)\n    numbers.add(\"five\")\n    println(reversedNumbers)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n    val reversedNumbers = numbers.asReversed()\n    println(reversedNumbers)\n    numbers.add(\"five\")\n    println(reversedNumbers)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "However, if the mutability of the list is unknown or the source is not a list at all, reversed() is more preferable since its result is a copy that won't change in the future."}, {"type": "code", "text": "reversed()"}, {"type": "h2", "text": "Random order"}, {"type": "p", "text": "Finally, there is a function that returns a new List containing the collection elements in a random order - shuffled().\nYou can call it without arguments or with a Random object."}, {"type": "code", "text": "List"}, {"type": "a", "text": "shuffled()"}, {"type": "code", "text": "shuffled()"}, {"type": "a", "text": "Random"}, {"type": "code", "text": "Random"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n     val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n     println(numbers.shuffled())\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n     val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n     println(numbers.shuffled())\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n     val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n     println(numbers.shuffled())\n//sampleEnd\n}\n\n"}]