[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Destructuring Declarations"}, {"type": "p", "text": "Sometimes it is convenient to destructure an object into a number of variables, for example:"}, {"type": "em", "text": "destructure"}, {"type": "div", "text": "\nval (name, age) = person \n\n"}, {"type": "pre", "text": "val (name, age) = person \n"}, {"type": "code", "text": "val (name, age) = person \n"}, {"type": "p", "text": "This syntax is called a destructuring declaration. A destructuring declaration creates multiple variables at once.\nWe have declared two new variables: name and age, and can use them independently:"}, {"type": "em", "text": "destructuring declaration"}, {"type": "code", "text": "name"}, {"type": "code", "text": "age"}, {"type": "div", "text": "\nprintln(name)\nprintln(age)\n\n"}, {"type": "pre", "text": "println(name)\nprintln(age)\n"}, {"type": "code", "text": "println(name)\nprintln(age)\n"}, {"type": "p", "text": "A destructuring declaration is compiled down to the following code:"}, {"type": "div", "text": "\nval name = person.component1()\nval age = person.component2()\n\n"}, {"type": "pre", "text": "val name = person.component1()\nval age = person.component2()\n"}, {"type": "code", "text": "val name = person.component1()\nval age = person.component2()\n"}, {"type": "p", "text": "The component1() and component2() functions are another example of the principle of conventions widely used in Kotlin \n(see operators like + and *, for-loops etc.). \nAnything can be on the right-hand side of a destructuring declaration, as long as the required number of component functions can be called on it.\nAnd, of course, there can be component3() and component4() and so on."}, {"type": "code", "text": "component1()"}, {"type": "code", "text": "component2()"}, {"type": "em", "text": "principle of conventions"}, {"type": "code", "text": "+"}, {"type": "code", "text": "*"}, {"type": "em", "text": "for"}, {"type": "code", "text": "component3()"}, {"type": "code", "text": "component4()"}, {"type": "p", "text": "Note that the componentN() functions need to be marked with the operator keyword to allow using them in a destructuring declaration."}, {"type": "code", "text": "componentN()"}, {"type": "code", "text": "operator"}, {"type": "p", "text": "Destructuring declarations also work in for-loops: when you say:"}, {"type": "em", "text": "for"}, {"type": "div", "text": "\nfor ((a, b) in collection) { ... }\n\n"}, {"type": "pre", "text": "for ((a, b) in collection) { ... }\n"}, {"type": "code", "text": "for ((a, b) in collection) { ... }\n"}, {"type": "p", "text": "Variables a and b get the values returned by component1() and component2() called on elements of the collection."}, {"type": "code", "text": "a"}, {"type": "code", "text": "b"}, {"type": "code", "text": "component1()"}, {"type": "code", "text": "component2()"}, {"type": "h2", "text": "Example: Returning Two Values from a Function"}, {"type": "p", "text": "Let's say we need to return two things from a function. For example, a result object and a status of some sort.\nA compact way of doing this in Kotlin is to declare a data class and return its instance:"}, {"type": "a", "text": "data class"}, {"type": "em", "text": "data class"}, {"type": "div", "text": "\ndata class Result(val result: Int, val status: Status)\nfun function(...): Result {\n    // computations\n    \n    return Result(result, status)\n}\n\n// Now, to use this function:\nval (result, status) = function(...)\n\n"}, {"type": "pre", "text": "data class Result(val result: Int, val status: Status)\nfun function(...): Result {\n    // computations\n    \n    return Result(result, status)\n}\n\n// Now, to use this function:\nval (result, status) = function(...)\n"}, {"type": "code", "text": "data class Result(val result: Int, val status: Status)\nfun function(...): Result {\n    // computations\n    \n    return Result(result, status)\n}\n\n// Now, to use this function:\nval (result, status) = function(...)\n"}, {"type": "p", "text": "Since data classes automatically declare componentN() functions, destructuring declarations work here."}, {"type": "code", "text": "componentN()"}, {"type": "p", "text": "NOTE: we could also use the standard class Pair and have function() return Pair<Int, Status>, \nbut it's often better to have your data named properly."}, {"type": "strong", "text": "NOTE"}, {"type": "code", "text": "Pair"}, {"type": "code", "text": "function()"}, {"type": "code", "text": "Pair<Int, Status>"}, {"type": "h2", "text": "Example: Destructuring Declarations and Maps"}, {"type": "p", "text": "Probably the nicest way to traverse a map is this:"}, {"type": "div", "text": "\nfor ((key, value) in map) {\n   // do something with the key and the value\n}\n\n"}, {"type": "pre", "text": "for ((key, value) in map) {\n   // do something with the key and the value\n}\n"}, {"type": "code", "text": "for ((key, value) in map) {\n   // do something with the key and the value\n}\n"}, {"type": "p", "text": "To make this work, we should"}, {"type": "ul", "text": "\npresent the map as a sequence of values by providing an iterator() function;\npresent each of the elements as a pair by providing functions component1() and component2().\n"}, {"type": "li", "text": "present the map as a sequence of values by providing an iterator() function;"}, {"type": "code", "text": "iterator()"}, {"type": "li", "text": "present each of the elements as a pair by providing functions component1() and component2()."}, {"type": "code", "text": "component1()"}, {"type": "code", "text": "component2()"}, {"type": "p", "text": "And indeed, the standard library provides such extensions:"}, {"type": "div", "text": "\noperator fun <K, V> Map<K, V>.iterator(): Iterator<Map.Entry<K, V>> = entrySet().iterator()\noperator fun <K, V> Map.Entry<K, V>.component1() = getKey()\noperator fun <K, V> Map.Entry<K, V>.component2() = getValue()\n\n"}, {"type": "pre", "text": "operator fun <K, V> Map<K, V>.iterator(): Iterator<Map.Entry<K, V>> = entrySet().iterator()\noperator fun <K, V> Map.Entry<K, V>.component1() = getKey()\noperator fun <K, V> Map.Entry<K, V>.component2() = getValue()\n"}, {"type": "code", "text": "operator fun <K, V> Map<K, V>.iterator(): Iterator<Map.Entry<K, V>> = entrySet().iterator()\noperator fun <K, V> Map.Entry<K, V>.component1() = getKey()\noperator fun <K, V> Map.Entry<K, V>.component2() = getValue()\n"}, {"type": "p", "text": "So you can freely use destructuring declarations in for-loops with maps (as well as collections of data class instances etc)."}, {"type": "em", "text": "for"}, {"type": "h2", "text": "Underscore for unused variables (since 1.1)"}, {"type": "p", "text": "If you don't need a variable in the destructuring declaration, you can place an underscore instead of its name:"}, {"type": "div", "text": "\nval (_, status) = getResult()\n\n"}, {"type": "pre", "text": "val (_, status) = getResult()\n"}, {"type": "code", "text": "val (_, status) = getResult()\n"}, {"type": "p", "text": "The componentN() operator functions are not called for the components that are skipped in this way."}, {"type": "code", "text": "componentN()"}, {"type": "h2", "text": "Destructuring in Lambdas (since 1.1)"}, {"type": "p", "text": "You can use the destructuring declarations syntax for lambda parameters.\nIf a lambda has a parameter of the Pair type (or Map.Entry, or any other type that has the appropriate componentN functions), you can introduce several new parameters instead of one by putting them in parentheses:"}, {"type": "code", "text": "Pair"}, {"type": "code", "text": "Map.Entry"}, {"type": "code", "text": "componentN"}, {"type": "div", "text": "\nmap.mapValues { entry -> \"${entry.value}!\" }\nmap.mapValues { (key, value) -> \"$value!\" }\n\n"}, {"type": "pre", "text": "map.mapValues { entry -> \"${entry.value}!\" }\nmap.mapValues { (key, value) -> \"$value!\" }\n"}, {"type": "code", "text": "map.mapValues { entry -> \"${entry.value}!\" }\nmap.mapValues { (key, value) -> \"$value!\" }\n"}, {"type": "p", "text": "Note the difference between declaring two parameters and declaring a destructuring pair instead of a parameter:"}, {"type": "div", "text": "\n{ a -> ... } // one parameter\n{ a, b -> ... } // two parameters\n{ (a, b) -> ... } // a destructured pair\n{ (a, b), c -> ... } // a destructured pair and another parameter\n\n"}, {"type": "pre", "text": "{ a -> ... } // one parameter\n{ a, b -> ... } // two parameters\n{ (a, b) -> ... } // a destructured pair\n{ (a, b), c -> ... } // a destructured pair and another parameter\n"}, {"type": "code", "text": "{ a -> ... } // one parameter\n{ a, b -> ... } // two parameters\n{ (a, b) -> ... } // a destructured pair\n{ (a, b), c -> ... } // a destructured pair and another parameter\n"}, {"type": "p", "text": "If a component of the destructured parameter is unused, you can replace it with the underscore to avoid inventing its name:"}, {"type": "div", "text": "\nmap.mapValues { (_, value) -> \"$value!\" }\n\n"}, {"type": "pre", "text": "map.mapValues { (_, value) -> \"$value!\" }\n"}, {"type": "code", "text": "map.mapValues { (_, value) -> \"$value!\" }\n"}, {"type": "p", "text": "You can specify the type for the whole destructured parameter or for a specific component separately:"}, {"type": "div", "text": "\nmap.mapValues { (_, value): Map.Entry<Int, String> -> \"$value!\" }\n\nmap.mapValues { (_, value: String) -> \"$value!\" }\n\n"}, {"type": "pre", "text": "map.mapValues { (_, value): Map.Entry<Int, String> -> \"$value!\" }\n\nmap.mapValues { (_, value: String) -> \"$value!\" }\n"}, {"type": "code", "text": "map.mapValues { (_, value): Map.Entry<Int, String> -> \"$value!\" }\n\nmap.mapValues { (_, value: String) -> \"$value!\" }\n"}]