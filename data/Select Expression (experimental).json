[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "p", "text": "Table of contents"}, {"type": "strong", "text": "Table of contents"}, {"type": "ul", "text": "\nSelect Expression (experimental)\n\nSelecting from channels\nSelecting on close\nSelecting to send\nSelecting deferred values\nSwitch over a channel of deferred values\n\n\n"}, {"type": "li", "text": "Select Expression (experimental)\n\nSelecting from channels\nSelecting on close\nSelecting to send\nSelecting deferred values\nSwitch over a channel of deferred values\n\n"}, {"type": "a", "text": "Select Expression (experimental)"}, {"type": "ul", "text": "\nSelecting from channels\nSelecting on close\nSelecting to send\nSelecting deferred values\nSwitch over a channel of deferred values\n"}, {"type": "li", "text": "Selecting from channels"}, {"type": "a", "text": "Selecting from channels"}, {"type": "li", "text": "Selecting on close"}, {"type": "a", "text": "Selecting on close"}, {"type": "li", "text": "Selecting to send"}, {"type": "a", "text": "Selecting to send"}, {"type": "li", "text": "Selecting deferred values"}, {"type": "a", "text": "Selecting deferred values"}, {"type": "li", "text": "Switch over a channel of deferred values"}, {"type": "a", "text": "Switch over a channel of deferred values"}, {"type": "h2", "text": "Select Expression (experimental)"}, {"type": "p", "text": "Select expression makes it possible to await multiple suspending functions simultaneously and select\nthe first one that becomes available."}, {"type": "em", "text": "select"}, {"type": "blockquote", "text": "\nSelect expressions are an experimental feature of kotlinx.coroutines. Their API is expected to \nevolve in the upcoming updates of the kotlinx.coroutines library with potentially\nbreaking changes.\n"}, {"type": "p", "text": "Select expressions are an experimental feature of kotlinx.coroutines. Their API is expected to \nevolve in the upcoming updates of the kotlinx.coroutines library with potentially\nbreaking changes."}, {"type": "code", "text": "kotlinx.coroutines"}, {"type": "code", "text": "kotlinx.coroutines"}, {"type": "h3", "text": "Selecting from channels"}, {"type": "p", "text": "Let us have two producers of strings: fizz and buzz. The fizz produces \"Fizz\" string every 300 ms:"}, {"type": "code", "text": "fizz"}, {"type": "code", "text": "buzz"}, {"type": "code", "text": "fizz"}, {"type": "div", "text": "\nfun CoroutineScope.fizz() = produce<String> {\n    while (true) { // sends \"Fizz\" every 300 ms\n        delay(300)\n        send(\"Fizz\")\n    }\n}\n\n"}, {"type": "pre", "text": "fun CoroutineScope.fizz() = produce<String> {\n    while (true) { // sends \"Fizz\" every 300 ms\n        delay(300)\n        send(\"Fizz\")\n    }\n}\n"}, {"type": "code", "text": "fun CoroutineScope.fizz() = produce<String> {\n    while (true) { // sends \"Fizz\" every 300 ms\n        delay(300)\n        send(\"Fizz\")\n    }\n}\n"}, {"type": "p", "text": "And the buzz produces \"Buzz!\" string every 500 ms:"}, {"type": "code", "text": "buzz"}, {"type": "div", "text": "\nfun CoroutineScope.buzz() = produce<String> {\n    while (true) { // sends \"Buzz!\" every 500 ms\n        delay(500)\n        send(\"Buzz!\")\n    }\n}\n\n"}, {"type": "pre", "text": "fun CoroutineScope.buzz() = produce<String> {\n    while (true) { // sends \"Buzz!\" every 500 ms\n        delay(500)\n        send(\"Buzz!\")\n    }\n}\n"}, {"type": "code", "text": "fun CoroutineScope.buzz() = produce<String> {\n    while (true) { // sends \"Buzz!\" every 500 ms\n        delay(500)\n        send(\"Buzz!\")\n    }\n}\n"}, {"type": "p", "text": "Using receive suspending function we can receive either from one channel or the\nother. But select expression allows us to receive from both simultaneously using its\nonReceive clauses:"}, {"type": "a", "text": "receive"}, {"type": "em", "text": "either"}, {"type": "a", "text": "select"}, {"type": "em", "text": "both"}, {"type": "a", "text": "onReceive"}, {"type": "div", "text": "\nsuspend fun selectFizzBuzz(fizz: ReceiveChannel<String>, buzz: ReceiveChannel<String>) {\n    select<Unit> { // <Unit> means that this select expression does not produce any result \n        fizz.onReceive { value ->  // this is the first select clause\n            println(\"fizz -> '$value'\")\n        }\n        buzz.onReceive { value ->  // this is the second select clause\n            println(\"buzz -> '$value'\")\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "suspend fun selectFizzBuzz(fizz: ReceiveChannel<String>, buzz: ReceiveChannel<String>) {\n    select<Unit> { // <Unit> means that this select expression does not produce any result \n        fizz.onReceive { value ->  // this is the first select clause\n            println(\"fizz -> '$value'\")\n        }\n        buzz.onReceive { value ->  // this is the second select clause\n            println(\"buzz -> '$value'\")\n        }\n    }\n}\n"}, {"type": "code", "text": "suspend fun selectFizzBuzz(fizz: ReceiveChannel<String>, buzz: ReceiveChannel<String>) {\n    select<Unit> { // <Unit> means that this select expression does not produce any result \n        fizz.onReceive { value ->  // this is the first select clause\n            println(\"fizz -> '$value'\")\n        }\n        buzz.onReceive { value ->  // this is the second select clause\n            println(\"buzz -> '$value'\")\n        }\n    }\n}\n"}, {"type": "p", "text": "Let us run it all seven times:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n\nfun CoroutineScope.fizz() = produce<String> {\n    while (true) { // sends \"Fizz\" every 300 ms\n        delay(300)\n        send(\"Fizz\")\n    }\n}\n\nfun CoroutineScope.buzz() = produce<String> {\n    while (true) { // sends \"Buzz!\" every 500 ms\n        delay(500)\n        send(\"Buzz!\")\n    }\n}\n\nsuspend fun selectFizzBuzz(fizz: ReceiveChannel<String>, buzz: ReceiveChannel<String>) {\n    select<Unit> { // <Unit> means that this select expression does not produce any result \n        fizz.onReceive { value ->  // this is the first select clause\n            println(\"fizz -> '$value'\")\n        }\n        buzz.onReceive { value ->  // this is the second select clause\n            println(\"buzz -> '$value'\")\n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val fizz = fizz()\n    val buzz = buzz()\n    repeat(7) {\n        selectFizzBuzz(fizz, buzz)\n    }\n    coroutineContext.cancelChildren() // cancel fizz & buzz coroutines\n//sampleEnd        \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n\nfun CoroutineScope.fizz() = produce<String> {\n    while (true) { // sends \"Fizz\" every 300 ms\n        delay(300)\n        send(\"Fizz\")\n    }\n}\n\nfun CoroutineScope.buzz() = produce<String> {\n    while (true) { // sends \"Buzz!\" every 500 ms\n        delay(500)\n        send(\"Buzz!\")\n    }\n}\n\nsuspend fun selectFizzBuzz(fizz: ReceiveChannel<String>, buzz: ReceiveChannel<String>) {\n    select<Unit> { // <Unit> means that this select expression does not produce any result \n        fizz.onReceive { value ->  // this is the first select clause\n            println(\"fizz -> '$value'\")\n        }\n        buzz.onReceive { value ->  // this is the second select clause\n            println(\"buzz -> '$value'\")\n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val fizz = fizz()\n    val buzz = buzz()\n    repeat(7) {\n        selectFizzBuzz(fizz, buzz)\n    }\n    coroutineContext.cancelChildren() // cancel fizz & buzz coroutines\n//sampleEnd        \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n\nfun CoroutineScope.fizz() = produce<String> {\n    while (true) { // sends \"Fizz\" every 300 ms\n        delay(300)\n        send(\"Fizz\")\n    }\n}\n\nfun CoroutineScope.buzz() = produce<String> {\n    while (true) { // sends \"Buzz!\" every 500 ms\n        delay(500)\n        send(\"Buzz!\")\n    }\n}\n\nsuspend fun selectFizzBuzz(fizz: ReceiveChannel<String>, buzz: ReceiveChannel<String>) {\n    select<Unit> { // <Unit> means that this select expression does not produce any result \n        fizz.onReceive { value ->  // this is the first select clause\n            println(\"fizz -> '$value'\")\n        }\n        buzz.onReceive { value ->  // this is the second select clause\n            println(\"buzz -> '$value'\")\n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val fizz = fizz()\n    val buzz = buzz()\n    repeat(7) {\n        selectFizzBuzz(fizz, buzz)\n    }\n    coroutineContext.cancelChildren() // cancel fizz & buzz coroutines\n//sampleEnd        \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The result of this code is:"}, {"type": "pre", "text": "fizz -> 'Fizz'\nbuzz -> 'Buzz!'\nfizz -> 'Fizz'\nfizz -> 'Fizz'\nbuzz -> 'Buzz!'\nfizz -> 'Fizz'\nbuzz -> 'Buzz!'\n"}, {"type": "code", "text": "fizz -> 'Fizz'\nbuzz -> 'Buzz!'\nfizz -> 'Fizz'\nfizz -> 'Fizz'\nbuzz -> 'Buzz!'\nfizz -> 'Fizz'\nbuzz -> 'Buzz!'\n"}, {"type": "h3", "text": "Selecting on close"}, {"type": "p", "text": "The onReceive clause in select fails when the channel is closed causing the corresponding\nselect to throw an exception. We can use onReceiveOrNull clause to perform a\nspecific action when the channel is closed. The following example also shows that select is an expression that returns \nthe result of its selected clause:"}, {"type": "a", "text": "onReceive"}, {"type": "code", "text": "select"}, {"type": "code", "text": "select"}, {"type": "a", "text": "onReceiveOrNull"}, {"type": "code", "text": "select"}, {"type": "div", "text": "\nsuspend fun selectAorB(a: ReceiveChannel<String>, b: ReceiveChannel<String>): String =\n    select<String> {\n        a.onReceiveOrNull { value -> \n            if (value == null) \n                \"Channel 'a' is closed\" \n            else \n                \"a -> '$value'\"\n        }\n        b.onReceiveOrNull { value -> \n            if (value == null) \n                \"Channel 'b' is closed\"\n            else    \n                \"b -> '$value'\"\n        }\n    }\n\n"}, {"type": "pre", "text": "suspend fun selectAorB(a: ReceiveChannel<String>, b: ReceiveChannel<String>): String =\n    select<String> {\n        a.onReceiveOrNull { value -> \n            if (value == null) \n                \"Channel 'a' is closed\" \n            else \n                \"a -> '$value'\"\n        }\n        b.onReceiveOrNull { value -> \n            if (value == null) \n                \"Channel 'b' is closed\"\n            else    \n                \"b -> '$value'\"\n        }\n    }\n"}, {"type": "code", "text": "suspend fun selectAorB(a: ReceiveChannel<String>, b: ReceiveChannel<String>): String =\n    select<String> {\n        a.onReceiveOrNull { value -> \n            if (value == null) \n                \"Channel 'a' is closed\" \n            else \n                \"a -> '$value'\"\n        }\n        b.onReceiveOrNull { value -> \n            if (value == null) \n                \"Channel 'b' is closed\"\n            else    \n                \"b -> '$value'\"\n        }\n    }\n"}, {"type": "p", "text": "Note that onReceiveOrNull is an extension function defined only \nfor channels with non-nullable elements so that there is no accidental confusion between a closed channel\nand a null value."}, {"type": "a", "text": "onReceiveOrNull"}, {"type": "p", "text": "Let's use it with channel a that produces \"Hello\" string four times and \nchannel b that produces \"World\" four times:"}, {"type": "code", "text": "a"}, {"type": "code", "text": "b"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n\nsuspend fun selectAorB(a: ReceiveChannel<String>, b: ReceiveChannel<String>): String =\n    select<String> {\n        a.onReceiveOrNull { value -> \n            if (value == null) \n                \"Channel 'a' is closed\" \n            else \n                \"a -> '$value'\"\n        }\n        b.onReceiveOrNull { value -> \n            if (value == null) \n                \"Channel 'b' is closed\"\n            else    \n                \"b -> '$value'\"\n        }\n    }\n    \nfun main() = runBlocking<Unit> {\n//sampleStart\n    val a = produce<String> {\n        repeat(4) { send(\"Hello $it\") }\n    }\n    val b = produce<String> {\n        repeat(4) { send(\"World $it\") }\n    }\n    repeat(8) { // print first eight results\n        println(selectAorB(a, b))\n    }\n    coroutineContext.cancelChildren()  \n//sampleEnd      \n}    \n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n\nsuspend fun selectAorB(a: ReceiveChannel<String>, b: ReceiveChannel<String>): String =\n    select<String> {\n        a.onReceiveOrNull { value -> \n            if (value == null) \n                \"Channel 'a' is closed\" \n            else \n                \"a -> '$value'\"\n        }\n        b.onReceiveOrNull { value -> \n            if (value == null) \n                \"Channel 'b' is closed\"\n            else    \n                \"b -> '$value'\"\n        }\n    }\n    \nfun main() = runBlocking<Unit> {\n//sampleStart\n    val a = produce<String> {\n        repeat(4) { send(\"Hello $it\") }\n    }\n    val b = produce<String> {\n        repeat(4) { send(\"World $it\") }\n    }\n    repeat(8) { // print first eight results\n        println(selectAorB(a, b))\n    }\n    coroutineContext.cancelChildren()  \n//sampleEnd      \n}    \n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n\nsuspend fun selectAorB(a: ReceiveChannel<String>, b: ReceiveChannel<String>): String =\n    select<String> {\n        a.onReceiveOrNull { value -> \n            if (value == null) \n                \"Channel 'a' is closed\" \n            else \n                \"a -> '$value'\"\n        }\n        b.onReceiveOrNull { value -> \n            if (value == null) \n                \"Channel 'b' is closed\"\n            else    \n                \"b -> '$value'\"\n        }\n    }\n    \nfun main() = runBlocking<Unit> {\n//sampleStart\n    val a = produce<String> {\n        repeat(4) { send(\"Hello $it\") }\n    }\n    val b = produce<String> {\n        repeat(4) { send(\"World $it\") }\n    }\n    repeat(8) { // print first eight results\n        println(selectAorB(a, b))\n    }\n    coroutineContext.cancelChildren()  \n//sampleEnd      \n}    \n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The result of this code is quite interesting, so we'll analyze it in mode detail:"}, {"type": "pre", "text": "a -> 'Hello 0'\na -> 'Hello 1'\nb -> 'World 0'\na -> 'Hello 2'\na -> 'Hello 3'\nb -> 'World 1'\nChannel 'a' is closed\nChannel 'a' is closed\n"}, {"type": "code", "text": "a -> 'Hello 0'\na -> 'Hello 1'\nb -> 'World 0'\na -> 'Hello 2'\na -> 'Hello 3'\nb -> 'World 1'\nChannel 'a' is closed\nChannel 'a' is closed\n"}, {"type": "p", "text": "There are couple of observations to make out of it."}, {"type": "p", "text": "First of all, select is biased to the first clause. When several clauses are selectable at the same time, \nthe first one among them gets selected. Here, both channels are constantly producing strings, so a channel,\nbeing the first clause in select, wins. However, because we are using unbuffered channel, the a gets suspended from\ntime to time on its send invocation and gives a chance for b to send, too."}, {"type": "code", "text": "select"}, {"type": "em", "text": "biased"}, {"type": "code", "text": "a"}, {"type": "code", "text": "a"}, {"type": "a", "text": "send"}, {"type": "code", "text": "b"}, {"type": "p", "text": "The second observation, is that onReceiveOrNull gets immediately selected when the \nchannel is already closed."}, {"type": "a", "text": "onReceiveOrNull"}, {"type": "h3", "text": "Selecting to send"}, {"type": "p", "text": "Select expression has onSend clause that can be used for a great good in combination \nwith a biased nature of selection."}, {"type": "a", "text": "onSend"}, {"type": "p", "text": "Let us write an example of producer of integers that sends its values to a side channel when \nthe consumers on its primary channel cannot keep up with it:"}, {"type": "code", "text": "side"}, {"type": "div", "text": "\nfun CoroutineScope.produceNumbers(side: SendChannel<Int>) = produce<Int> {\n    for (num in 1..10) { // produce 10 numbers from 1 to 10\n        delay(100) // every 100 ms\n        select<Unit> {\n            onSend(num) {} // Send to the primary channel\n            side.onSend(num) {} // or to the side channel     \n        }\n    }\n}\n\n"}, {"type": "pre", "text": "fun CoroutineScope.produceNumbers(side: SendChannel<Int>) = produce<Int> {\n    for (num in 1..10) { // produce 10 numbers from 1 to 10\n        delay(100) // every 100 ms\n        select<Unit> {\n            onSend(num) {} // Send to the primary channel\n            side.onSend(num) {} // or to the side channel     \n        }\n    }\n}\n"}, {"type": "code", "text": "fun CoroutineScope.produceNumbers(side: SendChannel<Int>) = produce<Int> {\n    for (num in 1..10) { // produce 10 numbers from 1 to 10\n        delay(100) // every 100 ms\n        select<Unit> {\n            onSend(num) {} // Send to the primary channel\n            side.onSend(num) {} // or to the side channel     \n        }\n    }\n}\n"}, {"type": "p", "text": "Consumer is going to be quite slow, taking 250 ms to process each number:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n\nfun CoroutineScope.produceNumbers(side: SendChannel<Int>) = produce<Int> {\n    for (num in 1..10) { // produce 10 numbers from 1 to 10\n        delay(100) // every 100 ms\n        select<Unit> {\n            onSend(num) {} // Send to the primary channel\n            side.onSend(num) {} // or to the side channel     \n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val side = Channel<Int>() // allocate side channel\n    launch { // this is a very fast consumer for the side channel\n        side.consumeEach { println(\"Side channel has $it\") }\n    }\n    produceNumbers(side).consumeEach { \n        println(\"Consuming $it\")\n        delay(250) // let us digest the consumed number properly, do not hurry\n    }\n    println(\"Done consuming\")\n    coroutineContext.cancelChildren()  \n//sampleEnd      \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n\nfun CoroutineScope.produceNumbers(side: SendChannel<Int>) = produce<Int> {\n    for (num in 1..10) { // produce 10 numbers from 1 to 10\n        delay(100) // every 100 ms\n        select<Unit> {\n            onSend(num) {} // Send to the primary channel\n            side.onSend(num) {} // or to the side channel     \n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val side = Channel<Int>() // allocate side channel\n    launch { // this is a very fast consumer for the side channel\n        side.consumeEach { println(\"Side channel has $it\") }\n    }\n    produceNumbers(side).consumeEach { \n        println(\"Consuming $it\")\n        delay(250) // let us digest the consumed number properly, do not hurry\n    }\n    println(\"Done consuming\")\n    coroutineContext.cancelChildren()  \n//sampleEnd      \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n\nfun CoroutineScope.produceNumbers(side: SendChannel<Int>) = produce<Int> {\n    for (num in 1..10) { // produce 10 numbers from 1 to 10\n        delay(100) // every 100 ms\n        select<Unit> {\n            onSend(num) {} // Send to the primary channel\n            side.onSend(num) {} // or to the side channel     \n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val side = Channel<Int>() // allocate side channel\n    launch { // this is a very fast consumer for the side channel\n        side.consumeEach { println(\"Side channel has $it\") }\n    }\n    produceNumbers(side).consumeEach { \n        println(\"Consuming $it\")\n        delay(250) // let us digest the consumed number properly, do not hurry\n    }\n    println(\"Done consuming\")\n    coroutineContext.cancelChildren()  \n//sampleEnd      \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "So let us see what happens:"}, {"type": "pre", "text": "Consuming 1\nSide channel has 2\nSide channel has 3\nConsuming 4\nSide channel has 5\nSide channel has 6\nConsuming 7\nSide channel has 8\nSide channel has 9\nConsuming 10\nDone consuming\n"}, {"type": "code", "text": "Consuming 1\nSide channel has 2\nSide channel has 3\nConsuming 4\nSide channel has 5\nSide channel has 6\nConsuming 7\nSide channel has 8\nSide channel has 9\nConsuming 10\nDone consuming\n"}, {"type": "h3", "text": "Selecting deferred values"}, {"type": "p", "text": "Deferred values can be selected using onAwait clause. \nLet us start with an async function that returns a deferred string value after \na random delay:"}, {"type": "a", "text": "onAwait"}, {"type": "div", "text": "\nfun CoroutineScope.asyncString(time: Int) = async {\n    delay(time.toLong())\n    \"Waited for $time ms\"\n}\n\n"}, {"type": "pre", "text": "fun CoroutineScope.asyncString(time: Int) = async {\n    delay(time.toLong())\n    \"Waited for $time ms\"\n}\n"}, {"type": "code", "text": "fun CoroutineScope.asyncString(time: Int) = async {\n    delay(time.toLong())\n    \"Waited for $time ms\"\n}\n"}, {"type": "p", "text": "Let us start a dozen of them with a random delay."}, {"type": "div", "text": "\nfun CoroutineScope.asyncStringsList(): List<Deferred<String>> {\n    val random = Random(3)\n    return List(12) { asyncString(random.nextInt(1000)) }\n}\n\n"}, {"type": "pre", "text": "fun CoroutineScope.asyncStringsList(): List<Deferred<String>> {\n    val random = Random(3)\n    return List(12) { asyncString(random.nextInt(1000)) }\n}\n"}, {"type": "code", "text": "fun CoroutineScope.asyncStringsList(): List<Deferred<String>> {\n    val random = Random(3)\n    return List(12) { asyncString(random.nextInt(1000)) }\n}\n"}, {"type": "p", "text": "Now the main function awaits for the first of them to complete and counts the number of deferred values\nthat are still active. Note that we've used here the fact that select expression is a Kotlin DSL, \nso we can provide clauses for it using an arbitrary code. In this case we iterate over a list\nof deferred values to provide onAwait clause for each deferred value."}, {"type": "code", "text": "select"}, {"type": "code", "text": "onAwait"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport java.util.*\n    \nfun CoroutineScope.asyncString(time: Int) = async {\n    delay(time.toLong())\n    \"Waited for $time ms\"\n}\n\nfun CoroutineScope.asyncStringsList(): List<Deferred<String>> {\n    val random = Random(3)\n    return List(12) { asyncString(random.nextInt(1000)) }\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val list = asyncStringsList()\n    val result = select<String> {\n        list.withIndex().forEach { (index, deferred) ->\n            deferred.onAwait { answer ->\n                \"Deferred $index produced answer '$answer'\"\n            }\n        }\n    }\n    println(result)\n    val countActive = list.count { it.isActive }\n    println(\"$countActive coroutines are still active\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport java.util.*\n    \nfun CoroutineScope.asyncString(time: Int) = async {\n    delay(time.toLong())\n    \"Waited for $time ms\"\n}\n\nfun CoroutineScope.asyncStringsList(): List<Deferred<String>> {\n    val random = Random(3)\n    return List(12) { asyncString(random.nextInt(1000)) }\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val list = asyncStringsList()\n    val result = select<String> {\n        list.withIndex().forEach { (index, deferred) ->\n            deferred.onAwait { answer ->\n                \"Deferred $index produced answer '$answer'\"\n            }\n        }\n    }\n    println(result)\n    val countActive = list.count { it.isActive }\n    println(\"$countActive coroutines are still active\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport java.util.*\n    \nfun CoroutineScope.asyncString(time: Int) = async {\n    delay(time.toLong())\n    \"Waited for $time ms\"\n}\n\nfun CoroutineScope.asyncStringsList(): List<Deferred<String>> {\n    val random = Random(3)\n    return List(12) { asyncString(random.nextInt(1000)) }\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val list = asyncStringsList()\n    val result = select<String> {\n        list.withIndex().forEach { (index, deferred) ->\n            deferred.onAwait { answer ->\n                \"Deferred $index produced answer '$answer'\"\n            }\n        }\n    }\n    println(result)\n    val countActive = list.count { it.isActive }\n    println(\"$countActive coroutines are still active\")\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output is:"}, {"type": "pre", "text": "Deferred 4 produced answer 'Waited for 128 ms'\n11 coroutines are still active\n"}, {"type": "code", "text": "Deferred 4 produced answer 'Waited for 128 ms'\n11 coroutines are still active\n"}, {"type": "h3", "text": "Switch over a channel of deferred values"}, {"type": "p", "text": "Let us write a channel producer function that consumes a channel of deferred string values, waits for each received\ndeferred value, but only until the next deferred value comes over or the channel is closed. This example puts together \nonReceiveOrNull and onAwait clauses in the same select:"}, {"type": "a", "text": "onReceiveOrNull"}, {"type": "a", "text": "onAwait"}, {"type": "code", "text": "select"}, {"type": "div", "text": "\nfun CoroutineScope.switchMapDeferreds(input: ReceiveChannel<Deferred<String>>) = produce<String> {\n    var current = input.receive() // start with first received deferred value\n    while (isActive) { // loop while not cancelled/closed\n        val next = select<Deferred<String>?> { // return next deferred value from this select or null\n            input.onReceiveOrNull { update ->\n                update // replaces next value to wait\n            }\n            current.onAwait { value ->  \n                send(value) // send value that current deferred has produced\n                input.receiveOrNull() // and use the next deferred from the input channel\n            }\n        }\n        if (next == null) {\n            println(\"Channel was closed\")\n            break // out of loop\n        } else {\n            current = next\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "fun CoroutineScope.switchMapDeferreds(input: ReceiveChannel<Deferred<String>>) = produce<String> {\n    var current = input.receive() // start with first received deferred value\n    while (isActive) { // loop while not cancelled/closed\n        val next = select<Deferred<String>?> { // return next deferred value from this select or null\n            input.onReceiveOrNull { update ->\n                update // replaces next value to wait\n            }\n            current.onAwait { value ->  \n                send(value) // send value that current deferred has produced\n                input.receiveOrNull() // and use the next deferred from the input channel\n            }\n        }\n        if (next == null) {\n            println(\"Channel was closed\")\n            break // out of loop\n        } else {\n            current = next\n        }\n    }\n}\n"}, {"type": "code", "text": "fun CoroutineScope.switchMapDeferreds(input: ReceiveChannel<Deferred<String>>) = produce<String> {\n    var current = input.receive() // start with first received deferred value\n    while (isActive) { // loop while not cancelled/closed\n        val next = select<Deferred<String>?> { // return next deferred value from this select or null\n            input.onReceiveOrNull { update ->\n                update // replaces next value to wait\n            }\n            current.onAwait { value ->  \n                send(value) // send value that current deferred has produced\n                input.receiveOrNull() // and use the next deferred from the input channel\n            }\n        }\n        if (next == null) {\n            println(\"Channel was closed\")\n            break // out of loop\n        } else {\n            current = next\n        }\n    }\n}\n"}, {"type": "p", "text": "To test it, we'll use a simple async function that resolves to a specified string after a specified time:"}, {"type": "div", "text": "\nfun CoroutineScope.asyncString(str: String, time: Long) = async {\n    delay(time)\n    str\n}\n\n"}, {"type": "pre", "text": "fun CoroutineScope.asyncString(str: String, time: Long) = async {\n    delay(time)\n    str\n}\n"}, {"type": "code", "text": "fun CoroutineScope.asyncString(str: String, time: Long) = async {\n    delay(time)\n    str\n}\n"}, {"type": "p", "text": "The main function just launches a coroutine to print results of switchMapDeferreds and sends some test\ndata to it:"}, {"type": "code", "text": "switchMapDeferreds"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n    \nfun CoroutineScope.switchMapDeferreds(input: ReceiveChannel<Deferred<String>>) = produce<String> {\n    var current = input.receive() // start with first received deferred value\n    while (isActive) { // loop while not cancelled/closed\n        val next = select<Deferred<String>?> { // return next deferred value from this select or null\n            input.onReceiveOrNull { update ->\n                update // replaces next value to wait\n            }\n            current.onAwait { value ->  \n                send(value) // send value that current deferred has produced\n                input.receiveOrNull() // and use the next deferred from the input channel\n            }\n        }\n        if (next == null) {\n            println(\"Channel was closed\")\n            break // out of loop\n        } else {\n            current = next\n        }\n    }\n}\n\nfun CoroutineScope.asyncString(str: String, time: Long) = async {\n    delay(time)\n    str\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val chan = Channel<Deferred<String>>() // the channel for test\n    launch { // launch printing coroutine\n        for (s in switchMapDeferreds(chan)) \n            println(s) // print each received string\n    }\n    chan.send(asyncString(\"BEGIN\", 100))\n    delay(200) // enough time for \"BEGIN\" to be produced\n    chan.send(asyncString(\"Slow\", 500))\n    delay(100) // not enough time to produce slow\n    chan.send(asyncString(\"Replace\", 100))\n    delay(500) // give it time before the last one\n    chan.send(asyncString(\"END\", 500))\n    delay(1000) // give it time to process\n    chan.close() // close the channel ... \n    delay(500) // and wait some time to let it finish\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n    \nfun CoroutineScope.switchMapDeferreds(input: ReceiveChannel<Deferred<String>>) = produce<String> {\n    var current = input.receive() // start with first received deferred value\n    while (isActive) { // loop while not cancelled/closed\n        val next = select<Deferred<String>?> { // return next deferred value from this select or null\n            input.onReceiveOrNull { update ->\n                update // replaces next value to wait\n            }\n            current.onAwait { value ->  \n                send(value) // send value that current deferred has produced\n                input.receiveOrNull() // and use the next deferred from the input channel\n            }\n        }\n        if (next == null) {\n            println(\"Channel was closed\")\n            break // out of loop\n        } else {\n            current = next\n        }\n    }\n}\n\nfun CoroutineScope.asyncString(str: String, time: Long) = async {\n    delay(time)\n    str\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val chan = Channel<Deferred<String>>() // the channel for test\n    launch { // launch printing coroutine\n        for (s in switchMapDeferreds(chan)) \n            println(s) // print each received string\n    }\n    chan.send(asyncString(\"BEGIN\", 100))\n    delay(200) // enough time for \"BEGIN\" to be produced\n    chan.send(asyncString(\"Slow\", 500))\n    delay(100) // not enough time to produce slow\n    chan.send(asyncString(\"Replace\", 100))\n    delay(500) // give it time before the last one\n    chan.send(asyncString(\"END\", 500))\n    delay(1000) // give it time to process\n    chan.close() // close the channel ... \n    delay(500) // and wait some time to let it finish\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n    \nfun CoroutineScope.switchMapDeferreds(input: ReceiveChannel<Deferred<String>>) = produce<String> {\n    var current = input.receive() // start with first received deferred value\n    while (isActive) { // loop while not cancelled/closed\n        val next = select<Deferred<String>?> { // return next deferred value from this select or null\n            input.onReceiveOrNull { update ->\n                update // replaces next value to wait\n            }\n            current.onAwait { value ->  \n                send(value) // send value that current deferred has produced\n                input.receiveOrNull() // and use the next deferred from the input channel\n            }\n        }\n        if (next == null) {\n            println(\"Channel was closed\")\n            break // out of loop\n        } else {\n            current = next\n        }\n    }\n}\n\nfun CoroutineScope.asyncString(str: String, time: Long) = async {\n    delay(time)\n    str\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val chan = Channel<Deferred<String>>() // the channel for test\n    launch { // launch printing coroutine\n        for (s in switchMapDeferreds(chan)) \n            println(s) // print each received string\n    }\n    chan.send(asyncString(\"BEGIN\", 100))\n    delay(200) // enough time for \"BEGIN\" to be produced\n    chan.send(asyncString(\"Slow\", 500))\n    delay(100) // not enough time to produce slow\n    chan.send(asyncString(\"Replace\", 100))\n    delay(500) // give it time before the last one\n    chan.send(asyncString(\"END\", 500))\n    delay(1000) // give it time to process\n    chan.close() // close the channel ... \n    delay(500) // and wait some time to let it finish\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The result of this code:"}, {"type": "pre", "text": "BEGIN\nReplace\nEND\nChannel was closed\n"}, {"type": "code", "text": "BEGIN\nReplace\nEND\nChannel was closed\n"}]