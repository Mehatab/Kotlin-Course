[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Ranges and Progressions"}, {"type": "p", "text": "Kotlin lets you easily create ranges of values using the rangeTo() function from the kotlin.ranges package and its operator form ...\nUsually, rangeTo() is complemented by in or !in functions."}, {"type": "a", "text": "rangeTo()"}, {"type": "code", "text": "rangeTo()"}, {"type": "code", "text": "kotlin.ranges"}, {"type": "code", "text": ".."}, {"type": "code", "text": "rangeTo()"}, {"type": "code", "text": "in"}, {"type": "code", "text": "!in"}, {"type": "div", "text": "\nif (i in 1..4) {  // equivalent of 1 <= i && i <= 4\n    print(i)\n}\n\n"}, {"type": "pre", "text": "if (i in 1..4) {  // equivalent of 1 <= i && i <= 4\n    print(i)\n}\n"}, {"type": "code", "text": "if (i in 1..4) {  // equivalent of 1 <= i && i <= 4\n    print(i)\n}\n"}, {"type": "p", "text": "Integral type ranges (IntRange, LongRange, CharRange) have an extra feature: they can be iterated over.\nThese ranges are also progressions of the corresponding integral types.\nSuch ranges are generally used for iteration in the for loops."}, {"type": "a", "text": "IntRange"}, {"type": "code", "text": "IntRange"}, {"type": "a", "text": "LongRange"}, {"type": "code", "text": "LongRange"}, {"type": "a", "text": "CharRange"}, {"type": "code", "text": "CharRange"}, {"type": "a", "text": "progressions"}, {"type": "code", "text": "for"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    for (i in 1..4) print(i)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    for (i in 1..4) print(i)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    for (i in 1..4) print(i)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "To iterate numbers in reverse order, use the downTo function instead of ..."}, {"type": "a", "text": "downTo"}, {"type": "code", "text": "downTo"}, {"type": "code", "text": ".."}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    for (i in 4 downTo 1) print(i)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    for (i in 4 downTo 1) print(i)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    for (i in 4 downTo 1) print(i)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "It is also possible to iterate over numbers with an arbitrary step (not necessarily 1). This is done via the step function."}, {"type": "a", "text": "step"}, {"type": "code", "text": "step"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    for (i in 1..8 step 2) print(i)\n    println()\n    for (i in 8 downTo 1 step 2) print(i)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    for (i in 1..8 step 2) print(i)\n    println()\n    for (i in 8 downTo 1 step 2) print(i)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    for (i in 1..8 step 2) print(i)\n    println()\n    for (i in 8 downTo 1 step 2) print(i)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "To iterate a number range which does not include its end element, use the until function:"}, {"type": "a", "text": "until"}, {"type": "code", "text": "until"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    for (i in 1 until 10) {       // i in [1, 10), 10 is excluded\n        print(i)\n    }\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    for (i in 1 until 10) {       // i in [1, 10), 10 is excluded\n        print(i)\n    }\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    for (i in 1 until 10) {       // i in [1, 10), 10 is excluded\n        print(i)\n    }\n//sampleEnd\n}\n\n"}, {"type": "h2", "text": "Range"}, {"type": "p", "text": "A range defines a closed interval in the mathematical sense: it is defined by its two endpoint values which are both included in the range.\nRanges are defined for comparable types: having an order, you can define whether an arbitrary instance is in the range between two given instances.\nThe main operation on ranges is contains, which is usually used in the form of in and !in operators."}, {"type": "code", "text": "contains"}, {"type": "code", "text": "in"}, {"type": "code", "text": "!in"}, {"type": "p", "text": "To create a range for your class, call the rangeTo() function on the range start value and provide the end value as an argument.\nrangeTo() is often called in its operator form ..."}, {"type": "code", "text": "rangeTo()"}, {"type": "code", "text": "rangeTo()"}, {"type": "code", "text": ".."}, {"type": "div", "text": "\nclass Version(val major: Int, val minor: Int): Comparable<Version> {\n    override fun compareTo(other: Version): Int {\n        if (this.major != other.major) {\n            return this.major - other.major\n        }\n        return this.minor - other.minor\n    }\n}\n\nfun main() {\n//sampleStart\n    val versionRange = Version(1, 11)..Version(1, 30)\n    println(Version(0, 9) in versionRange)\n    println(Version(1, 20) in versionRange)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "class Version(val major: Int, val minor: Int): Comparable<Version> {\n    override fun compareTo(other: Version): Int {\n        if (this.major != other.major) {\n            return this.major - other.major\n        }\n        return this.minor - other.minor\n    }\n}\n\nfun main() {\n//sampleStart\n    val versionRange = Version(1, 11)..Version(1, 30)\n    println(Version(0, 9) in versionRange)\n    println(Version(1, 20) in versionRange)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "class Version(val major: Int, val minor: Int): Comparable<Version> {\n    override fun compareTo(other: Version): Int {\n        if (this.major != other.major) {\n            return this.major - other.major\n        }\n        return this.minor - other.minor\n    }\n}\n\nfun main() {\n//sampleStart\n    val versionRange = Version(1, 11)..Version(1, 30)\n    println(Version(0, 9) in versionRange)\n    println(Version(1, 20) in versionRange)\n//sampleEnd\n}\n\n"}, {"type": "h2", "text": "Progression"}, {"type": "p", "text": "As shown in the examples above, the ranges of integral types, such as Int, Long, and Char, can be treated as arithmetic progressions of them.\nIn Kotlin, these progressions are defined by special types: IntProgression, LongProgression, and CharProgression."}, {"type": "code", "text": "Int"}, {"type": "code", "text": "Long"}, {"type": "code", "text": "Char"}, {"type": "a", "text": "arithmetic progressions"}, {"type": "a", "text": "IntProgression"}, {"type": "code", "text": "IntProgression"}, {"type": "a", "text": "LongProgression"}, {"type": "code", "text": "LongProgression"}, {"type": "a", "text": "CharProgression"}, {"type": "code", "text": "CharProgression"}, {"type": "p", "text": "Progressions have three essential properties: the first element, the last element, and a non-zero step.\nThe first element is first, subsequent elements are the previous element plus a step. \nIteration over a progression with a positive step is equivalent to an indexed for loop in Java/JavaScript."}, {"type": "code", "text": "first"}, {"type": "code", "text": "last"}, {"type": "code", "text": "step"}, {"type": "code", "text": "first"}, {"type": "code", "text": "step"}, {"type": "code", "text": "for"}, {"type": "div", "text": "\nfor (int i = first; i <= last; i += step) {\n  // ...\n}\n\n"}, {"type": "pre", "text": "for (int i = first; i <= last; i += step) {\n  // ...\n}\n"}, {"type": "code", "text": "for (int i = first; i <= last; i += step) {\n  // ...\n}\n"}, {"type": "p", "text": "When you create a progression implicitly by iterating a range, this progression's first and last elements are the range's endpoints, and the step is 1."}, {"type": "code", "text": "first"}, {"type": "code", "text": "last"}, {"type": "code", "text": "step"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    for (i in 1..10) print(i)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    for (i in 1..10) print(i)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    for (i in 1..10) print(i)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "To define a custom progression step, use the step function on a range."}, {"type": "code", "text": "step"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    for (i in 1..8 step 2) print(i)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    for (i in 1..8 step 2) print(i)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    for (i in 1..8 step 2) print(i)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "The last element of the progression is calculated this way:"}, {"type": "code", "text": "last"}, {"type": "ul", "text": "\nFor a positive step: the maximum value not greater than the end value such that (last - first) % step == 0.\nFor a negative step: the minimum value not less than the end value such that (last - first) % step == 0.\n"}, {"type": "li", "text": "For a positive step: the maximum value not greater than the end value such that (last - first) % step == 0."}, {"type": "code", "text": "(last - first) % step == 0"}, {"type": "li", "text": "For a negative step: the minimum value not less than the end value such that (last - first) % step == 0."}, {"type": "code", "text": "(last - first) % step == 0"}, {"type": "p", "text": "Thus, the last element is not always the same as the specified end value."}, {"type": "code", "text": "last"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    for (i in 1..9 step 3) print(i) // the last element is 7\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    for (i in 1..9 step 3) print(i) // the last element is 7\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    for (i in 1..9 step 3) print(i) // the last element is 7\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "To create a progression for iterating in reverse order, use downTo instead of .. when defining the range for it."}, {"type": "code", "text": "downTo"}, {"type": "code", "text": ".."}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    for (i in 4 downTo 1) print(i)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    for (i in 4 downTo 1) print(i)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    for (i in 4 downTo 1) print(i)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "Progressions implement Iterable<N>, where N is Int, Long, or Char respectively, so you can use them in various collection functions like map, filter, and other."}, {"type": "code", "text": "Iterable<N>"}, {"type": "code", "text": "N"}, {"type": "code", "text": "Int"}, {"type": "code", "text": "Long"}, {"type": "code", "text": "Char"}, {"type": "a", "text": "collection functions"}, {"type": "code", "text": "map"}, {"type": "code", "text": "filter"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    println((1..10).filter { it % 2 == 0 })\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    println((1..10).filter { it % 2 == 0 })\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    println((1..10).filter { it % 2 == 0 })\n//sampleEnd\n}\n\n"}]