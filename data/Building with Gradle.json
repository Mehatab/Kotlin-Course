[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Building Multiplatform Projects with Gradle"}, {"type": "blockquote", "text": "\nMultiplatform projects are an experimental feature in Kotlin 1.2 and 1.3. All of the language\nand tooling features described in this document are subject to change in future Kotlin versions.\n"}, {"type": "p", "text": "Multiplatform projects are an experimental feature in Kotlin 1.2 and 1.3. All of the language\nand tooling features described in this document are subject to change in future Kotlin versions."}, {"type": "p", "text": "This document explains the structure of Kotlin multiplatform projects and describes how \nthose are configured and built using Gradle."}, {"type": "a", "text": "Kotlin multiplatform projects"}, {"type": "h2", "text": "Table of Contents"}, {"type": "ul", "text": "\nProject Structure\nSetting up a Multiplatform Project\nGradle Plugin\nSetting up Targets\n\nSupported platforms\nConfiguring compilations\n\n\nConfiguring Source Sets\n\nConnecting source sets\nAdding dependencies\nLanguage settings\n\n\nDefault Project Layout\nRunning Tests\nPublishing a Multiplatform Library\n\nExperimental metadata publishing mode\nDisambiguating targets\n\n\nJava Support in JVM Targets\nAndroid Support\n\nPublishing Android libraries\n\n\nUsing Kotlin/Native Targets\n\nTarget shortcuts\nBuilding final native binaries\n\n\n"}, {"type": "li", "text": "Project Structure"}, {"type": "a", "text": "Project Structure"}, {"type": "li", "text": "Setting up a Multiplatform Project"}, {"type": "a", "text": "Setting up a Multiplatform Project"}, {"type": "li", "text": "Gradle Plugin"}, {"type": "a", "text": "Gradle Plugin"}, {"type": "li", "text": "Setting up Targets\n\nSupported platforms\nConfiguring compilations\n\n"}, {"type": "a", "text": "Setting up Targets"}, {"type": "ul", "text": "\nSupported platforms\nConfiguring compilations\n"}, {"type": "li", "text": "Supported platforms"}, {"type": "a", "text": "Supported platforms"}, {"type": "li", "text": "Configuring compilations"}, {"type": "a", "text": "Configuring compilations"}, {"type": "li", "text": "Configuring Source Sets\n\nConnecting source sets\nAdding dependencies\nLanguage settings\n\n"}, {"type": "a", "text": "Configuring Source Sets"}, {"type": "ul", "text": "\nConnecting source sets\nAdding dependencies\nLanguage settings\n"}, {"type": "li", "text": "Connecting source sets"}, {"type": "a", "text": "Connecting source sets"}, {"type": "li", "text": "Adding dependencies"}, {"type": "a", "text": "Adding dependencies"}, {"type": "li", "text": "Language settings"}, {"type": "a", "text": "Language settings"}, {"type": "li", "text": "Default Project Layout"}, {"type": "a", "text": "Default Project Layout"}, {"type": "li", "text": "Running Tests"}, {"type": "a", "text": "Running Tests"}, {"type": "li", "text": "Publishing a Multiplatform Library\n\nExperimental metadata publishing mode\nDisambiguating targets\n\n"}, {"type": "a", "text": "Publishing a Multiplatform Library"}, {"type": "ul", "text": "\nExperimental metadata publishing mode\nDisambiguating targets\n"}, {"type": "li", "text": "Experimental metadata publishing mode"}, {"type": "a", "text": "Experimental metadata publishing mode"}, {"type": "li", "text": "Disambiguating targets"}, {"type": "a", "text": "Disambiguating targets"}, {"type": "li", "text": "Java Support in JVM Targets"}, {"type": "a", "text": "Java Support in JVM Targets"}, {"type": "li", "text": "Android Support\n\nPublishing Android libraries\n\n"}, {"type": "a", "text": "Android Support"}, {"type": "ul", "text": "\nPublishing Android libraries\n"}, {"type": "li", "text": "Publishing Android libraries"}, {"type": "a", "text": "Publishing Android libraries"}, {"type": "li", "text": "Using Kotlin/Native Targets\n\nTarget shortcuts\nBuilding final native binaries\n\n"}, {"type": "a", "text": "Using Kotlin/Native Targets"}, {"type": "ul", "text": "\nTarget shortcuts\nBuilding final native binaries\n"}, {"type": "li", "text": "Target shortcuts"}, {"type": "a", "text": "Target shortcuts"}, {"type": "li", "text": "Building final native binaries"}, {"type": "a", "text": "Building final native binaries"}, {"type": "h2", "text": "Project Structure"}, {"type": "p", "text": "The layout of a Kotlin multiplatform project is constructed out of the following building blocks:"}, {"type": "ul", "text": "\n\nA target is a part of the build that is responsible for building, testing, \nand packaging a complete piece of software for one of the platforms. Therefore, a multiplatform project usually contains \nmultiple targets.\n\n\nBuilding each target involves compiling Kotlin sources once or multiple times. In other words, a target may have one or \nmore compilations. For example, one compilation for production sources, the other for tests.\n\n\nThe Kotlin sources are arranged into source sets. In addition to Kotlin source files and \nresources, each source set may have its own dependencies. Source sets form a hierarchy that is built with \nthe \"depends on\" relation. A source set by itself is platform agnostic, but it may contain platform-specific code and \ndependencies if it's only compiled for a single platform.\n\n"}, {"type": "li", "text": "\nA target is a part of the build that is responsible for building, testing, \nand packaging a complete piece of software for one of the platforms. Therefore, a multiplatform project usually contains \nmultiple targets.\n"}, {"type": "p", "text": "A target is a part of the build that is responsible for building, testing, \nand packaging a complete piece of software for one of the platforms. Therefore, a multiplatform project usually contains \nmultiple targets."}, {"type": "a", "text": "target"}, {"type": "li", "text": "\nBuilding each target involves compiling Kotlin sources once or multiple times. In other words, a target may have one or \nmore compilations. For example, one compilation for production sources, the other for tests.\n"}, {"type": "p", "text": "Building each target involves compiling Kotlin sources once or multiple times. In other words, a target may have one or \nmore compilations. For example, one compilation for production sources, the other for tests."}, {"type": "a", "text": "compilations"}, {"type": "li", "text": "\nThe Kotlin sources are arranged into source sets. In addition to Kotlin source files and \nresources, each source set may have its own dependencies. Source sets form a hierarchy that is built with \nthe \"depends on\" relation. A source set by itself is platform agnostic, but it may contain platform-specific code and \ndependencies if it's only compiled for a single platform.\n"}, {"type": "p", "text": "The Kotlin sources are arranged into source sets. In addition to Kotlin source files and \nresources, each source set may have its own dependencies. Source sets form a hierarchy that is built with \nthe \"depends on\" relation. A source set by itself is platform agnostic, but it may contain platform-specific code and \ndependencies if it's only compiled for a single platform."}, {"type": "a", "text": "source sets"}, {"type": "em", "text": "\"depends on\""}, {"type": "p", "text": "Each compilation has a default source set, which is the place for sources and dependencies that are specific to that \ncompilation. The default source set is also used for directing other source sets to the compilation by the means of the \n\"depends on\" relation."}, {"type": "p", "text": "Here's an illustration of what a project targeting the JVM and JS looks like:"}, {"type": "p", "text": ""}, {"type": "img", "text": ""}, {"type": "p", "text": "Here, the two targets, jvm and js, each compile the production and test sources, and some of the sources are shared.\nThis layout is achieved by just creating the two targets, with no additional configuration for the compilations and \nsource sets: those are created by default for these targets."}, {"type": "code", "text": "jvm"}, {"type": "code", "text": "js"}, {"type": "a", "text": "created by default"}, {"type": "p", "text": "In the example above, the production sources for the JVM target are compiled by its main compilation and therefore \ninclude the sources and dependencies from the source sets jvmMain and commonMain (due to the depends on relation):"}, {"type": "code", "text": "main"}, {"type": "code", "text": "jvmMain"}, {"type": "code", "text": "commonMain"}, {"type": "em", "text": "depends on"}, {"type": "p", "text": ""}, {"type": "img", "text": ""}, {"type": "p", "text": "Here, the jvmMain source set provides plaform-specific implementations for the \nexpected API in the shared commonMain sources. This is how the code is shared between the platforms in a flexible way\nwith platform-specific implementations where needed."}, {"type": "code", "text": "jvmMain"}, {"type": "a", "text": "plaform-specific implementations"}, {"type": "code", "text": "commonMain"}, {"type": "p", "text": "In further sections, these concepts are described in more detail along with the DSL to configure them in a project."}, {"type": "h2", "text": "Setting up a Multiplatform Project"}, {"type": "p", "text": "You can create a new multiplatform project in the IDE by selecting one of the multiplatform project templates in the \nNew Project dialog under the \"Kotlin\" section."}, {"type": "p", "text": "For example, if you choose \"Kotlin (Multiplatform Library)\", a library project is created that has three \ntargets, one for the JVM, one for JS, and one for the Native platform that you are using. \nThese are configured in the build.gradle\nscript in the following way:"}, {"type": "a", "text": "targets"}, {"type": "code", "text": "build.gradle"}, {"type": "div", "text": "\n\nplugins {\n    id 'org.jetbrains.kotlin.multiplatform' version '1.3.72'\n}\n\nrepositories {\n    mavenCentral()\n}\n\nkotlin {\n    jvm() // Creates a JVM target with the default name 'jvm'\n    js()  // JS target named 'js'\n    mingwX64(\"mingw\") // Windows (MinGW X64) target named 'mingw'\n    \n    sourceSets { /* ... */ }\n}\n\n\n"}, {"type": "div", "text": "\nplugins {\n    id 'org.jetbrains.kotlin.multiplatform' version '1.3.72'\n}\n\nrepositories {\n    mavenCentral()\n}\n\nkotlin {\n    jvm() // Creates a JVM target with the default name 'jvm'\n    js()  // JS target named 'js'\n    mingwX64(\"mingw\") // Windows (MinGW X64) target named 'mingw'\n    \n    sourceSets { /* ... */ }\n}\n\n"}, {"type": "pre", "text": "plugins {\n    id 'org.jetbrains.kotlin.multiplatform' version '1.3.72'\n}\n\nrepositories {\n    mavenCentral()\n}\n\nkotlin {\n    jvm() // Creates a JVM target with the default name 'jvm'\n    js()  // JS target named 'js'\n    mingwX64(\"mingw\") // Windows (MinGW X64) target named 'mingw'\n    \n    sourceSets { /* ... */ }\n}\n"}, {"type": "code", "text": "plugins {\n    id 'org.jetbrains.kotlin.multiplatform' version '1.3.72'\n}\n\nrepositories {\n    mavenCentral()\n}\n\nkotlin {\n    jvm() // Creates a JVM target with the default name 'jvm'\n    js()  // JS target named 'js'\n    mingwX64(\"mingw\") // Windows (MinGW X64) target named 'mingw'\n    \n    sourceSets { /* ... */ }\n}\n"}, {"type": "div", "text": "\n\nplugins {\n    kotlin(\"multiplatform\") version \"1.3.72\"\n}\n\nrepositories {\n    mavenCentral()\n}\n\nkotlin {\n    jvm() // Creates a JVM target with the default name 'jvm'\n    js()  // JS target named 'js'\n    mingwX64(\"mingw\") // Windows (MinGW X64) target named 'mingw'\n    \n    sourceSets { /* ... */ }\n}\n\n\n"}, {"type": "div", "text": "\nplugins {\n    kotlin(\"multiplatform\") version \"1.3.72\"\n}\n\nrepositories {\n    mavenCentral()\n}\n\nkotlin {\n    jvm() // Creates a JVM target with the default name 'jvm'\n    js()  // JS target named 'js'\n    mingwX64(\"mingw\") // Windows (MinGW X64) target named 'mingw'\n    \n    sourceSets { /* ... */ }\n}\n\n"}, {"type": "pre", "text": "plugins {\n    kotlin(\"multiplatform\") version \"1.3.72\"\n}\n\nrepositories {\n    mavenCentral()\n}\n\nkotlin {\n    jvm() // Creates a JVM target with the default name 'jvm'\n    js()  // JS target named 'js'\n    mingwX64(\"mingw\") // Windows (MinGW X64) target named 'mingw'\n    \n    sourceSets { /* ... */ }\n}\n"}, {"type": "code", "text": "plugins {\n    kotlin(\"multiplatform\") version \"1.3.72\"\n}\n\nrepositories {\n    mavenCentral()\n}\n\nkotlin {\n    jvm() // Creates a JVM target with the default name 'jvm'\n    js()  // JS target named 'js'\n    mingwX64(\"mingw\") // Windows (MinGW X64) target named 'mingw'\n    \n    sourceSets { /* ... */ }\n}\n"}, {"type": "p", "text": "The three targets are created with the preset functions jvm(), js(), and mingwX64() that provide some \ndefault configuration. There are presets for each of the supported platforms."}, {"type": "code", "text": "jvm()"}, {"type": "code", "text": "js()"}, {"type": "code", "text": "mingwX64()"}, {"type": "a", "text": "default configuration"}, {"type": "a", "text": "supported platforms"}, {"type": "p", "text": "The source sets and their dependencies are then configured as follows:"}, {"type": "a", "text": "source sets"}, {"type": "a", "text": "dependencies"}, {"type": "div", "text": "\n\nplugins { /* ... */ }\n\nkotlin {\n    /* Targets declarations omitted */\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                implementation kotlin('stdlib-common')\n            }\n        }\n        commonTest {\n            dependencies {\n                implementation kotlin('test-common')\n                implementation kotlin('test-annotations-common')\n            }\n        }\n        \n        // Default source set for JVM-specific sources and dependencies.\n        // Alternatively, jvmMain { ... } would work as well:\n        jvm().compilations.main.defaultSourceSet {\n            dependencies {\n                implementation kotlin('stdlib-jdk8')\n            }\n        }\n        // JVM-specific tests and their dependencies:\n        jvm().compilations.test.defaultSourceSet {\n            dependencies {\n                implementation kotlin('test-junit')\n            }\n        }\n        \n        js().compilations.main.defaultSourceSet  { /* ... */ }\n        js().compilations.test.defaultSourceSet { /* ... */ }\n        \n        mingwX64('mingw').compilations.main.defaultSourceSet { /* ... */ }\n        mingwX64('mingw').compilations.test.defaultSourceSet { /* ... */ }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nplugins { /* ... */ }\n\nkotlin {\n    /* Targets declarations omitted */\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                implementation kotlin('stdlib-common')\n            }\n        }\n        commonTest {\n            dependencies {\n                implementation kotlin('test-common')\n                implementation kotlin('test-annotations-common')\n            }\n        }\n        \n        // Default source set for JVM-specific sources and dependencies.\n        // Alternatively, jvmMain { ... } would work as well:\n        jvm().compilations.main.defaultSourceSet {\n            dependencies {\n                implementation kotlin('stdlib-jdk8')\n            }\n        }\n        // JVM-specific tests and their dependencies:\n        jvm().compilations.test.defaultSourceSet {\n            dependencies {\n                implementation kotlin('test-junit')\n            }\n        }\n        \n        js().compilations.main.defaultSourceSet  { /* ... */ }\n        js().compilations.test.defaultSourceSet { /* ... */ }\n        \n        mingwX64('mingw').compilations.main.defaultSourceSet { /* ... */ }\n        mingwX64('mingw').compilations.test.defaultSourceSet { /* ... */ }\n    }\n}\n\n"}, {"type": "pre", "text": "plugins { /* ... */ }\n\nkotlin {\n    /* Targets declarations omitted */\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                implementation kotlin('stdlib-common')\n            }\n        }\n        commonTest {\n            dependencies {\n                implementation kotlin('test-common')\n                implementation kotlin('test-annotations-common')\n            }\n        }\n        \n        // Default source set for JVM-specific sources and dependencies.\n        // Alternatively, jvmMain { ... } would work as well:\n        jvm().compilations.main.defaultSourceSet {\n            dependencies {\n                implementation kotlin('stdlib-jdk8')\n            }\n        }\n        // JVM-specific tests and their dependencies:\n        jvm().compilations.test.defaultSourceSet {\n            dependencies {\n                implementation kotlin('test-junit')\n            }\n        }\n        \n        js().compilations.main.defaultSourceSet  { /* ... */ }\n        js().compilations.test.defaultSourceSet { /* ... */ }\n        \n        mingwX64('mingw').compilations.main.defaultSourceSet { /* ... */ }\n        mingwX64('mingw').compilations.test.defaultSourceSet { /* ... */ }\n    }\n}\n"}, {"type": "code", "text": "plugins { /* ... */ }\n\nkotlin {\n    /* Targets declarations omitted */\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                implementation kotlin('stdlib-common')\n            }\n        }\n        commonTest {\n            dependencies {\n                implementation kotlin('test-common')\n                implementation kotlin('test-annotations-common')\n            }\n        }\n        \n        // Default source set for JVM-specific sources and dependencies.\n        // Alternatively, jvmMain { ... } would work as well:\n        jvm().compilations.main.defaultSourceSet {\n            dependencies {\n                implementation kotlin('stdlib-jdk8')\n            }\n        }\n        // JVM-specific tests and their dependencies:\n        jvm().compilations.test.defaultSourceSet {\n            dependencies {\n                implementation kotlin('test-junit')\n            }\n        }\n        \n        js().compilations.main.defaultSourceSet  { /* ... */ }\n        js().compilations.test.defaultSourceSet { /* ... */ }\n        \n        mingwX64('mingw').compilations.main.defaultSourceSet { /* ... */ }\n        mingwX64('mingw').compilations.test.defaultSourceSet { /* ... */ }\n    }\n}\n"}, {"type": "div", "text": "\n\nplugins { /* ... */ }\n\nkotlin {\n    /* Targets declarations omitted */\n\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(kotlin(\"stdlib-common\"))\n            }\n        }\n        val commonTest by getting {\n            dependencies {\n                implementation(kotlin(\"test-common\"))\n                implementation(kotlin(\"test-annotations-common\"))\n            }\n        }\n        \n        // Default source set for JVM-specific sources and dependencies:\n        jvm().compilations[\"main\"].defaultSourceSet {\n            dependencies {\n                implementation(kotlin(\"stdlib-jdk8\"))\n            }\n        }\n        // JVM-specific tests and their dependencies:\n        jvm().compilations[\"test\"].defaultSourceSet {\n            dependencies {\n                implementation(kotlin(\"test-junit\"))\n            }\n        }\n        \n        js().compilations[\"main\"].defaultSourceSet  { /* ... */ }\n        js().compilations[\"test\"].defaultSourceSet { /* ... */ }\n        \n        mingwX64(\"mingw\").compilations[\"main\"].defaultSourceSet { /* ... */ }\n        mingwX64(\"mingw\").compilations[\"test\"].defaultSourceSet { /* ... */ }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nplugins { /* ... */ }\n\nkotlin {\n    /* Targets declarations omitted */\n\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(kotlin(\"stdlib-common\"))\n            }\n        }\n        val commonTest by getting {\n            dependencies {\n                implementation(kotlin(\"test-common\"))\n                implementation(kotlin(\"test-annotations-common\"))\n            }\n        }\n        \n        // Default source set for JVM-specific sources and dependencies:\n        jvm().compilations[\"main\"].defaultSourceSet {\n            dependencies {\n                implementation(kotlin(\"stdlib-jdk8\"))\n            }\n        }\n        // JVM-specific tests and their dependencies:\n        jvm().compilations[\"test\"].defaultSourceSet {\n            dependencies {\n                implementation(kotlin(\"test-junit\"))\n            }\n        }\n        \n        js().compilations[\"main\"].defaultSourceSet  { /* ... */ }\n        js().compilations[\"test\"].defaultSourceSet { /* ... */ }\n        \n        mingwX64(\"mingw\").compilations[\"main\"].defaultSourceSet { /* ... */ }\n        mingwX64(\"mingw\").compilations[\"test\"].defaultSourceSet { /* ... */ }\n    }\n}\n\n"}, {"type": "pre", "text": "plugins { /* ... */ }\n\nkotlin {\n    /* Targets declarations omitted */\n\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(kotlin(\"stdlib-common\"))\n            }\n        }\n        val commonTest by getting {\n            dependencies {\n                implementation(kotlin(\"test-common\"))\n                implementation(kotlin(\"test-annotations-common\"))\n            }\n        }\n        \n        // Default source set for JVM-specific sources and dependencies:\n        jvm().compilations[\"main\"].defaultSourceSet {\n            dependencies {\n                implementation(kotlin(\"stdlib-jdk8\"))\n            }\n        }\n        // JVM-specific tests and their dependencies:\n        jvm().compilations[\"test\"].defaultSourceSet {\n            dependencies {\n                implementation(kotlin(\"test-junit\"))\n            }\n        }\n        \n        js().compilations[\"main\"].defaultSourceSet  { /* ... */ }\n        js().compilations[\"test\"].defaultSourceSet { /* ... */ }\n        \n        mingwX64(\"mingw\").compilations[\"main\"].defaultSourceSet { /* ... */ }\n        mingwX64(\"mingw\").compilations[\"test\"].defaultSourceSet { /* ... */ }\n    }\n}\n"}, {"type": "code", "text": "plugins { /* ... */ }\n\nkotlin {\n    /* Targets declarations omitted */\n\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(kotlin(\"stdlib-common\"))\n            }\n        }\n        val commonTest by getting {\n            dependencies {\n                implementation(kotlin(\"test-common\"))\n                implementation(kotlin(\"test-annotations-common\"))\n            }\n        }\n        \n        // Default source set for JVM-specific sources and dependencies:\n        jvm().compilations[\"main\"].defaultSourceSet {\n            dependencies {\n                implementation(kotlin(\"stdlib-jdk8\"))\n            }\n        }\n        // JVM-specific tests and their dependencies:\n        jvm().compilations[\"test\"].defaultSourceSet {\n            dependencies {\n                implementation(kotlin(\"test-junit\"))\n            }\n        }\n        \n        js().compilations[\"main\"].defaultSourceSet  { /* ... */ }\n        js().compilations[\"test\"].defaultSourceSet { /* ... */ }\n        \n        mingwX64(\"mingw\").compilations[\"main\"].defaultSourceSet { /* ... */ }\n        mingwX64(\"mingw\").compilations[\"test\"].defaultSourceSet { /* ... */ }\n    }\n}\n"}, {"type": "p", "text": "These are the default source set names for the production and test sources for the targets \nconfigured above. The source sets commonMain and commonTest are included into production and test compilations, respectively, of all targets. \nNote that the dependencies for common source sets commonMain and commonTest are the common artifacts, and the \nplatform libraries go to the source sets of the specific targets."}, {"type": "a", "text": "default source set names"}, {"type": "code", "text": "commonMain"}, {"type": "code", "text": "commonTest"}, {"type": "code", "text": "commonMain"}, {"type": "code", "text": "commonTest"}, {"type": "h2", "text": "Gradle Plugin"}, {"type": "p", "text": "Kotlin Multiplatform projects require Gradle version 4.7 and above, older Gradle versions are not supported."}, {"type": "p", "text": "To setup a multiplatform project from scratch in a Gradle project, first apply the \nkotlin-multiplatform plugin to the project by adding the following to the\nbeginning of the build.gradle file:"}, {"type": "code", "text": "kotlin-multiplatform"}, {"type": "code", "text": "build.gradle"}, {"type": "div", "text": "\n\nplugins {\n    id 'org.jetbrains.kotlin.multiplatform' version '1.3.72'\n}\n\n\n"}, {"type": "div", "text": "\nplugins {\n    id 'org.jetbrains.kotlin.multiplatform' version '1.3.72'\n}\n\n"}, {"type": "pre", "text": "plugins {\n    id 'org.jetbrains.kotlin.multiplatform' version '1.3.72'\n}\n"}, {"type": "code", "text": "plugins {\n    id 'org.jetbrains.kotlin.multiplatform' version '1.3.72'\n}\n"}, {"type": "div", "text": "\n\nplugins {\n    kotlin(\"multiplatform\") version \"1.3.72\"\n}\n\n\n"}, {"type": "div", "text": "\nplugins {\n    kotlin(\"multiplatform\") version \"1.3.72\"\n}\n\n"}, {"type": "pre", "text": "plugins {\n    kotlin(\"multiplatform\") version \"1.3.72\"\n}\n"}, {"type": "code", "text": "plugins {\n    kotlin(\"multiplatform\") version \"1.3.72\"\n}\n"}, {"type": "p", "text": "This creates the kotlin extension at the top level. You can then access it in the build script for:"}, {"type": "code", "text": "kotlin"}, {"type": "ul", "text": "\nsetting up the targets for multiple platforms (no targets are created by default);\nconfiguring the source sets and their dependencies;\n"}, {"type": "li", "text": "setting up the targets for multiple platforms (no targets are created by default);"}, {"type": "a", "text": "setting up the targets"}, {"type": "li", "text": "configuring the source sets and their dependencies;"}, {"type": "a", "text": "configuring the source sets"}, {"type": "a", "text": "dependencies"}, {"type": "h2", "text": "Setting up Targets"}, {"type": "p", "text": "A target is a part of the build responsible for compiling, testing, and packaging a piece of software aimed for\none of the supported platforms."}, {"type": "a", "text": "supported platforms"}, {"type": "p", "text": "All of the targets may share some of the sources and may have platform-specific sources as well."}, {"type": "p", "text": "As the platforms are different, targets are built in different ways as well and have various platform-specific \nsettings. The Gradle plugin bundles a number of presets for the supported platforms."}, {"type": "p", "text": "To create a target, use one of the preset functions, which are named according to the target platforms and optionally \naccept the target name and a configuring code block:"}, {"type": "div", "text": "\nkotlin {\n    jvm() // Create a JVM target with the default name 'jvm'\n    js(\"nodeJs\") // Create a JS target with a custom name 'nodeJs'\n        \n    linuxX64(\"linux\") {\n        /* Specify additional settings for the 'linux' target here */\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm() // Create a JVM target with the default name 'jvm'\n    js(\"nodeJs\") // Create a JS target with a custom name 'nodeJs'\n        \n    linuxX64(\"linux\") {\n        /* Specify additional settings for the 'linux' target here */\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm() // Create a JVM target with the default name 'jvm'\n    js(\"nodeJs\") // Create a JS target with a custom name 'nodeJs'\n        \n    linuxX64(\"linux\") {\n        /* Specify additional settings for the 'linux' target here */\n    }\n}\n"}, {"type": "p", "text": "The preset functions return an existing target if there is one. This can be used to configure an existing target:"}, {"type": "div", "text": "\nkotlin {\n    /* ... */\n    \n    // Configure the attributes of the 'jvm6' target:\n    jvm(\"jvm6\").attributes { /* ... */ }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    /* ... */\n    \n    // Configure the attributes of the 'jvm6' target:\n    jvm(\"jvm6\").attributes { /* ... */ }\n}\n"}, {"type": "code", "text": "kotlin {\n    /* ... */\n    \n    // Configure the attributes of the 'jvm6' target:\n    jvm(\"jvm6\").attributes { /* ... */ }\n}\n"}, {"type": "p", "text": "Note that both the target platform and the name matter: if a target was created as jvm('jvm6'), using jvm() will\ncreate a separate target (with the default name jvm). If the preset function used to create the target under that name\nwas different, an error is reported."}, {"type": "code", "text": "jvm('jvm6')"}, {"type": "code", "text": "jvm()"}, {"type": "code", "text": "jvm"}, {"type": "p", "text": "The targets created from presets are added to the kotlin.targets domain object collection, which can be used to \naccess them by their names or configure all targets:"}, {"type": "code", "text": "kotlin.targets"}, {"type": "div", "text": "\nkotlin {\n    jvm()\n    js(\"nodeJs\")\n    \n    println(targets.names) // Prints: [jvm, metadata, nodeJs]\n    \n    // Configure all targets, including those which will be added later:\n    targets.all {\n        compilations[\"main\"].defaultSourceSet { /* ... */ }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm()\n    js(\"nodeJs\")\n    \n    println(targets.names) // Prints: [jvm, metadata, nodeJs]\n    \n    // Configure all targets, including those which will be added later:\n    targets.all {\n        compilations[\"main\"].defaultSourceSet { /* ... */ }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm()\n    js(\"nodeJs\")\n    \n    println(targets.names) // Prints: [jvm, metadata, nodeJs]\n    \n    // Configure all targets, including those which will be added later:\n    targets.all {\n        compilations[\"main\"].defaultSourceSet { /* ... */ }\n    }\n}\n"}, {"type": "p", "text": "To create or access several targets from multiple presets dynamically, you can use the targetFromPreset function which\naccepts a preset (those are contained in the kotlin.presets domain object collection) and, optionally, a target name \nand a configuration code block."}, {"type": "code", "text": "targetFromPreset"}, {"type": "code", "text": "kotlin.presets"}, {"type": "p", "text": "For example, to create a target for each of the Kotlin/Native supported platforms (see below), use this code:"}, {"type": "div", "text": "\n\nkotlin {\n    presets.withType(org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTargetPreset).each {\n        targetFromPreset(it) { \n            /* Configure each of the created targets */\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    presets.withType(org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTargetPreset).each {\n        targetFromPreset(it) { \n            /* Configure each of the created targets */\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    presets.withType(org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTargetPreset).each {\n        targetFromPreset(it) { \n            /* Configure each of the created targets */\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    presets.withType(org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTargetPreset).each {\n        targetFromPreset(it) { \n            /* Configure each of the created targets */\n        }\n    }\n}\n"}, {"type": "div", "text": "\n\nimport org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTargetPreset\n\n/* ... */\n\nkotlin {\n    presets.withType<KotlinNativeTargetPreset>().forEach {\n        targetFromPreset(it) { \n            /* Configure each of the created targets */\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nimport org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTargetPreset\n\n/* ... */\n\nkotlin {\n    presets.withType<KotlinNativeTargetPreset>().forEach {\n        targetFromPreset(it) { \n            /* Configure each of the created targets */\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTargetPreset\n\n/* ... */\n\nkotlin {\n    presets.withType<KotlinNativeTargetPreset>().forEach {\n        targetFromPreset(it) { \n            /* Configure each of the created targets */\n        }\n    }\n}\n"}, {"type": "code", "text": "import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTargetPreset\n\n/* ... */\n\nkotlin {\n    presets.withType<KotlinNativeTargetPreset>().forEach {\n        targetFromPreset(it) { \n            /* Configure each of the created targets */\n        }\n    }\n}\n"}, {"type": "h3", "text": "Supported platforms"}, {"type": "p", "text": "There are target presets that one can apply using the preset functions, as shown above, for the\nfollowing target platforms:"}, {"type": "ul", "text": "\njvm for Kotlin/JVM;\njs for Kotlin/JS;\n\nandroid for Android applications and libraries. Note that one of the Android Gradle \n plugins should be applied before the target is created;\n\n\nKotlin/Native target presets (see the notes below):\n\nandroidNativeArm32 and androidNativeArm64 for Android NDK;\niosArm32, iosArm64, iosX64 for iOS;\nwatchosArm32, watchosArm64, watchosX86 for watchOS;\ntvosArm64, tvosX64 for tvOS;\nlinuxArm64, linuxArm32Hfp, linuxMips32, linuxMipsel32, linuxX64 for Linux;\nmacosX64 for MacOS;\nmingwX64 and mingwX86 for Windows;\nwasm32 for WebAssembly.\n\nNote that some of the Kotlin/Native targets require an appropriate host machine to build on.\n\n"}, {"type": "li", "text": "jvm for Kotlin/JVM;"}, {"type": "code", "text": "jvm"}, {"type": "li", "text": "js for Kotlin/JS;"}, {"type": "code", "text": "js"}, {"type": "li", "text": "\nandroid for Android applications and libraries. Note that one of the Android Gradle \n plugins should be applied before the target is created;\n"}, {"type": "p", "text": "android for Android applications and libraries. Note that one of the Android Gradle \n plugins should be applied before the target is created;"}, {"type": "code", "text": "android"}, {"type": "li", "text": "\nKotlin/Native target presets (see the notes below):\n\nandroidNativeArm32 and androidNativeArm64 for Android NDK;\niosArm32, iosArm64, iosX64 for iOS;\nwatchosArm32, watchosArm64, watchosX86 for watchOS;\ntvosArm64, tvosX64 for tvOS;\nlinuxArm64, linuxArm32Hfp, linuxMips32, linuxMipsel32, linuxX64 for Linux;\nmacosX64 for MacOS;\nmingwX64 and mingwX86 for Windows;\nwasm32 for WebAssembly.\n\nNote that some of the Kotlin/Native targets require an appropriate host machine to build on.\n"}, {"type": "p", "text": "Kotlin/Native target presets (see the notes below):"}, {"type": "a", "text": "notes"}, {"type": "ul", "text": "\nandroidNativeArm32 and androidNativeArm64 for Android NDK;\niosArm32, iosArm64, iosX64 for iOS;\nwatchosArm32, watchosArm64, watchosX86 for watchOS;\ntvosArm64, tvosX64 for tvOS;\nlinuxArm64, linuxArm32Hfp, linuxMips32, linuxMipsel32, linuxX64 for Linux;\nmacosX64 for MacOS;\nmingwX64 and mingwX86 for Windows;\nwasm32 for WebAssembly.\n"}, {"type": "li", "text": "androidNativeArm32 and androidNativeArm64 for Android NDK;"}, {"type": "code", "text": "androidNativeArm32"}, {"type": "code", "text": "androidNativeArm64"}, {"type": "li", "text": "iosArm32, iosArm64, iosX64 for iOS;"}, {"type": "code", "text": "iosArm32"}, {"type": "code", "text": "iosArm64"}, {"type": "code", "text": "iosX64"}, {"type": "li", "text": "watchosArm32, watchosArm64, watchosX86 for watchOS;"}, {"type": "code", "text": "watchosArm32"}, {"type": "code", "text": "watchosArm64"}, {"type": "code", "text": "watchosX86"}, {"type": "li", "text": "tvosArm64, tvosX64 for tvOS;"}, {"type": "code", "text": "tvosArm64"}, {"type": "code", "text": "tvosX64"}, {"type": "li", "text": "linuxArm64, linuxArm32Hfp, linuxMips32, linuxMipsel32, linuxX64 for Linux;"}, {"type": "code", "text": "linuxArm64"}, {"type": "code", "text": "linuxArm32Hfp"}, {"type": "code", "text": "linuxMips32"}, {"type": "code", "text": "linuxMipsel32"}, {"type": "code", "text": "linuxX64"}, {"type": "li", "text": "macosX64 for MacOS;"}, {"type": "code", "text": "macosX64"}, {"type": "li", "text": "mingwX64 and mingwX86 for Windows;"}, {"type": "code", "text": "mingwX64"}, {"type": "code", "text": "mingwX86"}, {"type": "li", "text": "wasm32 for WebAssembly."}, {"type": "code", "text": "wasm32"}, {"type": "p", "text": "Note that some of the Kotlin/Native targets require an appropriate host machine to build on."}, {"type": "a", "text": "appropriate host machine"}, {"type": "p", "text": "Some targets may require additional configuration. For Android and iOS examples, see \nthe Multiplatform Project: iOS and Android tutorial."}, {"type": "a", "text": "Multiplatform Project: iOS and Android"}, {"type": "h3", "text": "Configuring compilations"}, {"type": "p", "text": "Building a target requires compiling Kotlin once or multiple times. Each Kotlin compilation of a target may serve a \ndifferent purpose (e.g. production code, tests) and incorporate different source sets. \nThe compilations of a target may be accessed in the DSL, for example, to get the tasks, configure \nthe Kotlin compiler options or get the dependency files and compilation outputs:"}, {"type": "a", "text": "source sets"}, {"type": "a", "text": "the Kotlin compiler options"}, {"type": "div", "text": "\n\nkotlin {\n    jvm {\n        compilations.main.kotlinOptions { \n            // Setup the Kotlin compiler options for the 'main' compilation:\n            jvmTarget = \"1.8\"\n        }\n        \n        compilations.main.compileKotlinTask // get the Kotlin task 'compileKotlinJvm' \n        compilations.main.output // get the main compilation output\n        compilations.test.runtimeDependencyFiles // get the test runtime classpath\n    }\n    \n    // Configure all compilations of all targets:\n    targets.all {\n        compilations.all {\n            kotlinOptions {\n                allWarningsAsErrors = true\n            }\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    jvm {\n        compilations.main.kotlinOptions { \n            // Setup the Kotlin compiler options for the 'main' compilation:\n            jvmTarget = \"1.8\"\n        }\n        \n        compilations.main.compileKotlinTask // get the Kotlin task 'compileKotlinJvm' \n        compilations.main.output // get the main compilation output\n        compilations.test.runtimeDependencyFiles // get the test runtime classpath\n    }\n    \n    // Configure all compilations of all targets:\n    targets.all {\n        compilations.all {\n            kotlinOptions {\n                allWarningsAsErrors = true\n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm {\n        compilations.main.kotlinOptions { \n            // Setup the Kotlin compiler options for the 'main' compilation:\n            jvmTarget = \"1.8\"\n        }\n        \n        compilations.main.compileKotlinTask // get the Kotlin task 'compileKotlinJvm' \n        compilations.main.output // get the main compilation output\n        compilations.test.runtimeDependencyFiles // get the test runtime classpath\n    }\n    \n    // Configure all compilations of all targets:\n    targets.all {\n        compilations.all {\n            kotlinOptions {\n                allWarningsAsErrors = true\n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm {\n        compilations.main.kotlinOptions { \n            // Setup the Kotlin compiler options for the 'main' compilation:\n            jvmTarget = \"1.8\"\n        }\n        \n        compilations.main.compileKotlinTask // get the Kotlin task 'compileKotlinJvm' \n        compilations.main.output // get the main compilation output\n        compilations.test.runtimeDependencyFiles // get the test runtime classpath\n    }\n    \n    // Configure all compilations of all targets:\n    targets.all {\n        compilations.all {\n            kotlinOptions {\n                allWarningsAsErrors = true\n            }\n        }\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin {\n    jvm {\n        val main by compilations.getting {\n            kotlinOptions { \n                // Setup the Kotlin compiler options for the 'main' compilation:\n                jvmTarget = \"1.8\"\n            }\n        \n            compileKotlinTask // get the Kotlin task 'compileKotlinJvm' \n            output // get the main compilation output\n        }\n        \n        compilations[\"test\"].runtimeDependencyFiles // get the test runtime classpath\n    }\n    \n    // Configure all compilations of all targets:\n    targets.all {\n        compilations.all {\n            kotlinOptions {\n                allWarningsAsErrors = true\n            }\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    jvm {\n        val main by compilations.getting {\n            kotlinOptions { \n                // Setup the Kotlin compiler options for the 'main' compilation:\n                jvmTarget = \"1.8\"\n            }\n        \n            compileKotlinTask // get the Kotlin task 'compileKotlinJvm' \n            output // get the main compilation output\n        }\n        \n        compilations[\"test\"].runtimeDependencyFiles // get the test runtime classpath\n    }\n    \n    // Configure all compilations of all targets:\n    targets.all {\n        compilations.all {\n            kotlinOptions {\n                allWarningsAsErrors = true\n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm {\n        val main by compilations.getting {\n            kotlinOptions { \n                // Setup the Kotlin compiler options for the 'main' compilation:\n                jvmTarget = \"1.8\"\n            }\n        \n            compileKotlinTask // get the Kotlin task 'compileKotlinJvm' \n            output // get the main compilation output\n        }\n        \n        compilations[\"test\"].runtimeDependencyFiles // get the test runtime classpath\n    }\n    \n    // Configure all compilations of all targets:\n    targets.all {\n        compilations.all {\n            kotlinOptions {\n                allWarningsAsErrors = true\n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm {\n        val main by compilations.getting {\n            kotlinOptions { \n                // Setup the Kotlin compiler options for the 'main' compilation:\n                jvmTarget = \"1.8\"\n            }\n        \n            compileKotlinTask // get the Kotlin task 'compileKotlinJvm' \n            output // get the main compilation output\n        }\n        \n        compilations[\"test\"].runtimeDependencyFiles // get the test runtime classpath\n    }\n    \n    // Configure all compilations of all targets:\n    targets.all {\n        compilations.all {\n            kotlinOptions {\n                allWarningsAsErrors = true\n            }\n        }\n    }\n}\n"}, {"type": "p", "text": "Each compilation is accompanied by a default source set that stores sources and dependencies \nspecific to that compilation. The default source set for a compilation foo of a target bar has the name barFoo.\nIt can also be accessed from a compilation using defaultSourceSet:"}, {"type": "a", "text": "source set"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "bar"}, {"type": "code", "text": "barFoo"}, {"type": "code", "text": "defaultSourceSet"}, {"type": "div", "text": "\n\nkotlin {\n    jvm() // Create a JVM target with the default name 'jvm'\n    \n    sourceSets {\n        // The default source set for the 'main` compilation of the 'jvm' target:\n        jvmMain {\n            /* ... */\n        }\n    }\n    \n    // Alternatively, access it from the target's compilation:\n    jvm().compilations.main.defaultSourceSet { \n        /* ... */\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    jvm() // Create a JVM target with the default name 'jvm'\n    \n    sourceSets {\n        // The default source set for the 'main` compilation of the 'jvm' target:\n        jvmMain {\n            /* ... */\n        }\n    }\n    \n    // Alternatively, access it from the target's compilation:\n    jvm().compilations.main.defaultSourceSet { \n        /* ... */\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm() // Create a JVM target with the default name 'jvm'\n    \n    sourceSets {\n        // The default source set for the 'main` compilation of the 'jvm' target:\n        jvmMain {\n            /* ... */\n        }\n    }\n    \n    // Alternatively, access it from the target's compilation:\n    jvm().compilations.main.defaultSourceSet { \n        /* ... */\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm() // Create a JVM target with the default name 'jvm'\n    \n    sourceSets {\n        // The default source set for the 'main` compilation of the 'jvm' target:\n        jvmMain {\n            /* ... */\n        }\n    }\n    \n    // Alternatively, access it from the target's compilation:\n    jvm().compilations.main.defaultSourceSet { \n        /* ... */\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin {\n    jvm() // Create a JVM target with the default name 'jvm'\n    \n    sourceSets {\n        // The default source set for the 'main` compilation of the 'jvm' target:\n        val jvmMain by getting {\n            /* ... */\n        }\n    }\n    \n    // Alternatively, access it from the target's compilation:\n    jvm().compilations[\"main\"].defaultSourceSet { \n        /* ... */\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    jvm() // Create a JVM target with the default name 'jvm'\n    \n    sourceSets {\n        // The default source set for the 'main` compilation of the 'jvm' target:\n        val jvmMain by getting {\n            /* ... */\n        }\n    }\n    \n    // Alternatively, access it from the target's compilation:\n    jvm().compilations[\"main\"].defaultSourceSet { \n        /* ... */\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm() // Create a JVM target with the default name 'jvm'\n    \n    sourceSets {\n        // The default source set for the 'main` compilation of the 'jvm' target:\n        val jvmMain by getting {\n            /* ... */\n        }\n    }\n    \n    // Alternatively, access it from the target's compilation:\n    jvm().compilations[\"main\"].defaultSourceSet { \n        /* ... */\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm() // Create a JVM target with the default name 'jvm'\n    \n    sourceSets {\n        // The default source set for the 'main` compilation of the 'jvm' target:\n        val jvmMain by getting {\n            /* ... */\n        }\n    }\n    \n    // Alternatively, access it from the target's compilation:\n    jvm().compilations[\"main\"].defaultSourceSet { \n        /* ... */\n    }\n}\n"}, {"type": "p", "text": "To collect all source sets participating in a compilation, including those added via the depends-on relation, one can\nuse the property allKotlinSourceSets."}, {"type": "code", "text": "allKotlinSourceSets"}, {"type": "p", "text": "For some specific use cases, creating a custom compilation may be required. This can be done within the target's compilations \ndomain object collection. Note that the dependencies need to be set up manually for all custom compilations, and the \nusage of a custom compilation's outputs is up to the build author. For example, consider a custom compilation for integration tests\nof a jvm() target:"}, {"type": "code", "text": "compilations"}, {"type": "code", "text": "jvm()"}, {"type": "div", "text": "\n\nkotlin {\n    jvm() {\n        compilations.create('integrationTest') {\n            defaultSourceSet {\n                dependencies {\n                    def main = compilations.main\n                    // Compile against the main compilation's compile classpath and outputs:\n                    implementation(main.compileDependencyFiles + main.output.classesDirs)\n                    implementation kotlin('test-junit')\n                    /* ... */\n                }\n            }\n\n            // Create a test task to run the tests produced by this compilation:\n            tasks.create('jvmIntegrationTest', Test) {\n                // Run the tests with the classpath containing the compile dependencies (including 'main'),\n                // runtime dependencies, and the outputs of this compilation:\n                classpath = compileDependencyFiles + runtimeDependencyFiles + output.allOutputs\n\n                // Run only the tests from this compilation's outputs:\n                testClassesDirs = output.classesDirs\n            }\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    jvm() {\n        compilations.create('integrationTest') {\n            defaultSourceSet {\n                dependencies {\n                    def main = compilations.main\n                    // Compile against the main compilation's compile classpath and outputs:\n                    implementation(main.compileDependencyFiles + main.output.classesDirs)\n                    implementation kotlin('test-junit')\n                    /* ... */\n                }\n            }\n\n            // Create a test task to run the tests produced by this compilation:\n            tasks.create('jvmIntegrationTest', Test) {\n                // Run the tests with the classpath containing the compile dependencies (including 'main'),\n                // runtime dependencies, and the outputs of this compilation:\n                classpath = compileDependencyFiles + runtimeDependencyFiles + output.allOutputs\n\n                // Run only the tests from this compilation's outputs:\n                testClassesDirs = output.classesDirs\n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm() {\n        compilations.create('integrationTest') {\n            defaultSourceSet {\n                dependencies {\n                    def main = compilations.main\n                    // Compile against the main compilation's compile classpath and outputs:\n                    implementation(main.compileDependencyFiles + main.output.classesDirs)\n                    implementation kotlin('test-junit')\n                    /* ... */\n                }\n            }\n\n            // Create a test task to run the tests produced by this compilation:\n            tasks.create('jvmIntegrationTest', Test) {\n                // Run the tests with the classpath containing the compile dependencies (including 'main'),\n                // runtime dependencies, and the outputs of this compilation:\n                classpath = compileDependencyFiles + runtimeDependencyFiles + output.allOutputs\n\n                // Run only the tests from this compilation's outputs:\n                testClassesDirs = output.classesDirs\n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm() {\n        compilations.create('integrationTest') {\n            defaultSourceSet {\n                dependencies {\n                    def main = compilations.main\n                    // Compile against the main compilation's compile classpath and outputs:\n                    implementation(main.compileDependencyFiles + main.output.classesDirs)\n                    implementation kotlin('test-junit')\n                    /* ... */\n                }\n            }\n\n            // Create a test task to run the tests produced by this compilation:\n            tasks.create('jvmIntegrationTest', Test) {\n                // Run the tests with the classpath containing the compile dependencies (including 'main'),\n                // runtime dependencies, and the outputs of this compilation:\n                classpath = compileDependencyFiles + runtimeDependencyFiles + output.allOutputs\n\n                // Run only the tests from this compilation's outputs:\n                testClassesDirs = output.classesDirs\n            }\n        }\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin {\n    jvm() {\n        compilations {\n            val main by getting\n\n            val integrationTest by compilations.creating {\n                defaultSourceSet {\n                    dependencies {\n                        // Compile against the main compilation's compile classpath and outputs:\n                        implementation(main.compileDependencyFiles + main.output.classesDirs)\n                        implementation(kotlin(\"test-junit\"))\n                        /* ... */\n                    }\n                }\n\n                // Create a test task to run the tests produced by this compilation:\n                tasks.create<Test>(\"integrationTest\") {\n                    // Run the tests with the classpath containing the compile dependencies (including 'main'),\n                    // runtime dependencies, and the outputs of this compilation:\n                    classpath = compileDependencyFiles + runtimeDependencyFiles + output.allOutputs\n\n                    // Run only the tests from this compilation's outputs:\n                    testClassesDirs = output.classesDirs\n                }\n            }\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    jvm() {\n        compilations {\n            val main by getting\n\n            val integrationTest by compilations.creating {\n                defaultSourceSet {\n                    dependencies {\n                        // Compile against the main compilation's compile classpath and outputs:\n                        implementation(main.compileDependencyFiles + main.output.classesDirs)\n                        implementation(kotlin(\"test-junit\"))\n                        /* ... */\n                    }\n                }\n\n                // Create a test task to run the tests produced by this compilation:\n                tasks.create<Test>(\"integrationTest\") {\n                    // Run the tests with the classpath containing the compile dependencies (including 'main'),\n                    // runtime dependencies, and the outputs of this compilation:\n                    classpath = compileDependencyFiles + runtimeDependencyFiles + output.allOutputs\n\n                    // Run only the tests from this compilation's outputs:\n                    testClassesDirs = output.classesDirs\n                }\n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm() {\n        compilations {\n            val main by getting\n\n            val integrationTest by compilations.creating {\n                defaultSourceSet {\n                    dependencies {\n                        // Compile against the main compilation's compile classpath and outputs:\n                        implementation(main.compileDependencyFiles + main.output.classesDirs)\n                        implementation(kotlin(\"test-junit\"))\n                        /* ... */\n                    }\n                }\n\n                // Create a test task to run the tests produced by this compilation:\n                tasks.create<Test>(\"integrationTest\") {\n                    // Run the tests with the classpath containing the compile dependencies (including 'main'),\n                    // runtime dependencies, and the outputs of this compilation:\n                    classpath = compileDependencyFiles + runtimeDependencyFiles + output.allOutputs\n\n                    // Run only the tests from this compilation's outputs:\n                    testClassesDirs = output.classesDirs\n                }\n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm() {\n        compilations {\n            val main by getting\n\n            val integrationTest by compilations.creating {\n                defaultSourceSet {\n                    dependencies {\n                        // Compile against the main compilation's compile classpath and outputs:\n                        implementation(main.compileDependencyFiles + main.output.classesDirs)\n                        implementation(kotlin(\"test-junit\"))\n                        /* ... */\n                    }\n                }\n\n                // Create a test task to run the tests produced by this compilation:\n                tasks.create<Test>(\"integrationTest\") {\n                    // Run the tests with the classpath containing the compile dependencies (including 'main'),\n                    // runtime dependencies, and the outputs of this compilation:\n                    classpath = compileDependencyFiles + runtimeDependencyFiles + output.allOutputs\n\n                    // Run only the tests from this compilation's outputs:\n                    testClassesDirs = output.classesDirs\n                }\n            }\n        }\n    }\n}\n"}, {"type": "p", "text": "Also note that the default source set of a custom compilation depends on neither commonMain nor commonTest by \ndefault."}, {"type": "code", "text": "commonMain"}, {"type": "code", "text": "commonTest"}, {"type": "h2", "text": "Configuring Source Sets"}, {"type": "p", "text": "A Kotlin source set is a collection of Kotlin sources, along with their resources, dependencies, and language settings, \nwhich may take part in Kotlin compilations of one or more targets."}, {"type": "a", "text": "targets"}, {"type": "p", "text": "A source set is not bound to be platform-specific or \"shared\"; what it's allowed to contain depends on its usage: \na source set added to multiple compilations is limited to the common language features and dependencies, while a source \nset that is only used by a single target can have platform-specific dependencies, and its code may use language \nfeatures specific to that target's platform."}, {"type": "p", "text": "Some source sets are created and configured by default: commonMain, commonTest, and the default source sets for the\n compilations. See Default Project Layout."}, {"type": "code", "text": "commonMain"}, {"type": "code", "text": "commonTest"}, {"type": "a", "text": "Default Project Layout"}, {"type": "p", "text": "The source sets are configured within a sourceSets { ... } block of the kotlin { ... } extension:"}, {"type": "code", "text": "sourceSets { ... }"}, {"type": "code", "text": "kotlin { ... }"}, {"type": "div", "text": "\n\nkotlin { \n    sourceSets { \n        foo { /* ... */ } // create or configure a source set by the name 'foo' \n        bar { /* ... */ }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin { \n    sourceSets { \n        foo { /* ... */ } // create or configure a source set by the name 'foo' \n        bar { /* ... */ }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin { \n    sourceSets { \n        foo { /* ... */ } // create or configure a source set by the name 'foo' \n        bar { /* ... */ }\n    }\n}\n"}, {"type": "code", "text": "kotlin { \n    sourceSets { \n        foo { /* ... */ } // create or configure a source set by the name 'foo' \n        bar { /* ... */ }\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin { \n    sourceSets { \n        val foo by creating { /* ... */ } // create a new source set by the name 'foo'\n        val bar by getting { /* ... */ } // configure an existing source set by the name 'bar' \n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin { \n    sourceSets { \n        val foo by creating { /* ... */ } // create a new source set by the name 'foo'\n        val bar by getting { /* ... */ } // configure an existing source set by the name 'bar' \n    }\n}\n\n"}, {"type": "pre", "text": "kotlin { \n    sourceSets { \n        val foo by creating { /* ... */ } // create a new source set by the name 'foo'\n        val bar by getting { /* ... */ } // configure an existing source set by the name 'bar' \n    }\n}\n"}, {"type": "code", "text": "kotlin { \n    sourceSets { \n        val foo by creating { /* ... */ } // create a new source set by the name 'foo'\n        val bar by getting { /* ... */ } // configure an existing source set by the name 'bar' \n    }\n}\n"}, {"type": "blockquote", "text": "\nNote: creating a source set does not link it to any target. Some source sets are predefined \nand thus compiled by default. However, custom source sets always need to be explicitly directed to the compilations. \nSee: Connecting source sets.\n"}, {"type": "p", "text": "Note: creating a source set does not link it to any target. Some source sets are predefined \nand thus compiled by default. However, custom source sets always need to be explicitly directed to the compilations. \nSee: Connecting source sets."}, {"type": "a", "text": "predefined"}, {"type": "a", "text": "Connecting source sets"}, {"type": "p", "text": "The source set names are case-sensitive. When referring to a default source set by its name, make sure the name prefix \nmatches a target's name, for example, a source set iosX64Main for a target iosX64."}, {"type": "code", "text": "iosX64Main"}, {"type": "code", "text": "iosX64"}, {"type": "p", "text": "A source set by itself is platform-agnostic, but\nit can be considered platform-specific if it is only compiled for a single platform. A source set can, therefore, contain either\ncommon code shared between the platforms or platform-specific code."}, {"type": "p", "text": "Each source set has a default source directory for Kotlin sources: src/<source set name>/kotlin. To add Kotlin source \ndirectories and resources to a source set, use its kotlin and resources SourceDirectorySets:"}, {"type": "code", "text": "src/<source set name>/kotlin"}, {"type": "code", "text": "kotlin"}, {"type": "code", "text": "resources"}, {"type": "code", "text": "SourceDirectorySet"}, {"type": "p", "text": "By default, the files of a source set are stored in the following directories:"}, {"type": "ul", "text": "\nsource files: src/<source set name>/kotlin\nresources files: src/<source set name>/resources\n"}, {"type": "li", "text": "source files: src/<source set name>/kotlin"}, {"type": "code", "text": "src/<source set name>/kotlin"}, {"type": "li", "text": "resources files: src/<source set name>/resources"}, {"type": "code", "text": "src/<source set name>/resources"}, {"type": "p", "text": "You should create these directories manually."}, {"type": "p", "text": "To add custom Kotlin source directories and resources to a source set, use its kotlin and resources SourceDirectorySets:"}, {"type": "code", "text": "kotlin"}, {"type": "code", "text": "resources"}, {"type": "code", "text": "SourceDirectorySet"}, {"type": "div", "text": "\n\nkotlin { \n    sourceSets { \n        commonMain {\n            kotlin.srcDir('src')\n            resources.srcDir('res')\n        } \n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin { \n    sourceSets { \n        commonMain {\n            kotlin.srcDir('src')\n            resources.srcDir('res')\n        } \n    }\n}\n\n"}, {"type": "pre", "text": "kotlin { \n    sourceSets { \n        commonMain {\n            kotlin.srcDir('src')\n            resources.srcDir('res')\n        } \n    }\n}\n"}, {"type": "code", "text": "kotlin { \n    sourceSets { \n        commonMain {\n            kotlin.srcDir('src')\n            resources.srcDir('res')\n        } \n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin { \n    sourceSets { \n        val commonMain by getting {\n            kotlin.srcDir(\"src\")\n            resources.srcDir(\"res\")\n        } \n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin { \n    sourceSets { \n        val commonMain by getting {\n            kotlin.srcDir(\"src\")\n            resources.srcDir(\"res\")\n        } \n    }\n}\n\n"}, {"type": "pre", "text": "kotlin { \n    sourceSets { \n        val commonMain by getting {\n            kotlin.srcDir(\"src\")\n            resources.srcDir(\"res\")\n        } \n    }\n}\n"}, {"type": "code", "text": "kotlin { \n    sourceSets { \n        val commonMain by getting {\n            kotlin.srcDir(\"src\")\n            resources.srcDir(\"res\")\n        } \n    }\n}\n"}, {"type": "h3", "text": "Connecting source sets"}, {"type": "p", "text": "Kotlin source sets may be connected with the 'depends on' relation, so that if a source set foo  depends on a \nsource set bar then:"}, {"type": "em", "text": "'depends on'"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "bar"}, {"type": "ul", "text": "\n\nwhenever foo is compiled for a certain target, bar takes part in that compilation as well and is also compiled \ninto the same target binary form, such as JVM class files or JS code;\n\n\nsources of foo 'see' the declarations of bar, including the internal ones, and the dependencies of bar, even those\n specified as implementation dependencies;\n\n\nfoo may contain platform-specific implementations for the expected declarations of bar;\n\n\nthe resources of bar are always processed and copied along with the resources of foo;\n\n\nthe language settings of foo and bar should be consistent;\n\n"}, {"type": "li", "text": "\nwhenever foo is compiled for a certain target, bar takes part in that compilation as well and is also compiled \ninto the same target binary form, such as JVM class files or JS code;\n"}, {"type": "p", "text": "whenever foo is compiled for a certain target, bar takes part in that compilation as well and is also compiled \ninto the same target binary form, such as JVM class files or JS code;"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "bar"}, {"type": "li", "text": "\nsources of foo 'see' the declarations of bar, including the internal ones, and the dependencies of bar, even those\n specified as implementation dependencies;\n"}, {"type": "p", "text": "sources of foo 'see' the declarations of bar, including the internal ones, and the dependencies of bar, even those\n specified as implementation dependencies;"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "bar"}, {"type": "code", "text": "internal"}, {"type": "a", "text": "dependencies"}, {"type": "code", "text": "bar"}, {"type": "code", "text": "implementation"}, {"type": "li", "text": "\nfoo may contain platform-specific implementations for the expected declarations of bar;\n"}, {"type": "p", "text": "foo may contain platform-specific implementations for the expected declarations of bar;"}, {"type": "code", "text": "foo"}, {"type": "a", "text": "platform-specific implementations"}, {"type": "code", "text": "bar"}, {"type": "li", "text": "\nthe resources of bar are always processed and copied along with the resources of foo;\n"}, {"type": "p", "text": "the resources of bar are always processed and copied along with the resources of foo;"}, {"type": "code", "text": "bar"}, {"type": "code", "text": "foo"}, {"type": "li", "text": "\nthe language settings of foo and bar should be consistent;\n"}, {"type": "p", "text": "the language settings of foo and bar should be consistent;"}, {"type": "a", "text": "language settings"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "bar"}, {"type": "p", "text": "Circular source set dependencies are prohibited."}, {"type": "p", "text": "The source sets DSL can be used to define these connections between the source sets:"}, {"type": "div", "text": "\n\nkotlin { \n    sourceSets { \n        commonMain { /* ... */ }\n        allJvm {\n            dependsOn commonMain\n            /* ... */\n        } \n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin { \n    sourceSets { \n        commonMain { /* ... */ }\n        allJvm {\n            dependsOn commonMain\n            /* ... */\n        } \n    }\n}\n\n"}, {"type": "pre", "text": "kotlin { \n    sourceSets { \n        commonMain { /* ... */ }\n        allJvm {\n            dependsOn commonMain\n            /* ... */\n        } \n    }\n}\n"}, {"type": "code", "text": "kotlin { \n    sourceSets { \n        commonMain { /* ... */ }\n        allJvm {\n            dependsOn commonMain\n            /* ... */\n        } \n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin { \n    sourceSets { \n        val commonMain by getting { /* ... */ }\n        val allJvm by creating {\n            dependsOn(commonMain)\n            /* ... */\n        } \n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin { \n    sourceSets { \n        val commonMain by getting { /* ... */ }\n        val allJvm by creating {\n            dependsOn(commonMain)\n            /* ... */\n        } \n    }\n}\n\n"}, {"type": "pre", "text": "kotlin { \n    sourceSets { \n        val commonMain by getting { /* ... */ }\n        val allJvm by creating {\n            dependsOn(commonMain)\n            /* ... */\n        } \n    }\n}\n"}, {"type": "code", "text": "kotlin { \n    sourceSets { \n        val commonMain by getting { /* ... */ }\n        val allJvm by creating {\n            dependsOn(commonMain)\n            /* ... */\n        } \n    }\n}\n"}, {"type": "p", "text": "Custom source sets created in addition to the default ones should be explicitly included into\n the dependencies hierarchy to be able to use declarations from other source sets and, most importantly, to take part \n in compilations. \nMost often, they need a dependsOn(commonMain) or dependsOn(commonTest) statement, and some of the default platform-specific\n source sets should depend on the custom ones, \n directly or indirectly:"}, {"type": "a", "text": "default ones"}, {"type": "code", "text": "dependsOn(commonMain)"}, {"type": "code", "text": "dependsOn(commonTest)"}, {"type": "div", "text": "\n\nkotlin { \n    mingwX64()\n    linuxX64()\n    \n    sourceSets {\n        // custom source set with tests for the two targets\n        desktopTest { \n            dependsOn commonTest\n            /* ... */\n        }\n        // Make the 'windows' default test source set for depend on 'desktopTest'\n        mingwX64().compilations.test.defaultSourceSet { \n            dependsOn desktopTest\n            /* ... */\n        }\n        // And do the same for the other target:\n        linuxX64().compilations.test.defaultSourceSet {\n            dependsOn desktopTest\n            /* ... */\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin { \n    mingwX64()\n    linuxX64()\n    \n    sourceSets {\n        // custom source set with tests for the two targets\n        desktopTest { \n            dependsOn commonTest\n            /* ... */\n        }\n        // Make the 'windows' default test source set for depend on 'desktopTest'\n        mingwX64().compilations.test.defaultSourceSet { \n            dependsOn desktopTest\n            /* ... */\n        }\n        // And do the same for the other target:\n        linuxX64().compilations.test.defaultSourceSet {\n            dependsOn desktopTest\n            /* ... */\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin { \n    mingwX64()\n    linuxX64()\n    \n    sourceSets {\n        // custom source set with tests for the two targets\n        desktopTest { \n            dependsOn commonTest\n            /* ... */\n        }\n        // Make the 'windows' default test source set for depend on 'desktopTest'\n        mingwX64().compilations.test.defaultSourceSet { \n            dependsOn desktopTest\n            /* ... */\n        }\n        // And do the same for the other target:\n        linuxX64().compilations.test.defaultSourceSet {\n            dependsOn desktopTest\n            /* ... */\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin { \n    mingwX64()\n    linuxX64()\n    \n    sourceSets {\n        // custom source set with tests for the two targets\n        desktopTest { \n            dependsOn commonTest\n            /* ... */\n        }\n        // Make the 'windows' default test source set for depend on 'desktopTest'\n        mingwX64().compilations.test.defaultSourceSet { \n            dependsOn desktopTest\n            /* ... */\n        }\n        // And do the same for the other target:\n        linuxX64().compilations.test.defaultSourceSet {\n            dependsOn desktopTest\n            /* ... */\n        }\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin { \n    mingwX64()\n    linuxX64()\n    \n    sourceSets {\n        // custom source set with tests for the two targets\n        val desktopTest by creating { \n            dependsOn(getByName(\"commonTest\"))\n            /* ... */\n        }\n        // Make the 'windows' default test source set for depend on 'desktopTest'\n        mingwX64().compilations[\"test\"].defaultSourceSet { \n            dependsOn(desktopTest)\n            /* ... */\n        }\n        // And do the same for the other target:\n        linuxX64().compilations[\"test\"].defaultSourceSet {\n            dependsOn(desktopTest)\n            /* ... */\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin { \n    mingwX64()\n    linuxX64()\n    \n    sourceSets {\n        // custom source set with tests for the two targets\n        val desktopTest by creating { \n            dependsOn(getByName(\"commonTest\"))\n            /* ... */\n        }\n        // Make the 'windows' default test source set for depend on 'desktopTest'\n        mingwX64().compilations[\"test\"].defaultSourceSet { \n            dependsOn(desktopTest)\n            /* ... */\n        }\n        // And do the same for the other target:\n        linuxX64().compilations[\"test\"].defaultSourceSet {\n            dependsOn(desktopTest)\n            /* ... */\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin { \n    mingwX64()\n    linuxX64()\n    \n    sourceSets {\n        // custom source set with tests for the two targets\n        val desktopTest by creating { \n            dependsOn(getByName(\"commonTest\"))\n            /* ... */\n        }\n        // Make the 'windows' default test source set for depend on 'desktopTest'\n        mingwX64().compilations[\"test\"].defaultSourceSet { \n            dependsOn(desktopTest)\n            /* ... */\n        }\n        // And do the same for the other target:\n        linuxX64().compilations[\"test\"].defaultSourceSet {\n            dependsOn(desktopTest)\n            /* ... */\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin { \n    mingwX64()\n    linuxX64()\n    \n    sourceSets {\n        // custom source set with tests for the two targets\n        val desktopTest by creating { \n            dependsOn(getByName(\"commonTest\"))\n            /* ... */\n        }\n        // Make the 'windows' default test source set for depend on 'desktopTest'\n        mingwX64().compilations[\"test\"].defaultSourceSet { \n            dependsOn(desktopTest)\n            /* ... */\n        }\n        // And do the same for the other target:\n        linuxX64().compilations[\"test\"].defaultSourceSet {\n            dependsOn(desktopTest)\n            /* ... */\n        }\n    }\n}\n"}, {"type": "h3", "text": "Adding Dependencies"}, {"type": "p", "text": "To add a dependency to a source set, use a dependencies { ... } block of the source sets DSL. Four kinds of dependencies\nare supported:"}, {"type": "code", "text": "dependencies { ... }"}, {"type": "ul", "text": "\n\napi dependencies are used both during compilation and at runtime and are exported to library consumers. If any types \nfrom a dependency are used in the public API of the current module, then it should be an api dependency;\n\n\nimplementation dependencies are used during compilation and at runtime for the current module, but are not exposed for compilation \nof other modules depending on the one with the implementation dependency. Theimplementation dependency kind should be used for \ndependencies needed for the internal logic of a module. If a module is an endpoint application which is not published, it may\nuse implementation dependencies instead of api ones.\n\n\ncompileOnly dependencies are only used for compilation of the current module and are available neither at runtime nor during compilation\nof other modules. These dependencies should be used for APIs which have a third-party implementation available at runtime.\n\n\nruntimeOnly dependencies are available at runtime but are not visible during compilation of any module.\n\n"}, {"type": "li", "text": "\napi dependencies are used both during compilation and at runtime and are exported to library consumers. If any types \nfrom a dependency are used in the public API of the current module, then it should be an api dependency;\n"}, {"type": "p", "text": "api dependencies are used both during compilation and at runtime and are exported to library consumers. If any types \nfrom a dependency are used in the public API of the current module, then it should be an api dependency;"}, {"type": "code", "text": "api"}, {"type": "code", "text": "api"}, {"type": "li", "text": "\nimplementation dependencies are used during compilation and at runtime for the current module, but are not exposed for compilation \nof other modules depending on the one with the implementation dependency. Theimplementation dependency kind should be used for \ndependencies needed for the internal logic of a module. If a module is an endpoint application which is not published, it may\nuse implementation dependencies instead of api ones.\n"}, {"type": "p", "text": "implementation dependencies are used during compilation and at runtime for the current module, but are not exposed for compilation \nof other modules depending on the one with the implementation dependency. Theimplementation dependency kind should be used for \ndependencies needed for the internal logic of a module. If a module is an endpoint application which is not published, it may\nuse implementation dependencies instead of api ones."}, {"type": "code", "text": "implementation"}, {"type": "code", "text": "implementation"}, {"type": "code", "text": "implementation"}, {"type": "code", "text": "implementation"}, {"type": "code", "text": "api"}, {"type": "li", "text": "\ncompileOnly dependencies are only used for compilation of the current module and are available neither at runtime nor during compilation\nof other modules. These dependencies should be used for APIs which have a third-party implementation available at runtime.\n"}, {"type": "p", "text": "compileOnly dependencies are only used for compilation of the current module and are available neither at runtime nor during compilation\nof other modules. These dependencies should be used for APIs which have a third-party implementation available at runtime."}, {"type": "code", "text": "compileOnly"}, {"type": "li", "text": "\nruntimeOnly dependencies are available at runtime but are not visible during compilation of any module.\n"}, {"type": "p", "text": "runtimeOnly dependencies are available at runtime but are not visible during compilation of any module."}, {"type": "code", "text": "runtimeOnly"}, {"type": "p", "text": "Dependencies are specified per source set as follows:"}, {"type": "div", "text": "\n\nkotlin {\n    sourceSets {\n        commonMain {\n            dependencies {\n                api 'com.example:foo-metadata:1.0'\n            }\n        }\n        jvm6Main {\n            dependencies {\n                api 'com.example:foo-jvm6:1.0'\n            }\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    sourceSets {\n        commonMain {\n            dependencies {\n                api 'com.example:foo-metadata:1.0'\n            }\n        }\n        jvm6Main {\n            dependencies {\n                api 'com.example:foo-jvm6:1.0'\n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    sourceSets {\n        commonMain {\n            dependencies {\n                api 'com.example:foo-metadata:1.0'\n            }\n        }\n        jvm6Main {\n            dependencies {\n                api 'com.example:foo-jvm6:1.0'\n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    sourceSets {\n        commonMain {\n            dependencies {\n                api 'com.example:foo-metadata:1.0'\n            }\n        }\n        jvm6Main {\n            dependencies {\n                api 'com.example:foo-jvm6:1.0'\n            }\n        }\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                api(\"com.example:foo-metadata:1.0\")\n            }\n        }\n        val jvm6Main by getting {\n            dependencies {\n                api(\"com.example:foo-jvm6:1.0\")\n            }\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                api(\"com.example:foo-metadata:1.0\")\n            }\n        }\n        val jvm6Main by getting {\n            dependencies {\n                api(\"com.example:foo-jvm6:1.0\")\n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                api(\"com.example:foo-metadata:1.0\")\n            }\n        }\n        val jvm6Main by getting {\n            dependencies {\n                api(\"com.example:foo-jvm6:1.0\")\n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                api(\"com.example:foo-metadata:1.0\")\n            }\n        }\n        val jvm6Main by getting {\n            dependencies {\n                api(\"com.example:foo-jvm6:1.0\")\n            }\n        }\n    }\n}\n"}, {"type": "p", "text": "Note that for the IDE to correctly analyze the dependencies of the common sources, the common source sets need to have \ncorresponding dependencies on the Kotlin metadata packages in addition to the platform-specific artifact dependencies \nof the platform-specific source sets. Usually, an artifact with a suffix \n-common (as in kotlin-stdlib-common) or -metadata is required when using a published library (unless it is \npublished with Gradle metadata, as described below)."}, {"type": "code", "text": "-common"}, {"type": "code", "text": "kotlin-stdlib-common"}, {"type": "code", "text": "-metadata"}, {"type": "p", "text": "However, a project('...') dependency on another multiplatform project is resolved to an appropriate target\nautomatically. It is enough to specify a single project('...') dependency in a source set's dependencies, \nand the compilations that include the source set will receive a corresponding platform-specific artifact of \nthat project, given that it has a compatible target:"}, {"type": "code", "text": "project('...')"}, {"type": "code", "text": "project('...')"}, {"type": "div", "text": "\n\nkotlin {\n    sourceSets {\n        commonMain {\n            dependencies {\n                // All of the compilations that include source set 'commonMain'\n                // will get this dependency resolved to a compatible target, if any:\n                api project(':foo-lib')\n            }\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    sourceSets {\n        commonMain {\n            dependencies {\n                // All of the compilations that include source set 'commonMain'\n                // will get this dependency resolved to a compatible target, if any:\n                api project(':foo-lib')\n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    sourceSets {\n        commonMain {\n            dependencies {\n                // All of the compilations that include source set 'commonMain'\n                // will get this dependency resolved to a compatible target, if any:\n                api project(':foo-lib')\n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    sourceSets {\n        commonMain {\n            dependencies {\n                // All of the compilations that include source set 'commonMain'\n                // will get this dependency resolved to a compatible target, if any:\n                api project(':foo-lib')\n            }\n        }\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                // All of the compilations that include source set 'commonMain'\n                // will get this dependency resolved to a compatible target, if any:\n                api(project(\":foo-lib\"))\n            }\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                // All of the compilations that include source set 'commonMain'\n                // will get this dependency resolved to a compatible target, if any:\n                api(project(\":foo-lib\"))\n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                // All of the compilations that include source set 'commonMain'\n                // will get this dependency resolved to a compatible target, if any:\n                api(project(\":foo-lib\"))\n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                // All of the compilations that include source set 'commonMain'\n                // will get this dependency resolved to a compatible target, if any:\n                api(project(\":foo-lib\"))\n            }\n        }\n    }\n}\n"}, {"type": "p", "text": "Likewise, if a multiplatform library is published in the experimental Gradle metadata publishing mode and the project \nis set up to consume the metadata as well, then it is enough to specify a dependency only once, for the common source set. \nOtherwise, each platform-specific source set should be \nprovided with a corresponding platform module of the library, in addition to the common module, as shown above."}, {"type": "a", "text": "Gradle metadata publishing mode"}, {"type": "p", "text": "An alternative way to specify the dependencies is to use the Gradle built-in DSL at the top level with the configuration names following the \npattern <sourceSetName><DependencyKind>:"}, {"type": "code", "text": "<sourceSetName><DependencyKind>"}, {"type": "div", "text": "\n\ndependencies {\n    commonMainApi 'com.example:foo-common:1.0'\n    jvm6MainApi 'com.example:foo-jvm6:1.0'\n}\n\n\n"}, {"type": "div", "text": "\ndependencies {\n    commonMainApi 'com.example:foo-common:1.0'\n    jvm6MainApi 'com.example:foo-jvm6:1.0'\n}\n\n"}, {"type": "pre", "text": "dependencies {\n    commonMainApi 'com.example:foo-common:1.0'\n    jvm6MainApi 'com.example:foo-jvm6:1.0'\n}\n"}, {"type": "code", "text": "dependencies {\n    commonMainApi 'com.example:foo-common:1.0'\n    jvm6MainApi 'com.example:foo-jvm6:1.0'\n}\n"}, {"type": "div", "text": "\n\ndependencies {\n    \"commonMainApi\"(\"com.example:foo-common:1.0\")\n    \"jvm6MainApi\"(\"com.example:foo-jvm6:1.0\")\n}\n\n\n"}, {"type": "div", "text": "\ndependencies {\n    \"commonMainApi\"(\"com.example:foo-common:1.0\")\n    \"jvm6MainApi\"(\"com.example:foo-jvm6:1.0\")\n}\n\n"}, {"type": "pre", "text": "dependencies {\n    \"commonMainApi\"(\"com.example:foo-common:1.0\")\n    \"jvm6MainApi\"(\"com.example:foo-jvm6:1.0\")\n}\n"}, {"type": "code", "text": "dependencies {\n    \"commonMainApi\"(\"com.example:foo-common:1.0\")\n    \"jvm6MainApi\"(\"com.example:foo-jvm6:1.0\")\n}\n"}, {"type": "p", "text": "Some of the Gradle built-in dependencies, like gradleApi(), localGroovy(), or gradleTestKit() are not available\nin the source sets dependency DSL. You can, however, add them within the top-level dependency block, as shown above."}, {"type": "code", "text": "gradleApi()"}, {"type": "code", "text": "localGroovy()"}, {"type": "code", "text": "gradleTestKit()"}, {"type": "p", "text": "A dependency on a Kotlin module like kotlin-stdlib or kotlin-reflect may be added with the notation kotlin(\"stdlib\"),\nwhich is a shorthand for \"org.jetbrains.kotlin:kotlin-stdlib\"."}, {"type": "code", "text": "kotlin-stdlib"}, {"type": "code", "text": "kotlin-reflect"}, {"type": "code", "text": "kotlin(\"stdlib\")"}, {"type": "code", "text": "\"org.jetbrains.kotlin:kotlin-stdlib\""}, {"type": "h3", "text": "Language settings"}, {"type": "p", "text": "The language settings for a source set can be specified as follows:"}, {"type": "div", "text": "\n\nkotlin {\n    sourceSets {\n        commonMain {\n            languageSettings {\n                languageVersion = '1.3' // possible values: '1.0', '1.1', '1.2', '1.3'\n                apiVersion = '1.3' // possible values: '1.0', '1.1', '1.2', '1.3'\n                enableLanguageFeature('InlineClasses') // language feature name\n                useExperimentalAnnotation('kotlin.ExperimentalUnsignedTypes') // annotation FQ-name\n                progressiveMode = true // false by default\n            }\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    sourceSets {\n        commonMain {\n            languageSettings {\n                languageVersion = '1.3' // possible values: '1.0', '1.1', '1.2', '1.3'\n                apiVersion = '1.3' // possible values: '1.0', '1.1', '1.2', '1.3'\n                enableLanguageFeature('InlineClasses') // language feature name\n                useExperimentalAnnotation('kotlin.ExperimentalUnsignedTypes') // annotation FQ-name\n                progressiveMode = true // false by default\n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    sourceSets {\n        commonMain {\n            languageSettings {\n                languageVersion = '1.3' // possible values: '1.0', '1.1', '1.2', '1.3'\n                apiVersion = '1.3' // possible values: '1.0', '1.1', '1.2', '1.3'\n                enableLanguageFeature('InlineClasses') // language feature name\n                useExperimentalAnnotation('kotlin.ExperimentalUnsignedTypes') // annotation FQ-name\n                progressiveMode = true // false by default\n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    sourceSets {\n        commonMain {\n            languageSettings {\n                languageVersion = '1.3' // possible values: '1.0', '1.1', '1.2', '1.3'\n                apiVersion = '1.3' // possible values: '1.0', '1.1', '1.2', '1.3'\n                enableLanguageFeature('InlineClasses') // language feature name\n                useExperimentalAnnotation('kotlin.ExperimentalUnsignedTypes') // annotation FQ-name\n                progressiveMode = true // false by default\n            }\n        }\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            languageSettings.apply {\n                languageVersion = \"1.3\" // possible values: '1.0', '1.1', '1.2', '1.3'\n                apiVersion = \"1.3\" // possible values: '1.0', '1.1', '1.2', '1.3'\n                enableLanguageFeature(\"InlineClasses\") // language feature name\n                useExperimentalAnnotation(\"kotlin.ExperimentalUnsignedTypes\") // annotation FQ-name\n                progressiveMode = true // false by default\n            }\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            languageSettings.apply {\n                languageVersion = \"1.3\" // possible values: '1.0', '1.1', '1.2', '1.3'\n                apiVersion = \"1.3\" // possible values: '1.0', '1.1', '1.2', '1.3'\n                enableLanguageFeature(\"InlineClasses\") // language feature name\n                useExperimentalAnnotation(\"kotlin.ExperimentalUnsignedTypes\") // annotation FQ-name\n                progressiveMode = true // false by default\n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    sourceSets {\n        val commonMain by getting {\n            languageSettings.apply {\n                languageVersion = \"1.3\" // possible values: '1.0', '1.1', '1.2', '1.3'\n                apiVersion = \"1.3\" // possible values: '1.0', '1.1', '1.2', '1.3'\n                enableLanguageFeature(\"InlineClasses\") // language feature name\n                useExperimentalAnnotation(\"kotlin.ExperimentalUnsignedTypes\") // annotation FQ-name\n                progressiveMode = true // false by default\n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    sourceSets {\n        val commonMain by getting {\n            languageSettings.apply {\n                languageVersion = \"1.3\" // possible values: '1.0', '1.1', '1.2', '1.3'\n                apiVersion = \"1.3\" // possible values: '1.0', '1.1', '1.2', '1.3'\n                enableLanguageFeature(\"InlineClasses\") // language feature name\n                useExperimentalAnnotation(\"kotlin.ExperimentalUnsignedTypes\") // annotation FQ-name\n                progressiveMode = true // false by default\n            }\n        }\n    }\n}\n"}, {"type": "p", "text": "It is possible to configure the language settings of all source sets at once:"}, {"type": "div", "text": "\nkotlin.sourceSets.all {\n    languageSettings.progressiveMode = true\n}\n\n"}, {"type": "pre", "text": "kotlin.sourceSets.all {\n    languageSettings.progressiveMode = true\n}\n"}, {"type": "code", "text": "kotlin.sourceSets.all {\n    languageSettings.progressiveMode = true\n}\n"}, {"type": "p", "text": "Language settings of a source set affect how the sources are analyzed in the IDE. Due to the current limitations, in a \nGradle build, only the language settings of the compilation's default source set are used and are applied to all of the\nsources participating in the compilation."}, {"type": "p", "text": "The language settings are checked for consistency between source sets depending on each other. Namely, if foo depends on bar:"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "bar"}, {"type": "ul", "text": "\nfoo should set languageVersion that is greater than or equal to that of bar;\nfoo should enable all unstable language features that bar enables (there's no such requirement for bugfix features);\nfoo should use all experimental annotations that bar uses;\napiVersion, bugfix language features, and progressiveMode can be set arbitrarily;\n"}, {"type": "li", "text": "foo should set languageVersion that is greater than or equal to that of bar;"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "languageVersion"}, {"type": "code", "text": "bar"}, {"type": "li", "text": "foo should enable all unstable language features that bar enables (there's no such requirement for bugfix features);"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "bar"}, {"type": "li", "text": "foo should use all experimental annotations that bar uses;"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "bar"}, {"type": "li", "text": "apiVersion, bugfix language features, and progressiveMode can be set arbitrarily;"}, {"type": "code", "text": "apiVersion"}, {"type": "code", "text": "progressiveMode"}, {"type": "h2", "text": "Default Project Layout"}, {"type": "p", "text": "By default, each project contains two source sets, commonMain and commonTest, where one can place all the code that should be \nshared between all of the target platforms. These source sets are added to each production and test compilation, respectively."}, {"type": "code", "text": "commonMain"}, {"type": "code", "text": "commonTest"}, {"type": "p", "text": "Then, once a target is added, default compilations are created for it:"}, {"type": "ul", "text": "\nmain and test compilations for JVM, JS, and Native targets;\na compilation per Android build variant, for Android targets;\n"}, {"type": "li", "text": "main and test compilations for JVM, JS, and Native targets;"}, {"type": "code", "text": "main"}, {"type": "code", "text": "test"}, {"type": "li", "text": "a compilation per Android build variant, for Android targets;"}, {"type": "a", "text": "Android build variant"}, {"type": "p", "text": "For each compilation, there is a default source set under the name composed as <targetName><CompilationName>. This default source\nset participates in the compilation, and thus it should be used for the platform-specific code and dependencies, and for adding other source\n sets to the compilation by the means of 'depends on'. For example, a project with\ntargets jvm6 (JVM) and nodeJs (JS) will have source sets: commonMain, commonTest, jvm6Main, jvm6Test, nodeJsMain, nodeJsTest."}, {"type": "code", "text": "<targetName><CompilationName>"}, {"type": "code", "text": "jvm6"}, {"type": "code", "text": "nodeJs"}, {"type": "code", "text": "commonMain"}, {"type": "code", "text": "commonTest"}, {"type": "code", "text": "jvm6Main"}, {"type": "code", "text": "jvm6Test"}, {"type": "code", "text": "nodeJsMain"}, {"type": "code", "text": "nodeJsTest"}, {"type": "p", "text": "Numerous use cases are covered by just the default source sets and don't require custom source sets."}, {"type": "p", "text": "Each source set by default has its Kotlin sources under src/<sourceSetName>/kotlin directory and the resources under src/<sourceSetName>/resources."}, {"type": "code", "text": "src/<sourceSetName>/kotlin"}, {"type": "code", "text": "src/<sourceSetName>/resources"}, {"type": "p", "text": "In Android projects, additional Kotlin source sets are created for each Android source set. \nIf the Android target has a name foo, the Android source set bar gets a Kotlin source set counterpart fooBar. \nThe Kotlin compilations, however, are able to consume Kotlin sources from all of the directories src/bar/java, \nsrc/bar/kotlin, and src/fooBar/kotlin. Java sources are only read from the first of these directories."}, {"type": "a", "text": "Android source set"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "bar"}, {"type": "code", "text": "fooBar"}, {"type": "code", "text": "src/bar/java"}, {"type": "code", "text": "src/bar/kotlin"}, {"type": "code", "text": "src/fooBar/kotlin"}, {"type": "h2", "text": "Running Tests"}, {"type": "p", "text": "Running tests in a Gradle build is currently supported by default for JVM, Android, Linux, Windows and macOS; \nJS and other Kotlin/Native targets\nneed to be manually configured to run the tests with an appropriate environment, an emulator or a test framework."}, {"type": "p", "text": "A test task is created under the name <targetName>Test for each target that is suitable for testing. Run the check task to run \nthe tests for all targets."}, {"type": "code", "text": "<targetName>Test"}, {"type": "code", "text": "check"}, {"type": "p", "text": "As the commonTest default source set is added to all test compilations, tests and test tools that are needed\non all target platforms may be placed there."}, {"type": "code", "text": "commonTest"}, {"type": "a", "text": "default source set"}, {"type": "p", "text": "The kotlin.test API is available for multiplatform tests. \nAdd the kotlin-test-common and kotlin-test-annotations-common dependencies to commonTest to use the assertion \nfunctions like kotlin.test.assertTrue(...)\nand @Test/@Ignore/@BeforeTest/@AfterTest annotations in the common tests."}, {"type": "a", "text": "kotlin.test API"}, {"type": "code", "text": "kotlin.test"}, {"type": "code", "text": "kotlin-test-common"}, {"type": "code", "text": "kotlin-test-annotations-common"}, {"type": "code", "text": "commonTest"}, {"type": "code", "text": "kotlin.test.assertTrue(...)"}, {"type": "br", "text": ""}, {"type": "code", "text": "@Test"}, {"type": "code", "text": "@Ignore"}, {"type": "code", "text": "@BeforeTest"}, {"type": "code", "text": "@AfterTest"}, {"type": "p", "text": "For JVM targets, use kotlin-test-junit or kotlin-test-testng for the corresponding asserter implementation and\nannotations mapping."}, {"type": "code", "text": "kotlin-test-junit"}, {"type": "code", "text": "kotlin-test-testng"}, {"type": "p", "text": "For Kotlin/JS targets, add kotlin-test-js as a test dependency. At this point, test tasks for Kotlin/JS are created \nbut do not run tests by default; they should be manually configured to run the tests with a JavaScript test framework."}, {"type": "code", "text": "kotlin-test-js"}, {"type": "p", "text": "Kotlin/Native targets do not require additional test dependencies, and the kotlin.test API implementations are built-in."}, {"type": "code", "text": "kotlin.test"}, {"type": "h2", "text": "Publishing a Multiplatform Library"}, {"type": "blockquote", "text": "\nThe set of target platforms is defined by a multiplatform library author, and they should provide all of the platform-specific implementations for the library. \nAdding new targets for a multiplatform library at the consumer's side is not supported.\n"}, {"type": "p", "text": "The set of target platforms is defined by a multiplatform library author, and they should provide all of the platform-specific implementations for the library. \nAdding new targets for a multiplatform library at the consumer's side is not supported."}, {"type": "p", "text": "A library built from a multiplatform project may be published to a Maven repository with the \nmaven-publish Gradle plugin, which can be applied as \nfollows:"}, {"type": "a", "text": "maven-publish Gradle plugin"}, {"type": "code", "text": "maven-publish"}, {"type": "div", "text": "\nplugins {\n    /* ... */\n    id(\"maven-publish\")\n}\n\n"}, {"type": "pre", "text": "plugins {\n    /* ... */\n    id(\"maven-publish\")\n}\n"}, {"type": "code", "text": "plugins {\n    /* ... */\n    id(\"maven-publish\")\n}\n"}, {"type": "p", "text": "A library also needs group and version to be set in the project:"}, {"type": "code", "text": "group"}, {"type": "code", "text": "version"}, {"type": "div", "text": "\nplugins { /* ... */ }\n\ngroup = \"com.example.my.library\"\nversion = \"0.0.1\"\n\n"}, {"type": "pre", "text": "plugins { /* ... */ }\n\ngroup = \"com.example.my.library\"\nversion = \"0.0.1\"\n"}, {"type": "code", "text": "plugins { /* ... */ }\n\ngroup = \"com.example.my.library\"\nversion = \"0.0.1\"\n"}, {"type": "p", "text": "Compared to publishing a plain Kotlin/JVM or Java project, there is no need to create publications manually \nvia the publishing { ... } DSL. The publications are automatically created for each of the targets that can be \nbuilt on the current host, except for the Android target, which needs an additional step to configure \npublishing, see Publishing Android libraries."}, {"type": "code", "text": "publishing { ... }"}, {"type": "a", "text": "Publishing Android libraries"}, {"type": "p", "text": "The repositories where the library will be published are added via the repositories block in the publishing { ... } \nDSL, as explained in Maven Publish Plugin. Repositories."}, {"type": "code", "text": "repositories"}, {"type": "code", "text": "publishing { ... }"}, {"type": "a", "text": "Maven Publish Plugin. Repositories"}, {"type": "p", "text": "The default artifact IDs follow the pattern <projectName>-<targetNameToLowerCase>, for example sample-lib-nodejs \nfor a target named nodeJs in a project sample-lib."}, {"type": "code", "text": "<projectName>-<targetNameToLowerCase>"}, {"type": "code", "text": "sample-lib-nodejs"}, {"type": "code", "text": "nodeJs"}, {"type": "code", "text": "sample-lib"}, {"type": "p", "text": "By default, a sources JAR is added to each publication in addition to its main artifact. The sources JAR contains the \nsources used by the main compilation of the target. If you also need to publish a documentation artifact (like a \nJavadoc JAR), you need to configure its build manually and add it as an artifact to the relevant publications, as shown\nbelow."}, {"type": "code", "text": "main"}, {"type": "p", "text": "Also, an additional publication under the name metadata is added by default which contains serialized Kotlin \ndeclarations and is used by the IDE to analyze multiplatform libraries. \nThe default artifact ID of this publication is formed as <projectName>-metadata."}, {"type": "code", "text": "metadata"}, {"type": "code", "text": "<projectName>-metadata"}, {"type": "p", "text": "The Maven coordinates can be altered and additional artifact files may be added to the publications within the \ntargets { ... } block or the publishing { ... } DSL:"}, {"type": "code", "text": "targets { ... }"}, {"type": "code", "text": "publishing { ... }"}, {"type": "div", "text": "\n\nkotlin {\n    jvm('jvm6') {\n        mavenPublication { // Setup the publication for the target 'jvm6'\n            // The default artifactId was 'foo-jvm6', change it:  \n            artifactId = 'foo-jvm'\n            // Add a docs JAR artifact (it should be a custom task): \n            artifact(jvmDocsJar)\n        }\n    }\n}\n\n// Alternatively, configure the publications with the `publishing { ... }` DSL:\npublishing {\n    publications {\n        jvm6 { /* Setup the publication for target 'jvm6' */ }\n        metadata { /* Setup the publication for Kotlin metadata */ }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    jvm('jvm6') {\n        mavenPublication { // Setup the publication for the target 'jvm6'\n            // The default artifactId was 'foo-jvm6', change it:  \n            artifactId = 'foo-jvm'\n            // Add a docs JAR artifact (it should be a custom task): \n            artifact(jvmDocsJar)\n        }\n    }\n}\n\n// Alternatively, configure the publications with the `publishing { ... }` DSL:\npublishing {\n    publications {\n        jvm6 { /* Setup the publication for target 'jvm6' */ }\n        metadata { /* Setup the publication for Kotlin metadata */ }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm('jvm6') {\n        mavenPublication { // Setup the publication for the target 'jvm6'\n            // The default artifactId was 'foo-jvm6', change it:  \n            artifactId = 'foo-jvm'\n            // Add a docs JAR artifact (it should be a custom task): \n            artifact(jvmDocsJar)\n        }\n    }\n}\n\n// Alternatively, configure the publications with the `publishing { ... }` DSL:\npublishing {\n    publications {\n        jvm6 { /* Setup the publication for target 'jvm6' */ }\n        metadata { /* Setup the publication for Kotlin metadata */ }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm('jvm6') {\n        mavenPublication { // Setup the publication for the target 'jvm6'\n            // The default artifactId was 'foo-jvm6', change it:  \n            artifactId = 'foo-jvm'\n            // Add a docs JAR artifact (it should be a custom task): \n            artifact(jvmDocsJar)\n        }\n    }\n}\n\n// Alternatively, configure the publications with the `publishing { ... }` DSL:\npublishing {\n    publications {\n        jvm6 { /* Setup the publication for target 'jvm6' */ }\n        metadata { /* Setup the publication for Kotlin metadata */ }\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin {\n    jvm(\"jvm6\") {\n        mavenPublication { // Setup the publication for the target 'jvm6'\n            // The default artifactId was 'foo-jvm6', change it:  \n            artifactId = \"foo-jvm\"\n            // Add a docs JAR artifact (it should be a custom task): \n            artifact(jvmDocsJar)\n        }\n    }\n}\n\n// Alternatively, configure the publications with the `publishing { ... }` DSL:\npublishing {\n    publications.withType<MavenPublication>().apply {\n        val jvm6 by getting { /* Setup the publication for target 'jvm6' */ }\n        val metadata by getting { /* Setup the publication for Kotlin metadata */ }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    jvm(\"jvm6\") {\n        mavenPublication { // Setup the publication for the target 'jvm6'\n            // The default artifactId was 'foo-jvm6', change it:  \n            artifactId = \"foo-jvm\"\n            // Add a docs JAR artifact (it should be a custom task): \n            artifact(jvmDocsJar)\n        }\n    }\n}\n\n// Alternatively, configure the publications with the `publishing { ... }` DSL:\npublishing {\n    publications.withType<MavenPublication>().apply {\n        val jvm6 by getting { /* Setup the publication for target 'jvm6' */ }\n        val metadata by getting { /* Setup the publication for Kotlin metadata */ }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm(\"jvm6\") {\n        mavenPublication { // Setup the publication for the target 'jvm6'\n            // The default artifactId was 'foo-jvm6', change it:  \n            artifactId = \"foo-jvm\"\n            // Add a docs JAR artifact (it should be a custom task): \n            artifact(jvmDocsJar)\n        }\n    }\n}\n\n// Alternatively, configure the publications with the `publishing { ... }` DSL:\npublishing {\n    publications.withType<MavenPublication>().apply {\n        val jvm6 by getting { /* Setup the publication for target 'jvm6' */ }\n        val metadata by getting { /* Setup the publication for Kotlin metadata */ }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm(\"jvm6\") {\n        mavenPublication { // Setup the publication for the target 'jvm6'\n            // The default artifactId was 'foo-jvm6', change it:  \n            artifactId = \"foo-jvm\"\n            // Add a docs JAR artifact (it should be a custom task): \n            artifact(jvmDocsJar)\n        }\n    }\n}\n\n// Alternatively, configure the publications with the `publishing { ... }` DSL:\npublishing {\n    publications.withType<MavenPublication>().apply {\n        val jvm6 by getting { /* Setup the publication for target 'jvm6' */ }\n        val metadata by getting { /* Setup the publication for Kotlin metadata */ }\n    }\n}\n"}, {"type": "p", "text": "As assembling Kotlin/Native artifacts requires several builds to run on different host platforms, publishing a \nmultiplatform library that includes Kotlin/Native targets needs to be done with that same set of host machines. To avoid\nduplicate publications of modules that can be built on more than one of the platforms \n(like JVM, JS, Kotlin metadata, WebAssembly), the publishing tasks for these modules may be configured to run \nconditionally."}, {"type": "p", "text": "This simplified example ensures that the JVM, JS, and Kotlin metadata publications are only uploaded when \n-PisLinux=true is passed to the build in the command line:"}, {"type": "code", "text": "-PisLinux=true"}, {"type": "div", "text": "\n\nkotlin {\n    jvm()\n    js()\n    mingwX64()\n    linuxX64()\n    \n    // Note that the Kotlin metadata is here, too. \n    // The mingwx64() target is automatically skipped as incompatible in Linux builds.\n    configure([targets[\"metadata\"], jvm(), js()]) {\n        mavenPublication { targetPublication ->\n            tasks.withType(AbstractPublishToMaven)\n                .matching { it.publication == targetPublication }\n                .all { onlyIf { findProperty(\"isLinux\") == \"true\" } }            \n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    jvm()\n    js()\n    mingwX64()\n    linuxX64()\n    \n    // Note that the Kotlin metadata is here, too. \n    // The mingwx64() target is automatically skipped as incompatible in Linux builds.\n    configure([targets[\"metadata\"], jvm(), js()]) {\n        mavenPublication { targetPublication ->\n            tasks.withType(AbstractPublishToMaven)\n                .matching { it.publication == targetPublication }\n                .all { onlyIf { findProperty(\"isLinux\") == \"true\" } }            \n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm()\n    js()\n    mingwX64()\n    linuxX64()\n    \n    // Note that the Kotlin metadata is here, too. \n    // The mingwx64() target is automatically skipped as incompatible in Linux builds.\n    configure([targets[\"metadata\"], jvm(), js()]) {\n        mavenPublication { targetPublication ->\n            tasks.withType(AbstractPublishToMaven)\n                .matching { it.publication == targetPublication }\n                .all { onlyIf { findProperty(\"isLinux\") == \"true\" } }            \n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm()\n    js()\n    mingwX64()\n    linuxX64()\n    \n    // Note that the Kotlin metadata is here, too. \n    // The mingwx64() target is automatically skipped as incompatible in Linux builds.\n    configure([targets[\"metadata\"], jvm(), js()]) {\n        mavenPublication { targetPublication ->\n            tasks.withType(AbstractPublishToMaven)\n                .matching { it.publication == targetPublication }\n                .all { onlyIf { findProperty(\"isLinux\") == \"true\" } }            \n        }\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin {\n    jvm()\n    js()\n    mingwX64()\n    linuxX64()\n       \n    // Note that the Kotlin metadata is here, too. \n    // The mingwx64() target is automatically skipped as incompatible in Linux builds.\n    configure(listOf(metadata(), jvm(), js())) {\n        mavenPublication { \n            val targetPublication = this@mavenPublication\n            tasks.withType<AbstractPublishToMaven>()\n                .matching { it.publication == targetPublication }\n                .all { onlyIf { findProperty(\"isLinux\") == \"true\" } }            \n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    jvm()\n    js()\n    mingwX64()\n    linuxX64()\n       \n    // Note that the Kotlin metadata is here, too. \n    // The mingwx64() target is automatically skipped as incompatible in Linux builds.\n    configure(listOf(metadata(), jvm(), js())) {\n        mavenPublication { \n            val targetPublication = this@mavenPublication\n            tasks.withType<AbstractPublishToMaven>()\n                .matching { it.publication == targetPublication }\n                .all { onlyIf { findProperty(\"isLinux\") == \"true\" } }            \n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm()\n    js()\n    mingwX64()\n    linuxX64()\n       \n    // Note that the Kotlin metadata is here, too. \n    // The mingwx64() target is automatically skipped as incompatible in Linux builds.\n    configure(listOf(metadata(), jvm(), js())) {\n        mavenPublication { \n            val targetPublication = this@mavenPublication\n            tasks.withType<AbstractPublishToMaven>()\n                .matching { it.publication == targetPublication }\n                .all { onlyIf { findProperty(\"isLinux\") == \"true\" } }            \n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm()\n    js()\n    mingwX64()\n    linuxX64()\n       \n    // Note that the Kotlin metadata is here, too. \n    // The mingwx64() target is automatically skipped as incompatible in Linux builds.\n    configure(listOf(metadata(), jvm(), js())) {\n        mavenPublication { \n            val targetPublication = this@mavenPublication\n            tasks.withType<AbstractPublishToMaven>()\n                .matching { it.publication == targetPublication }\n                .all { onlyIf { findProperty(\"isLinux\") == \"true\" } }            \n        }\n    }\n}\n"}, {"type": "h3", "text": "Experimental metadata publishing mode"}, {"type": "p", "text": "Gradle module metadata provides rich publishing and dependency resolution features that are used in Kotlin \nmultiplatform projects to simplify dependencies configuration for build authors. In particular, the publications of a \nmultiplatform library may include a special 'root' module that stands for the whole library and is automatically \nresolved to the appropriate platform-specific artifacts when added as a dependency, as described below."}, {"type": "p", "text": "In Gradle 5.3 and above, the module metadata is always used during dependency resolution, but publications don't \ninclude any module metadata by default. To enable module metadata publishing, add \nenableFeaturePreview(\"GRADLE_METADATA\") to the root project's settings.gradle file. With older Gradle versions, \nthis is also required for module metadata consumption."}, {"type": "code", "text": "enableFeaturePreview(\"GRADLE_METADATA\")"}, {"type": "code", "text": "settings.gradle"}, {"type": "blockquote", "text": "\nNote that the module metadata published by Gradle 5.3 and above cannot be read by Gradle versions older\nthan 5.3.\n"}, {"type": "p", "text": "Note that the module metadata published by Gradle 5.3 and above cannot be read by Gradle versions older\nthan 5.3."}, {"type": "p", "text": "With Gradle metadata enabled, an additional 'root' publication named kotlinMultiplatform is added to the project's \npublications. The default artifact ID of this publication matches the project name without any additional suffix. \nTo configure this publication, access it via the publishing { ... } DSL of the maven-publish plugin:"}, {"type": "code", "text": "kotlinMultiplatform"}, {"type": "code", "text": "publishing { ... }"}, {"type": "code", "text": "maven-publish"}, {"type": "div", "text": "\n\nkotlin { /* ... */ }\n\npublishing {\n    publications {\n        kotlinMultiplatform {\n            artifactId = \"foo\"        \n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin { /* ... */ }\n\npublishing {\n    publications {\n        kotlinMultiplatform {\n            artifactId = \"foo\"        \n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin { /* ... */ }\n\npublishing {\n    publications {\n        kotlinMultiplatform {\n            artifactId = \"foo\"        \n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin { /* ... */ }\n\npublishing {\n    publications {\n        kotlinMultiplatform {\n            artifactId = \"foo\"        \n        }\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin { /* ... */ }\n\npublishing {\n    publications {\n        val kotlinMultiplatform by getting {\n            artifactId = \"foo\"        \n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin { /* ... */ }\n\npublishing {\n    publications {\n        val kotlinMultiplatform by getting {\n            artifactId = \"foo\"        \n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin { /* ... */ }\n\npublishing {\n    publications {\n        val kotlinMultiplatform by getting {\n            artifactId = \"foo\"        \n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin { /* ... */ }\n\npublishing {\n    publications {\n        val kotlinMultiplatform by getting {\n            artifactId = \"foo\"        \n        }\n    }\n}\n"}, {"type": "p", "text": "This publication does not include any artifacts and only references the other publications as its variants. However, it\nmay need the sources and documentation artifacts if that is required by the repository. In that case, add those artifacts\nby using artifact(...)\nin the publication's scope, which is accessed as shown above."}, {"type": "a", "text": "artifact(...)"}, {"type": "code", "text": "artifact(...)"}, {"type": "p", "text": "If a library has a 'root' publication, the consumer may specify a single dependency on the library as a whole in a \n common source set, and a corresponding platform-specific variant will be chosen, if available, for each of the \n compilations that include this dependency. Consider a sample-lib library built for the JVM and JS and published with \n a 'root' publication:"}, {"type": "code", "text": "sample-lib"}, {"type": "div", "text": "\n\nkotlin {\n    jvm('jvm6')\n    js('nodeJs')\n        \n    sourceSets {\n        commonMain {\n            dependencies {\n                // This single dependency is resolved to the appropriate target modules, \n                // for example, `sample-lib-jvm6` for JVM, `sample-lib-js` for JS:\n                api 'com.example:sample-lib:1.0' \n            }\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    jvm('jvm6')\n    js('nodeJs')\n        \n    sourceSets {\n        commonMain {\n            dependencies {\n                // This single dependency is resolved to the appropriate target modules, \n                // for example, `sample-lib-jvm6` for JVM, `sample-lib-js` for JS:\n                api 'com.example:sample-lib:1.0' \n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm('jvm6')\n    js('nodeJs')\n        \n    sourceSets {\n        commonMain {\n            dependencies {\n                // This single dependency is resolved to the appropriate target modules, \n                // for example, `sample-lib-jvm6` for JVM, `sample-lib-js` for JS:\n                api 'com.example:sample-lib:1.0' \n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm('jvm6')\n    js('nodeJs')\n        \n    sourceSets {\n        commonMain {\n            dependencies {\n                // This single dependency is resolved to the appropriate target modules, \n                // for example, `sample-lib-jvm6` for JVM, `sample-lib-js` for JS:\n                api 'com.example:sample-lib:1.0' \n            }\n        }\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin {\n    jvm(\"jvm6\")\n    js(\"nodeJs\")\n        \n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                // This single dependency is resolved to the appropriate target modules, \n                // for example, `sample-lib-jvm6` for JVM, `sample-lib-js` for JS:\n                api(\"com.example:sample-lib:1.0\") \n            }\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    jvm(\"jvm6\")\n    js(\"nodeJs\")\n        \n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                // This single dependency is resolved to the appropriate target modules, \n                // for example, `sample-lib-jvm6` for JVM, `sample-lib-js` for JS:\n                api(\"com.example:sample-lib:1.0\") \n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm(\"jvm6\")\n    js(\"nodeJs\")\n        \n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                // This single dependency is resolved to the appropriate target modules, \n                // for example, `sample-lib-jvm6` for JVM, `sample-lib-js` for JS:\n                api(\"com.example:sample-lib:1.0\") \n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    jvm(\"jvm6\")\n    js(\"nodeJs\")\n        \n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                // This single dependency is resolved to the appropriate target modules, \n                // for example, `sample-lib-jvm6` for JVM, `sample-lib-js` for JS:\n                api(\"com.example:sample-lib:1.0\") \n            }\n        }\n    }\n}\n"}, {"type": "p", "text": "This requires that the consumer's Gradle build can read Gradle module metadata, either using Gradle 5.3+ or explicitly \nenabling it by enableFeaturePreview(\"GRADLE_METADATA\") in settings.gradle."}, {"type": "code", "text": "enableFeaturePreview(\"GRADLE_METADATA\")"}, {"type": "code", "text": "settings.gradle"}, {"type": "h3", "text": "Disambiguating targets"}, {"type": "p", "text": "It is possible to have more than one target for a single platform in a multiplatform library. For example, these targets\nmay provide the same API and differ in the libraries they cooperate with at runtime, like testing frameworks or logging solutions."}, {"type": "p", "text": "However, dependencies on such a multiplatform library may be ambiguous and may thus fail to resolve because there is not\nenough information to decide which of the targets to choose."}, {"type": "p", "text": "The solution is to mark the targets with a custom attribute, which is taken into account by Gradle during dependency \nresolution. This, however, must be done on both the library author and the consumer sides, \nand it's the library author's responsibility to communicate the attribute and its possible values to the consumers."}, {"type": "p", "text": "Adding attributes is done symmetrically, to both the library and the consumer projects. For example, consider a testing\nlibrary that supports both JUnit and TestNG in the two targets. The library author needs to add an attribute to both \ntargets as follows:"}, {"type": "div", "text": "\n\ndef testFrameworkAttribute = Attribute.of('com.example.testFramework', String)\n  \nkotlin {\n    jvm('junit') {\n        attributes.attribute(testFrameworkAttribute, 'junit')\n    }\n    jvm('testng') {\n        attributes.attribute(testFrameworkAttribute, 'testng')\n    }\n}\n\n\n"}, {"type": "div", "text": "\ndef testFrameworkAttribute = Attribute.of('com.example.testFramework', String)\n  \nkotlin {\n    jvm('junit') {\n        attributes.attribute(testFrameworkAttribute, 'junit')\n    }\n    jvm('testng') {\n        attributes.attribute(testFrameworkAttribute, 'testng')\n    }\n}\n\n"}, {"type": "pre", "text": "def testFrameworkAttribute = Attribute.of('com.example.testFramework', String)\n  \nkotlin {\n    jvm('junit') {\n        attributes.attribute(testFrameworkAttribute, 'junit')\n    }\n    jvm('testng') {\n        attributes.attribute(testFrameworkAttribute, 'testng')\n    }\n}\n"}, {"type": "code", "text": "def testFrameworkAttribute = Attribute.of('com.example.testFramework', String)\n  \nkotlin {\n    jvm('junit') {\n        attributes.attribute(testFrameworkAttribute, 'junit')\n    }\n    jvm('testng') {\n        attributes.attribute(testFrameworkAttribute, 'testng')\n    }\n}\n"}, {"type": "div", "text": "\n\nval testFrameworkAttribute = Attribute.of(\"com.example.testFramework\", String::class.java)\n  \nkotlin {\n    jvm(\"junit\") {\n        attributes.attribute(testFrameworkAttribute, \"junit\")\n    }\n    jvm(\"testng\") {\n        attributes.attribute(testFrameworkAttribute, \"testng\")\n    }\n}\n\n\n"}, {"type": "div", "text": "\nval testFrameworkAttribute = Attribute.of(\"com.example.testFramework\", String::class.java)\n  \nkotlin {\n    jvm(\"junit\") {\n        attributes.attribute(testFrameworkAttribute, \"junit\")\n    }\n    jvm(\"testng\") {\n        attributes.attribute(testFrameworkAttribute, \"testng\")\n    }\n}\n\n"}, {"type": "pre", "text": "val testFrameworkAttribute = Attribute.of(\"com.example.testFramework\", String::class.java)\n  \nkotlin {\n    jvm(\"junit\") {\n        attributes.attribute(testFrameworkAttribute, \"junit\")\n    }\n    jvm(\"testng\") {\n        attributes.attribute(testFrameworkAttribute, \"testng\")\n    }\n}\n"}, {"type": "code", "text": "val testFrameworkAttribute = Attribute.of(\"com.example.testFramework\", String::class.java)\n  \nkotlin {\n    jvm(\"junit\") {\n        attributes.attribute(testFrameworkAttribute, \"junit\")\n    }\n    jvm(\"testng\") {\n        attributes.attribute(testFrameworkAttribute, \"testng\")\n    }\n}\n"}, {"type": "p", "text": "The consumer may only need to add the attribute to a single target where the ambiguity arises."}, {"type": "p", "text": "If the same kind of ambiguity arises when a dependency is added to a custom configuration rather than one of the \nconfigurations created by the plugin, you can add the attributes to the configuration in the same way:"}, {"type": "div", "text": "\n\ndef testFrameworkAttribute = Attribute.of('com.example.testFramework', String)\n\nconfigurations {\n    myConfiguration {\n        attributes.attribute(testFrameworkAttribute, 'junit')\n    }\n}  \n\n\n"}, {"type": "div", "text": "\ndef testFrameworkAttribute = Attribute.of('com.example.testFramework', String)\n\nconfigurations {\n    myConfiguration {\n        attributes.attribute(testFrameworkAttribute, 'junit')\n    }\n}  \n\n"}, {"type": "pre", "text": "def testFrameworkAttribute = Attribute.of('com.example.testFramework', String)\n\nconfigurations {\n    myConfiguration {\n        attributes.attribute(testFrameworkAttribute, 'junit')\n    }\n}  \n"}, {"type": "code", "text": "def testFrameworkAttribute = Attribute.of('com.example.testFramework', String)\n\nconfigurations {\n    myConfiguration {\n        attributes.attribute(testFrameworkAttribute, 'junit')\n    }\n}  \n"}, {"type": "div", "text": "\n\nval testFrameworkAttribute = Attribute.of(\"com.example.testFramework\", String::class.java)\n\nconfigurations {\n    val myConfiguration by creating {\n        attributes.attribute(testFrameworkAttribute, \"junit\")\n    }\n}  \n\n\n"}, {"type": "div", "text": "\nval testFrameworkAttribute = Attribute.of(\"com.example.testFramework\", String::class.java)\n\nconfigurations {\n    val myConfiguration by creating {\n        attributes.attribute(testFrameworkAttribute, \"junit\")\n    }\n}  \n\n"}, {"type": "pre", "text": "val testFrameworkAttribute = Attribute.of(\"com.example.testFramework\", String::class.java)\n\nconfigurations {\n    val myConfiguration by creating {\n        attributes.attribute(testFrameworkAttribute, \"junit\")\n    }\n}  \n"}, {"type": "code", "text": "val testFrameworkAttribute = Attribute.of(\"com.example.testFramework\", String::class.java)\n\nconfigurations {\n    val myConfiguration by creating {\n        attributes.attribute(testFrameworkAttribute, \"junit\")\n    }\n}  \n"}, {"type": "h2", "text": "Java Support in JVM Targets"}, {"type": "p", "text": "This feature is available since Kotlin 1.3.40."}, {"type": "p", "text": "By default, a JVM target ignores Java sources and only compiles Kotlin source files.\nTo include Java sources in the compilations of a JVM target, or to apply a Gradle plugin that requires the \njava plugin to work, you need to explicitly enable Java support for the target:"}, {"type": "br", "text": ""}, {"type": "code", "text": "java"}, {"type": "div", "text": "\nkotlin {\n    jvm {\n        withJava()\n    } \n}\n\n"}, {"type": "pre", "text": "kotlin {\n    jvm {\n        withJava()\n    } \n}\n"}, {"type": "code", "text": "kotlin {\n    jvm {\n        withJava()\n    } \n}\n"}, {"type": "p", "text": "This will apply the Gradle java plugin and configure the target to cooperate with it. \nNote that just applying the Java plugin without specifying withJava() in a JVM \ntarget will have no effect on the target."}, {"type": "code", "text": "java"}, {"type": "code", "text": "withJava()"}, {"type": "p", "text": "The file system locations for the Java sources are different from  the java plugin's defaults. \nThe Java source files need to be placed in the sibling directories of the Kotlin source \nroots. For example, if the JVM target has the default name jvm, the paths are:"}, {"type": "code", "text": "java"}, {"type": "code", "text": "jvm"}, {"type": "div", "text": "\nsrc\n\u251c\u2500\u2500 jvmMain\n\u2502   \u251c\u2500\u2500 java // production Java sources\n\u2502   \u251c\u2500\u2500 kotlin\n\u2502   \u2514\u2500\u2500 resources\n\u251c\u2500\u2500 jvmTest\n\u2502   \u251c\u2500\u2500 java // test Java sources\n\u2502   \u251c\u2500\u2500 kotlin\n\u2026   \u2514\u2500\u2500 resources\n\n"}, {"type": "pre", "text": "src\n\u251c\u2500\u2500 jvmMain\n\u2502   \u251c\u2500\u2500 java // production Java sources\n\u2502   \u251c\u2500\u2500 kotlin\n\u2502   \u2514\u2500\u2500 resources\n\u251c\u2500\u2500 jvmTest\n\u2502   \u251c\u2500\u2500 java // test Java sources\n\u2502   \u251c\u2500\u2500 kotlin\n\u2026   \u2514\u2500\u2500 resources\n"}, {"type": "code", "text": "src\n\u251c\u2500\u2500 jvmMain\n\u2502   \u251c\u2500\u2500 java // production Java sources\n\u2502   \u251c\u2500\u2500 kotlin\n\u2502   \u2514\u2500\u2500 resources\n\u251c\u2500\u2500 jvmTest\n\u2502   \u251c\u2500\u2500 java // test Java sources\n\u2502   \u251c\u2500\u2500 kotlin\n\u2026   \u2514\u2500\u2500 resources\n"}, {"type": "p", "text": "The common source sets cannot include Java sources."}, {"type": "p", "text": "Due to the current limitations, some tasks configured by the Java plugin are disabled, and the corresponding tasks added\nby the Kotlin plugin are used instead:"}, {"type": "ul", "text": "\njar is disabled in favor of the target's JAR task (e.g. jvmJar)\ntest is disabled, and the target's test task is used (e.g. jvmTest)\n*ProcessResources tasks are disabled, and the resources are processed by the equivalent tasks of the compilations\n"}, {"type": "li", "text": "jar is disabled in favor of the target's JAR task (e.g. jvmJar)"}, {"type": "code", "text": "jar"}, {"type": "code", "text": "jvmJar"}, {"type": "li", "text": "test is disabled, and the target's test task is used (e.g. jvmTest)"}, {"type": "code", "text": "test"}, {"type": "code", "text": "jvmTest"}, {"type": "li", "text": "*ProcessResources tasks are disabled, and the resources are processed by the equivalent tasks of the compilations"}, {"type": "code", "text": "*ProcessResources"}, {"type": "p", "text": "The publication of this target is handled by the Kotlin plugin and doesn't require the steps that are specific to the \nJava plugin, such as manually creating a publication and configuring it as from(components.java)."}, {"type": "code", "text": "from(components.java)"}, {"type": "h2", "text": "Android Support"}, {"type": "p", "text": "Kotlin Multiplatform projects support the Android platform by providing the android preset. \nCreating an Android target requires that one of the Android Gradle plugins, like com.android.application or \ncom.android.library is manually applied to the project. Only one Android target may be created per Gradle subproject:"}, {"type": "code", "text": "android"}, {"type": "code", "text": "com.android.application"}, {"type": "code", "text": "com.android.library"}, {"type": "div", "text": "\n\nplugins {\n    id(\"com.android.library\")\n    id(\"org.jetbrains.kotlin.multiplatform\").version(\"1.3.72\")\n}\n\nandroid { /* ... */ }\n\nkotlin {\n    android { // Create the Android target\n        // Provide additional configuration if necessary\n    }\n}\n\n\n"}, {"type": "div", "text": "\nplugins {\n    id(\"com.android.library\")\n    id(\"org.jetbrains.kotlin.multiplatform\").version(\"1.3.72\")\n}\n\nandroid { /* ... */ }\n\nkotlin {\n    android { // Create the Android target\n        // Provide additional configuration if necessary\n    }\n}\n\n"}, {"type": "pre", "text": "plugins {\n    id(\"com.android.library\")\n    id(\"org.jetbrains.kotlin.multiplatform\").version(\"1.3.72\")\n}\n\nandroid { /* ... */ }\n\nkotlin {\n    android { // Create the Android target\n        // Provide additional configuration if necessary\n    }\n}\n"}, {"type": "code", "text": "plugins {\n    id(\"com.android.library\")\n    id(\"org.jetbrains.kotlin.multiplatform\").version(\"1.3.72\")\n}\n\nandroid { /* ... */ }\n\nkotlin {\n    android { // Create the Android target\n        // Provide additional configuration if necessary\n    }\n}\n"}, {"type": "div", "text": "\n\nplugins {\n    id(\"com.android.library\")\n    kotlin(\"multiplatform\").version(\"1.3.72\")\n}\n\nandroid { /* ... */ }\n\nkotlin {\n    android { // Create the Android target\n        // Provide additional configuration if necessary\n    }\n} \n\n\n"}, {"type": "div", "text": "\nplugins {\n    id(\"com.android.library\")\n    kotlin(\"multiplatform\").version(\"1.3.72\")\n}\n\nandroid { /* ... */ }\n\nkotlin {\n    android { // Create the Android target\n        // Provide additional configuration if necessary\n    }\n} \n\n"}, {"type": "pre", "text": "plugins {\n    id(\"com.android.library\")\n    kotlin(\"multiplatform\").version(\"1.3.72\")\n}\n\nandroid { /* ... */ }\n\nkotlin {\n    android { // Create the Android target\n        // Provide additional configuration if necessary\n    }\n} \n"}, {"type": "code", "text": "plugins {\n    id(\"com.android.library\")\n    kotlin(\"multiplatform\").version(\"1.3.72\")\n}\n\nandroid { /* ... */ }\n\nkotlin {\n    android { // Create the Android target\n        // Provide additional configuration if necessary\n    }\n} \n"}, {"type": "p", "text": "An Android target's compilations created by default are tied to Android build variants: \nfor each build variant, a Kotlin compilation is created under the same name."}, {"type": "a", "text": "Android build variants"}, {"type": "p", "text": "Then, for each Android source set compiled by \nthe variants, a Kotlin source set is created under that source set name \nprepended by the target name, like Kotlin source set androidDebug for an Android source set debug and the Kotlin target \nnamed android. These Kotlin source sets are added to the variants compilations accordingly."}, {"type": "a", "text": "Android source set"}, {"type": "code", "text": "androidDebug"}, {"type": "code", "text": "debug"}, {"type": "code", "text": "android"}, {"type": "p", "text": "The default source set commonMain is added to each production (application or library) variant's compilation. The \ncommonTest source set is, similarly, added to the compilations of unit test and instrumented test variants."}, {"type": "code", "text": "commonMain"}, {"type": "code", "text": "commonTest"}, {"type": "p", "text": "Annotation processing with kapt is also supported but, due to the current limitations, \nit requires that the Android target is created before the kapt dependencies are configured, which needs \nto be done in a top-level dependencies { ... } block rather than within Kotlin source sets dependencies."}, {"type": "a", "text": "kapt"}, {"type": "code", "text": "kapt"}, {"type": "code", "text": "dependencies { ... }"}, {"type": "div", "text": "\n// ...\n\nkotlin {\n    android { /* ... */ }\n}\n\ndependencies {\n    kapt(\"com.my.annotation:processor:1.0.0\")\n}\n\n"}, {"type": "pre", "text": "// ...\n\nkotlin {\n    android { /* ... */ }\n}\n\ndependencies {\n    kapt(\"com.my.annotation:processor:1.0.0\")\n}\n"}, {"type": "code", "text": "// ...\n\nkotlin {\n    android { /* ... */ }\n}\n\ndependencies {\n    kapt(\"com.my.annotation:processor:1.0.0\")\n}\n"}, {"type": "h3", "text": "Publishing Android libraries"}, {"type": "p", "text": "To publish an Android library as a part of a multiplatform library, one needs to \nsetup publishing for the library and provide additional configuration for the\nAndroid library target."}, {"type": "a", "text": "setup publishing for the library"}, {"type": "p", "text": "By default, no artifacts of an Android library are published. To publish artifacts produced by a set of \nAndroid variants, specify the variant names in the Android \ntarget block as follows:"}, {"type": "a", "text": "Android variants"}, {"type": "div", "text": "\nkotlin {\n    android {\n        publishLibraryVariants(\"release\", \"debug\")\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    android {\n        publishLibraryVariants(\"release\", \"debug\")\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    android {\n        publishLibraryVariants(\"release\", \"debug\")\n    }\n}\n"}, {"type": "p", "text": "The example above will work for Android libraries with no product flavors. For a library with product flavors, the \nvariant names also contain the flavors, like fooBarDebug or fooBazRelease."}, {"type": "code", "text": "fooBarDebug"}, {"type": "code", "text": "fooBazRelease"}, {"type": "p", "text": "Note that if a library consumer defines variants that are missing in the library, they need to provide \nmatching fallbacks. For example, if \na library does not have or does not publish a staging build type, it will be necessary to provide a fallback for the\nconsumers who have such a build type, specifying at least one of the build types that the library publishes:"}, {"type": "a", "text": "matching fallbacks"}, {"type": "code", "text": "staging"}, {"type": "div", "text": "\n\nandroid {\n    buildTypes {\n        staging {\n            // ...\n            matchingFallbacks = ['release', 'debug'] \n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nandroid {\n    buildTypes {\n        staging {\n            // ...\n            matchingFallbacks = ['release', 'debug'] \n        }\n    }\n}\n\n"}, {"type": "pre", "text": "android {\n    buildTypes {\n        staging {\n            // ...\n            matchingFallbacks = ['release', 'debug'] \n        }\n    }\n}\n"}, {"type": "code", "text": "android {\n    buildTypes {\n        staging {\n            // ...\n            matchingFallbacks = ['release', 'debug'] \n        }\n    }\n}\n"}, {"type": "div", "text": "\n\nandroid {\n    buildTypes {\n        val staging by creating {\n            // ...\n            matchingFallbacks = listOf(\"release\", \"debug\") \n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nandroid {\n    buildTypes {\n        val staging by creating {\n            // ...\n            matchingFallbacks = listOf(\"release\", \"debug\") \n        }\n    }\n}\n\n"}, {"type": "pre", "text": "android {\n    buildTypes {\n        val staging by creating {\n            // ...\n            matchingFallbacks = listOf(\"release\", \"debug\") \n        }\n    }\n}\n"}, {"type": "code", "text": "android {\n    buildTypes {\n        val staging by creating {\n            // ...\n            matchingFallbacks = listOf(\"release\", \"debug\") \n        }\n    }\n}\n"}, {"type": "p", "text": "Similarly, a library consumer may need to provide matching fallbacks for custom product flavors if some are missing in\nthe library publications."}, {"type": "p", "text": "There is an option to publish variants grouped by the product flavor, so that the outputs of the different build\ntypes are placed in a single module, with the build type becoming a classifier for the artifacts (the release build\ntype is still published with no classifier). This mode is disabled by default and can be enabled as follows:"}, {"type": "div", "text": "\nkotlin {\n    android {\n        publishLibraryVariantsGroupedByFlavor = true\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    android {\n        publishLibraryVariantsGroupedByFlavor = true\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    android {\n        publishLibraryVariantsGroupedByFlavor = true\n    }\n}\n"}, {"type": "p", "text": "It is not recommended to publish variants grouped by the product flavor in case they have different dependencies, as \nthose will be merged into one dependencies list."}, {"type": "h2", "text": "Using Kotlin/Native Targets"}, {"type": "p", "text": "It is important to note that some of the Kotlin/Native targets may only be built with an appropriate host machine:"}, {"type": "a", "text": "Kotlin/Native targets"}, {"type": "ul", "text": "\nLinux MIPS targets (linuxMips32 and linuxMipsel32) require a Linux host. Other Linux targets can be built on any supported host;\nWindows targets require a Windows host;\nmacOS and iOS targets can only be built on a macOS host;\nThe 64-bit Android Native target require a Linux or macOS host. The 32-bit Android Native target can be built on any supported host.\n"}, {"type": "li", "text": "Linux MIPS targets (linuxMips32 and linuxMipsel32) require a Linux host. Other Linux targets can be built on any supported host;"}, {"type": "code", "text": "linuxMips32"}, {"type": "code", "text": "linuxMipsel32"}, {"type": "li", "text": "Windows targets require a Windows host;"}, {"type": "li", "text": "macOS and iOS targets can only be built on a macOS host;"}, {"type": "li", "text": "The 64-bit Android Native target require a Linux or macOS host. The 32-bit Android Native target can be built on any supported host."}, {"type": "p", "text": "A target that is not supported by the current host is ignored during build and therefore not published. A library author may want to set up\nbuilds and publishing from different hosts as required by the library target platforms."}, {"type": "h3", "text": "Target shortcuts"}, {"type": "p", "text": "Some native targets are often created together and use the same sources. For example, building for an iOS device and a simulator\nis represented by different targets (iosArm64 and iosX64 respectively) but their source codes are usually the same.\nA canonical way to express such shared code in the multiplatform project model is creating an intermediate\nsource set (iosMain) and configuring links between it and the platform source sets:"}, {"type": "code", "text": "iosArm64"}, {"type": "code", "text": "iosX64"}, {"type": "code", "text": "iosMain"}, {"type": "div", "text": "\n\nsourceSets{\n    iosMain {\n        dependsOn(commonMain)\n        iosDeviceMain.dependsOn(it)\n        iosSimulatorMain.dependsOn(it)\n    }\n}\n\n\n"}, {"type": "div", "text": "\nsourceSets{\n    iosMain {\n        dependsOn(commonMain)\n        iosDeviceMain.dependsOn(it)\n        iosSimulatorMain.dependsOn(it)\n    }\n}\n\n"}, {"type": "pre", "text": "sourceSets{\n    iosMain {\n        dependsOn(commonMain)\n        iosDeviceMain.dependsOn(it)\n        iosSimulatorMain.dependsOn(it)\n    }\n}\n"}, {"type": "code", "text": "sourceSets{\n    iosMain {\n        dependsOn(commonMain)\n        iosDeviceMain.dependsOn(it)\n        iosSimulatorMain.dependsOn(it)\n    }\n}\n"}, {"type": "div", "text": "\n\nval commonMain by sourceSets.getting\nval iosDeviceMain by sourceSets.getting\nval iosSimulatorMain by sourceSets.getting\n\nval iosMain by sourceSets.creating {\n    dependsOn(commonMain)\n    iosDeviceMain.dependsOn(this)\n    iosSimulatorMain.dependsOn(this)\n}\n\n\n"}, {"type": "div", "text": "\nval commonMain by sourceSets.getting\nval iosDeviceMain by sourceSets.getting\nval iosSimulatorMain by sourceSets.getting\n\nval iosMain by sourceSets.creating {\n    dependsOn(commonMain)\n    iosDeviceMain.dependsOn(this)\n    iosSimulatorMain.dependsOn(this)\n}\n\n"}, {"type": "pre", "text": "val commonMain by sourceSets.getting\nval iosDeviceMain by sourceSets.getting\nval iosSimulatorMain by sourceSets.getting\n\nval iosMain by sourceSets.creating {\n    dependsOn(commonMain)\n    iosDeviceMain.dependsOn(this)\n    iosSimulatorMain.dependsOn(this)\n}\n"}, {"type": "code", "text": "val commonMain by sourceSets.getting\nval iosDeviceMain by sourceSets.getting\nval iosSimulatorMain by sourceSets.getting\n\nval iosMain by sourceSets.creating {\n    dependsOn(commonMain)\n    iosDeviceMain.dependsOn(this)\n    iosSimulatorMain.dependsOn(this)\n}\n"}, {"type": "p", "text": "Since 1.3.60, the kotlin-multiplaform plugin provides shortcuts that automate such a configuration: they let users\ncreate a group of targets along with a common source set for them with a single DSL method."}, {"type": "code", "text": "kotlin-multiplaform"}, {"type": "p", "text": "The following shortcuts are available:"}, {"type": "ul", "text": "\nios creates targets for iosArm64 and iosX64.\nwatchos creates targets for  watchosArm32, watchosArm64, and watchosX86.\ntvos creates targets for  tvosArm64 and tvosX64.\n"}, {"type": "li", "text": "ios creates targets for iosArm64 and iosX64."}, {"type": "code", "text": "ios"}, {"type": "code", "text": "iosArm64"}, {"type": "code", "text": "iosX64"}, {"type": "li", "text": "watchos creates targets for  watchosArm32, watchosArm64, and watchosX86."}, {"type": "code", "text": "watchos"}, {"type": "code", "text": "watchosArm32"}, {"type": "code", "text": "watchosArm64"}, {"type": "code", "text": "watchosX86"}, {"type": "li", "text": "tvos creates targets for  tvosArm64 and tvosX64."}, {"type": "code", "text": "tvos"}, {"type": "code", "text": "tvosArm64"}, {"type": "code", "text": "tvosX64"}, {"type": "div", "text": "\n// Create two targets for iOS.\n// Create common source sets: iosMain and iosTest.\nios {\n    // Configure targets.\n    // Note: this lambda will be called for each target.\n}\n\n// You can also specify a name prefix for created targets.\n// Common source sets will also have this prefix:\n// anotherIosMain and anotherIosTest.\nios(\"anotherIos\")\n\n"}, {"type": "pre", "text": "// Create two targets for iOS.\n// Create common source sets: iosMain and iosTest.\nios {\n    // Configure targets.\n    // Note: this lambda will be called for each target.\n}\n\n// You can also specify a name prefix for created targets.\n// Common source sets will also have this prefix:\n// anotherIosMain and anotherIosTest.\nios(\"anotherIos\")\n"}, {"type": "code", "text": "// Create two targets for iOS.\n// Create common source sets: iosMain and iosTest.\nios {\n    // Configure targets.\n    // Note: this lambda will be called for each target.\n}\n\n// You can also specify a name prefix for created targets.\n// Common source sets will also have this prefix:\n// anotherIosMain and anotherIosTest.\nios(\"anotherIos\")\n"}, {"type": "h3", "text": "Building final native binaries"}, {"type": "p", "text": "By default, a Kotlin/Native target is compiled down to a *.klib library artifact, which can be consumed by Kotlin/Native itself as a\ndependency but cannot be executed or used as a native library. To declare final native binaries like executables or shared libraries a binaries\nproperty of a native target is used. This property represents a collection of native binaries built for this target in addition to the\ndefault *.klib artifact and provides a set of methods for declaring and configuring them."}, {"type": "code", "text": "*.klib"}, {"type": "code", "text": "binaries"}, {"type": "code", "text": "*.klib"}, {"type": "p", "text": "Note that the kotlin-multiplaform plugin doesn't create any production binaries by default. The only binary available by default\nis a debug executable allowing one to run tests from the test compilation."}, {"type": "code", "text": "kotlin-multiplaform"}, {"type": "code", "text": "test"}, {"type": "h4", "text": "Declaring binaries"}, {"type": "p", "text": "A set of factory methods is used for declaring elements of the binaries collection. These methods allow one to specify what kinds of binaries are to be created and configure them. The following binary kinds are supported (note that not all the kinds are available for\nall native platforms):"}, {"type": "code", "text": "binaries"}, {"type": "table", "text": "\n\n\nFactory method\nBinary kind\nAvailable for\n\n\n\n\nexecutable\na product executable\nall native targets\n\n\ntest\na test executable\nall native targets\n\n\nsharedLib\na shared native library\nall native targets except wasm32\n\n\nstaticLib\na static native library\nall native targets except wasm32\n\n\nframework\nan Objective-C framework\nmacOS, iOS, watchOS, and tvOS targets only\n\n\n"}, {"type": "thead", "text": "\n\nFactory method\nBinary kind\nAvailable for\n\n"}, {"type": "tr", "text": "\nFactory method\nBinary kind\nAvailable for\n"}, {"type": "th", "text": "Factory method"}, {"type": "strong", "text": "Factory method"}, {"type": "th", "text": "Binary kind"}, {"type": "strong", "text": "Binary kind"}, {"type": "th", "text": "Available for"}, {"type": "strong", "text": "Available for"}, {"type": "tbody", "text": "\n\nexecutable\na product executable\nall native targets\n\n\ntest\na test executable\nall native targets\n\n\nsharedLib\na shared native library\nall native targets except wasm32\n\n\nstaticLib\na static native library\nall native targets except wasm32\n\n\nframework\nan Objective-C framework\nmacOS, iOS, watchOS, and tvOS targets only\n\n"}, {"type": "tr", "text": "\nexecutable\na product executable\nall native targets\n"}, {"type": "td", "text": "executable"}, {"type": "code", "text": "executable"}, {"type": "td", "text": "a product executable"}, {"type": "td", "text": "all native targets"}, {"type": "tr", "text": "\ntest\na test executable\nall native targets\n"}, {"type": "td", "text": "test"}, {"type": "code", "text": "test"}, {"type": "td", "text": "a test executable"}, {"type": "td", "text": "all native targets"}, {"type": "tr", "text": "\nsharedLib\na shared native library\nall native targets except wasm32\n"}, {"type": "td", "text": "sharedLib"}, {"type": "code", "text": "sharedLib"}, {"type": "td", "text": "a shared native library"}, {"type": "td", "text": "all native targets except wasm32"}, {"type": "code", "text": "wasm32"}, {"type": "tr", "text": "\nstaticLib\na static native library\nall native targets except wasm32\n"}, {"type": "td", "text": "staticLib"}, {"type": "code", "text": "staticLib"}, {"type": "td", "text": "a static native library"}, {"type": "td", "text": "all native targets except wasm32"}, {"type": "code", "text": "wasm32"}, {"type": "tr", "text": "\nframework\nan Objective-C framework\nmacOS, iOS, watchOS, and tvOS targets only\n"}, {"type": "td", "text": "framework"}, {"type": "code", "text": "framework"}, {"type": "td", "text": "an Objective-C framework"}, {"type": "td", "text": "macOS, iOS, watchOS, and tvOS targets only"}, {"type": "p", "text": "Each factory method exists in several versions. Consider them by example of the executable method. All the same versions are available\nfor all other factory methods."}, {"type": "code", "text": "executable"}, {"type": "p", "text": "The simplest version doesn't require any additional parameters and creates one binary for each build type.\nCurrently there a two build types available: DEBUG (produces a not optimized binary with a debug information) and RELEASE (produces\nan optimized binary without debug information). Consequently the following snippet creates two executable binaries: debug and release."}, {"type": "code", "text": "DEBUG"}, {"type": "code", "text": "RELEASE"}, {"type": "div", "text": "\nkotlin {\n    linuxX64 { // Use your target instead.\n        binaries {\n            executable {\n                // Binary configuration.\n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    linuxX64 { // Use your target instead.\n        binaries {\n            executable {\n                // Binary configuration.\n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    linuxX64 { // Use your target instead.\n        binaries {\n            executable {\n                // Binary configuration.\n            }\n        }\n    }\n}\n"}, {"type": "p", "text": "A lambda expression accepted by the executable method in the example above is applied to each binary created and allows one to configure the binary\n(see the corresponding section). Note that this lambda can be dropped if there is no need for additional configuration:"}, {"type": "code", "text": "executable"}, {"type": "a", "text": "corresponding section"}, {"type": "div", "text": "\nbinaries {\n    executable()\n}\n\n"}, {"type": "pre", "text": "binaries {\n    executable()\n}\n"}, {"type": "code", "text": "binaries {\n    executable()\n}\n"}, {"type": "p", "text": "It is possible to specify which build types will be used to create binaries and which won't. In the following example only debug executable is created."}, {"type": "div", "text": "\n\nbinaries {\n    executable([DEBUG]) {\n        // Binary configuration.\n    }\n}\n\n\n"}, {"type": "div", "text": "\nbinaries {\n    executable([DEBUG]) {\n        // Binary configuration.\n    }\n}\n\n"}, {"type": "pre", "text": "binaries {\n    executable([DEBUG]) {\n        // Binary configuration.\n    }\n}\n"}, {"type": "code", "text": "binaries {\n    executable([DEBUG]) {\n        // Binary configuration.\n    }\n}\n"}, {"type": "div", "text": "\n\nbinaries {\n    executable(listOf(DEBUG)) {\n        // Binary configuration.\n    }\n}\n\n\n"}, {"type": "div", "text": "\nbinaries {\n    executable(listOf(DEBUG)) {\n        // Binary configuration.\n    }\n}\n\n"}, {"type": "pre", "text": "binaries {\n    executable(listOf(DEBUG)) {\n        // Binary configuration.\n    }\n}\n"}, {"type": "code", "text": "binaries {\n    executable(listOf(DEBUG)) {\n        // Binary configuration.\n    }\n}\n"}, {"type": "p", "text": "Finally the last factory method version allows customizing the binary name."}, {"type": "div", "text": "\n\nbinaries {\n    executable('foo', [DEBUG]) {\n        // Binary configuration.\n    }\n\n    // It's possible to drop the list of build types (all the available build types will be used in this case).\n    executable('bar') {\n        // Binary configuration.\n    }\n}\n\n\n"}, {"type": "div", "text": "\nbinaries {\n    executable('foo', [DEBUG]) {\n        // Binary configuration.\n    }\n\n    // It's possible to drop the list of build types (all the available build types will be used in this case).\n    executable('bar') {\n        // Binary configuration.\n    }\n}\n\n"}, {"type": "pre", "text": "binaries {\n    executable('foo', [DEBUG]) {\n        // Binary configuration.\n    }\n\n    // It's possible to drop the list of build types (all the available build types will be used in this case).\n    executable('bar') {\n        // Binary configuration.\n    }\n}\n"}, {"type": "code", "text": "binaries {\n    executable('foo', [DEBUG]) {\n        // Binary configuration.\n    }\n\n    // It's possible to drop the list of build types (all the available build types will be used in this case).\n    executable('bar') {\n        // Binary configuration.\n    }\n}\n"}, {"type": "div", "text": "\n\nbinaries {\n    executable(\"foo\", listOf(DEBUG)) {\n        // Binary configuration.\n    }\n\n    // It's possible to drop the list of build types (all the available build types will be used in this case).\n    executable(\"bar\") {\n        // Binary configuration.\n    }\n}\n\n\n"}, {"type": "div", "text": "\nbinaries {\n    executable(\"foo\", listOf(DEBUG)) {\n        // Binary configuration.\n    }\n\n    // It's possible to drop the list of build types (all the available build types will be used in this case).\n    executable(\"bar\") {\n        // Binary configuration.\n    }\n}\n\n"}, {"type": "pre", "text": "binaries {\n    executable(\"foo\", listOf(DEBUG)) {\n        // Binary configuration.\n    }\n\n    // It's possible to drop the list of build types (all the available build types will be used in this case).\n    executable(\"bar\") {\n        // Binary configuration.\n    }\n}\n"}, {"type": "code", "text": "binaries {\n    executable(\"foo\", listOf(DEBUG)) {\n        // Binary configuration.\n    }\n\n    // It's possible to drop the list of build types (all the available build types will be used in this case).\n    executable(\"bar\") {\n        // Binary configuration.\n    }\n}\n"}, {"type": "p", "text": "The first argument in this example allows one to set a name prefix for the created binaries which is used to access them in the buildscript (see the \"Accessing binaries\" section).\nAlso this prefix is used as a default name for the binary file. For example on Windows the sample above produces files foo.exe and bar.exe."}, {"type": "a", "text": "\"Accessing binaries\""}, {"type": "code", "text": "foo.exe"}, {"type": "code", "text": "bar.exe"}, {"type": "h4", "text": "Accessing binaries"}, {"type": "p", "text": "The binaries DSL allows not only creating binaries but also accessing already created ones to configure them or get their properties\n(e.g. path to an output file). The binaries collection implements the\nDomainObjectSet interface and provides methods like\nall or matching allowing configuring groups of elements."}, {"type": "code", "text": "binaries"}, {"type": "a", "text": "DomainObjectSet"}, {"type": "code", "text": "DomainObjectSet"}, {"type": "code", "text": "all"}, {"type": "code", "text": "matching"}, {"type": "p", "text": "Also it's possible to get a certain element of the collection. There are two ways to do this. First, each binary has a unique \nname. This name is based on the name prefix (if it's specified), build type and binary kind according to the following pattern:\n<optional-name-prefix><build-type><binary-kind>, e.g. releaseFramework or testDebugExecutable."}, {"type": "code", "text": "<optional-name-prefix><build-type><binary-kind>"}, {"type": "code", "text": "releaseFramework"}, {"type": "code", "text": "testDebugExecutable"}, {"type": "blockquote", "text": "\nNote: static and shared libraries has suffixes static and shared respectively, e.g. fooDebugStatic or barReleaseShared\n"}, {"type": "p", "text": "Note: static and shared libraries has suffixes static and shared respectively, e.g. fooDebugStatic or barReleaseShared"}, {"type": "code", "text": "static"}, {"type": "code", "text": "shared"}, {"type": "code", "text": "fooDebugStatic"}, {"type": "code", "text": "barReleaseShared"}, {"type": "p", "text": "This name can be used to access the binary:"}, {"type": "div", "text": "\n\n// Fails if there is no such a binary.\nbinaries['fooDebugExecutable']\nbinaries.fooDebugExecutable\nbinaries.getByName('fooDebugExecutable')\n\n // Returns null if there is no such a binary.\nbinaries.findByName('fooDebugExecutable')\n\n\n"}, {"type": "div", "text": "\n// Fails if there is no such a binary.\nbinaries['fooDebugExecutable']\nbinaries.fooDebugExecutable\nbinaries.getByName('fooDebugExecutable')\n\n // Returns null if there is no such a binary.\nbinaries.findByName('fooDebugExecutable')\n\n"}, {"type": "pre", "text": "// Fails if there is no such a binary.\nbinaries['fooDebugExecutable']\nbinaries.fooDebugExecutable\nbinaries.getByName('fooDebugExecutable')\n\n // Returns null if there is no such a binary.\nbinaries.findByName('fooDebugExecutable')\n"}, {"type": "code", "text": "// Fails if there is no such a binary.\nbinaries['fooDebugExecutable']\nbinaries.fooDebugExecutable\nbinaries.getByName('fooDebugExecutable')\n\n // Returns null if there is no such a binary.\nbinaries.findByName('fooDebugExecutable')\n"}, {"type": "div", "text": "\n\n// Fails if there is no such a binary.\nbinaries[\"fooDebugExecutable\"]\nbinaries.getByName(\"fooDebugExecutable\")\n\n // Returns null if there is no such a binary.\nbinaries.findByName(\"fooDebugExecutable\")\n\n\n"}, {"type": "div", "text": "\n// Fails if there is no such a binary.\nbinaries[\"fooDebugExecutable\"]\nbinaries.getByName(\"fooDebugExecutable\")\n\n // Returns null if there is no such a binary.\nbinaries.findByName(\"fooDebugExecutable\")\n\n"}, {"type": "pre", "text": "// Fails if there is no such a binary.\nbinaries[\"fooDebugExecutable\"]\nbinaries.getByName(\"fooDebugExecutable\")\n\n // Returns null if there is no such a binary.\nbinaries.findByName(\"fooDebugExecutable\")\n"}, {"type": "code", "text": "// Fails if there is no such a binary.\nbinaries[\"fooDebugExecutable\"]\nbinaries.getByName(\"fooDebugExecutable\")\n\n // Returns null if there is no such a binary.\nbinaries.findByName(\"fooDebugExecutable\")\n"}, {"type": "p", "text": "The second way is using typed getters. These getters allow one to access a binary of a certain type by its name prefix and build type."}, {"type": "div", "text": "\n\n// Fails if there is no such a binary.\nbinaries.getExecutable('foo', DEBUG)\nbinaries.getExecutable(DEBUG)          // Skip the first argument if the name prefix isn't set.\nbinaries.getExecutable('bar', 'DEBUG') // You also can use a string for build type.\n\n// Similar getters are available for other binary kinds:\n// getFramework, getStaticLib and getSharedLib.\n\n// Returns null if there is no such a binary.\nbinaries.findExecutable('foo', DEBUG)\n\n// Similar getters are available for other binary kinds:\n// findFramework, findStaticLib and findSharedLib.\n\n\n"}, {"type": "div", "text": "\n// Fails if there is no such a binary.\nbinaries.getExecutable('foo', DEBUG)\nbinaries.getExecutable(DEBUG)          // Skip the first argument if the name prefix isn't set.\nbinaries.getExecutable('bar', 'DEBUG') // You also can use a string for build type.\n\n// Similar getters are available for other binary kinds:\n// getFramework, getStaticLib and getSharedLib.\n\n// Returns null if there is no such a binary.\nbinaries.findExecutable('foo', DEBUG)\n\n// Similar getters are available for other binary kinds:\n// findFramework, findStaticLib and findSharedLib.\n\n"}, {"type": "pre", "text": "// Fails if there is no such a binary.\nbinaries.getExecutable('foo', DEBUG)\nbinaries.getExecutable(DEBUG)          // Skip the first argument if the name prefix isn't set.\nbinaries.getExecutable('bar', 'DEBUG') // You also can use a string for build type.\n\n// Similar getters are available for other binary kinds:\n// getFramework, getStaticLib and getSharedLib.\n\n// Returns null if there is no such a binary.\nbinaries.findExecutable('foo', DEBUG)\n\n// Similar getters are available for other binary kinds:\n// findFramework, findStaticLib and findSharedLib.\n"}, {"type": "code", "text": "// Fails if there is no such a binary.\nbinaries.getExecutable('foo', DEBUG)\nbinaries.getExecutable(DEBUG)          // Skip the first argument if the name prefix isn't set.\nbinaries.getExecutable('bar', 'DEBUG') // You also can use a string for build type.\n\n// Similar getters are available for other binary kinds:\n// getFramework, getStaticLib and getSharedLib.\n\n// Returns null if there is no such a binary.\nbinaries.findExecutable('foo', DEBUG)\n\n// Similar getters are available for other binary kinds:\n// findFramework, findStaticLib and findSharedLib.\n"}, {"type": "div", "text": "\n\n// Fails if there is no such a binary.\nbinaries.getExecutable(\"foo\", DEBUG)\nbinaries.getExecutable(DEBUG)          // Skip the first argument if the name prefix isn't set.\nbinaries.getExecutable(\"bar\", \"DEBUG\") // You also can use a string for build type.\n\n// Similar getters are available for other binary kinds:\n// getFramework, getStaticLib and getSharedLib.\n\n// Returns null if there is no such a binary.\nbinaries.findExecutable(\"foo\", DEBUG)\n\n// Similar getters are available for other binary kinds:\n// findFramework, findStaticLib and findSharedLib.\n\n\n"}, {"type": "div", "text": "\n// Fails if there is no such a binary.\nbinaries.getExecutable(\"foo\", DEBUG)\nbinaries.getExecutable(DEBUG)          // Skip the first argument if the name prefix isn't set.\nbinaries.getExecutable(\"bar\", \"DEBUG\") // You also can use a string for build type.\n\n// Similar getters are available for other binary kinds:\n// getFramework, getStaticLib and getSharedLib.\n\n// Returns null if there is no such a binary.\nbinaries.findExecutable(\"foo\", DEBUG)\n\n// Similar getters are available for other binary kinds:\n// findFramework, findStaticLib and findSharedLib.\n\n"}, {"type": "pre", "text": "// Fails if there is no such a binary.\nbinaries.getExecutable(\"foo\", DEBUG)\nbinaries.getExecutable(DEBUG)          // Skip the first argument if the name prefix isn't set.\nbinaries.getExecutable(\"bar\", \"DEBUG\") // You also can use a string for build type.\n\n// Similar getters are available for other binary kinds:\n// getFramework, getStaticLib and getSharedLib.\n\n// Returns null if there is no such a binary.\nbinaries.findExecutable(\"foo\", DEBUG)\n\n// Similar getters are available for other binary kinds:\n// findFramework, findStaticLib and findSharedLib.\n"}, {"type": "code", "text": "// Fails if there is no such a binary.\nbinaries.getExecutable(\"foo\", DEBUG)\nbinaries.getExecutable(DEBUG)          // Skip the first argument if the name prefix isn't set.\nbinaries.getExecutable(\"bar\", \"DEBUG\") // You also can use a string for build type.\n\n// Similar getters are available for other binary kinds:\n// getFramework, getStaticLib and getSharedLib.\n\n// Returns null if there is no such a binary.\nbinaries.findExecutable(\"foo\", DEBUG)\n\n// Similar getters are available for other binary kinds:\n// findFramework, findStaticLib and findSharedLib.\n"}, {"type": "blockquote", "text": "\nBefore 1.3.40, both test and product executables were represented by the same binary type. Thus to access the default test binary created by the plugin, the following line was used:\nbinaries.getExecutable(\"test\", \"DEBUG\")\n\nSince 1.3.40, test executables are represented by a separate binary type and have their own getter. To access the default test binary, use:\nbinaries.getTest(\"DEBUG\")\n\n"}, {"type": "p", "text": "Before 1.3.40, both test and product executables were represented by the same binary type. Thus to access the default test binary created by the plugin, the following line was used:"}, {"type": "pre", "text": "binaries.getExecutable(\"test\", \"DEBUG\")\n"}, {"type": "code", "text": "binaries.getExecutable(\"test\", \"DEBUG\")\n"}, {"type": "p", "text": "Since 1.3.40, test executables are represented by a separate binary type and have their own getter. To access the default test binary, use:"}, {"type": "pre", "text": "binaries.getTest(\"DEBUG\")\n"}, {"type": "code", "text": "binaries.getTest(\"DEBUG\")\n"}, {"type": "h4", "text": "Configuring binaries"}, {"type": "p", "text": "Binaries have a set of properties allowing one to configure them. The following options are available:"}, {"type": "ul", "text": "\nCompilation. Each binary is built on basis of some compilation available in the same target. The default value of this parameter depends\n on the binary type: Test binaries are based on the test compilation while other binaries - on the main compilation.\nLinker options. Options passed to a system linker during binary building. One can use this setting for linking against some native library.\nOutput file name. By default the output file name is based on binary name prefix or, if the name prefix isn't specified, on a project name.\n But it's possible to configure the output file name independently using the baseName property. Note that final file name will be formed\n by adding system-dependent prefix and postfix to this base name. E.g. a libfoo.so is produced for a Linux shared library with the base name foo.\nEntry point (for executable binaries only). By default the entry point for Kotlin/Native programs is a main function located in the root\n package. This setting allows one to change this default and use a custom function as an entry point. For example it can be used to move the main\n function from the root package.\nAccess to the output file.\nAccess to a link task.\nAccess to a run task (for executable binaries only). The kotlin-multiplatform plugin creates run tasks for all executable binaries of host\n platforms (Windows, Linux and macOS). Names of such tasks are based on binary names, e.g. runReleaseExecutable<target-name>\n or runFooDebugExecutable<target-name>. A run task can be accessed using the runTask property of an executable binary.\nFramework type (only for Objective-C frameworks). By default a framework built by Kotlin/Native contains a dynamic library. But it's possible\n to replace it with a static library.\n"}, {"type": "li", "text": "Compilation. Each binary is built on basis of some compilation available in the same target. The default value of this parameter depends\n on the binary type: Test binaries are based on the test compilation while other binaries - on the main compilation."}, {"type": "strong", "text": "Compilation."}, {"type": "code", "text": "Test"}, {"type": "code", "text": "test"}, {"type": "code", "text": "main"}, {"type": "li", "text": "Linker options. Options passed to a system linker during binary building. One can use this setting for linking against some native library."}, {"type": "strong", "text": "Linker options."}, {"type": "li", "text": "Output file name. By default the output file name is based on binary name prefix or, if the name prefix isn't specified, on a project name.\n But it's possible to configure the output file name independently using the baseName property. Note that final file name will be formed\n by adding system-dependent prefix and postfix to this base name. E.g. a libfoo.so is produced for a Linux shared library with the base name foo."}, {"type": "strong", "text": "Output file name."}, {"type": "code", "text": "baseName"}, {"type": "code", "text": "libfoo.so"}, {"type": "code", "text": "foo"}, {"type": "li", "text": "Entry point (for executable binaries only). By default the entry point for Kotlin/Native programs is a main function located in the root\n package. This setting allows one to change this default and use a custom function as an entry point. For example it can be used to move the main\n function from the root package."}, {"type": "strong", "text": "Entry point"}, {"type": "code", "text": "main"}, {"type": "code", "text": "main"}, {"type": "li", "text": "Access to the output file."}, {"type": "strong", "text": "Access to the output file."}, {"type": "li", "text": "Access to a link task."}, {"type": "strong", "text": "Access to a link task."}, {"type": "li", "text": "Access to a run task (for executable binaries only). The kotlin-multiplatform plugin creates run tasks for all executable binaries of host\n platforms (Windows, Linux and macOS). Names of such tasks are based on binary names, e.g. runReleaseExecutable<target-name>\n or runFooDebugExecutable<target-name>. A run task can be accessed using the runTask property of an executable binary."}, {"type": "strong", "text": "Access to a run task"}, {"type": "code", "text": "kotlin-multiplatform"}, {"type": "code", "text": "runReleaseExecutable<target-name>"}, {"type": "code", "text": "runFooDebugExecutable<target-name>"}, {"type": "code", "text": "runTask"}, {"type": "li", "text": "Framework type (only for Objective-C frameworks). By default a framework built by Kotlin/Native contains a dynamic library. But it's possible\n to replace it with a static library."}, {"type": "strong", "text": "Framework type"}, {"type": "p", "text": "The following example shows how to use these settings."}, {"type": "div", "text": "\n\nbinaries {\n    executable('my_executable', [RELEASE]) {\n        // Build a binary on the basis of the test compilation.\n        compilation = compilations.test\n\n        // Custom command line options for the linker.\n        linkerOpts = ['-L/lib/search/path', '-L/another/search/path', '-lmylib']\n\n        // Base name for the output file.\n        baseName = 'foo'\n\n        // Custom entry point function.\n        entryPoint = 'org.example.main'\n\n        // Accessing the output file.\n        println(\"Executable path: ${outputFile.absolutePath}\")\n\n        // Accessing the link task.\n        linkTask.dependsOn(additionalPreprocessingTask)\n\n        // Accessing the run task.\n        // Note that the runTask is null for non-host platforms.\n        runTask?.dependsOn(prepareForRun)\n    }\n\n    framework('my_framework' [RELEASE]) {\n        // Include a static library instead of a dynamic one into the framework.\n        isStatic = true\n    }\n}\n\n\n"}, {"type": "div", "text": "\nbinaries {\n    executable('my_executable', [RELEASE]) {\n        // Build a binary on the basis of the test compilation.\n        compilation = compilations.test\n\n        // Custom command line options for the linker.\n        linkerOpts = ['-L/lib/search/path', '-L/another/search/path', '-lmylib']\n\n        // Base name for the output file.\n        baseName = 'foo'\n\n        // Custom entry point function.\n        entryPoint = 'org.example.main'\n\n        // Accessing the output file.\n        println(\"Executable path: ${outputFile.absolutePath}\")\n\n        // Accessing the link task.\n        linkTask.dependsOn(additionalPreprocessingTask)\n\n        // Accessing the run task.\n        // Note that the runTask is null for non-host platforms.\n        runTask?.dependsOn(prepareForRun)\n    }\n\n    framework('my_framework' [RELEASE]) {\n        // Include a static library instead of a dynamic one into the framework.\n        isStatic = true\n    }\n}\n\n"}, {"type": "pre", "text": "binaries {\n    executable('my_executable', [RELEASE]) {\n        // Build a binary on the basis of the test compilation.\n        compilation = compilations.test\n\n        // Custom command line options for the linker.\n        linkerOpts = ['-L/lib/search/path', '-L/another/search/path', '-lmylib']\n\n        // Base name for the output file.\n        baseName = 'foo'\n\n        // Custom entry point function.\n        entryPoint = 'org.example.main'\n\n        // Accessing the output file.\n        println(\"Executable path: ${outputFile.absolutePath}\")\n\n        // Accessing the link task.\n        linkTask.dependsOn(additionalPreprocessingTask)\n\n        // Accessing the run task.\n        // Note that the runTask is null for non-host platforms.\n        runTask?.dependsOn(prepareForRun)\n    }\n\n    framework('my_framework' [RELEASE]) {\n        // Include a static library instead of a dynamic one into the framework.\n        isStatic = true\n    }\n}\n"}, {"type": "code", "text": "binaries {\n    executable('my_executable', [RELEASE]) {\n        // Build a binary on the basis of the test compilation.\n        compilation = compilations.test\n\n        // Custom command line options for the linker.\n        linkerOpts = ['-L/lib/search/path', '-L/another/search/path', '-lmylib']\n\n        // Base name for the output file.\n        baseName = 'foo'\n\n        // Custom entry point function.\n        entryPoint = 'org.example.main'\n\n        // Accessing the output file.\n        println(\"Executable path: ${outputFile.absolutePath}\")\n\n        // Accessing the link task.\n        linkTask.dependsOn(additionalPreprocessingTask)\n\n        // Accessing the run task.\n        // Note that the runTask is null for non-host platforms.\n        runTask?.dependsOn(prepareForRun)\n    }\n\n    framework('my_framework' [RELEASE]) {\n        // Include a static library instead of a dynamic one into the framework.\n        isStatic = true\n    }\n}\n"}, {"type": "div", "text": "\n\nbinaries {\n    executable(\"my_executable\", listOf(RELEASE)) {\n        // Build a binary on the basis of the test compilation.\n        compilation = compilations[\"test\"]\n\n        // Custom command line options for the linker.\n        linkerOpts = mutableListOf(\"-L/lib/search/path\", \"-L/another/search/path\", \"-lmylib\")\n\n        // Base name for the output file.\n        baseName = \"foo\"\n\n        // Custom entry point function.\n        entryPoint = \"org.example.main\"\n\n        // Accessing the output file.\n        println(\"Executable path: ${outputFile.absolutePath}\")\n\n        // Accessing the link task.\n        linkTask.dependsOn(additionalPreprocessingTask)\n\n        // Accessing the run task.\n        // Note that the runTask is null for non-host platforms.\n        runTask?.dependsOn(prepareForRun)\n    }\n\n    framework(\"my_framework\" listOf(RELEASE)) {\n        // Include a static library instead of a dynamic one into the framework.\n        isStatic = true\n    }\n}\n\n\n"}, {"type": "div", "text": "\nbinaries {\n    executable(\"my_executable\", listOf(RELEASE)) {\n        // Build a binary on the basis of the test compilation.\n        compilation = compilations[\"test\"]\n\n        // Custom command line options for the linker.\n        linkerOpts = mutableListOf(\"-L/lib/search/path\", \"-L/another/search/path\", \"-lmylib\")\n\n        // Base name for the output file.\n        baseName = \"foo\"\n\n        // Custom entry point function.\n        entryPoint = \"org.example.main\"\n\n        // Accessing the output file.\n        println(\"Executable path: ${outputFile.absolutePath}\")\n\n        // Accessing the link task.\n        linkTask.dependsOn(additionalPreprocessingTask)\n\n        // Accessing the run task.\n        // Note that the runTask is null for non-host platforms.\n        runTask?.dependsOn(prepareForRun)\n    }\n\n    framework(\"my_framework\" listOf(RELEASE)) {\n        // Include a static library instead of a dynamic one into the framework.\n        isStatic = true\n    }\n}\n\n"}, {"type": "pre", "text": "binaries {\n    executable(\"my_executable\", listOf(RELEASE)) {\n        // Build a binary on the basis of the test compilation.\n        compilation = compilations[\"test\"]\n\n        // Custom command line options for the linker.\n        linkerOpts = mutableListOf(\"-L/lib/search/path\", \"-L/another/search/path\", \"-lmylib\")\n\n        // Base name for the output file.\n        baseName = \"foo\"\n\n        // Custom entry point function.\n        entryPoint = \"org.example.main\"\n\n        // Accessing the output file.\n        println(\"Executable path: ${outputFile.absolutePath}\")\n\n        // Accessing the link task.\n        linkTask.dependsOn(additionalPreprocessingTask)\n\n        // Accessing the run task.\n        // Note that the runTask is null for non-host platforms.\n        runTask?.dependsOn(prepareForRun)\n    }\n\n    framework(\"my_framework\" listOf(RELEASE)) {\n        // Include a static library instead of a dynamic one into the framework.\n        isStatic = true\n    }\n}\n"}, {"type": "code", "text": "binaries {\n    executable(\"my_executable\", listOf(RELEASE)) {\n        // Build a binary on the basis of the test compilation.\n        compilation = compilations[\"test\"]\n\n        // Custom command line options for the linker.\n        linkerOpts = mutableListOf(\"-L/lib/search/path\", \"-L/another/search/path\", \"-lmylib\")\n\n        // Base name for the output file.\n        baseName = \"foo\"\n\n        // Custom entry point function.\n        entryPoint = \"org.example.main\"\n\n        // Accessing the output file.\n        println(\"Executable path: ${outputFile.absolutePath}\")\n\n        // Accessing the link task.\n        linkTask.dependsOn(additionalPreprocessingTask)\n\n        // Accessing the run task.\n        // Note that the runTask is null for non-host platforms.\n        runTask?.dependsOn(prepareForRun)\n    }\n\n    framework(\"my_framework\" listOf(RELEASE)) {\n        // Include a static library instead of a dynamic one into the framework.\n        isStatic = true\n    }\n}\n"}, {"type": "h4", "text": "Exporting dependencies to binaries"}, {"type": "p", "text": "When building an Objective-C framework or a native library (shared or static), it is often necessary to pack not just the\nclasses of the current project, but also the classes of some of its dependencies. The Binaries DSL allows one to specify\nwhich dependencies will be exported to a binary using the export method. Note that only API dependencies of a corresponding source set can be exported."}, {"type": "code", "text": "export"}, {"type": "div", "text": "\n\nkotlin {\n    sourceSets {\n        macosMain.dependencies {\n            // Will be exported.\n            api project(':dependency')\n            api 'org.example:exported-library:1.0'\n\n            // Will not be exported.\n            api 'org.example:not-exported-library:1.0'\n        }\n    }\n\n    macosX64(\"macos\").binaries {\n        framework {\n            export project(':dependency')\n            export 'org.example:exported-library:1.0'\n        }\n\n        sharedLib {\n            // It's possible to export different sets of dependencies to different binaries.\n            export project(':dependency')\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    sourceSets {\n        macosMain.dependencies {\n            // Will be exported.\n            api project(':dependency')\n            api 'org.example:exported-library:1.0'\n\n            // Will not be exported.\n            api 'org.example:not-exported-library:1.0'\n        }\n    }\n\n    macosX64(\"macos\").binaries {\n        framework {\n            export project(':dependency')\n            export 'org.example:exported-library:1.0'\n        }\n\n        sharedLib {\n            // It's possible to export different sets of dependencies to different binaries.\n            export project(':dependency')\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    sourceSets {\n        macosMain.dependencies {\n            // Will be exported.\n            api project(':dependency')\n            api 'org.example:exported-library:1.0'\n\n            // Will not be exported.\n            api 'org.example:not-exported-library:1.0'\n        }\n    }\n\n    macosX64(\"macos\").binaries {\n        framework {\n            export project(':dependency')\n            export 'org.example:exported-library:1.0'\n        }\n\n        sharedLib {\n            // It's possible to export different sets of dependencies to different binaries.\n            export project(':dependency')\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    sourceSets {\n        macosMain.dependencies {\n            // Will be exported.\n            api project(':dependency')\n            api 'org.example:exported-library:1.0'\n\n            // Will not be exported.\n            api 'org.example:not-exported-library:1.0'\n        }\n    }\n\n    macosX64(\"macos\").binaries {\n        framework {\n            export project(':dependency')\n            export 'org.example:exported-library:1.0'\n        }\n\n        sharedLib {\n            // It's possible to export different sets of dependencies to different binaries.\n            export project(':dependency')\n        }\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin {\n    sourceSets {\n        macosMain.dependencies {\n            // Will be exported.\n            api(project(\":dependency\"))\n            api(\"org.example:exported-library:1.0\")\n\n            // Will not be exported.\n            api(\"org.example:not-exported-library:1.0\")\n        }\n    }\n\n    macosX64(\"macos\").binaries {\n        framework {\n            export(project(\":dependency\"))\n            export(\"org.example:exported-library:1.0\")\n        }\n\n        sharedLib {\n            // It's possible to export different sets of dependencies to different binaries.\n            export(project(':dependency'))\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    sourceSets {\n        macosMain.dependencies {\n            // Will be exported.\n            api(project(\":dependency\"))\n            api(\"org.example:exported-library:1.0\")\n\n            // Will not be exported.\n            api(\"org.example:not-exported-library:1.0\")\n        }\n    }\n\n    macosX64(\"macos\").binaries {\n        framework {\n            export(project(\":dependency\"))\n            export(\"org.example:exported-library:1.0\")\n        }\n\n        sharedLib {\n            // It's possible to export different sets of dependencies to different binaries.\n            export(project(':dependency'))\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    sourceSets {\n        macosMain.dependencies {\n            // Will be exported.\n            api(project(\":dependency\"))\n            api(\"org.example:exported-library:1.0\")\n\n            // Will not be exported.\n            api(\"org.example:not-exported-library:1.0\")\n        }\n    }\n\n    macosX64(\"macos\").binaries {\n        framework {\n            export(project(\":dependency\"))\n            export(\"org.example:exported-library:1.0\")\n        }\n\n        sharedLib {\n            // It's possible to export different sets of dependencies to different binaries.\n            export(project(':dependency'))\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    sourceSets {\n        macosMain.dependencies {\n            // Will be exported.\n            api(project(\":dependency\"))\n            api(\"org.example:exported-library:1.0\")\n\n            // Will not be exported.\n            api(\"org.example:not-exported-library:1.0\")\n        }\n    }\n\n    macosX64(\"macos\").binaries {\n        framework {\n            export(project(\":dependency\"))\n            export(\"org.example:exported-library:1.0\")\n        }\n\n        sharedLib {\n            // It's possible to export different sets of dependencies to different binaries.\n            export(project(':dependency'))\n        }\n    }\n}\n"}, {"type": "blockquote", "text": "\nAs shown in this example, maven dependency also can be exported. But due to current limitations of Gradle metadata such a dependency\nshould be either a platform one (e.g. kotlinx-coroutines-core-native_debug_macos_x64 instead of kotlinx-coroutines-core-native)\nor be exported transitively (see below).\n"}, {"type": "p", "text": "As shown in this example, maven dependency also can be exported. But due to current limitations of Gradle metadata such a dependency\nshould be either a platform one (e.g. kotlinx-coroutines-core-native_debug_macos_x64 instead of kotlinx-coroutines-core-native)\nor be exported transitively (see below)."}, {"type": "code", "text": "kotlinx-coroutines-core-native_debug_macos_x64"}, {"type": "code", "text": "kotlinx-coroutines-core-native"}, {"type": "p", "text": "By default, export works non-transitively. If a library foo depending on library bar is exported, only methods of foo will\nbe added in the output framework. This behaviour can be changed by the transitiveExport flag."}, {"type": "code", "text": "foo"}, {"type": "code", "text": "bar"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "transitiveExport"}, {"type": "div", "text": "\n\nbinaries {\n    framework {\n        export project(':dependency')\n        // Export transitively.\n        transitiveExport = true\n    }\n}\n\n\n"}, {"type": "div", "text": "\nbinaries {\n    framework {\n        export project(':dependency')\n        // Export transitively.\n        transitiveExport = true\n    }\n}\n\n"}, {"type": "pre", "text": "binaries {\n    framework {\n        export project(':dependency')\n        // Export transitively.\n        transitiveExport = true\n    }\n}\n"}, {"type": "code", "text": "binaries {\n    framework {\n        export project(':dependency')\n        // Export transitively.\n        transitiveExport = true\n    }\n}\n"}, {"type": "div", "text": "\n\nbinaries {\n    framework {\n        export(project(\":dependency\"))\n        // Export transitively.\n        transitiveExport = true\n    }\n}\n\n\n"}, {"type": "div", "text": "\nbinaries {\n    framework {\n        export(project(\":dependency\"))\n        // Export transitively.\n        transitiveExport = true\n    }\n}\n\n"}, {"type": "pre", "text": "binaries {\n    framework {\n        export(project(\":dependency\"))\n        // Export transitively.\n        transitiveExport = true\n    }\n}\n"}, {"type": "code", "text": "binaries {\n    framework {\n        export(project(\":dependency\"))\n        // Export transitively.\n        transitiveExport = true\n    }\n}\n"}, {"type": "h4", "text": "Building universal frameworks"}, {"type": "p", "text": "By default, an Objective-C framework produced by Kotlin/Native supports only one platform. However, such frameworks can be merged\ninto a single universal (fat) binary using the lipo utility. Particularly, such an operation makes sense for 32-bit and 64-bit iOS\nframeworks. In this case the resulting universal framework can be used on both 32-bit and 64-bit devices."}, {"type": "code", "text": "lipo"}, {"type": "p", "text": "The Gradle plugin provides a separate task that creates a universal framework for iOS targets from several regular ones.\nThe example below shows how to use this task. Note that the fat framework must have the same base name as the initial frameworks."}, {"type": "div", "text": "\n\nimport org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask\n\nkotlin {\n    // Create and configure the targets.\n    targets {\n        iosArm32(\"ios32\")\n        iosArm64(\"ios64\")\n\n        configure([ios32, ios64]) {\n            binaries.framework {\n                baseName = \"my_framework\"\n            }\n        }\n    }\n\n    // Create a task building a fat framework.\n    task debugFatFramework(type: FatFrameworkTask) {\n        // The fat framework must have the same base name as the initial frameworks.\n        baseName = \"my_framework\"\n\n        // The default destination directory is '<build directory>/fat-framework'.\n        destinationDir = file(\"$buildDir/fat-framework/debug\")\n\n        // Specify the frameworks to be merged.\n        from(\n            targets.ios32.binaries.getFramework(\"DEBUG\"),\n            targets.ios64.binaries.getFramework(\"DEBUG\")\n        )\n    }\n}\n\n\n"}, {"type": "div", "text": "\nimport org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask\n\nkotlin {\n    // Create and configure the targets.\n    targets {\n        iosArm32(\"ios32\")\n        iosArm64(\"ios64\")\n\n        configure([ios32, ios64]) {\n            binaries.framework {\n                baseName = \"my_framework\"\n            }\n        }\n    }\n\n    // Create a task building a fat framework.\n    task debugFatFramework(type: FatFrameworkTask) {\n        // The fat framework must have the same base name as the initial frameworks.\n        baseName = \"my_framework\"\n\n        // The default destination directory is '<build directory>/fat-framework'.\n        destinationDir = file(\"$buildDir/fat-framework/debug\")\n\n        // Specify the frameworks to be merged.\n        from(\n            targets.ios32.binaries.getFramework(\"DEBUG\"),\n            targets.ios64.binaries.getFramework(\"DEBUG\")\n        )\n    }\n}\n\n"}, {"type": "pre", "text": "import org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask\n\nkotlin {\n    // Create and configure the targets.\n    targets {\n        iosArm32(\"ios32\")\n        iosArm64(\"ios64\")\n\n        configure([ios32, ios64]) {\n            binaries.framework {\n                baseName = \"my_framework\"\n            }\n        }\n    }\n\n    // Create a task building a fat framework.\n    task debugFatFramework(type: FatFrameworkTask) {\n        // The fat framework must have the same base name as the initial frameworks.\n        baseName = \"my_framework\"\n\n        // The default destination directory is '<build directory>/fat-framework'.\n        destinationDir = file(\"$buildDir/fat-framework/debug\")\n\n        // Specify the frameworks to be merged.\n        from(\n            targets.ios32.binaries.getFramework(\"DEBUG\"),\n            targets.ios64.binaries.getFramework(\"DEBUG\")\n        )\n    }\n}\n"}, {"type": "code", "text": "import org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask\n\nkotlin {\n    // Create and configure the targets.\n    targets {\n        iosArm32(\"ios32\")\n        iosArm64(\"ios64\")\n\n        configure([ios32, ios64]) {\n            binaries.framework {\n                baseName = \"my_framework\"\n            }\n        }\n    }\n\n    // Create a task building a fat framework.\n    task debugFatFramework(type: FatFrameworkTask) {\n        // The fat framework must have the same base name as the initial frameworks.\n        baseName = \"my_framework\"\n\n        // The default destination directory is '<build directory>/fat-framework'.\n        destinationDir = file(\"$buildDir/fat-framework/debug\")\n\n        // Specify the frameworks to be merged.\n        from(\n            targets.ios32.binaries.getFramework(\"DEBUG\"),\n            targets.ios64.binaries.getFramework(\"DEBUG\")\n        )\n    }\n}\n"}, {"type": "div", "text": "\n\nimport org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask\n\nkotlin {\n    // Create and configure the targets.\n    val ios32 = iosArm32(\"ios32\")\n    val ios64 = iosArm64(\"ios64\")\n\n    configure(listOf(ios32, ios64)) {\n        binaries.framework {\n            baseName = \"my_framework\"\n        }\n    }\n\n    // Create a task building a fat framework.\n    tasks.create(\"debugFatFramework\", FatFrameworkTask::class) {\n        // The fat framework must have the same base name as the initial frameworks.\n        baseName = \"my_framework\"\n\n        // The default destination directory is '<build directory>/fat-framework'.\n        destinationDir = buildDir.resolve(\"fat-framework/debug\")\n\n        // Specify the frameworks to be merged.\n        from(\n            ios32.binaries.getFramework(\"DEBUG\"),\n            ios64.binaries.getFramework(\"DEBUG\")\n        )\n    }\n}\n\n\n"}, {"type": "div", "text": "\nimport org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask\n\nkotlin {\n    // Create and configure the targets.\n    val ios32 = iosArm32(\"ios32\")\n    val ios64 = iosArm64(\"ios64\")\n\n    configure(listOf(ios32, ios64)) {\n        binaries.framework {\n            baseName = \"my_framework\"\n        }\n    }\n\n    // Create a task building a fat framework.\n    tasks.create(\"debugFatFramework\", FatFrameworkTask::class) {\n        // The fat framework must have the same base name as the initial frameworks.\n        baseName = \"my_framework\"\n\n        // The default destination directory is '<build directory>/fat-framework'.\n        destinationDir = buildDir.resolve(\"fat-framework/debug\")\n\n        // Specify the frameworks to be merged.\n        from(\n            ios32.binaries.getFramework(\"DEBUG\"),\n            ios64.binaries.getFramework(\"DEBUG\")\n        )\n    }\n}\n\n"}, {"type": "pre", "text": "import org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask\n\nkotlin {\n    // Create and configure the targets.\n    val ios32 = iosArm32(\"ios32\")\n    val ios64 = iosArm64(\"ios64\")\n\n    configure(listOf(ios32, ios64)) {\n        binaries.framework {\n            baseName = \"my_framework\"\n        }\n    }\n\n    // Create a task building a fat framework.\n    tasks.create(\"debugFatFramework\", FatFrameworkTask::class) {\n        // The fat framework must have the same base name as the initial frameworks.\n        baseName = \"my_framework\"\n\n        // The default destination directory is '<build directory>/fat-framework'.\n        destinationDir = buildDir.resolve(\"fat-framework/debug\")\n\n        // Specify the frameworks to be merged.\n        from(\n            ios32.binaries.getFramework(\"DEBUG\"),\n            ios64.binaries.getFramework(\"DEBUG\")\n        )\n    }\n}\n"}, {"type": "code", "text": "import org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask\n\nkotlin {\n    // Create and configure the targets.\n    val ios32 = iosArm32(\"ios32\")\n    val ios64 = iosArm64(\"ios64\")\n\n    configure(listOf(ios32, ios64)) {\n        binaries.framework {\n            baseName = \"my_framework\"\n        }\n    }\n\n    // Create a task building a fat framework.\n    tasks.create(\"debugFatFramework\", FatFrameworkTask::class) {\n        // The fat framework must have the same base name as the initial frameworks.\n        baseName = \"my_framework\"\n\n        // The default destination directory is '<build directory>/fat-framework'.\n        destinationDir = buildDir.resolve(\"fat-framework/debug\")\n\n        // Specify the frameworks to be merged.\n        from(\n            ios32.binaries.getFramework(\"DEBUG\"),\n            ios64.binaries.getFramework(\"DEBUG\")\n        )\n    }\n}\n"}, {"type": "h3", "text": "CInterop support"}, {"type": "p", "text": "Since Kotlin/Native provides interoperability with native languages,\nthere is a DSL allowing one to configure this feature for a specific compilation."}, {"type": "a", "text": "interoperability with native languages"}, {"type": "p", "text": "A compilation can interact with several native libraries. Interoperability with each of them can be configured in\nthe cinterops block of the compilation:"}, {"type": "code", "text": "cinterops"}, {"type": "div", "text": "\n\nkotlin {\n    linuxX64 { // Replace with a target you need.\n        compilations.main {\n            cinterops {\n                myInterop {\n                    // Def-file describing the native API.\n                    // The default path is src/nativeInterop/cinterop/<interop-name>.def\n                    defFile project.file(\"def-file.def\")\n\n                    // Package to place the Kotlin API generated.\n                    packageName 'org.sample'\n\n                    // Options to be passed to compiler by cinterop tool.\n                    compilerOpts '-Ipath/to/headers'\n\n                    // Directories for header search (an analogue of the -I<path> compiler option).\n                    includeDirs.allHeaders(\"path1\", \"path2\")\n\n                    // Additional directories to search headers listed in the 'headerFilter' def-file option.\n                    // -headerFilterAdditionalSearchPrefix command line option analogue.\n                    includeDirs.headerFilterOnly(\"path1\", \"path2\")\n\n                    // A shortcut for includeDirs.allHeaders.\n                    includeDirs(\"include/directory\", \"another/directory\")\n                }\n\n                anotherInterop { /* ... */ }\n            }\n        }\n    }\n}\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    linuxX64 { // Replace with a target you need.\n        compilations.main {\n            cinterops {\n                myInterop {\n                    // Def-file describing the native API.\n                    // The default path is src/nativeInterop/cinterop/<interop-name>.def\n                    defFile project.file(\"def-file.def\")\n\n                    // Package to place the Kotlin API generated.\n                    packageName 'org.sample'\n\n                    // Options to be passed to compiler by cinterop tool.\n                    compilerOpts '-Ipath/to/headers'\n\n                    // Directories for header search (an analogue of the -I<path> compiler option).\n                    includeDirs.allHeaders(\"path1\", \"path2\")\n\n                    // Additional directories to search headers listed in the 'headerFilter' def-file option.\n                    // -headerFilterAdditionalSearchPrefix command line option analogue.\n                    includeDirs.headerFilterOnly(\"path1\", \"path2\")\n\n                    // A shortcut for includeDirs.allHeaders.\n                    includeDirs(\"include/directory\", \"another/directory\")\n                }\n\n                anotherInterop { /* ... */ }\n            }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    linuxX64 { // Replace with a target you need.\n        compilations.main {\n            cinterops {\n                myInterop {\n                    // Def-file describing the native API.\n                    // The default path is src/nativeInterop/cinterop/<interop-name>.def\n                    defFile project.file(\"def-file.def\")\n\n                    // Package to place the Kotlin API generated.\n                    packageName 'org.sample'\n\n                    // Options to be passed to compiler by cinterop tool.\n                    compilerOpts '-Ipath/to/headers'\n\n                    // Directories for header search (an analogue of the -I<path> compiler option).\n                    includeDirs.allHeaders(\"path1\", \"path2\")\n\n                    // Additional directories to search headers listed in the 'headerFilter' def-file option.\n                    // -headerFilterAdditionalSearchPrefix command line option analogue.\n                    includeDirs.headerFilterOnly(\"path1\", \"path2\")\n\n                    // A shortcut for includeDirs.allHeaders.\n                    includeDirs(\"include/directory\", \"another/directory\")\n                }\n\n                anotherInterop { /* ... */ }\n            }\n        }\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    linuxX64 { // Replace with a target you need.\n        compilations.main {\n            cinterops {\n                myInterop {\n                    // Def-file describing the native API.\n                    // The default path is src/nativeInterop/cinterop/<interop-name>.def\n                    defFile project.file(\"def-file.def\")\n\n                    // Package to place the Kotlin API generated.\n                    packageName 'org.sample'\n\n                    // Options to be passed to compiler by cinterop tool.\n                    compilerOpts '-Ipath/to/headers'\n\n                    // Directories for header search (an analogue of the -I<path> compiler option).\n                    includeDirs.allHeaders(\"path1\", \"path2\")\n\n                    // Additional directories to search headers listed in the 'headerFilter' def-file option.\n                    // -headerFilterAdditionalSearchPrefix command line option analogue.\n                    includeDirs.headerFilterOnly(\"path1\", \"path2\")\n\n                    // A shortcut for includeDirs.allHeaders.\n                    includeDirs(\"include/directory\", \"another/directory\")\n                }\n\n                anotherInterop { /* ... */ }\n            }\n        }\n    }\n}\n"}, {"type": "div", "text": "\n\nkotlin {\n    linuxX64 {  // Replace with a target you need.\n        compilations.getByName(\"main\") {\n            val myInterop by cinterops.creating {\n                // Def-file describing the native API.\n                // The default path is src/nativeInterop/cinterop/<interop-name>.def\n                defFile(project.file(\"def-file.def\"))\n\n                // Package to place the Kotlin API generated.\n                packageName(\"org.sample\")\n\n                // Options to be passed to compiler by cinterop tool.\n                compilerOpts(\"-Ipath/to/headers\")\n\n                // Directories to look for headers.\n                includeDirs.apply {\n                    // Directories for header search (an analogue of the -I<path> compiler option).\n                    allHeaders(\"path1\", \"path2\")\n\n                    // Additional directories to search headers listed in the 'headerFilter' def-file option.\n                    // -headerFilterAdditionalSearchPrefix command line option analogue.\n                    headerFilterOnly(\"path1\", \"path2\")\n                }\n                // A shortcut for includeDirs.allHeaders.\n                includeDirs(\"include/directory\", \"another/directory\")\n            }\n\n            val anotherInterop by cinterops.creating { /* ... */ }\n        }\n    }\n}\n\n\n\n"}, {"type": "div", "text": "\nkotlin {\n    linuxX64 {  // Replace with a target you need.\n        compilations.getByName(\"main\") {\n            val myInterop by cinterops.creating {\n                // Def-file describing the native API.\n                // The default path is src/nativeInterop/cinterop/<interop-name>.def\n                defFile(project.file(\"def-file.def\"))\n\n                // Package to place the Kotlin API generated.\n                packageName(\"org.sample\")\n\n                // Options to be passed to compiler by cinterop tool.\n                compilerOpts(\"-Ipath/to/headers\")\n\n                // Directories to look for headers.\n                includeDirs.apply {\n                    // Directories for header search (an analogue of the -I<path> compiler option).\n                    allHeaders(\"path1\", \"path2\")\n\n                    // Additional directories to search headers listed in the 'headerFilter' def-file option.\n                    // -headerFilterAdditionalSearchPrefix command line option analogue.\n                    headerFilterOnly(\"path1\", \"path2\")\n                }\n                // A shortcut for includeDirs.allHeaders.\n                includeDirs(\"include/directory\", \"another/directory\")\n            }\n\n            val anotherInterop by cinterops.creating { /* ... */ }\n        }\n    }\n}\n\n\n"}, {"type": "pre", "text": "kotlin {\n    linuxX64 {  // Replace with a target you need.\n        compilations.getByName(\"main\") {\n            val myInterop by cinterops.creating {\n                // Def-file describing the native API.\n                // The default path is src/nativeInterop/cinterop/<interop-name>.def\n                defFile(project.file(\"def-file.def\"))\n\n                // Package to place the Kotlin API generated.\n                packageName(\"org.sample\")\n\n                // Options to be passed to compiler by cinterop tool.\n                compilerOpts(\"-Ipath/to/headers\")\n\n                // Directories to look for headers.\n                includeDirs.apply {\n                    // Directories for header search (an analogue of the -I<path> compiler option).\n                    allHeaders(\"path1\", \"path2\")\n\n                    // Additional directories to search headers listed in the 'headerFilter' def-file option.\n                    // -headerFilterAdditionalSearchPrefix command line option analogue.\n                    headerFilterOnly(\"path1\", \"path2\")\n                }\n                // A shortcut for includeDirs.allHeaders.\n                includeDirs(\"include/directory\", \"another/directory\")\n            }\n\n            val anotherInterop by cinterops.creating { /* ... */ }\n        }\n    }\n}\n\n"}, {"type": "code", "text": "kotlin {\n    linuxX64 {  // Replace with a target you need.\n        compilations.getByName(\"main\") {\n            val myInterop by cinterops.creating {\n                // Def-file describing the native API.\n                // The default path is src/nativeInterop/cinterop/<interop-name>.def\n                defFile(project.file(\"def-file.def\"))\n\n                // Package to place the Kotlin API generated.\n                packageName(\"org.sample\")\n\n                // Options to be passed to compiler by cinterop tool.\n                compilerOpts(\"-Ipath/to/headers\")\n\n                // Directories to look for headers.\n                includeDirs.apply {\n                    // Directories for header search (an analogue of the -I<path> compiler option).\n                    allHeaders(\"path1\", \"path2\")\n\n                    // Additional directories to search headers listed in the 'headerFilter' def-file option.\n                    // -headerFilterAdditionalSearchPrefix command line option analogue.\n                    headerFilterOnly(\"path1\", \"path2\")\n                }\n                // A shortcut for includeDirs.allHeaders.\n                includeDirs(\"include/directory\", \"another/directory\")\n            }\n\n            val anotherInterop by cinterops.creating { /* ... */ }\n        }\n    }\n}\n\n"}, {"type": "p", "text": "Often it's necessary to specify target-specific linker options for a binary which uses a native library. It can by done\nusing the linkerOpts property of the binary. See the Configuring binaries section for details."}, {"type": "code", "text": "linkerOpts"}, {"type": "a", "text": "Configuring binaries"}]