[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Functions"}, {"type": "h2", "text": "Function declarations"}, {"type": "p", "text": "Functions in Kotlin are declared using the fun keyword:"}, {"type": "em", "text": "fun"}, {"type": "div", "text": "\nfun double(x: Int): Int {\n    return 2 * x\n}\n\n"}, {"type": "pre", "text": "fun double(x: Int): Int {\n    return 2 * x\n}\n"}, {"type": "code", "text": "fun double(x: Int): Int {\n    return 2 * x\n}\n"}, {"type": "h2", "text": "Function usage"}, {"type": "p", "text": "Calling functions uses the traditional approach:"}, {"type": "div", "text": "\nval result = double(2)\n\n"}, {"type": "pre", "text": "val result = double(2)\n"}, {"type": "code", "text": "val result = double(2)\n"}, {"type": "p", "text": "Calling member functions uses the dot notation:"}, {"type": "div", "text": "\nStream().read() // create instance of class Stream and call read()\n\n"}, {"type": "pre", "text": "Stream().read() // create instance of class Stream and call read()\n"}, {"type": "code", "text": "Stream().read() // create instance of class Stream and call read()\n"}, {"type": "h3", "text": "Parameters"}, {"type": "p", "text": "Function parameters are defined using Pascal notation, i.e. name: type. Parameters are separated using commas. Each parameter must be explicitly typed:"}, {"type": "em", "text": "name"}, {"type": "em", "text": "type"}, {"type": "div", "text": "\nfun powerOf(number: Int, exponent: Int) { /*...*/ }\n\n"}, {"type": "pre", "text": "fun powerOf(number: Int, exponent: Int) { /*...*/ }\n"}, {"type": "code", "text": "fun powerOf(number: Int, exponent: Int) { /*...*/ }\n"}, {"type": "h3", "text": "Default arguments"}, {"type": "p", "text": "Function parameters can have default values, which are used when a corresponding argument is omitted. This allows for a reduced number of overloads compared to\nother languages:"}, {"type": "div", "text": "\nfun read(b: Array<Byte>, off: Int = 0, len: Int = b.size) { /*...*/ }\n\n"}, {"type": "pre", "text": "fun read(b: Array<Byte>, off: Int = 0, len: Int = b.size) { /*...*/ }\n"}, {"type": "code", "text": "fun read(b: Array<Byte>, off: Int = 0, len: Int = b.size) { /*...*/ }\n"}, {"type": "p", "text": "Default values are defined using the = after type along with the value."}, {"type": "strong", "text": "="}, {"type": "p", "text": "Overriding methods always use the same default parameter values as the base method.\nWhen overriding a method with default parameter values, the default parameter values must be omitted from the signature:"}, {"type": "div", "text": "\nopen class A {\n    open fun foo(i: Int = 10) { /*...*/ }\n}\n\nclass B : A() {\n    override fun foo(i: Int) { /*...*/ }  // no default value allowed\n}\n\n"}, {"type": "pre", "text": "open class A {\n    open fun foo(i: Int = 10) { /*...*/ }\n}\n\nclass B : A() {\n    override fun foo(i: Int) { /*...*/ }  // no default value allowed\n}\n"}, {"type": "code", "text": "open class A {\n    open fun foo(i: Int = 10) { /*...*/ }\n}\n\nclass B : A() {\n    override fun foo(i: Int) { /*...*/ }  // no default value allowed\n}\n"}, {"type": "p", "text": "If a default parameter precedes a parameter with no default value, the default value can only be used by calling the function with named arguments:"}, {"type": "a", "text": "named arguments"}, {"type": "div", "text": "\nfun foo(bar: Int = 0, baz: Int) { /*...*/ }\n\nfoo(baz = 1) // The default value bar = 0 is used\n\n"}, {"type": "pre", "text": "fun foo(bar: Int = 0, baz: Int) { /*...*/ }\n\nfoo(baz = 1) // The default value bar = 0 is used\n"}, {"type": "code", "text": "fun foo(bar: Int = 0, baz: Int) { /*...*/ }\n\nfoo(baz = 1) // The default value bar = 0 is used\n"}, {"type": "p", "text": "If the last argument after default parameters is a lambda, it can be passed in either as a named argument or outside the parentheses:"}, {"type": "a", "text": "lambda"}, {"type": "a", "text": "outside the parentheses"}, {"type": "div", "text": "\nfun foo(bar: Int = 0, baz: Int = 1, qux: () -> Unit) { /*...*/ }\n\nfoo(1) { println(\"hello\") }     // Uses the default value baz = 1\nfoo(qux = { println(\"hello\") }) // Uses both default values bar = 0 and baz = 1 \nfoo { println(\"hello\") }        // Uses both default values bar = 0 and baz = 1\n\n"}, {"type": "pre", "text": "fun foo(bar: Int = 0, baz: Int = 1, qux: () -> Unit) { /*...*/ }\n\nfoo(1) { println(\"hello\") }     // Uses the default value baz = 1\nfoo(qux = { println(\"hello\") }) // Uses both default values bar = 0 and baz = 1 \nfoo { println(\"hello\") }        // Uses both default values bar = 0 and baz = 1\n"}, {"type": "code", "text": "fun foo(bar: Int = 0, baz: Int = 1, qux: () -> Unit) { /*...*/ }\n\nfoo(1) { println(\"hello\") }     // Uses the default value baz = 1\nfoo(qux = { println(\"hello\") }) // Uses both default values bar = 0 and baz = 1 \nfoo { println(\"hello\") }        // Uses both default values bar = 0 and baz = 1\n"}, {"type": "h3", "text": "Named arguments"}, {"type": "p", "text": "Function parameters can be named when calling functions. This is very convenient when a function has a high number of parameters or default ones."}, {"type": "p", "text": "Given the following function:"}, {"type": "div", "text": "\nfun reformat(str: String,\n             normalizeCase: Boolean = true,\n             upperCaseFirstLetter: Boolean = true,\n             divideByCamelHumps: Boolean = false,\n             wordSeparator: Char = ' ') {\n/*...*/\n}\n\n"}, {"type": "pre", "text": "fun reformat(str: String,\n             normalizeCase: Boolean = true,\n             upperCaseFirstLetter: Boolean = true,\n             divideByCamelHumps: Boolean = false,\n             wordSeparator: Char = ' ') {\n/*...*/\n}\n"}, {"type": "code", "text": "fun reformat(str: String,\n             normalizeCase: Boolean = true,\n             upperCaseFirstLetter: Boolean = true,\n             divideByCamelHumps: Boolean = false,\n             wordSeparator: Char = ' ') {\n/*...*/\n}\n"}, {"type": "p", "text": "We could call this using default arguments:"}, {"type": "div", "text": "\nreformat(str)\n\n"}, {"type": "pre", "text": "reformat(str)\n"}, {"type": "code", "text": "reformat(str)\n"}, {"type": "p", "text": "However, when calling it with non-default, the call would look something like:"}, {"type": "div", "text": "\nreformat(str, true, true, false, '_')\n\n"}, {"type": "pre", "text": "reformat(str, true, true, false, '_')\n"}, {"type": "code", "text": "reformat(str, true, true, false, '_')\n"}, {"type": "p", "text": "With named arguments we can make the code much more readable:"}, {"type": "div", "text": "\nreformat(str,\n    normalizeCase = true,\n    upperCaseFirstLetter = true,\n    divideByCamelHumps = false,\n    wordSeparator = '_'\n)\n\n"}, {"type": "pre", "text": "reformat(str,\n    normalizeCase = true,\n    upperCaseFirstLetter = true,\n    divideByCamelHumps = false,\n    wordSeparator = '_'\n)\n"}, {"type": "code", "text": "reformat(str,\n    normalizeCase = true,\n    upperCaseFirstLetter = true,\n    divideByCamelHumps = false,\n    wordSeparator = '_'\n)\n"}, {"type": "p", "text": "and if we do not need all arguments:"}, {"type": "div", "text": "\nreformat(str, wordSeparator = '_')\n\n"}, {"type": "pre", "text": "reformat(str, wordSeparator = '_')\n"}, {"type": "code", "text": "reformat(str, wordSeparator = '_')\n"}, {"type": "p", "text": "When a function is called with both positional and named arguments, all the positional arguments should be placed before the first named one. For example, the call f(1, y = 2) is allowed, but f(x = 1, 2) is not."}, {"type": "code", "text": "f(1, y = 2)"}, {"type": "code", "text": "f(x = 1, 2)"}, {"type": "p", "text": "Variable number of arguments (vararg) can be passed in the named form by using the spread operator:"}, {"type": "a", "text": "Variable number of arguments (vararg)"}, {"type": "em", "text": "vararg"}, {"type": "strong", "text": "spread"}, {"type": "div", "text": "\nfun foo(vararg strings: String) { /*...*/ }\n\nfoo(strings = *arrayOf(\"a\", \"b\", \"c\"))\n\n"}, {"type": "pre", "text": "fun foo(vararg strings: String) { /*...*/ }\n\nfoo(strings = *arrayOf(\"a\", \"b\", \"c\"))\n"}, {"type": "code", "text": "fun foo(vararg strings: String) { /*...*/ }\n\nfoo(strings = *arrayOf(\"a\", \"b\", \"c\"))\n"}, {"type": "blockquote", "text": "\nOn the JVM: the named argument syntax cannot be used when calling Java functions because Java bytecode does not\nalways preserve names of function parameters.\n"}, {"type": "p", "text": "On the JVM: the named argument syntax cannot be used when calling Java functions because Java bytecode does not\nalways preserve names of function parameters."}, {"type": "strong", "text": "On the JVM"}, {"type": "h3", "text": "Unit-returning functions"}, {"type": "p", "text": "If a function does not return any useful value, its return type is Unit. Unit is a type with only one value - Unit. This\nvalue does not have to be returned explicitly:"}, {"type": "code", "text": "Unit"}, {"type": "code", "text": "Unit"}, {"type": "code", "text": "Unit"}, {"type": "div", "text": "\nfun printHello(name: String?): Unit {\n    if (name != null)\n        println(\"Hello $name\")\n    else\n        println(\"Hi there!\")\n    // `return Unit` or `return` is optional\n}\n\n"}, {"type": "pre", "text": "fun printHello(name: String?): Unit {\n    if (name != null)\n        println(\"Hello $name\")\n    else\n        println(\"Hi there!\")\n    // `return Unit` or `return` is optional\n}\n"}, {"type": "code", "text": "fun printHello(name: String?): Unit {\n    if (name != null)\n        println(\"Hello $name\")\n    else\n        println(\"Hi there!\")\n    // `return Unit` or `return` is optional\n}\n"}, {"type": "p", "text": "The Unit return type declaration is also optional. The above code is equivalent to:"}, {"type": "code", "text": "Unit"}, {"type": "div", "text": "\nfun printHello(name: String?) { ... }\n\n"}, {"type": "pre", "text": "fun printHello(name: String?) { ... }\n"}, {"type": "code", "text": "fun printHello(name: String?) { ... }\n"}, {"type": "h3", "text": "Single-expression functions"}, {"type": "p", "text": "When a function returns a single expression, the curly braces can be omitted and the body is specified after a = symbol:"}, {"type": "strong", "text": "="}, {"type": "div", "text": "\nfun double(x: Int): Int = x * 2\n\n"}, {"type": "pre", "text": "fun double(x: Int): Int = x * 2\n"}, {"type": "code", "text": "fun double(x: Int): Int = x * 2\n"}, {"type": "p", "text": "Explicitly declaring the return type is optional when this can be inferred by the compiler:"}, {"type": "a", "text": "optional"}, {"type": "div", "text": "\nfun double(x: Int) = x * 2\n\n"}, {"type": "pre", "text": "fun double(x: Int) = x * 2\n"}, {"type": "code", "text": "fun double(x: Int) = x * 2\n"}, {"type": "h3", "text": "Explicit return types"}, {"type": "p", "text": "Functions with block body must always specify return types explicitly, unless it's intended for them to return Unit, in which case it is optional.\nKotlin does not infer return types for functions with block bodies because such functions may have complex control flow in the body, and the return\ntype will be non-obvious to the reader (and sometimes even for the compiler)."}, {"type": "code", "text": "Unit"}, {"type": "a", "text": "in which case it is optional"}, {"type": "h3", "text": "Variable number of arguments (Varargs)"}, {"type": "p", "text": "A parameter of a function (normally the last one) may be marked with vararg modifier:"}, {"type": "code", "text": "vararg"}, {"type": "div", "text": "\nfun <T> asList(vararg ts: T): List<T> {\n    val result = ArrayList<T>()\n    for (t in ts) // ts is an Array\n        result.add(t)\n    return result\n}\n\n"}, {"type": "pre", "text": "fun <T> asList(vararg ts: T): List<T> {\n    val result = ArrayList<T>()\n    for (t in ts) // ts is an Array\n        result.add(t)\n    return result\n}\n"}, {"type": "code", "text": "fun <T> asList(vararg ts: T): List<T> {\n    val result = ArrayList<T>()\n    for (t in ts) // ts is an Array\n        result.add(t)\n    return result\n}\n"}, {"type": "p", "text": "allowing a variable number of arguments to be passed to the function:"}, {"type": "div", "text": "\nval list = asList(1, 2, 3)\n\n"}, {"type": "pre", "text": "val list = asList(1, 2, 3)\n"}, {"type": "code", "text": "val list = asList(1, 2, 3)\n"}, {"type": "p", "text": "Inside a function a vararg-parameter of type T is visible as an array of T, i.e. the ts variable in the example above has type Array<out T>."}, {"type": "code", "text": "vararg"}, {"type": "code", "text": "T"}, {"type": "code", "text": "T"}, {"type": "code", "text": "ts"}, {"type": "code", "text": "Array<out T>"}, {"type": "p", "text": "Only one parameter may be marked as vararg. If a vararg parameter is not the last one in the list, values for the\nfollowing parameters can be passed using the named argument syntax, or, if the parameter has a function type, by passing\na lambda outside parentheses."}, {"type": "code", "text": "vararg"}, {"type": "code", "text": "vararg"}, {"type": "p", "text": "When we call a vararg-function, we can pass arguments one-by-one, e.g. asList(1, 2, 3), or, if we already have an array\n and want to pass its contents to the function, we use the spread operator (prefix the array with *):"}, {"type": "code", "text": "vararg"}, {"type": "code", "text": "asList(1, 2, 3)"}, {"type": "strong", "text": "spread"}, {"type": "code", "text": "*"}, {"type": "div", "text": "\nval a = arrayOf(1, 2, 3)\nval list = asList(-1, 0, *a, 4)\n\n"}, {"type": "pre", "text": "val a = arrayOf(1, 2, 3)\nval list = asList(-1, 0, *a, 4)\n"}, {"type": "code", "text": "val a = arrayOf(1, 2, 3)\nval list = asList(-1, 0, *a, 4)\n"}, {"type": "h3", "text": "Infix notation"}, {"type": "p", "text": "Functions marked with the infix keyword can also be called using the infix notation (omitting the dot and the parentheses for the call). Infix functions must satisfy the following requirements:"}, {"type": "em", "text": "infix"}, {"type": "ul", "text": "\nThey must be member functions or extension functions;\nThey must have a single parameter;\nThe parameter must not accept variable number of arguments and must have no default value.\n"}, {"type": "li", "text": "They must be member functions or extension functions;"}, {"type": "a", "text": "extension functions"}, {"type": "li", "text": "They must have a single parameter;"}, {"type": "li", "text": "The parameter must not accept variable number of arguments and must have no default value."}, {"type": "a", "text": "accept variable number of arguments"}, {"type": "a", "text": "default value"}, {"type": "div", "text": "\ninfix fun Int.shl(x: Int): Int { ... }\n\n// calling the function using the infix notation\n1 shl 2\n\n// is the same as\n1.shl(2)\n\n"}, {"type": "pre", "text": "infix fun Int.shl(x: Int): Int { ... }\n\n// calling the function using the infix notation\n1 shl 2\n\n// is the same as\n1.shl(2)\n"}, {"type": "code", "text": "infix fun Int.shl(x: Int): Int { ... }\n\n// calling the function using the infix notation\n1 shl 2\n\n// is the same as\n1.shl(2)\n"}, {"type": "blockquote", "text": "\nInfix function calls have lower precedence than the arithmetic operators, type casts, and the rangeTo operator.\nThe following expressions are equivalent:\n\n1 shl 2 + 3 is equivalent to 1 shl (2 + 3)\n0 until n * 2 is equivalent to 0 until (n * 2)\nxs union ys as Set<*> is equivalent to xs union (ys as Set<*>)\n\nOn the other hand, infix function call's precedence is higher than that of the boolean operators && and ||, is- and in-checks, and some other operators. These expressions are equivalent as well:\n\na && b xor c is equivalent to a && (b xor c)\na xor b in c is equivalent to (a xor b) in c\n\nSee the Grammar reference for the complete operators precedence hierarchy.\n"}, {"type": "p", "text": "Infix function calls have lower precedence than the arithmetic operators, type casts, and the rangeTo operator.\nThe following expressions are equivalent:"}, {"type": "code", "text": "rangeTo"}, {"type": "ul", "text": "\n1 shl 2 + 3 is equivalent to 1 shl (2 + 3)\n0 until n * 2 is equivalent to 0 until (n * 2)\nxs union ys as Set<*> is equivalent to xs union (ys as Set<*>)\n"}, {"type": "li", "text": "1 shl 2 + 3 is equivalent to 1 shl (2 + 3)"}, {"type": "code", "text": "1 shl 2 + 3"}, {"type": "code", "text": "1 shl (2 + 3)"}, {"type": "li", "text": "0 until n * 2 is equivalent to 0 until (n * 2)"}, {"type": "code", "text": "0 until n * 2"}, {"type": "code", "text": "0 until (n * 2)"}, {"type": "li", "text": "xs union ys as Set<*> is equivalent to xs union (ys as Set<*>)"}, {"type": "code", "text": "xs union ys as Set<*>"}, {"type": "code", "text": "xs union (ys as Set<*>)"}, {"type": "p", "text": "On the other hand, infix function call's precedence is higher than that of the boolean operators && and ||, is- and in-checks, and some other operators. These expressions are equivalent as well:"}, {"type": "code", "text": "&&"}, {"type": "code", "text": "||"}, {"type": "code", "text": "is"}, {"type": "code", "text": "in"}, {"type": "ul", "text": "\na && b xor c is equivalent to a && (b xor c)\na xor b in c is equivalent to (a xor b) in c\n"}, {"type": "li", "text": "a && b xor c is equivalent to a && (b xor c)"}, {"type": "code", "text": "a && b xor c"}, {"type": "code", "text": "a && (b xor c)"}, {"type": "li", "text": "a xor b in c is equivalent to (a xor b) in c"}, {"type": "code", "text": "a xor b in c"}, {"type": "code", "text": "(a xor b) in c"}, {"type": "p", "text": "See the Grammar reference for the complete operators precedence hierarchy."}, {"type": "a", "text": "Grammar reference"}, {"type": "p", "text": "Note that infix functions always require both the receiver and the parameter to be specified. When you're\ncalling a method on the current receiver using the infix notation, you need to use this explicitly; unlike regular method calls, \nit cannot be omitted. This is required to ensure unambiguous parsing."}, {"type": "code", "text": "this"}, {"type": "div", "text": "\nclass MyStringCollection {\n    infix fun add(s: String) { /*...*/ }\n    \n    fun build() {\n        this add \"abc\"   // Correct\n        add(\"abc\")       // Correct\n        //add \"abc\"        // Incorrect: the receiver must be specified\n    }\n}\n\n"}, {"type": "pre", "text": "class MyStringCollection {\n    infix fun add(s: String) { /*...*/ }\n    \n    fun build() {\n        this add \"abc\"   // Correct\n        add(\"abc\")       // Correct\n        //add \"abc\"        // Incorrect: the receiver must be specified\n    }\n}\n"}, {"type": "code", "text": "class MyStringCollection {\n    infix fun add(s: String) { /*...*/ }\n    \n    fun build() {\n        this add \"abc\"   // Correct\n        add(\"abc\")       // Correct\n        //add \"abc\"        // Incorrect: the receiver must be specified\n    }\n}\n"}, {"type": "h2", "text": "Function scope"}, {"type": "p", "text": "In Kotlin functions can be declared at top level in a file, meaning you do not need to create a class to hold a function, which you are required to do in languages such as Java, C# or Scala. In addition\nto top level functions, Kotlin functions can also be declared local, as member functions and extension functions."}, {"type": "h3", "text": "Local functions"}, {"type": "p", "text": "Kotlin supports local functions, i.e. a function inside another function:"}, {"type": "div", "text": "\nfun dfs(graph: Graph) {\n    fun dfs(current: Vertex, visited: MutableSet<Vertex>) {\n        if (!visited.add(current)) return\n        for (v in current.neighbors)\n            dfs(v, visited)\n    }\n\n    dfs(graph.vertices[0], HashSet())\n}\n\n"}, {"type": "pre", "text": "fun dfs(graph: Graph) {\n    fun dfs(current: Vertex, visited: MutableSet<Vertex>) {\n        if (!visited.add(current)) return\n        for (v in current.neighbors)\n            dfs(v, visited)\n    }\n\n    dfs(graph.vertices[0], HashSet())\n}\n"}, {"type": "code", "text": "fun dfs(graph: Graph) {\n    fun dfs(current: Vertex, visited: MutableSet<Vertex>) {\n        if (!visited.add(current)) return\n        for (v in current.neighbors)\n            dfs(v, visited)\n    }\n\n    dfs(graph.vertices[0], HashSet())\n}\n"}, {"type": "p", "text": "Local function can access local variables of outer functions (i.e. the closure), so in the case above, the visited can be a local variable:"}, {"type": "em", "text": "visited"}, {"type": "div", "text": "\nfun dfs(graph: Graph) {\n    val visited = HashSet<Vertex>()\n    fun dfs(current: Vertex) {\n        if (!visited.add(current)) return\n        for (v in current.neighbors)\n            dfs(v)\n    }\n\n    dfs(graph.vertices[0])\n}\n\n"}, {"type": "pre", "text": "fun dfs(graph: Graph) {\n    val visited = HashSet<Vertex>()\n    fun dfs(current: Vertex) {\n        if (!visited.add(current)) return\n        for (v in current.neighbors)\n            dfs(v)\n    }\n\n    dfs(graph.vertices[0])\n}\n"}, {"type": "code", "text": "fun dfs(graph: Graph) {\n    val visited = HashSet<Vertex>()\n    fun dfs(current: Vertex) {\n        if (!visited.add(current)) return\n        for (v in current.neighbors)\n            dfs(v)\n    }\n\n    dfs(graph.vertices[0])\n}\n"}, {"type": "h3", "text": "Member functions"}, {"type": "p", "text": "A member function is a function that is defined inside a class or object:"}, {"type": "div", "text": "\nclass Sample {\n    fun foo() { print(\"Foo\") }\n}\n\n"}, {"type": "pre", "text": "class Sample {\n    fun foo() { print(\"Foo\") }\n}\n"}, {"type": "code", "text": "class Sample {\n    fun foo() { print(\"Foo\") }\n}\n"}, {"type": "p", "text": "Member functions are called with dot notation:"}, {"type": "div", "text": "\nSample().foo() // creates instance of class Sample and calls foo\n\n"}, {"type": "pre", "text": "Sample().foo() // creates instance of class Sample and calls foo\n"}, {"type": "code", "text": "Sample().foo() // creates instance of class Sample and calls foo\n"}, {"type": "p", "text": "For more information on classes and overriding members see Classes and Inheritance."}, {"type": "a", "text": "Classes"}, {"type": "a", "text": "Inheritance"}, {"type": "h2", "text": "Generic functions"}, {"type": "p", "text": "Functions can have generic parameters which are specified using angle brackets before the function name:"}, {"type": "div", "text": "\nfun <T> singletonList(item: T): List<T> { /*...*/ }\n\n"}, {"type": "pre", "text": "fun <T> singletonList(item: T): List<T> { /*...*/ }\n"}, {"type": "code", "text": "fun <T> singletonList(item: T): List<T> { /*...*/ }\n"}, {"type": "p", "text": "For more information on generic functions see Generics."}, {"type": "a", "text": "Generics"}, {"type": "h2", "text": "Inline functions"}, {"type": "p", "text": "Inline functions are explained here."}, {"type": "a", "text": "here"}, {"type": "h2", "text": "Extension functions"}, {"type": "p", "text": "Extension functions are explained in their own section."}, {"type": "a", "text": "their own section"}, {"type": "h2", "text": "Higher-order functions and lambdas"}, {"type": "p", "text": "Higher-Order functions and Lambdas are explained in their own section."}, {"type": "a", "text": "their own section"}, {"type": "h2", "text": "Tail recursive functions"}, {"type": "p", "text": "Kotlin supports a style of functional programming known as tail recursion.\nThis allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow.\nWhen a function is marked with the tailrec modifier and meets the required form, the compiler optimises out the recursion, leaving behind a fast and efficient loop based version instead:"}, {"type": "a", "text": "tail recursion"}, {"type": "code", "text": "tailrec"}, {"type": "div", "text": "\nval eps = 1E-10 // \"good enough\", could be 10^-15\n\ntailrec fun findFixPoint(x: Double = 1.0): Double\n        = if (Math.abs(x - Math.cos(x)) < eps) x else findFixPoint(Math.cos(x))\n\n"}, {"type": "pre", "text": "val eps = 1E-10 // \"good enough\", could be 10^-15\n\ntailrec fun findFixPoint(x: Double = 1.0): Double\n        = if (Math.abs(x - Math.cos(x)) < eps) x else findFixPoint(Math.cos(x))\n"}, {"type": "code", "text": "val eps = 1E-10 // \"good enough\", could be 10^-15\n\ntailrec fun findFixPoint(x: Double = 1.0): Double\n        = if (Math.abs(x - Math.cos(x)) < eps) x else findFixPoint(Math.cos(x))\n"}, {"type": "p", "text": "This code calculates the fixpoint of cosine, which is a mathematical constant. It simply calls Math.cos repeatedly starting at 1.0 until the result doesn't change any more, yielding a result of 0.7390851332151611 for the specified eps precision. The resulting code is equivalent to this more traditional style:"}, {"type": "code", "text": "eps"}, {"type": "div", "text": "\nval eps = 1E-10 // \"good enough\", could be 10^-15\n\nprivate fun findFixPoint(): Double {\n    var x = 1.0\n    while (true) {\n        val y = Math.cos(x)\n        if (Math.abs(x - y) < eps) return x\n        x = Math.cos(x)\n    }\n}\n\n"}, {"type": "pre", "text": "val eps = 1E-10 // \"good enough\", could be 10^-15\n\nprivate fun findFixPoint(): Double {\n    var x = 1.0\n    while (true) {\n        val y = Math.cos(x)\n        if (Math.abs(x - y) < eps) return x\n        x = Math.cos(x)\n    }\n}\n"}, {"type": "code", "text": "val eps = 1E-10 // \"good enough\", could be 10^-15\n\nprivate fun findFixPoint(): Double {\n    var x = 1.0\n    while (true) {\n        val y = Math.cos(x)\n        if (Math.abs(x - y) < eps) return x\n        x = Math.cos(x)\n    }\n}\n"}, {"type": "p", "text": "To be eligible for the tailrec modifier, a function must call itself as the last operation it performs. You cannot use tail recursion when there is more code after the recursive call, and you cannot use it within try/catch/finally blocks. Currently, tail recursion is supported by Kotlin for JVM and Kotlin/Native."}, {"type": "code", "text": "tailrec"}]