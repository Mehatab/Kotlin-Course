[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Type-Safe Builders"}, {"type": "p", "text": "By using well-named functions as builders in combination with function literals with receiver it is possible to create type-safe, statically-typed builders in Kotlin."}, {"type": "a", "text": "function literals with receiver"}, {"type": "p", "text": "Type-safe builders allow creating Kotlin-based domain-specific languages (DSLs) suitable for building complex hierarchical data structures in a semi-declarative way. Some of the example use cases for the builders are:"}, {"type": "ul", "text": "\nGenerating markup with Kotlin code, such as HTML or XML;\nProgrammatically laying out UI components: Anko\nConfiguring routes for a web server: Ktor.\n"}, {"type": "li", "text": "Generating markup with Kotlin code, such as HTML or XML;"}, {"type": "a", "text": "HTML"}, {"type": "li", "text": "Programmatically laying out UI components: Anko"}, {"type": "a", "text": "Anko"}, {"type": "li", "text": "Configuring routes for a web server: Ktor."}, {"type": "a", "text": "Ktor"}, {"type": "h2", "text": "A type-safe builder example"}, {"type": "p", "text": "Consider the following code:"}, {"type": "div", "text": "\nimport com.example.html.* // see declarations below\n\nfun result() =\n    html {\n        head {\n            title {+\"XML encoding with Kotlin\"}\n        }\n        body {\n            h1 {+\"XML encoding with Kotlin\"}\n            p  {+\"this format can be used as an alternative markup to XML\"}\n\n            // an element with attributes and text content\n            a(href = \"http://kotlinlang.org\") {+\"Kotlin\"}\n\n            // mixed content\n            p {\n                +\"This is some\"\n                b {+\"mixed\"}\n                +\"text. For more see the\"\n                a(href = \"http://kotlinlang.org\") {+\"Kotlin\"}\n                +\"project\"\n            }\n            p {+\"some text\"}\n\n            // content generated by\n            p {\n                for (arg in args)\n                    +arg\n            }\n        }\n    }\n\n"}, {"type": "pre", "text": "import com.example.html.* // see declarations below\n\nfun result() =\n    html {\n        head {\n            title {+\"XML encoding with Kotlin\"}\n        }\n        body {\n            h1 {+\"XML encoding with Kotlin\"}\n            p  {+\"this format can be used as an alternative markup to XML\"}\n\n            // an element with attributes and text content\n            a(href = \"http://kotlinlang.org\") {+\"Kotlin\"}\n\n            // mixed content\n            p {\n                +\"This is some\"\n                b {+\"mixed\"}\n                +\"text. For more see the\"\n                a(href = \"http://kotlinlang.org\") {+\"Kotlin\"}\n                +\"project\"\n            }\n            p {+\"some text\"}\n\n            // content generated by\n            p {\n                for (arg in args)\n                    +arg\n            }\n        }\n    }\n"}, {"type": "code", "text": "import com.example.html.* // see declarations below\n\nfun result() =\n    html {\n        head {\n            title {+\"XML encoding with Kotlin\"}\n        }\n        body {\n            h1 {+\"XML encoding with Kotlin\"}\n            p  {+\"this format can be used as an alternative markup to XML\"}\n\n            // an element with attributes and text content\n            a(href = \"http://kotlinlang.org\") {+\"Kotlin\"}\n\n            // mixed content\n            p {\n                +\"This is some\"\n                b {+\"mixed\"}\n                +\"text. For more see the\"\n                a(href = \"http://kotlinlang.org\") {+\"Kotlin\"}\n                +\"project\"\n            }\n            p {+\"some text\"}\n\n            // content generated by\n            p {\n                for (arg in args)\n                    +arg\n            }\n        }\n    }\n"}, {"type": "p", "text": "This is completely legitimate Kotlin code.\nYou can play with this code online (modify it and run in the browser) here."}, {"type": "a", "text": "here"}, {"type": "h2", "text": "How it works"}, {"type": "p", "text": "Let's walk through the mechanisms of implementing type-safe builders in Kotlin.\nFirst of all, we need to define the model we want to build, in this case we need to model HTML tags.\nIt is easily done with a bunch of classes.\nFor example, HTML is a class that describes the <html> tag, i.e. it defines children like <head> and <body>.\n(See its declaration below.)"}, {"type": "code", "text": "HTML"}, {"type": "code", "text": "<html>"}, {"type": "code", "text": "<head>"}, {"type": "code", "text": "<body>"}, {"type": "a", "text": "below"}, {"type": "p", "text": "Now, let's recall why we can say something like this in the code:"}, {"type": "div", "text": "\nhtml {\n // ...\n}\n\n"}, {"type": "pre", "text": "html {\n // ...\n}\n"}, {"type": "code", "text": "html {\n // ...\n}\n"}, {"type": "p", "text": "html is actually a function call that takes a lambda expression as an argument.\nThis function is defined as follows:"}, {"type": "code", "text": "html"}, {"type": "a", "text": "lambda expression"}, {"type": "div", "text": "\nfun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}\n\n"}, {"type": "pre", "text": "fun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}\n"}, {"type": "code", "text": "fun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}\n"}, {"type": "p", "text": "This function takes one parameter named init, which is itself a function.\nThe type of the function is HTML.() -> Unit, which is a function type with receiver.\nThis means that we need to pass an instance of type HTML (a receiver) to the function,\nand we can call members of that instance inside the function.\nThe receiver can be accessed through the this keyword:"}, {"type": "code", "text": "init"}, {"type": "code", "text": "HTML.() -> Unit"}, {"type": "em", "text": "function type with receiver"}, {"type": "code", "text": "HTML"}, {"type": "em", "text": "receiver"}, {"type": "em", "text": "this"}, {"type": "div", "text": "\nhtml {\n    this.head { ... }\n    this.body { ... }\n}\n\n"}, {"type": "pre", "text": "html {\n    this.head { ... }\n    this.body { ... }\n}\n"}, {"type": "code", "text": "html {\n    this.head { ... }\n    this.body { ... }\n}\n"}, {"type": "p", "text": "(head and body are member functions of HTML.)"}, {"type": "code", "text": "head"}, {"type": "code", "text": "body"}, {"type": "code", "text": "HTML"}, {"type": "p", "text": "Now, this can be omitted, as usual, and we get something that looks very much like a builder already:"}, {"type": "em", "text": "this"}, {"type": "div", "text": "\nhtml {\n    head { ... }\n    body { ... }\n}\n\n"}, {"type": "pre", "text": "html {\n    head { ... }\n    body { ... }\n}\n"}, {"type": "code", "text": "html {\n    head { ... }\n    body { ... }\n}\n"}, {"type": "p", "text": "So, what does this call do? Let's look at the body of html function as defined above.\nIt creates a new instance of HTML, then it initializes it by calling the function that is passed as an argument\n(in our example this boils down to calling head and body on the HTML instance), and then it returns this instance. \nThis is exactly what a builder should do."}, {"type": "code", "text": "html"}, {"type": "code", "text": "HTML"}, {"type": "code", "text": "head"}, {"type": "code", "text": "body"}, {"type": "code", "text": "HTML"}, {"type": "p", "text": "The head and body functions in the HTML class are defined similarly to html. \nThe only difference is that they add the built instances to the children collection of the enclosing HTML instance:"}, {"type": "code", "text": "head"}, {"type": "code", "text": "body"}, {"type": "code", "text": "HTML"}, {"type": "code", "text": "html"}, {"type": "code", "text": "children"}, {"type": "code", "text": "HTML"}, {"type": "div", "text": "\nfun head(init: Head.() -> Unit) : Head {\n    val head = Head()\n    head.init()\n    children.add(head)\n    return head\n}\n\nfun body(init: Body.() -> Unit) : Body {\n    val body = Body()\n    body.init()\n    children.add(body)\n    return body\n}\n\n"}, {"type": "pre", "text": "fun head(init: Head.() -> Unit) : Head {\n    val head = Head()\n    head.init()\n    children.add(head)\n    return head\n}\n\nfun body(init: Body.() -> Unit) : Body {\n    val body = Body()\n    body.init()\n    children.add(body)\n    return body\n}\n"}, {"type": "code", "text": "fun head(init: Head.() -> Unit) : Head {\n    val head = Head()\n    head.init()\n    children.add(head)\n    return head\n}\n\nfun body(init: Body.() -> Unit) : Body {\n    val body = Body()\n    body.init()\n    children.add(body)\n    return body\n}\n"}, {"type": "p", "text": "Actually these two functions do just the same thing, so we can have a generic version, initTag:"}, {"type": "code", "text": "initTag"}, {"type": "div", "text": "\nprotected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {\n    tag.init()\n    children.add(tag)\n    return tag\n}\n\n"}, {"type": "pre", "text": "protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {\n    tag.init()\n    children.add(tag)\n    return tag\n}\n"}, {"type": "code", "text": "protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {\n    tag.init()\n    children.add(tag)\n    return tag\n}\n"}, {"type": "p", "text": "So, now our functions are very simple:"}, {"type": "div", "text": "\nfun head(init: Head.() -> Unit) = initTag(Head(), init)\n\nfun body(init: Body.() -> Unit) = initTag(Body(), init)\n\n"}, {"type": "pre", "text": "fun head(init: Head.() -> Unit) = initTag(Head(), init)\n\nfun body(init: Body.() -> Unit) = initTag(Body(), init)\n"}, {"type": "code", "text": "fun head(init: Head.() -> Unit) = initTag(Head(), init)\n\nfun body(init: Body.() -> Unit) = initTag(Body(), init)\n"}, {"type": "p", "text": "And we can use them to build <head> and <body> tags."}, {"type": "code", "text": "<head>"}, {"type": "code", "text": "<body>"}, {"type": "p", "text": "One other thing to be discussed here is how we add text to tag bodies. In the example above we say something like:"}, {"type": "div", "text": "\nhtml {\n    head {\n        title {+\"XML encoding with Kotlin\"}\n    }\n    // ...\n}\n\n"}, {"type": "pre", "text": "html {\n    head {\n        title {+\"XML encoding with Kotlin\"}\n    }\n    // ...\n}\n"}, {"type": "code", "text": "html {\n    head {\n        title {+\"XML encoding with Kotlin\"}\n    }\n    // ...\n}\n"}, {"type": "p", "text": "So basically, we just put a string inside a tag body, but there is this little + in front of it,\nso it is a function call that invokes a prefix unaryPlus() operation.\nThat operation is actually defined by an extension function unaryPlus() that is a member of the TagWithText abstract class (a parent of Title):"}, {"type": "code", "text": "+"}, {"type": "code", "text": "unaryPlus()"}, {"type": "code", "text": "unaryPlus()"}, {"type": "code", "text": "TagWithText"}, {"type": "code", "text": "Title"}, {"type": "div", "text": "\noperator fun String.unaryPlus() {\n    children.add(TextElement(this))\n}\n\n"}, {"type": "pre", "text": "operator fun String.unaryPlus() {\n    children.add(TextElement(this))\n}\n"}, {"type": "code", "text": "operator fun String.unaryPlus() {\n    children.add(TextElement(this))\n}\n"}, {"type": "p", "text": "So, what the prefix + does here is wrapping a string into an instance of TextElement and adding it to the children collection,\nso that it becomes a proper part of the tag tree."}, {"type": "code", "text": "+"}, {"type": "code", "text": "TextElement"}, {"type": "code", "text": "children"}, {"type": "p", "text": "All this is defined in a package com.example.html that is imported at the top of the builder example above.\nIn the last section you can read through the full definition of this package."}, {"type": "code", "text": "com.example.html"}, {"type": "h2", "text": "Scope control: @DslMarker (since 1.1)"}, {"type": "p", "text": "When using DSLs, one might have come across the problem that too many functions can be called in the context. \nWe can call methods of every available implicit receiver inside a lambda and therefore get an inconsistent result, like the tag head inside another head:"}, {"type": "code", "text": "head"}, {"type": "code", "text": "head"}, {"type": "div", "text": "\nhtml {\n    head {\n        head {} // should be forbidden\n    }\n    // ...\n}\n\n"}, {"type": "pre", "text": "html {\n    head {\n        head {} // should be forbidden\n    }\n    // ...\n}\n"}, {"type": "code", "text": "html {\n    head {\n        head {} // should be forbidden\n    }\n    // ...\n}\n"}, {"type": "p", "text": "In this example only members of the nearest implicit receiver this@head must be available; head() is a member of the outer receiver this@html, so it must be illegal to call it."}, {"type": "code", "text": "this@head"}, {"type": "code", "text": "head()"}, {"type": "code", "text": "this@html"}, {"type": "p", "text": "To address this problem, in Kotlin 1.1 a special mechanism to control receiver scope was introduced."}, {"type": "p", "text": "To make the compiler start controlling scopes we only have to annotate the types of all receivers used in the DSL with the same marker annotation.\nFor instance, for HTML Builders we declare an annotation @HTMLTagMarker:"}, {"type": "code", "text": "@HTMLTagMarker"}, {"type": "div", "text": "\n@DslMarker\nannotation class HtmlTagMarker\n\n"}, {"type": "pre", "text": "@DslMarker\nannotation class HtmlTagMarker\n"}, {"type": "code", "text": "@DslMarker\nannotation class HtmlTagMarker\n"}, {"type": "p", "text": "An annotation class is called a DSL marker if it is annotated with the @DslMarker annotation."}, {"type": "code", "text": "@DslMarker"}, {"type": "p", "text": "In our DSL all the tag classes extend the same superclass Tag.\nIt's enough to annotate only the superclass with @HtmlTagMarker and after that the Kotlin compiler will treat all the inherited classes as annotated:"}, {"type": "code", "text": "Tag"}, {"type": "code", "text": "@HtmlTagMarker"}, {"type": "div", "text": "\n@HtmlTagMarker\nabstract class Tag(val name: String) { ... }\n\n"}, {"type": "pre", "text": "@HtmlTagMarker\nabstract class Tag(val name: String) { ... }\n"}, {"type": "code", "text": "@HtmlTagMarker\nabstract class Tag(val name: String) { ... }\n"}, {"type": "p", "text": "We don't have to annotate the HTML or Head classes with @HtmlTagMarker because their superclass is already annotated:"}, {"type": "code", "text": "HTML"}, {"type": "code", "text": "Head"}, {"type": "code", "text": "@HtmlTagMarker"}, {"type": "div", "text": "\nclass HTML() : Tag(\"html\") { ... }\nclass Head() : Tag(\"head\") { ... }\n\n"}, {"type": "pre", "text": "class HTML() : Tag(\"html\") { ... }\nclass Head() : Tag(\"head\") { ... }\n"}, {"type": "code", "text": "class HTML() : Tag(\"html\") { ... }\nclass Head() : Tag(\"head\") { ... }\n"}, {"type": "p", "text": "After we've added this annotation, the Kotlin compiler knows which implicit receivers are part of the same DSL and allows to call members of the nearest receivers only:"}, {"type": "div", "text": "\nhtml {\n    head {\n        head { } // error: a member of outer receiver\n    }\n    // ...\n}\n\n"}, {"type": "pre", "text": "html {\n    head {\n        head { } // error: a member of outer receiver\n    }\n    // ...\n}\n"}, {"type": "code", "text": "html {\n    head {\n        head { } // error: a member of outer receiver\n    }\n    // ...\n}\n"}, {"type": "p", "text": "Note that it's still possible to call the members of the outer receiver, but to do that you have to specify this receiver explicitly:"}, {"type": "div", "text": "\nhtml {\n    head {\n        this@html.head { } // possible\n    }\n    // ...\n}\n\n"}, {"type": "pre", "text": "html {\n    head {\n        this@html.head { } // possible\n    }\n    // ...\n}\n"}, {"type": "code", "text": "html {\n    head {\n        this@html.head { } // possible\n    }\n    // ...\n}\n"}, {"type": "h2", "text": "Full definition of the com.example.html package"}, {"type": "code", "text": "com.example.html"}, {"type": "p", "text": "This is how the package com.example.html is defined (only the elements used in the example above).\nIt builds an HTML tree. It makes heavy use of extension functions and\nlambdas with receiver."}, {"type": "code", "text": "com.example.html"}, {"type": "a", "text": "extension functions"}, {"type": "a", "text": "lambdas with receiver"}, {"type": "p", "text": "Note that the @DslMarker annotation is available only since Kotlin 1.1."}, {"type": "code", "text": "@DslMarker"}, {"type": "p", "text": ""}, {"type": "a", "text": ""}, {"type": "div", "text": "\npackage com.example.html\n\ninterface Element {\n    fun render(builder: StringBuilder, indent: String)\n}\n\nclass TextElement(val text: String) : Element {\n    override fun render(builder: StringBuilder, indent: String) {\n        builder.append(\"$indent$text\\n\")\n    }\n}\n\n@DslMarker\nannotation class HtmlTagMarker\n\n@HtmlTagMarker\nabstract class Tag(val name: String) : Element {\n    val children = arrayListOf<Element>()\n    val attributes = hashMapOf<String, String>()\n\n    protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {\n        tag.init()\n        children.add(tag)\n        return tag\n    }\n\n    override fun render(builder: StringBuilder, indent: String) {\n        builder.append(\"$indent<$name${renderAttributes()}>\\n\")\n        for (c in children) {\n            c.render(builder, indent + \"  \")\n        }\n        builder.append(\"$indent</$name>\\n\")\n    }\n\n    private fun renderAttributes(): String {\n        val builder = StringBuilder()\n        for ((attr, value) in attributes) {\n            builder.append(\" $attr=\\\"$value\\\"\")\n        }\n        return builder.toString()\n    }\n\n    override fun toString(): String {\n        val builder = StringBuilder()\n        render(builder, \"\")\n        return builder.toString()\n    }\n}\n\nabstract class TagWithText(name: String) : Tag(name) {\n    operator fun String.unaryPlus() {\n        children.add(TextElement(this))\n    }\n}\n\nclass HTML : TagWithText(\"html\") {\n    fun head(init: Head.() -> Unit) = initTag(Head(), init)\n\n    fun body(init: Body.() -> Unit) = initTag(Body(), init)\n}\n\nclass Head : TagWithText(\"head\") {\n    fun title(init: Title.() -> Unit) = initTag(Title(), init)\n}\n\nclass Title : TagWithText(\"title\")\n\nabstract class BodyTag(name: String) : TagWithText(name) {\n    fun b(init: B.() -> Unit) = initTag(B(), init)\n    fun p(init: P.() -> Unit) = initTag(P(), init)\n    fun h1(init: H1.() -> Unit) = initTag(H1(), init)\n    fun a(href: String, init: A.() -> Unit) {\n        val a = initTag(A(), init)\n        a.href = href\n    }\n}\n\nclass Body : BodyTag(\"body\")\nclass B : BodyTag(\"b\")\nclass P : BodyTag(\"p\")\nclass H1 : BodyTag(\"h1\")\n\nclass A : BodyTag(\"a\") {\n    var href: String\n        get() = attributes[\"href\"]!!\n        set(value) {\n            attributes[\"href\"] = value\n        }\n}\n\nfun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}\n\n"}, {"type": "pre", "text": "package com.example.html\n\ninterface Element {\n    fun render(builder: StringBuilder, indent: String)\n}\n\nclass TextElement(val text: String) : Element {\n    override fun render(builder: StringBuilder, indent: String) {\n        builder.append(\"$indent$text\\n\")\n    }\n}\n\n@DslMarker\nannotation class HtmlTagMarker\n\n@HtmlTagMarker\nabstract class Tag(val name: String) : Element {\n    val children = arrayListOf<Element>()\n    val attributes = hashMapOf<String, String>()\n\n    protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {\n        tag.init()\n        children.add(tag)\n        return tag\n    }\n\n    override fun render(builder: StringBuilder, indent: String) {\n        builder.append(\"$indent<$name${renderAttributes()}>\\n\")\n        for (c in children) {\n            c.render(builder, indent + \"  \")\n        }\n        builder.append(\"$indent</$name>\\n\")\n    }\n\n    private fun renderAttributes(): String {\n        val builder = StringBuilder()\n        for ((attr, value) in attributes) {\n            builder.append(\" $attr=\\\"$value\\\"\")\n        }\n        return builder.toString()\n    }\n\n    override fun toString(): String {\n        val builder = StringBuilder()\n        render(builder, \"\")\n        return builder.toString()\n    }\n}\n\nabstract class TagWithText(name: String) : Tag(name) {\n    operator fun String.unaryPlus() {\n        children.add(TextElement(this))\n    }\n}\n\nclass HTML : TagWithText(\"html\") {\n    fun head(init: Head.() -> Unit) = initTag(Head(), init)\n\n    fun body(init: Body.() -> Unit) = initTag(Body(), init)\n}\n\nclass Head : TagWithText(\"head\") {\n    fun title(init: Title.() -> Unit) = initTag(Title(), init)\n}\n\nclass Title : TagWithText(\"title\")\n\nabstract class BodyTag(name: String) : TagWithText(name) {\n    fun b(init: B.() -> Unit) = initTag(B(), init)\n    fun p(init: P.() -> Unit) = initTag(P(), init)\n    fun h1(init: H1.() -> Unit) = initTag(H1(), init)\n    fun a(href: String, init: A.() -> Unit) {\n        val a = initTag(A(), init)\n        a.href = href\n    }\n}\n\nclass Body : BodyTag(\"body\")\nclass B : BodyTag(\"b\")\nclass P : BodyTag(\"p\")\nclass H1 : BodyTag(\"h1\")\n\nclass A : BodyTag(\"a\") {\n    var href: String\n        get() = attributes[\"href\"]!!\n        set(value) {\n            attributes[\"href\"] = value\n        }\n}\n\nfun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}\n"}, {"type": "code", "text": "package com.example.html\n\ninterface Element {\n    fun render(builder: StringBuilder, indent: String)\n}\n\nclass TextElement(val text: String) : Element {\n    override fun render(builder: StringBuilder, indent: String) {\n        builder.append(\"$indent$text\\n\")\n    }\n}\n\n@DslMarker\nannotation class HtmlTagMarker\n\n@HtmlTagMarker\nabstract class Tag(val name: String) : Element {\n    val children = arrayListOf<Element>()\n    val attributes = hashMapOf<String, String>()\n\n    protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {\n        tag.init()\n        children.add(tag)\n        return tag\n    }\n\n    override fun render(builder: StringBuilder, indent: String) {\n        builder.append(\"$indent<$name${renderAttributes()}>\\n\")\n        for (c in children) {\n            c.render(builder, indent + \"  \")\n        }\n        builder.append(\"$indent</$name>\\n\")\n    }\n\n    private fun renderAttributes(): String {\n        val builder = StringBuilder()\n        for ((attr, value) in attributes) {\n            builder.append(\" $attr=\\\"$value\\\"\")\n        }\n        return builder.toString()\n    }\n\n    override fun toString(): String {\n        val builder = StringBuilder()\n        render(builder, \"\")\n        return builder.toString()\n    }\n}\n\nabstract class TagWithText(name: String) : Tag(name) {\n    operator fun String.unaryPlus() {\n        children.add(TextElement(this))\n    }\n}\n\nclass HTML : TagWithText(\"html\") {\n    fun head(init: Head.() -> Unit) = initTag(Head(), init)\n\n    fun body(init: Body.() -> Unit) = initTag(Body(), init)\n}\n\nclass Head : TagWithText(\"head\") {\n    fun title(init: Title.() -> Unit) = initTag(Title(), init)\n}\n\nclass Title : TagWithText(\"title\")\n\nabstract class BodyTag(name: String) : TagWithText(name) {\n    fun b(init: B.() -> Unit) = initTag(B(), init)\n    fun p(init: P.() -> Unit) = initTag(P(), init)\n    fun h1(init: H1.() -> Unit) = initTag(H1(), init)\n    fun a(href: String, init: A.() -> Unit) {\n        val a = initTag(A(), init)\n        a.href = href\n    }\n}\n\nclass Body : BodyTag(\"body\")\nclass B : BodyTag(\"b\")\nclass P : BodyTag(\"p\")\nclass H1 : BodyTag(\"h1\")\n\nclass A : BodyTag(\"a\") {\n    var href: String\n        get() = attributes[\"href\"]!!\n        set(value) {\n            attributes[\"href\"] = value\n        }\n}\n\nfun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}\n"}]