[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Operator overloading"}, {"type": "p", "text": "Kotlin allows us to provide implementations for a predefined set of operators on our types. These operators have fixed symbolic representation\n(like + or *) and fixed precedence. To implement an operator, we provide a member function\nor an extension function with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones.\nFunctions that overload operators need to be marked with the operator modifier."}, {"type": "code", "text": "+"}, {"type": "code", "text": "*"}, {"type": "a", "text": "precedence"}, {"type": "a", "text": "member function"}, {"type": "a", "text": "extension function"}, {"type": "code", "text": "operator"}, {"type": "p", "text": "Further we describe the conventions that regulate operator overloading for different operators."}, {"type": "h2", "text": "Unary operations"}, {"type": "h3", "text": "Unary prefix operators"}, {"type": "table", "text": "\n\n\nExpression\nTranslated to\n\n\n\n\n+a\na.unaryPlus()\n\n\n-a\na.unaryMinus()\n\n\n!a\na.not()\n\n\n"}, {"type": "thead", "text": "\n\nExpression\nTranslated to\n\n"}, {"type": "tr", "text": "\nExpression\nTranslated to\n"}, {"type": "th", "text": "Expression"}, {"type": "th", "text": "Translated to"}, {"type": "tbody", "text": "\n\n+a\na.unaryPlus()\n\n\n-a\na.unaryMinus()\n\n\n!a\na.not()\n\n"}, {"type": "tr", "text": "\n+a\na.unaryPlus()\n"}, {"type": "td", "text": "+a"}, {"type": "code", "text": "+a"}, {"type": "td", "text": "a.unaryPlus()"}, {"type": "code", "text": "a.unaryPlus()"}, {"type": "tr", "text": "\n-a\na.unaryMinus()\n"}, {"type": "td", "text": "-a"}, {"type": "code", "text": "-a"}, {"type": "td", "text": "a.unaryMinus()"}, {"type": "code", "text": "a.unaryMinus()"}, {"type": "tr", "text": "\n!a\na.not()\n"}, {"type": "td", "text": "!a"}, {"type": "code", "text": "!a"}, {"type": "td", "text": "a.not()"}, {"type": "code", "text": "a.not()"}, {"type": "p", "text": "This table says that when the compiler processes, for example, an expression +a, it performs the following steps:"}, {"type": "code", "text": "+a"}, {"type": "ul", "text": "\nDetermines the type of a, let it be T;\nLooks up a function unaryPlus() with the operator modifier and no parameters for the receiver T, i.e. a member function or an extension function;\nIf the function is absent or ambiguous, it is a compilation error;\nIf the function is present and its return type is R, the expression +a has type R;\n"}, {"type": "li", "text": "Determines the type of a, let it be T;"}, {"type": "code", "text": "a"}, {"type": "code", "text": "T"}, {"type": "li", "text": "Looks up a function unaryPlus() with the operator modifier and no parameters for the receiver T, i.e. a member function or an extension function;"}, {"type": "code", "text": "unaryPlus()"}, {"type": "code", "text": "operator"}, {"type": "code", "text": "T"}, {"type": "li", "text": "If the function is absent or ambiguous, it is a compilation error;"}, {"type": "li", "text": "If the function is present and its return type is R, the expression +a has type R;"}, {"type": "code", "text": "R"}, {"type": "code", "text": "+a"}, {"type": "code", "text": "R"}, {"type": "p", "text": "Note that these operations, as well as all the others, are optimized for Basic types and do not introduce overhead of function calls for them."}, {"type": "em", "text": "Note"}, {"type": "a", "text": "Basic types"}, {"type": "p", "text": "As an example, here's how you can overload the unary minus operator:"}, {"type": "div", "text": "\ndata class Point(val x: Int, val y: Int)\n\noperator fun Point.unaryMinus() = Point(-x, -y)\n\nval point = Point(10, 20)\n\nfun main() {\n   println(-point)  // prints \"Point(x=-10, y=-20)\"\n}\n\n\n"}, {"type": "pre", "text": "data class Point(val x: Int, val y: Int)\n\noperator fun Point.unaryMinus() = Point(-x, -y)\n\nval point = Point(10, 20)\n\nfun main() {\n   println(-point)  // prints \"Point(x=-10, y=-20)\"\n}\n\n"}, {"type": "code", "text": "data class Point(val x: Int, val y: Int)\n\noperator fun Point.unaryMinus() = Point(-x, -y)\n\nval point = Point(10, 20)\n\nfun main() {\n   println(-point)  // prints \"Point(x=-10, y=-20)\"\n}\n\n"}, {"type": "h3", "text": "Increments and decrements"}, {"type": "table", "text": "\n\n\nExpression\nTranslated to\n\n\n\n\na++\na.inc() + see below\n\n\na--\na.dec() + see below\n\n\n"}, {"type": "thead", "text": "\n\nExpression\nTranslated to\n\n"}, {"type": "tr", "text": "\nExpression\nTranslated to\n"}, {"type": "th", "text": "Expression"}, {"type": "th", "text": "Translated to"}, {"type": "tbody", "text": "\n\na++\na.inc() + see below\n\n\na--\na.dec() + see below\n\n"}, {"type": "tr", "text": "\na++\na.inc() + see below\n"}, {"type": "td", "text": "a++"}, {"type": "code", "text": "a++"}, {"type": "td", "text": "a.inc() + see below"}, {"type": "code", "text": "a.inc()"}, {"type": "tr", "text": "\na--\na.dec() + see below\n"}, {"type": "td", "text": "a--"}, {"type": "code", "text": "a--"}, {"type": "td", "text": "a.dec() + see below"}, {"type": "code", "text": "a.dec()"}, {"type": "p", "text": "The inc() and dec() functions must return a value, which will be assigned to the variable on which the\n++ or -- operation was used. They shouldn't mutate the object on which the inc or dec was invoked."}, {"type": "code", "text": "inc()"}, {"type": "code", "text": "dec()"}, {"type": "code", "text": "++"}, {"type": "code", "text": "--"}, {"type": "code", "text": "inc"}, {"type": "code", "text": "dec"}, {"type": "p", "text": "The compiler performs the following steps for resolution of an operator in the postfix form, e.g. a++:"}, {"type": "em", "text": "postfix"}, {"type": "code", "text": "a++"}, {"type": "ul", "text": "\nDetermines the type of a, let it be T;\nLooks up a function inc() with the operator modifier and no parameters, applicable to the receiver of type T;\nChecks that the return type of the function is a subtype of T.\n"}, {"type": "li", "text": "Determines the type of a, let it be T;"}, {"type": "code", "text": "a"}, {"type": "code", "text": "T"}, {"type": "li", "text": "Looks up a function inc() with the operator modifier and no parameters, applicable to the receiver of type T;"}, {"type": "code", "text": "inc()"}, {"type": "code", "text": "operator"}, {"type": "code", "text": "T"}, {"type": "li", "text": "Checks that the return type of the function is a subtype of T."}, {"type": "code", "text": "T"}, {"type": "p", "text": "The effect of computing the expression is:"}, {"type": "ul", "text": "\nStore the initial value of a to a temporary storage a0;\nAssign the result of a.inc() to a;\nReturn a0 as a result of the expression.\n"}, {"type": "li", "text": "Store the initial value of a to a temporary storage a0;"}, {"type": "code", "text": "a"}, {"type": "code", "text": "a0"}, {"type": "li", "text": "Assign the result of a.inc() to a;"}, {"type": "code", "text": "a.inc()"}, {"type": "code", "text": "a"}, {"type": "li", "text": "Return a0 as a result of the expression."}, {"type": "code", "text": "a0"}, {"type": "p", "text": "For a-- the steps are completely analogous."}, {"type": "code", "text": "a--"}, {"type": "p", "text": "For the prefix forms ++a and --a resolution works the same way, and the effect is:"}, {"type": "em", "text": "prefix"}, {"type": "code", "text": "++a"}, {"type": "code", "text": "--a"}, {"type": "ul", "text": "\nAssign the result of a.inc() to a;\nReturn the new value of a as a result of the expression.\n"}, {"type": "li", "text": "Assign the result of a.inc() to a;"}, {"type": "code", "text": "a.inc()"}, {"type": "code", "text": "a"}, {"type": "li", "text": "Return the new value of a as a result of the expression."}, {"type": "code", "text": "a"}, {"type": "h2", "text": "Binary operations"}, {"type": "h3", "text": "Arithmetic operators"}, {"type": "table", "text": "\n\n\nExpression\nTranslated to\n\n\n\n\na + b\na.plus(b)\n\n\na - b\na.minus(b)\n\n\na * b\na.times(b)\n\n\na / b\na.div(b)\n\n\na % b\na.rem(b), a.mod(b) (deprecated)\n\n\na..b \na.rangeTo(b)\n\n\n"}, {"type": "thead", "text": "\n\nExpression\nTranslated to\n\n"}, {"type": "tr", "text": "\nExpression\nTranslated to\n"}, {"type": "th", "text": "Expression"}, {"type": "th", "text": "Translated to"}, {"type": "tbody", "text": "\n\na + b\na.plus(b)\n\n\na - b\na.minus(b)\n\n\na * b\na.times(b)\n\n\na / b\na.div(b)\n\n\na % b\na.rem(b), a.mod(b) (deprecated)\n\n\na..b \na.rangeTo(b)\n\n"}, {"type": "tr", "text": "\na + b\na.plus(b)\n"}, {"type": "td", "text": "a + b"}, {"type": "code", "text": "a + b"}, {"type": "td", "text": "a.plus(b)"}, {"type": "code", "text": "a.plus(b)"}, {"type": "tr", "text": "\na - b\na.minus(b)\n"}, {"type": "td", "text": "a - b"}, {"type": "code", "text": "a - b"}, {"type": "td", "text": "a.minus(b)"}, {"type": "code", "text": "a.minus(b)"}, {"type": "tr", "text": "\na * b\na.times(b)\n"}, {"type": "td", "text": "a * b"}, {"type": "code", "text": "a * b"}, {"type": "td", "text": "a.times(b)"}, {"type": "code", "text": "a.times(b)"}, {"type": "tr", "text": "\na / b\na.div(b)\n"}, {"type": "td", "text": "a / b"}, {"type": "code", "text": "a / b"}, {"type": "td", "text": "a.div(b)"}, {"type": "code", "text": "a.div(b)"}, {"type": "tr", "text": "\na % b\na.rem(b), a.mod(b) (deprecated)\n"}, {"type": "td", "text": "a % b"}, {"type": "code", "text": "a % b"}, {"type": "td", "text": "a.rem(b), a.mod(b) (deprecated)"}, {"type": "code", "text": "a.rem(b)"}, {"type": "code", "text": "a.mod(b)"}, {"type": "tr", "text": "\na..b \na.rangeTo(b)\n"}, {"type": "td", "text": "a..b "}, {"type": "code", "text": "a..b "}, {"type": "td", "text": "a.rangeTo(b)"}, {"type": "code", "text": "a.rangeTo(b)"}, {"type": "p", "text": "For the operations in this table, the compiler just resolves the expression in the Translated to column."}, {"type": "em", "text": "Translated to"}, {"type": "p", "text": "Note that the rem operator is supported since Kotlin 1.1. Kotlin 1.0 uses the mod operator, which is deprecated\nin Kotlin 1.1."}, {"type": "code", "text": "rem"}, {"type": "code", "text": "mod"}, {"type": "h4", "text": "Example"}, {"type": "p", "text": "Below is an example Counter class that starts at a given value and can be incremented using the overloaded + operator:"}, {"type": "code", "text": "+"}, {"type": "pre", "text": "data class Counter(val dayIndex: Int) {\n    operator fun plus(increment: Int): Counter {\n        return Counter(dayIndex + increment)\n    }\n}\n"}, {"type": "code", "text": "data class Counter(val dayIndex: Int) {\n    operator fun plus(increment: Int): Counter {\n        return Counter(dayIndex + increment)\n    }\n}\n"}, {"type": "h3", "text": "'In' operator"}, {"type": "table", "text": "\n\n\nExpression\nTranslated to\n\n\n\n\na in b\nb.contains(a)\n\n\na !in b\n!b.contains(a)\n\n\n"}, {"type": "thead", "text": "\n\nExpression\nTranslated to\n\n"}, {"type": "tr", "text": "\nExpression\nTranslated to\n"}, {"type": "th", "text": "Expression"}, {"type": "th", "text": "Translated to"}, {"type": "tbody", "text": "\n\na in b\nb.contains(a)\n\n\na !in b\n!b.contains(a)\n\n"}, {"type": "tr", "text": "\na in b\nb.contains(a)\n"}, {"type": "td", "text": "a in b"}, {"type": "code", "text": "a in b"}, {"type": "td", "text": "b.contains(a)"}, {"type": "code", "text": "b.contains(a)"}, {"type": "tr", "text": "\na !in b\n!b.contains(a)\n"}, {"type": "td", "text": "a !in b"}, {"type": "code", "text": "a !in b"}, {"type": "td", "text": "!b.contains(a)"}, {"type": "code", "text": "!b.contains(a)"}, {"type": "p", "text": "For in and !in the procedure is the same, but the order of arguments is reversed."}, {"type": "code", "text": "in"}, {"type": "code", "text": "!in"}, {"type": "h3", "text": "Indexed access operator"}, {"type": "table", "text": "\n\n\nExpression\nTranslated to\n\n\n\n\na[i]\na.get(i)\n\n\na[i, j]\na.get(i, j)\n\n\na[i_1, ...,  i_n]\na.get(i_1, ...,  i_n)\n\n\na[i] = b\na.set(i, b)\n\n\na[i, j] = b\na.set(i, j, b)\n\n\na[i_1, ...,  i_n] = b\na.set(i_1, ..., i_n, b)\n\n\n"}, {"type": "thead", "text": "\n\nExpression\nTranslated to\n\n"}, {"type": "tr", "text": "\nExpression\nTranslated to\n"}, {"type": "th", "text": "Expression"}, {"type": "th", "text": "Translated to"}, {"type": "tbody", "text": "\n\na[i]\na.get(i)\n\n\na[i, j]\na.get(i, j)\n\n\na[i_1, ...,  i_n]\na.get(i_1, ...,  i_n)\n\n\na[i] = b\na.set(i, b)\n\n\na[i, j] = b\na.set(i, j, b)\n\n\na[i_1, ...,  i_n] = b\na.set(i_1, ..., i_n, b)\n\n"}, {"type": "tr", "text": "\na[i]\na.get(i)\n"}, {"type": "td", "text": "a[i]"}, {"type": "code", "text": "a[i]"}, {"type": "td", "text": "a.get(i)"}, {"type": "code", "text": "a.get(i)"}, {"type": "tr", "text": "\na[i, j]\na.get(i, j)\n"}, {"type": "td", "text": "a[i, j]"}, {"type": "code", "text": "a[i, j]"}, {"type": "td", "text": "a.get(i, j)"}, {"type": "code", "text": "a.get(i, j)"}, {"type": "tr", "text": "\na[i_1, ...,  i_n]\na.get(i_1, ...,  i_n)\n"}, {"type": "td", "text": "a[i_1, ...,  i_n]"}, {"type": "code", "text": "a[i_1, ...,  i_n]"}, {"type": "td", "text": "a.get(i_1, ...,  i_n)"}, {"type": "code", "text": "a.get(i_1, ...,  i_n)"}, {"type": "tr", "text": "\na[i] = b\na.set(i, b)\n"}, {"type": "td", "text": "a[i] = b"}, {"type": "code", "text": "a[i] = b"}, {"type": "td", "text": "a.set(i, b)"}, {"type": "code", "text": "a.set(i, b)"}, {"type": "tr", "text": "\na[i, j] = b\na.set(i, j, b)\n"}, {"type": "td", "text": "a[i, j] = b"}, {"type": "code", "text": "a[i, j] = b"}, {"type": "td", "text": "a.set(i, j, b)"}, {"type": "code", "text": "a.set(i, j, b)"}, {"type": "tr", "text": "\na[i_1, ...,  i_n] = b\na.set(i_1, ..., i_n, b)\n"}, {"type": "td", "text": "a[i_1, ...,  i_n] = b"}, {"type": "code", "text": "a[i_1, ...,  i_n] = b"}, {"type": "td", "text": "a.set(i_1, ..., i_n, b)"}, {"type": "code", "text": "a.set(i_1, ..., i_n, b)"}, {"type": "p", "text": "Square brackets are translated to calls to get and set with appropriate numbers of arguments."}, {"type": "code", "text": "get"}, {"type": "code", "text": "set"}, {"type": "h3", "text": "Invoke operator"}, {"type": "table", "text": "\n\n\nExpression\nTranslated to\n\n\n\n\na()\na.invoke()\n\n\na(i)\na.invoke(i)\n\n\na(i, j)\na.invoke(i, j)\n\n\na(i_1, ...,  i_n)\na.invoke(i_1, ...,  i_n)\n\n\n"}, {"type": "thead", "text": "\n\nExpression\nTranslated to\n\n"}, {"type": "tr", "text": "\nExpression\nTranslated to\n"}, {"type": "th", "text": "Expression"}, {"type": "th", "text": "Translated to"}, {"type": "tbody", "text": "\n\na()\na.invoke()\n\n\na(i)\na.invoke(i)\n\n\na(i, j)\na.invoke(i, j)\n\n\na(i_1, ...,  i_n)\na.invoke(i_1, ...,  i_n)\n\n"}, {"type": "tr", "text": "\na()\na.invoke()\n"}, {"type": "td", "text": "a()"}, {"type": "code", "text": "a()"}, {"type": "td", "text": "a.invoke()"}, {"type": "code", "text": "a.invoke()"}, {"type": "tr", "text": "\na(i)\na.invoke(i)\n"}, {"type": "td", "text": "a(i)"}, {"type": "code", "text": "a(i)"}, {"type": "td", "text": "a.invoke(i)"}, {"type": "code", "text": "a.invoke(i)"}, {"type": "tr", "text": "\na(i, j)\na.invoke(i, j)\n"}, {"type": "td", "text": "a(i, j)"}, {"type": "code", "text": "a(i, j)"}, {"type": "td", "text": "a.invoke(i, j)"}, {"type": "code", "text": "a.invoke(i, j)"}, {"type": "tr", "text": "\na(i_1, ...,  i_n)\na.invoke(i_1, ...,  i_n)\n"}, {"type": "td", "text": "a(i_1, ...,  i_n)"}, {"type": "code", "text": "a(i_1, ...,  i_n)"}, {"type": "td", "text": "a.invoke(i_1, ...,  i_n)"}, {"type": "code", "text": "a.invoke(i_1, ...,  i_n)"}, {"type": "p", "text": "Parentheses are translated to calls to invoke with appropriate number of arguments."}, {"type": "code", "text": "invoke"}, {"type": "h3", "text": "Augmented assignments"}, {"type": "table", "text": "\n\n\nExpression\nTranslated to\n\n\n\n\na += b\na.plusAssign(b)\n\n\na -= b\na.minusAssign(b)\n\n\na *= b\na.timesAssign(b)\n\n\na /= b\na.divAssign(b)\n\n\na %= b\na.remAssign(b), a.modAssign(b) (deprecated)\n\n\n"}, {"type": "thead", "text": "\n\nExpression\nTranslated to\n\n"}, {"type": "tr", "text": "\nExpression\nTranslated to\n"}, {"type": "th", "text": "Expression"}, {"type": "th", "text": "Translated to"}, {"type": "tbody", "text": "\n\na += b\na.plusAssign(b)\n\n\na -= b\na.minusAssign(b)\n\n\na *= b\na.timesAssign(b)\n\n\na /= b\na.divAssign(b)\n\n\na %= b\na.remAssign(b), a.modAssign(b) (deprecated)\n\n"}, {"type": "tr", "text": "\na += b\na.plusAssign(b)\n"}, {"type": "td", "text": "a += b"}, {"type": "code", "text": "a += b"}, {"type": "td", "text": "a.plusAssign(b)"}, {"type": "code", "text": "a.plusAssign(b)"}, {"type": "tr", "text": "\na -= b\na.minusAssign(b)\n"}, {"type": "td", "text": "a -= b"}, {"type": "code", "text": "a -= b"}, {"type": "td", "text": "a.minusAssign(b)"}, {"type": "code", "text": "a.minusAssign(b)"}, {"type": "tr", "text": "\na *= b\na.timesAssign(b)\n"}, {"type": "td", "text": "a *= b"}, {"type": "code", "text": "a *= b"}, {"type": "td", "text": "a.timesAssign(b)"}, {"type": "code", "text": "a.timesAssign(b)"}, {"type": "tr", "text": "\na /= b\na.divAssign(b)\n"}, {"type": "td", "text": "a /= b"}, {"type": "code", "text": "a /= b"}, {"type": "td", "text": "a.divAssign(b)"}, {"type": "code", "text": "a.divAssign(b)"}, {"type": "tr", "text": "\na %= b\na.remAssign(b), a.modAssign(b) (deprecated)\n"}, {"type": "td", "text": "a %= b"}, {"type": "code", "text": "a %= b"}, {"type": "td", "text": "a.remAssign(b), a.modAssign(b) (deprecated)"}, {"type": "code", "text": "a.remAssign(b)"}, {"type": "code", "text": "a.modAssign(b)"}, {"type": "p", "text": "For the assignment operations, e.g. a += b, the compiler performs the following steps:"}, {"type": "code", "text": "a += b"}, {"type": "ul", "text": "\nIf the function from the right column is available\n    \nIf the corresponding binary function (i.e. plus() for plusAssign()) is available too, report error (ambiguity),\nMake sure its return type is Unit, and report an error otherwise,\nGenerate code for a.plusAssign(b);\n\n\nOtherwise, try to generate code for a = a + b (this includes a type check: the type of a + b must be a subtype of a).\n"}, {"type": "li", "text": "If the function from the right column is available\n    \nIf the corresponding binary function (i.e. plus() for plusAssign()) is available too, report error (ambiguity),\nMake sure its return type is Unit, and report an error otherwise,\nGenerate code for a.plusAssign(b);\n\n"}, {"type": "ul", "text": "\nIf the corresponding binary function (i.e. plus() for plusAssign()) is available too, report error (ambiguity),\nMake sure its return type is Unit, and report an error otherwise,\nGenerate code for a.plusAssign(b);\n"}, {"type": "li", "text": "If the corresponding binary function (i.e. plus() for plusAssign()) is available too, report error (ambiguity),"}, {"type": "code", "text": "plus()"}, {"type": "code", "text": "plusAssign()"}, {"type": "li", "text": "Make sure its return type is Unit, and report an error otherwise,"}, {"type": "code", "text": "Unit"}, {"type": "li", "text": "Generate code for a.plusAssign(b);"}, {"type": "code", "text": "a.plusAssign(b)"}, {"type": "li", "text": "Otherwise, try to generate code for a = a + b (this includes a type check: the type of a + b must be a subtype of a)."}, {"type": "code", "text": "a = a + b"}, {"type": "code", "text": "a + b"}, {"type": "code", "text": "a"}, {"type": "p", "text": "Note: assignments are NOT expressions in Kotlin."}, {"type": "em", "text": "Note"}, {"type": "em", "text": "NOT"}, {"type": "h3", "text": "Equality and inequality operators"}, {"type": "table", "text": "\n\n\nExpression\nTranslated to\n\n\n\n\na == b\na?.equals(b) ?: (b === null)\n\n\na != b\n!(a?.equals(b) ?: (b === null))\n\n\n"}, {"type": "thead", "text": "\n\nExpression\nTranslated to\n\n"}, {"type": "tr", "text": "\nExpression\nTranslated to\n"}, {"type": "th", "text": "Expression"}, {"type": "th", "text": "Translated to"}, {"type": "tbody", "text": "\n\na == b\na?.equals(b) ?: (b === null)\n\n\na != b\n!(a?.equals(b) ?: (b === null))\n\n"}, {"type": "tr", "text": "\na == b\na?.equals(b) ?: (b === null)\n"}, {"type": "td", "text": "a == b"}, {"type": "code", "text": "a == b"}, {"type": "td", "text": "a?.equals(b) ?: (b === null)"}, {"type": "code", "text": "a?.equals(b) ?: (b === null)"}, {"type": "tr", "text": "\na != b\n!(a?.equals(b) ?: (b === null))\n"}, {"type": "td", "text": "a != b"}, {"type": "code", "text": "a != b"}, {"type": "td", "text": "!(a?.equals(b) ?: (b === null))"}, {"type": "code", "text": "!(a?.equals(b) ?: (b === null))"}, {"type": "p", "text": "These operators only work with the function equals(other: Any?): Boolean, which can be overridden to provide custom equality check implementation. Any other function with the same name (like equals(other: Foo)) will not be called."}, {"type": "a", "text": "equals(other: Any?): Boolean"}, {"type": "code", "text": "equals(other: Any?): Boolean"}, {"type": "code", "text": "equals(other: Foo)"}, {"type": "p", "text": "Note: === and !== (identity checks) are not overloadable, so no conventions exist for them."}, {"type": "em", "text": "Note"}, {"type": "code", "text": "==="}, {"type": "code", "text": "!=="}, {"type": "p", "text": "The == operation is special: it is translated to a complex expression that screens for null's.\nnull == null is always true, and x == null for a non-null x is always false and won't invoke x.equals()."}, {"type": "code", "text": "=="}, {"type": "code", "text": "null"}, {"type": "code", "text": "null == null"}, {"type": "code", "text": "x == null"}, {"type": "code", "text": "x"}, {"type": "code", "text": "x.equals()"}, {"type": "h3", "text": "Comparison operators"}, {"type": "table", "text": "\n\n\nExpression\nTranslated to\n\n\n\n\na > b\na.compareTo(b) > 0\n\n\na < b\na.compareTo(b) < 0\n\n\na >= b\na.compareTo(b) >= 0\n\n\na <= b\na.compareTo(b) <= 0\n\n\n"}, {"type": "thead", "text": "\n\nExpression\nTranslated to\n\n"}, {"type": "tr", "text": "\nExpression\nTranslated to\n"}, {"type": "th", "text": "Expression"}, {"type": "th", "text": "Translated to"}, {"type": "tbody", "text": "\n\na > b\na.compareTo(b) > 0\n\n\na < b\na.compareTo(b) < 0\n\n\na >= b\na.compareTo(b) >= 0\n\n\na <= b\na.compareTo(b) <= 0\n\n"}, {"type": "tr", "text": "\na > b\na.compareTo(b) > 0\n"}, {"type": "td", "text": "a > b"}, {"type": "code", "text": "a > b"}, {"type": "td", "text": "a.compareTo(b) > 0"}, {"type": "code", "text": "a.compareTo(b) > 0"}, {"type": "tr", "text": "\na < b\na.compareTo(b) < 0\n"}, {"type": "td", "text": "a < b"}, {"type": "code", "text": "a < b"}, {"type": "td", "text": "a.compareTo(b) < 0"}, {"type": "code", "text": "a.compareTo(b) < 0"}, {"type": "tr", "text": "\na >= b\na.compareTo(b) >= 0\n"}, {"type": "td", "text": "a >= b"}, {"type": "code", "text": "a >= b"}, {"type": "td", "text": "a.compareTo(b) >= 0"}, {"type": "code", "text": "a.compareTo(b) >= 0"}, {"type": "tr", "text": "\na <= b\na.compareTo(b) <= 0\n"}, {"type": "td", "text": "a <= b"}, {"type": "code", "text": "a <= b"}, {"type": "td", "text": "a.compareTo(b) <= 0"}, {"type": "code", "text": "a.compareTo(b) <= 0"}, {"type": "p", "text": "All comparisons are translated into calls to compareTo, that is required to return Int."}, {"type": "code", "text": "compareTo"}, {"type": "code", "text": "Int"}, {"type": "h3", "text": "Property delegation operators"}, {"type": "p", "text": "provideDelegate, getValue and setValue operator functions are described\nin Delegated properties."}, {"type": "code", "text": "provideDelegate"}, {"type": "code", "text": "getValue"}, {"type": "code", "text": "setValue"}, {"type": "a", "text": "Delegated properties"}, {"type": "h2", "text": "Infix calls for named functions"}, {"type": "p", "text": "We can simulate custom infix operations by using infix function calls."}, {"type": "a", "text": "infix function calls"}]