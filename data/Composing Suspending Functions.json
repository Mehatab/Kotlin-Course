[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "p", "text": "Table of contents"}, {"type": "strong", "text": "Table of contents"}, {"type": "ul", "text": "\nComposing Suspending Functions\n\nSequential by default\nConcurrent using async\nLazily started async\nAsync-style functions\nStructured concurrency with async\n\n\n"}, {"type": "li", "text": "Composing Suspending Functions\n\nSequential by default\nConcurrent using async\nLazily started async\nAsync-style functions\nStructured concurrency with async\n\n"}, {"type": "a", "text": "Composing Suspending Functions"}, {"type": "ul", "text": "\nSequential by default\nConcurrent using async\nLazily started async\nAsync-style functions\nStructured concurrency with async\n"}, {"type": "li", "text": "Sequential by default"}, {"type": "a", "text": "Sequential by default"}, {"type": "li", "text": "Concurrent using async"}, {"type": "a", "text": "Concurrent using async"}, {"type": "li", "text": "Lazily started async"}, {"type": "a", "text": "Lazily started async"}, {"type": "li", "text": "Async-style functions"}, {"type": "a", "text": "Async-style functions"}, {"type": "li", "text": "Structured concurrency with async"}, {"type": "a", "text": "Structured concurrency with async"}, {"type": "h2", "text": "Composing Suspending Functions"}, {"type": "p", "text": "This section covers various approaches to composition of suspending functions."}, {"type": "h3", "text": "Sequential by default"}, {"type": "p", "text": "Assume that we have two suspending functions defined elsewhere that do something useful like some kind of \nremote service call or computation. We just pretend they are useful, but actually each one just\ndelays for a second for the purpose of this example:"}, {"type": "div", "text": "\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n\n"}, {"type": "pre", "text": "suspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"}, {"type": "code", "text": "suspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"}, {"type": "p", "text": "What do we do if we need them to be invoked sequentially \u2014 first doSomethingUsefulOne and then\ndoSomethingUsefulTwo, and compute the sum of their results? \nIn practice we do this if we use the result of the first function to make a decision on whether we need \nto invoke the second one or to decide on how to invoke it."}, {"type": "em", "text": "sequentially"}, {"type": "code", "text": "doSomethingUsefulOne"}, {"type": "em", "text": "and then"}, {"type": "code", "text": "doSomethingUsefulTwo"}, {"type": "p", "text": "We use a normal sequential invocation, because the code in the coroutine, just like in the regular \ncode, is sequential by default. The following example demonstrates it by measuring the total \ntime it takes to execute both suspending functions:"}, {"type": "em", "text": "sequential"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        val one = doSomethingUsefulOne()\n        val two = doSomethingUsefulTwo()\n        println(\"The answer is ${one + two}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        val one = doSomethingUsefulOne()\n        val two = doSomethingUsefulTwo()\n        println(\"The answer is ${one + two}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        val one = doSomethingUsefulOne()\n        val two = doSomethingUsefulTwo()\n        println(\"The answer is ${one + two}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It produces something like this:"}, {"type": "pre", "text": "The answer is 42\nCompleted in 2017 ms\n"}, {"type": "code", "text": "The answer is 42\nCompleted in 2017 ms\n"}, {"type": "h3", "text": "Concurrent using async"}, {"type": "p", "text": "What if there are no dependencies between invocations of doSomethingUsefulOne and doSomethingUsefulTwo and\nwe want to get the answer faster, by doing both concurrently? This is where async comes to help."}, {"type": "code", "text": "doSomethingUsefulOne"}, {"type": "code", "text": "doSomethingUsefulTwo"}, {"type": "em", "text": "concurrently"}, {"type": "a", "text": "async"}, {"type": "p", "text": "Conceptually, async is just like launch. It starts a separate coroutine which is a light-weight thread \nthat works concurrently with all the other coroutines. The difference is that launch returns a Job and \ndoes not carry any resulting value, while async returns a Deferred \u2014 a light-weight non-blocking future\nthat represents a promise to provide a result later. You can use .await() on a deferred value to get its eventual result,\nbut Deferred is also a Job, so you can cancel it if needed."}, {"type": "a", "text": "async"}, {"type": "a", "text": "launch"}, {"type": "code", "text": "launch"}, {"type": "a", "text": "Job"}, {"type": "code", "text": "async"}, {"type": "a", "text": "Deferred"}, {"type": "code", "text": ".await()"}, {"type": "code", "text": "Deferred"}, {"type": "code", "text": "Job"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        val one = async { doSomethingUsefulOne() }\n        val two = async { doSomethingUsefulTwo() }\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        val one = async { doSomethingUsefulOne() }\n        val two = async { doSomethingUsefulTwo() }\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        val one = async { doSomethingUsefulOne() }\n        val two = async { doSomethingUsefulTwo() }\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It produces something like this:"}, {"type": "pre", "text": "The answer is 42\nCompleted in 1017 ms\n"}, {"type": "code", "text": "The answer is 42\nCompleted in 1017 ms\n"}, {"type": "p", "text": "This is twice as fast, because the two coroutines execute concurrently. \nNote that concurrency with coroutines is always explicit."}, {"type": "h3", "text": "Lazily started async"}, {"type": "p", "text": "Optionally, async can be made lazy by setting its start parameter to CoroutineStart.LAZY. \nIn this mode it only starts the coroutine when its result is required by \nawait, or if its Job's start function \nis invoked. Run the following example:"}, {"type": "a", "text": "async"}, {"type": "code", "text": "start"}, {"type": "a", "text": "CoroutineStart.LAZY"}, {"type": "a", "text": "await"}, {"type": "code", "text": "Job"}, {"type": "a", "text": "start"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }\n        val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }\n        // some computation\n        one.start() // start the first one\n        two.start() // start the second one\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }\n        val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }\n        // some computation\n        one.start() // start the first one\n        two.start() // start the second one\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }\n        val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }\n        // some computation\n        one.start() // start the first one\n        two.start() // start the second one\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It produces something like this:"}, {"type": "pre", "text": "The answer is 42\nCompleted in 1017 ms\n"}, {"type": "code", "text": "The answer is 42\nCompleted in 1017 ms\n"}, {"type": "p", "text": "So, here the two coroutines are defined but not executed as in the previous example, but the control is given to\nthe programmer on when exactly to start the execution by calling start. We first \nstart one, then start two, and then await for the individual coroutines to finish."}, {"type": "a", "text": "start"}, {"type": "code", "text": "one"}, {"type": "code", "text": "two"}, {"type": "p", "text": "Note that if we just call await in println without first calling start on individual \ncoroutines, this will lead to sequential behavior, since await starts the coroutine \nexecution and waits for its finish, which is not the intended use-case for laziness. \nThe use-case for async(start = CoroutineStart.LAZY) is a replacement for the \nstandard lazy function in cases when computation of the value involves suspending functions."}, {"type": "a", "text": "await"}, {"type": "code", "text": "println"}, {"type": "a", "text": "start"}, {"type": "a", "text": "await"}, {"type": "code", "text": "async(start = CoroutineStart.LAZY)"}, {"type": "code", "text": "lazy"}, {"type": "h3", "text": "Async-style functions"}, {"type": "p", "text": "We can define async-style functions that invoke doSomethingUsefulOne and doSomethingUsefulTwo\nasynchronously using the async coroutine builder with an explicit GlobalScope reference.\nWe name such functions with the \n\"\u2026Async\" suffix to highlight the fact that they only start asynchronous computation and one needs\nto use the resulting deferred value to get the result."}, {"type": "code", "text": "doSomethingUsefulOne"}, {"type": "code", "text": "doSomethingUsefulTwo"}, {"type": "em", "text": "asynchronously"}, {"type": "a", "text": "async"}, {"type": "a", "text": "GlobalScope"}, {"type": "div", "text": "\n// The result type of somethingUsefulOneAsync is Deferred<Int>\nfun somethingUsefulOneAsync() = GlobalScope.async {\n    doSomethingUsefulOne()\n}\n\n// The result type of somethingUsefulTwoAsync is Deferred<Int>\nfun somethingUsefulTwoAsync() = GlobalScope.async {\n    doSomethingUsefulTwo()\n}\n\n"}, {"type": "pre", "text": "// The result type of somethingUsefulOneAsync is Deferred<Int>\nfun somethingUsefulOneAsync() = GlobalScope.async {\n    doSomethingUsefulOne()\n}\n\n// The result type of somethingUsefulTwoAsync is Deferred<Int>\nfun somethingUsefulTwoAsync() = GlobalScope.async {\n    doSomethingUsefulTwo()\n}\n"}, {"type": "code", "text": "// The result type of somethingUsefulOneAsync is Deferred<Int>\nfun somethingUsefulOneAsync() = GlobalScope.async {\n    doSomethingUsefulOne()\n}\n\n// The result type of somethingUsefulTwoAsync is Deferred<Int>\nfun somethingUsefulTwoAsync() = GlobalScope.async {\n    doSomethingUsefulTwo()\n}\n"}, {"type": "p", "text": "Note that these xxxAsync functions are not suspending functions. They can be used from anywhere.\nHowever, their use always implies asynchronous (here meaning concurrent) execution of their action\nwith the invoking code."}, {"type": "code", "text": "xxxAsync"}, {"type": "strong", "text": "not"}, {"type": "em", "text": "suspending"}, {"type": "em", "text": "concurrent"}, {"type": "p", "text": "The following example shows their use outside of coroutine:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\n//sampleStart\n// note that we don't have `runBlocking` to the right of `main` in this example\nfun main() {\n    val time = measureTimeMillis {\n        // we can initiate async actions outside of a coroutine\n        val one = somethingUsefulOneAsync()\n        val two = somethingUsefulTwoAsync()\n        // but waiting for a result must involve either suspending or blocking.\n        // here we use `runBlocking { ... }` to block the main thread while waiting for the result\n        runBlocking {\n            println(\"The answer is ${one.await() + two.await()}\")\n        }\n    }\n    println(\"Completed in $time ms\")\n}\n//sampleEnd\n\nfun somethingUsefulOneAsync() = GlobalScope.async {\n    doSomethingUsefulOne()\n}\n\nfun somethingUsefulTwoAsync() = GlobalScope.async {\n    doSomethingUsefulTwo()\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\n//sampleStart\n// note that we don't have `runBlocking` to the right of `main` in this example\nfun main() {\n    val time = measureTimeMillis {\n        // we can initiate async actions outside of a coroutine\n        val one = somethingUsefulOneAsync()\n        val two = somethingUsefulTwoAsync()\n        // but waiting for a result must involve either suspending or blocking.\n        // here we use `runBlocking { ... }` to block the main thread while waiting for the result\n        runBlocking {\n            println(\"The answer is ${one.await() + two.await()}\")\n        }\n    }\n    println(\"Completed in $time ms\")\n}\n//sampleEnd\n\nfun somethingUsefulOneAsync() = GlobalScope.async {\n    doSomethingUsefulOne()\n}\n\nfun somethingUsefulTwoAsync() = GlobalScope.async {\n    doSomethingUsefulTwo()\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\n//sampleStart\n// note that we don't have `runBlocking` to the right of `main` in this example\nfun main() {\n    val time = measureTimeMillis {\n        // we can initiate async actions outside of a coroutine\n        val one = somethingUsefulOneAsync()\n        val two = somethingUsefulTwoAsync()\n        // but waiting for a result must involve either suspending or blocking.\n        // here we use `runBlocking { ... }` to block the main thread while waiting for the result\n        runBlocking {\n            println(\"The answer is ${one.await() + two.await()}\")\n        }\n    }\n    println(\"Completed in $time ms\")\n}\n//sampleEnd\n\nfun somethingUsefulOneAsync() = GlobalScope.async {\n    doSomethingUsefulOne()\n}\n\nfun somethingUsefulTwoAsync() = GlobalScope.async {\n    doSomethingUsefulTwo()\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "blockquote", "text": "\nThis programming style with async functions is provided here only for illustration, because it is a popular style\nin other programming languages. Using this style with Kotlin coroutines is strongly discouraged for the\nreasons explained below.\n"}, {"type": "p", "text": "This programming style with async functions is provided here only for illustration, because it is a popular style\nin other programming languages. Using this style with Kotlin coroutines is strongly discouraged for the\nreasons explained below."}, {"type": "strong", "text": "strongly discouraged"}, {"type": "p", "text": "Consider what happens if between the val one = somethingUsefulOneAsync() line and one.await() expression there is some logic\nerror in the code and the program throws an exception and the operation that was being performed by the program aborts. \nNormally, a global error-handler could catch this exception, log and report the error for developers, but the program \ncould otherwise continue doing other operations. But here we have somethingUsefulOneAsync still running in the background,\neven though the operation that initiated it was aborted. This problem does not happen with structured\nconcurrency, as shown in the section below."}, {"type": "code", "text": "val one = somethingUsefulOneAsync()"}, {"type": "code", "text": "one.await()"}, {"type": "code", "text": "somethingUsefulOneAsync"}, {"type": "h3", "text": "Structured concurrency with async"}, {"type": "p", "text": "Let us take the Concurrent using async example and extract a function that \nconcurrently performs doSomethingUsefulOne and doSomethingUsefulTwo and returns the sum of their results.\nBecause the async coroutine builder is defined as an extension on CoroutineScope, we need to have it in the \nscope and that is what the coroutineScope function provides:"}, {"type": "a", "text": "Concurrent using async"}, {"type": "code", "text": "doSomethingUsefulOne"}, {"type": "code", "text": "doSomethingUsefulTwo"}, {"type": "a", "text": "async"}, {"type": "a", "text": "CoroutineScope"}, {"type": "a", "text": "coroutineScope"}, {"type": "div", "text": "\nsuspend fun concurrentSum(): Int = coroutineScope {\n    val one = async { doSomethingUsefulOne() }\n    val two = async { doSomethingUsefulTwo() }\n    one.await() + two.await()\n}\n\n"}, {"type": "pre", "text": "suspend fun concurrentSum(): Int = coroutineScope {\n    val one = async { doSomethingUsefulOne() }\n    val two = async { doSomethingUsefulTwo() }\n    one.await() + two.await()\n}\n"}, {"type": "code", "text": "suspend fun concurrentSum(): Int = coroutineScope {\n    val one = async { doSomethingUsefulOne() }\n    val two = async { doSomethingUsefulTwo() }\n    one.await() + two.await()\n}\n"}, {"type": "p", "text": "This way, if something goes wrong inside the code of the concurrentSum function and it throws an exception,\nall the coroutines that were launched in its scope will be cancelled."}, {"type": "code", "text": "concurrentSum"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        println(\"The answer is ${concurrentSum()}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun concurrentSum(): Int = coroutineScope {\n    val one = async { doSomethingUsefulOne() }\n    val two = async { doSomethingUsefulTwo() }\n    one.await() + two.await()\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        println(\"The answer is ${concurrentSum()}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun concurrentSum(): Int = coroutineScope {\n    val one = async { doSomethingUsefulOne() }\n    val two = async { doSomethingUsefulTwo() }\n    one.await() + two.await()\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        println(\"The answer is ${concurrentSum()}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun concurrentSum(): Int = coroutineScope {\n    val one = async { doSomethingUsefulOne() }\n    val two = async { doSomethingUsefulTwo() }\n    one.await() + two.await()\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "We still have concurrent execution of both operations, as evident from the output of the above main function:"}, {"type": "code", "text": "main"}, {"type": "pre", "text": "The answer is 42\nCompleted in 1017 ms\n"}, {"type": "code", "text": "The answer is 42\nCompleted in 1017 ms\n"}, {"type": "p", "text": "Cancellation is always propagated through coroutines hierarchy:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    try {\n        failedConcurrentSum()\n    } catch(e: ArithmeticException) {\n        println(\"Computation failed with ArithmeticException\")\n    }\n}\n\nsuspend fun failedConcurrentSum(): Int = coroutineScope {\n    val one = async<Int> { \n        try {\n            delay(Long.MAX_VALUE) // Emulates very long computation\n            42\n        } finally {\n            println(\"First child was cancelled\")\n        }\n    }\n    val two = async<Int> { \n        println(\"Second child throws an exception\")\n        throw ArithmeticException()\n    }\n    one.await() + two.await()\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    try {\n        failedConcurrentSum()\n    } catch(e: ArithmeticException) {\n        println(\"Computation failed with ArithmeticException\")\n    }\n}\n\nsuspend fun failedConcurrentSum(): Int = coroutineScope {\n    val one = async<Int> { \n        try {\n            delay(Long.MAX_VALUE) // Emulates very long computation\n            42\n        } finally {\n            println(\"First child was cancelled\")\n        }\n    }\n    val two = async<Int> { \n        println(\"Second child throws an exception\")\n        throw ArithmeticException()\n    }\n    one.await() + two.await()\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    try {\n        failedConcurrentSum()\n    } catch(e: ArithmeticException) {\n        println(\"Computation failed with ArithmeticException\")\n    }\n}\n\nsuspend fun failedConcurrentSum(): Int = coroutineScope {\n    val one = async<Int> { \n        try {\n            delay(Long.MAX_VALUE) // Emulates very long computation\n            42\n        } finally {\n            println(\"First child was cancelled\")\n        }\n    }\n    val two = async<Int> { \n        println(\"Second child throws an exception\")\n        throw ArithmeticException()\n    }\n    one.await() + two.await()\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Note how both the first async and the awaiting parent are cancelled on failure of one of the children\n(namely, two):"}, {"type": "code", "text": "async"}, {"type": "code", "text": "two"}, {"type": "pre", "text": "Second child throws an exception\nFirst child was cancelled\nComputation failed with ArithmeticException\n"}, {"type": "code", "text": "Second child throws an exception\nFirst child was cancelled\nComputation failed with ArithmeticException\n"}]