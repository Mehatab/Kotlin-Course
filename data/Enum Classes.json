[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Enum Classes"}, {"type": "p", "text": "The most basic usage of enum classes is implementing type-safe enums:"}, {"type": "div", "text": "\nenum class Direction {\n    NORTH, SOUTH, WEST, EAST\n}\n\n"}, {"type": "pre", "text": "enum class Direction {\n    NORTH, SOUTH, WEST, EAST\n}\n"}, {"type": "code", "text": "enum class Direction {\n    NORTH, SOUTH, WEST, EAST\n}\n"}, {"type": "p", "text": "Each enum constant is an object. Enum constants are separated with commas."}, {"type": "h2", "text": "Initialization"}, {"type": "p", "text": "Since each enum is an instance of the enum class, they can be initialized as:"}, {"type": "div", "text": "\nenum class Color(val rgb: Int) {\n        RED(0xFF0000),\n        GREEN(0x00FF00),\n        BLUE(0x0000FF)\n}\n\n"}, {"type": "pre", "text": "enum class Color(val rgb: Int) {\n        RED(0xFF0000),\n        GREEN(0x00FF00),\n        BLUE(0x0000FF)\n}\n"}, {"type": "code", "text": "enum class Color(val rgb: Int) {\n        RED(0xFF0000),\n        GREEN(0x00FF00),\n        BLUE(0x0000FF)\n}\n"}, {"type": "h2", "text": "Anonymous Classes"}, {"type": "p", "text": "Enum constants can also declare their own anonymous classes with their corresponding methods, as well as overriding base methods."}, {"type": "div", "text": "\nenum class ProtocolState {\n    WAITING {\n        override fun signal() = TALKING\n    },\n\n    TALKING {\n        override fun signal() = WAITING\n    };\n\n    abstract fun signal(): ProtocolState\n}\n\n"}, {"type": "pre", "text": "enum class ProtocolState {\n    WAITING {\n        override fun signal() = TALKING\n    },\n\n    TALKING {\n        override fun signal() = WAITING\n    };\n\n    abstract fun signal(): ProtocolState\n}\n"}, {"type": "code", "text": "enum class ProtocolState {\n    WAITING {\n        override fun signal() = TALKING\n    },\n\n    TALKING {\n        override fun signal() = WAITING\n    };\n\n    abstract fun signal(): ProtocolState\n}\n"}, {"type": "p", "text": "If the enum class defines any members, separate the enum constant definitions from the member definitions with a semicolon."}, {"type": "p", "text": "Enum entries cannot contain nested types other than inner classes (deprecated in Kotlin 1.2)."}, {"type": "h2", "text": "Implementing Interfaces in Enum Classes"}, {"type": "p", "text": "An enum class may implement an interface (but not derive from a class), providing either a single interface members implementation for all of the entries, or separate ones for each entry within its anonymous class. This is done by adding the interfaces to the enum class declaration as follows:"}, {"type": "div", "text": "\nimport java.util.function.BinaryOperator\nimport java.util.function.IntBinaryOperator\n\n//sampleStart\nenum class IntArithmetics : BinaryOperator<Int>, IntBinaryOperator {\n    PLUS {\n        override fun apply(t: Int, u: Int): Int = t + u\n    },\n    TIMES {\n        override fun apply(t: Int, u: Int): Int = t * u\n    };\n    \n    override fun applyAsInt(t: Int, u: Int) = apply(t, u)\n}\n//sampleEnd\n\nfun main() {\n    val a = 13\n    val b = 31\n    for (f in IntArithmetics.values()) {\n        println(\"$f($a, $b) = ${f.apply(a, b)}\")\n    }\n}\n\n"}, {"type": "pre", "text": "import java.util.function.BinaryOperator\nimport java.util.function.IntBinaryOperator\n\n//sampleStart\nenum class IntArithmetics : BinaryOperator<Int>, IntBinaryOperator {\n    PLUS {\n        override fun apply(t: Int, u: Int): Int = t + u\n    },\n    TIMES {\n        override fun apply(t: Int, u: Int): Int = t * u\n    };\n    \n    override fun applyAsInt(t: Int, u: Int) = apply(t, u)\n}\n//sampleEnd\n\nfun main() {\n    val a = 13\n    val b = 31\n    for (f in IntArithmetics.values()) {\n        println(\"$f($a, $b) = ${f.apply(a, b)}\")\n    }\n}\n"}, {"type": "code", "text": "import java.util.function.BinaryOperator\nimport java.util.function.IntBinaryOperator\n\n//sampleStart\nenum class IntArithmetics : BinaryOperator<Int>, IntBinaryOperator {\n    PLUS {\n        override fun apply(t: Int, u: Int): Int = t + u\n    },\n    TIMES {\n        override fun apply(t: Int, u: Int): Int = t * u\n    };\n    \n    override fun applyAsInt(t: Int, u: Int) = apply(t, u)\n}\n//sampleEnd\n\nfun main() {\n    val a = 13\n    val b = 31\n    for (f in IntArithmetics.values()) {\n        println(\"$f($a, $b) = ${f.apply(a, b)}\")\n    }\n}\n"}, {"type": "h2", "text": "Working with Enum Constants"}, {"type": "p", "text": "Enum classes in Kotlin have synthetic methods allowing to list\nthe defined enum constants and to get an enum constant by its name. The signatures\nof these methods are as follows (assuming the name of the enum class is EnumClass):"}, {"type": "code", "text": "EnumClass"}, {"type": "div", "text": "\nEnumClass.valueOf(value: String): EnumClass\nEnumClass.values(): Array<EnumClass>\n\n"}, {"type": "pre", "text": "EnumClass.valueOf(value: String): EnumClass\nEnumClass.values(): Array<EnumClass>\n"}, {"type": "code", "text": "EnumClass.valueOf(value: String): EnumClass\nEnumClass.values(): Array<EnumClass>\n"}, {"type": "p", "text": "The valueOf() method throws an IllegalArgumentException if the specified name does\nnot match any of the enum constants defined in the class."}, {"type": "code", "text": "valueOf()"}, {"type": "code", "text": "IllegalArgumentException"}, {"type": "p", "text": "Since Kotlin 1.1, it's possible to access the constants in an enum class in a generic way, using\nthe enumValues<T>() and enumValueOf<T>() functions:"}, {"type": "code", "text": "enumValues<T>()"}, {"type": "code", "text": "enumValueOf<T>()"}, {"type": "div", "text": "\nenum class RGB { RED, GREEN, BLUE }\n\ninline fun <reified T : Enum<T>> printAllValues() {\n    print(enumValues<T>().joinToString { it.name })\n}\n\nprintAllValues<RGB>() // prints RED, GREEN, BLUE\n\n"}, {"type": "pre", "text": "enum class RGB { RED, GREEN, BLUE }\n\ninline fun <reified T : Enum<T>> printAllValues() {\n    print(enumValues<T>().joinToString { it.name })\n}\n\nprintAllValues<RGB>() // prints RED, GREEN, BLUE\n"}, {"type": "code", "text": "enum class RGB { RED, GREEN, BLUE }\n\ninline fun <reified T : Enum<T>> printAllValues() {\n    print(enumValues<T>().joinToString { it.name })\n}\n\nprintAllValues<RGB>() // prints RED, GREEN, BLUE\n"}, {"type": "p", "text": "Every enum constant has properties to obtain its name and position in the enum class declaration:"}, {"type": "div", "text": "\nval name: String\nval ordinal: Int\n\n"}, {"type": "pre", "text": "val name: String\nval ordinal: Int\n"}, {"type": "code", "text": "val name: String\nval ordinal: Int\n"}, {"type": "p", "text": "The enum constants also implement the Comparable interface,\nwith the natural order being the order in which they are defined in the enum class."}, {"type": "a", "text": "Comparable"}]