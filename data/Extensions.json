[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Extensions"}, {"type": "p", "text": "Kotlin provides the ability to extend a class with new functionality\nwithout having to inherit from the class or use design patterns such as Decorator.\nThis is done via special declarations called extensions.\nFor example, you can write new functions for a class from a third-party library that you can't modify.\nSuch functions are available for calling in the usual way as if they were methods of the original class. \nThis mechanism is called extension functions. There are also extension properties that let you define\nnew properties for existing classes."}, {"type": "em", "text": "extensions"}, {"type": "em", "text": "extension functions"}, {"type": "em", "text": "extension properties"}, {"type": "h2", "text": "Extension functions"}, {"type": "p", "text": "To declare an extension function, we need to prefix its name with a receiver type, i.e. the type being extended.\nThe following adds a swap function to MutableList<Int>:"}, {"type": "em", "text": "receiver type"}, {"type": "code", "text": "swap"}, {"type": "code", "text": "MutableList<Int>"}, {"type": "div", "text": "\nfun MutableList<Int>.swap(index1: Int, index2: Int) {\n    val tmp = this[index1] // 'this' corresponds to the list\n    this[index1] = this[index2]\n    this[index2] = tmp\n}\n\n"}, {"type": "pre", "text": "fun MutableList<Int>.swap(index1: Int, index2: Int) {\n    val tmp = this[index1] // 'this' corresponds to the list\n    this[index1] = this[index2]\n    this[index2] = tmp\n}\n"}, {"type": "code", "text": "fun MutableList<Int>.swap(index1: Int, index2: Int) {\n    val tmp = this[index1] // 'this' corresponds to the list\n    this[index1] = this[index2]\n    this[index2] = tmp\n}\n"}, {"type": "p", "text": "The this keyword inside an extension function corresponds to the receiver object (the one that is passed before the dot). \nNow, we can call such a function on any MutableList<Int>:"}, {"type": "em", "text": "this"}, {"type": "code", "text": "MutableList<Int>"}, {"type": "div", "text": "\nval list = mutableListOf(1, 2, 3)\nlist.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'list'\n\n"}, {"type": "pre", "text": "val list = mutableListOf(1, 2, 3)\nlist.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'list'\n"}, {"type": "code", "text": "val list = mutableListOf(1, 2, 3)\nlist.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'list'\n"}, {"type": "p", "text": "Of course, this function makes sense for any MutableList<T>, and we can make it generic:"}, {"type": "code", "text": "MutableList<T>"}, {"type": "div", "text": "\nfun <T> MutableList<T>.swap(index1: Int, index2: Int) {\n    val tmp = this[index1] // 'this' corresponds to the list\n    this[index1] = this[index2]\n    this[index2] = tmp\n}\n\n"}, {"type": "pre", "text": "fun <T> MutableList<T>.swap(index1: Int, index2: Int) {\n    val tmp = this[index1] // 'this' corresponds to the list\n    this[index1] = this[index2]\n    this[index2] = tmp\n}\n"}, {"type": "code", "text": "fun <T> MutableList<T>.swap(index1: Int, index2: Int) {\n    val tmp = this[index1] // 'this' corresponds to the list\n    this[index1] = this[index2]\n    this[index2] = tmp\n}\n"}, {"type": "p", "text": "We declare the generic type parameter before the function name for it to be available in the receiver type expression. \nSee Generic functions."}, {"type": "a", "text": "Generic functions"}, {"type": "h2", "text": "Extensions are resolved statically"}, {"type": "strong", "text": "statically"}, {"type": "p", "text": "Extensions do not actually modify classes they extend. By defining an extension, you do not insert new members into a class,\nbut merely make new functions callable with the dot-notation on variables of this type."}, {"type": "p", "text": "We would like to emphasize that extension functions are dispatched statically, i.e. they are not virtual by receiver type.\nThis means that the extension function being called is determined by the type of the expression on which the function is invoked,\nnot by the type of the result of evaluating that expression at runtime. For example:"}, {"type": "strong", "text": "statically"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    open class Shape\n    \n    class Rectangle: Shape()\n    \n    fun Shape.getName() = \"Shape\"\n    \n    fun Rectangle.getName() = \"Rectangle\"\n    \n    fun printClassName(s: Shape) {\n        println(s.getName())\n    }    \n    \n    printClassName(Rectangle())\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    open class Shape\n    \n    class Rectangle: Shape()\n    \n    fun Shape.getName() = \"Shape\"\n    \n    fun Rectangle.getName() = \"Rectangle\"\n    \n    fun printClassName(s: Shape) {\n        println(s.getName())\n    }    \n    \n    printClassName(Rectangle())\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    open class Shape\n    \n    class Rectangle: Shape()\n    \n    fun Shape.getName() = \"Shape\"\n    \n    fun Rectangle.getName() = \"Rectangle\"\n    \n    fun printClassName(s: Shape) {\n        println(s.getName())\n    }    \n    \n    printClassName(Rectangle())\n//sampleEnd\n}\n"}, {"type": "p", "text": "This example prints \"Shape\", because the extension function being called depends only on the declared type of the\nparameter s, which is the Shape class."}, {"type": "em", "text": "Shape"}, {"type": "code", "text": "s"}, {"type": "code", "text": "Shape"}, {"type": "p", "text": "If a class has a member function, and an extension function is defined which has the same receiver type,\nthe same name, and is applicable to given arguments, the member always wins.\nFor example:"}, {"type": "strong", "text": "member always wins"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    class Example {\n        fun printFunctionType() { println(\"Class method\") }\n    }\n    \n    fun Example.printFunctionType() { println(\"Extension function\") }\n    \n    Example().printFunctionType()\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    class Example {\n        fun printFunctionType() { println(\"Class method\") }\n    }\n    \n    fun Example.printFunctionType() { println(\"Extension function\") }\n    \n    Example().printFunctionType()\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    class Example {\n        fun printFunctionType() { println(\"Class method\") }\n    }\n    \n    fun Example.printFunctionType() { println(\"Extension function\") }\n    \n    Example().printFunctionType()\n//sampleEnd\n}\n"}, {"type": "p", "text": "This code prints \"Class method\"."}, {"type": "em", "text": "Class method"}, {"type": "p", "text": "However, it's perfectly OK for extension functions to overload member functions which have the same name but a different signature:"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    class Example {\n        fun printFunctionType() { println(\"Class method\") }\n    }\n    \n    fun Example.printFunctionType(i: Int) { println(\"Extension function\") }\n    \n    Example().printFunctionType(1)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    class Example {\n        fun printFunctionType() { println(\"Class method\") }\n    }\n    \n    fun Example.printFunctionType(i: Int) { println(\"Extension function\") }\n    \n    Example().printFunctionType(1)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    class Example {\n        fun printFunctionType() { println(\"Class method\") }\n    }\n    \n    fun Example.printFunctionType(i: Int) { println(\"Extension function\") }\n    \n    Example().printFunctionType(1)\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Nullable receiver"}, {"type": "p", "text": "Note that extensions can be defined with a nullable receiver type. Such extensions can be called on an object variable\neven if its value is null, and can check for this == null inside the body. This is what allows you\nto call toString() in Kotlin without checking for null: the check happens inside the extension function."}, {"type": "code", "text": "this == null"}, {"type": "div", "text": "\nfun Any?.toString(): String {\n    if (this == null) return \"null\"\n    // after the null check, 'this' is autocast to a non-null type, so the toString() below\n    // resolves to the member function of the Any class\n    return toString()\n}\n\n"}, {"type": "pre", "text": "fun Any?.toString(): String {\n    if (this == null) return \"null\"\n    // after the null check, 'this' is autocast to a non-null type, so the toString() below\n    // resolves to the member function of the Any class\n    return toString()\n}\n"}, {"type": "code", "text": "fun Any?.toString(): String {\n    if (this == null) return \"null\"\n    // after the null check, 'this' is autocast to a non-null type, so the toString() below\n    // resolves to the member function of the Any class\n    return toString()\n}\n"}, {"type": "h2", "text": "Extension properties"}, {"type": "p", "text": "Similarly to functions, Kotlin supports extension properties:"}, {"type": "div", "text": "\nval <T> List<T>.lastIndex: Int\n    get() = size - 1\n\n"}, {"type": "pre", "text": "val <T> List<T>.lastIndex: Int\n    get() = size - 1\n"}, {"type": "code", "text": "val <T> List<T>.lastIndex: Int\n    get() = size - 1\n"}, {"type": "p", "text": "Note that, since extensions do not actually insert members into classes, there's no efficient way for an extension \nproperty to have a backing field. This is why initializers are not allowed for \nextension properties. Their behavior can only be defined by explicitly providing getters/setters."}, {"type": "a", "text": "backing field"}, {"type": "strong", "text": "initializers are not allowed for \nextension properties"}, {"type": "p", "text": "Example:"}, {"type": "div", "text": "\nval House.number = 1 // error: initializers are not allowed for extension properties\n\n"}, {"type": "pre", "text": "val House.number = 1 // error: initializers are not allowed for extension properties\n"}, {"type": "code", "text": "val House.number = 1 // error: initializers are not allowed for extension properties\n"}, {"type": "h2", "text": "Companion object extensions"}, {"type": "p", "text": "If a class has a companion object defined, you can also define extension\nfunctions and properties for the companion object. Just like regular members of the companion object,\nthey can be called using only the class name as the qualifier:"}, {"type": "a", "text": "companion object"}, {"type": "div", "text": "\nclass MyClass {\n    companion object { }  // will be called \"Companion\"\n}\n\nfun MyClass.Companion.printCompanion() { println(\"companion\") }\n\nfun main() {\n    MyClass.printCompanion()\n}\n\n"}, {"type": "pre", "text": "class MyClass {\n    companion object { }  // will be called \"Companion\"\n}\n\nfun MyClass.Companion.printCompanion() { println(\"companion\") }\n\nfun main() {\n    MyClass.printCompanion()\n}\n"}, {"type": "code", "text": "class MyClass {\n    companion object { }  // will be called \"Companion\"\n}\n\nfun MyClass.Companion.printCompanion() { println(\"companion\") }\n\nfun main() {\n    MyClass.printCompanion()\n}\n"}, {"type": "h2", "text": "Scope of extensions"}, {"type": "p", "text": "Most of the time we define extensions on the top level - directly under packages:"}, {"type": "div", "text": "\npackage org.example.declarations\n \nfun List<String>.getLongestString() { /*...*/}\n\n"}, {"type": "pre", "text": "package org.example.declarations\n \nfun List<String>.getLongestString() { /*...*/}\n"}, {"type": "code", "text": "package org.example.declarations\n \nfun List<String>.getLongestString() { /*...*/}\n"}, {"type": "p", "text": "To use such an extension outside its declaring package, we need to import it at the call site:"}, {"type": "div", "text": "\npackage org.example.usage\n\nimport org.example.declarations.getLongestString\n\nfun main() {\n    val list = listOf(\"red\", \"green\", \"blue\")\n    list.getLongestString()\n}\n\n"}, {"type": "pre", "text": "package org.example.usage\n\nimport org.example.declarations.getLongestString\n\nfun main() {\n    val list = listOf(\"red\", \"green\", \"blue\")\n    list.getLongestString()\n}\n"}, {"type": "code", "text": "package org.example.usage\n\nimport org.example.declarations.getLongestString\n\nfun main() {\n    val list = listOf(\"red\", \"green\", \"blue\")\n    list.getLongestString()\n}\n"}, {"type": "p", "text": "See Imports for more information."}, {"type": "a", "text": "Imports"}, {"type": "h2", "text": "Declaring extensions as members"}, {"type": "p", "text": "Inside a class, you can declare extensions for another class. Inside such an extension, there are multiple implicit receivers -\nobjects members of which can be accessed without a qualifier. The instance of the class in which the extension is declared is called\ndispatch receiver, and the instance of the receiver type of the extension method is called extension receiver."}, {"type": "em", "text": "implicit receivers"}, {"type": "em", "text": "dispatch receiver"}, {"type": "em", "text": "extension receiver"}, {"type": "div", "text": "\nclass Host(val hostname: String) {\n    fun printHostname() { print(hostname) }\n}\n\nclass Connection(val host: Host, val port: Int) {\n     fun printPort() { print(port) }\n\n     fun Host.printConnectionString() {\n         printHostname()   // calls Host.printHostname()\n         print(\":\")\n         printPort()   // calls Connection.printPort()\n     }\n\n     fun connect() {\n         /*...*/\n         host.printConnectionString()   // calls the extension function\n     }\n}\n\nfun main() {\n    Connection(Host(\"kotl.in\"), 443).connect()\n    //Host(\"kotl.in\").printConnectionString(443)  // error, the extension function is unavailable outside Connection\n}\n\n"}, {"type": "pre", "text": "class Host(val hostname: String) {\n    fun printHostname() { print(hostname) }\n}\n\nclass Connection(val host: Host, val port: Int) {\n     fun printPort() { print(port) }\n\n     fun Host.printConnectionString() {\n         printHostname()   // calls Host.printHostname()\n         print(\":\")\n         printPort()   // calls Connection.printPort()\n     }\n\n     fun connect() {\n         /*...*/\n         host.printConnectionString()   // calls the extension function\n     }\n}\n\nfun main() {\n    Connection(Host(\"kotl.in\"), 443).connect()\n    //Host(\"kotl.in\").printConnectionString(443)  // error, the extension function is unavailable outside Connection\n}\n"}, {"type": "code", "text": "class Host(val hostname: String) {\n    fun printHostname() { print(hostname) }\n}\n\nclass Connection(val host: Host, val port: Int) {\n     fun printPort() { print(port) }\n\n     fun Host.printConnectionString() {\n         printHostname()   // calls Host.printHostname()\n         print(\":\")\n         printPort()   // calls Connection.printPort()\n     }\n\n     fun connect() {\n         /*...*/\n         host.printConnectionString()   // calls the extension function\n     }\n}\n\nfun main() {\n    Connection(Host(\"kotl.in\"), 443).connect()\n    //Host(\"kotl.in\").printConnectionString(443)  // error, the extension function is unavailable outside Connection\n}\n"}, {"type": "p", "text": "In case of a name conflict between the members of the dispatch receiver and the extension receiver, the extension receiver takes\nprecedence. To refer to the member of the dispatch receiver you can use the qualified this syntax."}, {"type": "a", "text": "qualified this syntax"}, {"type": "code", "text": "this"}, {"type": "div", "text": "\nclass Connection {\n    fun Host.getConnectionString() {\n        toString()         // calls Host.toString()\n        this@Connection.toString()  // calls Connection.toString()\n    }\n}\n\n"}, {"type": "pre", "text": "class Connection {\n    fun Host.getConnectionString() {\n        toString()         // calls Host.toString()\n        this@Connection.toString()  // calls Connection.toString()\n    }\n}\n"}, {"type": "code", "text": "class Connection {\n    fun Host.getConnectionString() {\n        toString()         // calls Host.toString()\n        this@Connection.toString()  // calls Connection.toString()\n    }\n}\n"}, {"type": "p", "text": "Extensions declared as members can be declared as open and overridden in subclasses. This means that the dispatch of such\nfunctions is virtual with regard to the dispatch receiver type, but static with regard to the extension receiver type."}, {"type": "code", "text": "open"}, {"type": "div", "text": "\nopen class Base { }\n\nclass Derived : Base() { }\n\nopen class BaseCaller {\n    open fun Base.printFunctionInfo() {\n        println(\"Base extension function in BaseCaller\")\n    }\n\n    open fun Derived.printFunctionInfo() {\n        println(\"Derived extension function in BaseCaller\")\n    }\n\n    fun call(b: Base) {\n        b.printFunctionInfo()   // call the extension function\n    }\n}\n\nclass DerivedCaller: BaseCaller() {\n    override fun Base.printFunctionInfo() {\n        println(\"Base extension function in DerivedCaller\")\n    }\n\n    override fun Derived.printFunctionInfo() {\n        println(\"Derived extension function in DerivedCaller\")\n    }\n}\n\nfun main() {\n    BaseCaller().call(Base())   // \"Base extension function in BaseCaller\"\n    DerivedCaller().call(Base())  // \"Base extension function in DerivedCaller\" - dispatch receiver is resolved virtually\n    DerivedCaller().call(Derived())  // \"Base extension function in DerivedCaller\" - extension receiver is resolved statically\n}\n\n"}, {"type": "pre", "text": "open class Base { }\n\nclass Derived : Base() { }\n\nopen class BaseCaller {\n    open fun Base.printFunctionInfo() {\n        println(\"Base extension function in BaseCaller\")\n    }\n\n    open fun Derived.printFunctionInfo() {\n        println(\"Derived extension function in BaseCaller\")\n    }\n\n    fun call(b: Base) {\n        b.printFunctionInfo()   // call the extension function\n    }\n}\n\nclass DerivedCaller: BaseCaller() {\n    override fun Base.printFunctionInfo() {\n        println(\"Base extension function in DerivedCaller\")\n    }\n\n    override fun Derived.printFunctionInfo() {\n        println(\"Derived extension function in DerivedCaller\")\n    }\n}\n\nfun main() {\n    BaseCaller().call(Base())   // \"Base extension function in BaseCaller\"\n    DerivedCaller().call(Base())  // \"Base extension function in DerivedCaller\" - dispatch receiver is resolved virtually\n    DerivedCaller().call(Derived())  // \"Base extension function in DerivedCaller\" - extension receiver is resolved statically\n}\n"}, {"type": "code", "text": "open class Base { }\n\nclass Derived : Base() { }\n\nopen class BaseCaller {\n    open fun Base.printFunctionInfo() {\n        println(\"Base extension function in BaseCaller\")\n    }\n\n    open fun Derived.printFunctionInfo() {\n        println(\"Derived extension function in BaseCaller\")\n    }\n\n    fun call(b: Base) {\n        b.printFunctionInfo()   // call the extension function\n    }\n}\n\nclass DerivedCaller: BaseCaller() {\n    override fun Base.printFunctionInfo() {\n        println(\"Base extension function in DerivedCaller\")\n    }\n\n    override fun Derived.printFunctionInfo() {\n        println(\"Derived extension function in DerivedCaller\")\n    }\n}\n\nfun main() {\n    BaseCaller().call(Base())   // \"Base extension function in BaseCaller\"\n    DerivedCaller().call(Base())  // \"Base extension function in DerivedCaller\" - dispatch receiver is resolved virtually\n    DerivedCaller().call(Derived())  // \"Base extension function in DerivedCaller\" - extension receiver is resolved statically\n}\n"}, {"type": "h2", "text": "Note on visibility"}, {"type": "p", "text": "Extensions utilize the same visibility of other entities as regular functions declared in the same scope would. For example:"}, {"type": "a", "text": "visibility of other entities"}, {"type": "ul", "text": "\nAn extension declared on top level of a file has access to the other private top-level declarations in the same file;\nIf an extension is declared outside its receiver type, such an extension cannot access the receiver's private members.\n"}, {"type": "li", "text": "An extension declared on top level of a file has access to the other private top-level declarations in the same file;"}, {"type": "code", "text": "private"}, {"type": "li", "text": "If an extension is declared outside its receiver type, such an extension cannot access the receiver's private members."}, {"type": "code", "text": "private"}]