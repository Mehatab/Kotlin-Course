[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Interfaces"}, {"type": "p", "text": "Interfaces in Kotlin can contain declarations of abstract methods, as well as method\nimplementations. What makes them different from abstract classes is that interfaces cannot store state. They can have\nproperties but these need to be abstract or to provide accessor implementations."}, {"type": "p", "text": "An interface is defined using the keyword interface"}, {"type": "em", "text": "interface"}, {"type": "div", "text": "\ninterface MyInterface {\n    fun bar()\n    fun foo() {\n      // optional body\n    }\n}\n\n"}, {"type": "pre", "text": "interface MyInterface {\n    fun bar()\n    fun foo() {\n      // optional body\n    }\n}\n"}, {"type": "code", "text": "interface MyInterface {\n    fun bar()\n    fun foo() {\n      // optional body\n    }\n}\n"}, {"type": "h2", "text": "Implementing Interfaces"}, {"type": "p", "text": "A class or object can implement one or more interfaces"}, {"type": "div", "text": "\nclass Child : MyInterface {\n    override fun bar() {\n        // body\n    }\n}\n\n"}, {"type": "pre", "text": "class Child : MyInterface {\n    override fun bar() {\n        // body\n    }\n}\n"}, {"type": "code", "text": "class Child : MyInterface {\n    override fun bar() {\n        // body\n    }\n}\n"}, {"type": "h2", "text": "Properties in Interfaces"}, {"type": "p", "text": "You can declare properties in interfaces. A property declared in an interface can either be abstract, or it can provide\nimplementations for accessors. Properties declared in interfaces can't have backing fields, and therefore accessors\ndeclared in interfaces can't reference them."}, {"type": "div", "text": "\ninterface MyInterface {\n    val prop: Int // abstract\n\n    val propertyWithImplementation: String\n        get() = \"foo\"\n\n    fun foo() {\n        print(prop)\n    }\n}\n\nclass Child : MyInterface {\n    override val prop: Int = 29\n}\n\n"}, {"type": "pre", "text": "interface MyInterface {\n    val prop: Int // abstract\n\n    val propertyWithImplementation: String\n        get() = \"foo\"\n\n    fun foo() {\n        print(prop)\n    }\n}\n\nclass Child : MyInterface {\n    override val prop: Int = 29\n}\n"}, {"type": "code", "text": "interface MyInterface {\n    val prop: Int // abstract\n\n    val propertyWithImplementation: String\n        get() = \"foo\"\n\n    fun foo() {\n        print(prop)\n    }\n}\n\nclass Child : MyInterface {\n    override val prop: Int = 29\n}\n"}, {"type": "h2", "text": "Interfaces Inheritance"}, {"type": "p", "text": "An interface can derive from other interfaces and thus both provide implementations for their members and declare new functions and properties. Quite naturally, classes implementing such an interface are only required to define the missing implementations:"}, {"type": "div", "text": "\ninterface Named {\n    val name: String\n}\n\ninterface Person : Named {\n    val firstName: String\n    val lastName: String\n    \n    override val name: String get() = \"$firstName $lastName\"\n}\n\ndata class Employee(\n    // implementing 'name' is not required\n    override val firstName: String,\n    override val lastName: String,\n    val position: Position\n) : Person\n\n"}, {"type": "pre", "text": "interface Named {\n    val name: String\n}\n\ninterface Person : Named {\n    val firstName: String\n    val lastName: String\n    \n    override val name: String get() = \"$firstName $lastName\"\n}\n\ndata class Employee(\n    // implementing 'name' is not required\n    override val firstName: String,\n    override val lastName: String,\n    val position: Position\n) : Person\n"}, {"type": "code", "text": "interface Named {\n    val name: String\n}\n\ninterface Person : Named {\n    val firstName: String\n    val lastName: String\n    \n    override val name: String get() = \"$firstName $lastName\"\n}\n\ndata class Employee(\n    // implementing 'name' is not required\n    override val firstName: String,\n    override val lastName: String,\n    val position: Position\n) : Person\n"}, {"type": "h2", "text": "Resolving overriding conflicts"}, {"type": "p", "text": "When we declare many types in our supertype list, it may appear that we inherit more than one implementation of the same method. For example"}, {"type": "div", "text": "\ninterface A {\n    fun foo() { print(\"A\") }\n    fun bar()\n}\n\ninterface B {\n    fun foo() { print(\"B\") }\n    fun bar() { print(\"bar\") }\n}\n\nclass C : A {\n    override fun bar() { print(\"bar\") }\n}\n\nclass D : A, B {\n    override fun foo() {\n        super<A>.foo()\n        super<B>.foo()\n    }\n\n    override fun bar() {\n        super<B>.bar()\n    }\n}\n\n"}, {"type": "pre", "text": "interface A {\n    fun foo() { print(\"A\") }\n    fun bar()\n}\n\ninterface B {\n    fun foo() { print(\"B\") }\n    fun bar() { print(\"bar\") }\n}\n\nclass C : A {\n    override fun bar() { print(\"bar\") }\n}\n\nclass D : A, B {\n    override fun foo() {\n        super<A>.foo()\n        super<B>.foo()\n    }\n\n    override fun bar() {\n        super<B>.bar()\n    }\n}\n"}, {"type": "code", "text": "interface A {\n    fun foo() { print(\"A\") }\n    fun bar()\n}\n\ninterface B {\n    fun foo() { print(\"B\") }\n    fun bar() { print(\"bar\") }\n}\n\nclass C : A {\n    override fun bar() { print(\"bar\") }\n}\n\nclass D : A, B {\n    override fun foo() {\n        super<A>.foo()\n        super<B>.foo()\n    }\n\n    override fun bar() {\n        super<B>.bar()\n    }\n}\n"}, {"type": "p", "text": "Interfaces A and B both declare functions foo() and bar(). Both of them implement foo(), but only B implements bar() (bar() is not marked abstract in A,\nbecause this is the default for interfaces, if the function has no body). Now, if we derive a concrete class C from A, we, obviously, have to override bar() and provide\nan implementation."}, {"type": "em", "text": "A"}, {"type": "em", "text": "B"}, {"type": "em", "text": "foo()"}, {"type": "em", "text": "bar()"}, {"type": "em", "text": "foo()"}, {"type": "em", "text": "B"}, {"type": "em", "text": "bar()"}, {"type": "em", "text": "bar()"}, {"type": "em", "text": "A"}, {"type": "em", "text": "C"}, {"type": "em", "text": "A"}, {"type": "em", "text": "bar()"}, {"type": "p", "text": "However, if we derive D from A and B, we need to implement all the methods which we have\ninherited from multiple interfaces, and to specify how exactly D should implement them. This rule applies\nboth to methods for which we've inherited a single implementation (bar()) and multiple implementations (foo())."}, {"type": "em", "text": "D"}, {"type": "em", "text": "A"}, {"type": "em", "text": "B"}, {"type": "em", "text": "D"}, {"type": "em", "text": "bar()"}, {"type": "em", "text": "foo()"}]