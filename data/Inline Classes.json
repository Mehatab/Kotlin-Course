[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Inline classes"}, {"type": "blockquote", "text": "\nInline classes are available only since Kotlin 1.3 and currently are experimental. See details below\n"}, {"type": "p", "text": "Inline classes are available only since Kotlin 1.3 and currently are experimental. See details below"}, {"type": "em", "text": "experimental"}, {"type": "a", "text": "below"}, {"type": "p", "text": "Sometimes it is necessary for business logic to create a wrapper around some type. However, it introduces runtime overhead due to additional heap allocations. Moreover, if the wrapped type is primitive, the performance hit is terrible, because primitive types are usually heavily optimized by the runtime, while their wrappers don't get any special treatment."}, {"type": "p", "text": "To solve such issues, Kotlin introduces a special kind of class called an inline class, which is declared by placing an inline modifier before the name of the class:"}, {"type": "code", "text": "inline class"}, {"type": "code", "text": "inline"}, {"type": "div", "text": "\ninline class Password(val value: String)\n\n"}, {"type": "pre", "text": "inline class Password(val value: String)\n"}, {"type": "code", "text": "inline class Password(val value: String)\n"}, {"type": "p", "text": "An inline class must have a single property initialized in the primary constructor. At runtime, instances of the inline class will be represented using this single property (see details about runtime representation below):"}, {"type": "a", "text": "below"}, {"type": "div", "text": "\n// No actual instantiation of class 'Password' happens\n// At runtime 'securePassword' contains just 'String'\nval securePassword = Password(\"Don't try this in production\") \n\n"}, {"type": "pre", "text": "// No actual instantiation of class 'Password' happens\n// At runtime 'securePassword' contains just 'String'\nval securePassword = Password(\"Don't try this in production\") \n"}, {"type": "code", "text": "// No actual instantiation of class 'Password' happens\n// At runtime 'securePassword' contains just 'String'\nval securePassword = Password(\"Don't try this in production\") \n"}, {"type": "p", "text": "This is the main feature of inline classes, which inspired the name \"inline\": data of the class is \"inlined\" into its usages (similar to how content of inline functions is inlined to call sites)."}, {"type": "a", "text": "inline functions"}, {"type": "h2", "text": "Members"}, {"type": "p", "text": "Inline classes support some functionality of regular classes. In particular, they are allowed to declare properties and functions:"}, {"type": "div", "text": "\ninline class Name(val s: String) {\n    val length: Int\n        get() = s.length\n\n    fun greet() {\n        println(\"Hello, $s\")\n    }\n}    \n\nfun main() {\n    val name = Name(\"Kotlin\")\n    name.greet() // method `greet` is called as a static method\n    println(name.length) // property getter is called as a static method\n}\n\n"}, {"type": "pre", "text": "inline class Name(val s: String) {\n    val length: Int\n        get() = s.length\n\n    fun greet() {\n        println(\"Hello, $s\")\n    }\n}    \n\nfun main() {\n    val name = Name(\"Kotlin\")\n    name.greet() // method `greet` is called as a static method\n    println(name.length) // property getter is called as a static method\n}\n"}, {"type": "code", "text": "inline class Name(val s: String) {\n    val length: Int\n        get() = s.length\n\n    fun greet() {\n        println(\"Hello, $s\")\n    }\n}    \n\nfun main() {\n    val name = Name(\"Kotlin\")\n    name.greet() // method `greet` is called as a static method\n    println(name.length) // property getter is called as a static method\n}\n"}, {"type": "p", "text": "However, there are some restrictions for inline class members:"}, {"type": "ul", "text": "\ninline classes cannot have init blocks\ninline class properties cannot have backing fields\n\nit follows that inline classes can only have simple computable properties (no lateinit/delegated properties)\n\n\n"}, {"type": "li", "text": "inline classes cannot have init blocks"}, {"type": "em", "text": "init"}, {"type": "li", "text": "inline class properties cannot have backing fields\n\nit follows that inline classes can only have simple computable properties (no lateinit/delegated properties)\n\n"}, {"type": "a", "text": "backing fields"}, {"type": "ul", "text": "\nit follows that inline classes can only have simple computable properties (no lateinit/delegated properties)\n"}, {"type": "li", "text": "it follows that inline classes can only have simple computable properties (no lateinit/delegated properties)"}, {"type": "h2", "text": "Inheritance"}, {"type": "p", "text": "Inline classes are allowed to inherit from interfaces:"}, {"type": "div", "text": "\ninterface Printable {\n    fun prettyPrint(): String\n}\n\ninline class Name(val s: String) : Printable {\n    override fun prettyPrint(): String = \"Let's $s!\"\n}    \n\nfun main() {\n    val name = Name(\"Kotlin\")\n    println(name.prettyPrint()) // Still called as a static method\n}\n\n"}, {"type": "pre", "text": "interface Printable {\n    fun prettyPrint(): String\n}\n\ninline class Name(val s: String) : Printable {\n    override fun prettyPrint(): String = \"Let's $s!\"\n}    \n\nfun main() {\n    val name = Name(\"Kotlin\")\n    println(name.prettyPrint()) // Still called as a static method\n}\n"}, {"type": "code", "text": "interface Printable {\n    fun prettyPrint(): String\n}\n\ninline class Name(val s: String) : Printable {\n    override fun prettyPrint(): String = \"Let's $s!\"\n}    \n\nfun main() {\n    val name = Name(\"Kotlin\")\n    println(name.prettyPrint()) // Still called as a static method\n}\n"}, {"type": "p", "text": "It is forbidden for inline classes to participate in a class hierarchy. This means that inline classes cannot extend other classes and must be final."}, {"type": "em", "text": "final"}, {"type": "h2", "text": "Representation"}, {"type": "p", "text": "In generated code, the Kotlin compiler keeps a wrapper for each inline class. Inline class instances can be represented at runtime either as wrappers or as the underlying type. This is similar to how Int can be represented either as a primitive int or as the wrapper Integer."}, {"type": "em", "text": "wrapper"}, {"type": "code", "text": "Int"}, {"type": "a", "text": "represented"}, {"type": "code", "text": "int"}, {"type": "code", "text": "Integer"}, {"type": "p", "text": "The Kotlin compiler will prefer using underlying types instead of wrappers to produce the most performant and optimized code. However, sometimes it is necessary to keep wrappers around. As a rule of thumb, inline classes are boxed whenever they are used as another type."}, {"type": "div", "text": "\ninterface I\n\ninline class Foo(val i: Int) : I\n\nfun asInline(f: Foo) {}\nfun <T> asGeneric(x: T) {}\nfun asInterface(i: I) {}\nfun asNullable(i: Foo?) {}\n\nfun <T> id(x: T): T = x\n\nfun main() {\n    val f = Foo(42) \n    \n    asInline(f)    // unboxed: used as Foo itself\n    asGeneric(f)   // boxed: used as generic type T\n    asInterface(f) // boxed: used as type I\n    asNullable(f)  // boxed: used as Foo?, which is different from Foo\n    \n    // below, 'f' first is boxed (while being passed to 'id') and then unboxed (when returned from 'id') \n    // In the end, 'c' contains unboxed representation (just '42'), as 'f' \n    val c = id(f)  \n}\n\n"}, {"type": "pre", "text": "interface I\n\ninline class Foo(val i: Int) : I\n\nfun asInline(f: Foo) {}\nfun <T> asGeneric(x: T) {}\nfun asInterface(i: I) {}\nfun asNullable(i: Foo?) {}\n\nfun <T> id(x: T): T = x\n\nfun main() {\n    val f = Foo(42) \n    \n    asInline(f)    // unboxed: used as Foo itself\n    asGeneric(f)   // boxed: used as generic type T\n    asInterface(f) // boxed: used as type I\n    asNullable(f)  // boxed: used as Foo?, which is different from Foo\n    \n    // below, 'f' first is boxed (while being passed to 'id') and then unboxed (when returned from 'id') \n    // In the end, 'c' contains unboxed representation (just '42'), as 'f' \n    val c = id(f)  \n}\n"}, {"type": "code", "text": "interface I\n\ninline class Foo(val i: Int) : I\n\nfun asInline(f: Foo) {}\nfun <T> asGeneric(x: T) {}\nfun asInterface(i: I) {}\nfun asNullable(i: Foo?) {}\n\nfun <T> id(x: T): T = x\n\nfun main() {\n    val f = Foo(42) \n    \n    asInline(f)    // unboxed: used as Foo itself\n    asGeneric(f)   // boxed: used as generic type T\n    asInterface(f) // boxed: used as type I\n    asNullable(f)  // boxed: used as Foo?, which is different from Foo\n    \n    // below, 'f' first is boxed (while being passed to 'id') and then unboxed (when returned from 'id') \n    // In the end, 'c' contains unboxed representation (just '42'), as 'f' \n    val c = id(f)  \n}\n"}, {"type": "p", "text": "Because inline classes may be represented both as the underlying value and as a wrapper, referential equality is pointless for them and is therefore prohibited."}, {"type": "a", "text": "referential equality"}, {"type": "h3", "text": "Mangling"}, {"type": "p", "text": "Since inline classes are compiled to their underlying type, it may lead to various obscure errors, for example unexpected platform signature clashes:"}, {"type": "div", "text": "\ninline class UInt(val x: Int)\n\n// Represented as 'public final void compute(int x)' on the JVM\nfun compute(x: Int) { }\n\n// Also represented as 'public final void compute(int x)' on the JVM!\nfun compute(x: UInt) { }\n\n"}, {"type": "pre", "text": "inline class UInt(val x: Int)\n\n// Represented as 'public final void compute(int x)' on the JVM\nfun compute(x: Int) { }\n\n// Also represented as 'public final void compute(int x)' on the JVM!\nfun compute(x: UInt) { }\n"}, {"type": "code", "text": "inline class UInt(val x: Int)\n\n// Represented as 'public final void compute(int x)' on the JVM\nfun compute(x: Int) { }\n\n// Also represented as 'public final void compute(int x)' on the JVM!\nfun compute(x: UInt) { }\n"}, {"type": "p", "text": "To mitigate such issues, functions using inline classes are mangled by adding some stable hashcode to the function name. Therefore, fun compute(x: UInt) will be represented as public final void compute-<hashcode>(int x), which solves the clash problem."}, {"type": "em", "text": "mangled"}, {"type": "code", "text": "fun compute(x: UInt)"}, {"type": "code", "text": "public final void compute-<hashcode>(int x)"}, {"type": "blockquote", "text": "\nNote that - is an invalid symbol in Java, meaning that it's impossible to call functions which accept inline classes from Java.\n"}, {"type": "p", "text": "Note that - is an invalid symbol in Java, meaning that it's impossible to call functions which accept inline classes from Java."}, {"type": "code", "text": "-"}, {"type": "em", "text": "invalid"}, {"type": "h2", "text": "Inline classes vs type aliases"}, {"type": "p", "text": "At first sight, inline classes may appear to be very similar to type aliases. Indeed, both seem to introduce a new type and both will be represented as the underlying type at runtime."}, {"type": "a", "text": "type aliases"}, {"type": "p", "text": "However, the crucial difference is that type aliases are assignment-compatible with their underlying type (and with other type aliases with the same underlying type), while inline classes are not."}, {"type": "em", "text": "assignment-compatible"}, {"type": "p", "text": "In other words, inline classes introduce a truly new type, contrary to type aliases which only introduce an alternative name (alias) for an existing type:"}, {"type": "em", "text": "new"}, {"type": "div", "text": "\ntypealias NameTypeAlias = String\ninline class NameInlineClass(val s: String)\n\nfun acceptString(s: String) {}\nfun acceptNameTypeAlias(n: NameTypeAlias) {}\nfun acceptNameInlineClass(p: NameInlineClass) {}\n\nfun main() {\n    val nameAlias: NameTypeAlias = \"\"\n    val nameInlineClass: NameInlineClass = NameInlineClass(\"\")\n    val string: String = \"\"\n\n    acceptString(nameAlias) // OK: pass alias instead of underlying type\n    acceptString(nameInlineClass) // Not OK: can't pass inline class instead of underlying type\n\n    // And vice versa:\n    acceptNameTypeAlias(string) // OK: pass underlying type instead of alias\n    acceptNameInlineClass(string) // Not OK: can't pass underlying type instead of inline class\n}\n\n"}, {"type": "pre", "text": "typealias NameTypeAlias = String\ninline class NameInlineClass(val s: String)\n\nfun acceptString(s: String) {}\nfun acceptNameTypeAlias(n: NameTypeAlias) {}\nfun acceptNameInlineClass(p: NameInlineClass) {}\n\nfun main() {\n    val nameAlias: NameTypeAlias = \"\"\n    val nameInlineClass: NameInlineClass = NameInlineClass(\"\")\n    val string: String = \"\"\n\n    acceptString(nameAlias) // OK: pass alias instead of underlying type\n    acceptString(nameInlineClass) // Not OK: can't pass inline class instead of underlying type\n\n    // And vice versa:\n    acceptNameTypeAlias(string) // OK: pass underlying type instead of alias\n    acceptNameInlineClass(string) // Not OK: can't pass underlying type instead of inline class\n}\n"}, {"type": "code", "text": "typealias NameTypeAlias = String\ninline class NameInlineClass(val s: String)\n\nfun acceptString(s: String) {}\nfun acceptNameTypeAlias(n: NameTypeAlias) {}\nfun acceptNameInlineClass(p: NameInlineClass) {}\n\nfun main() {\n    val nameAlias: NameTypeAlias = \"\"\n    val nameInlineClass: NameInlineClass = NameInlineClass(\"\")\n    val string: String = \"\"\n\n    acceptString(nameAlias) // OK: pass alias instead of underlying type\n    acceptString(nameInlineClass) // Not OK: can't pass inline class instead of underlying type\n\n    // And vice versa:\n    acceptNameTypeAlias(string) // OK: pass underlying type instead of alias\n    acceptNameInlineClass(string) // Not OK: can't pass underlying type instead of inline class\n}\n"}, {"type": "h2", "text": "Experimental status of inline classes"}, {"type": "p", "text": "The design of inline classes is experimental, meaning that this feature is moving fast and no compatibility guarantees are given. When using inline classes in Kotlin 1.3+, a warning will be reported, indicating that this feature is experimental."}, {"type": "em", "text": "moving fast"}, {"type": "p", "text": "To remove the warning you have to opt in to the usage of this experimental feature by passing the compiler argument -Xinline-classes."}, {"type": "code", "text": "-Xinline-classes"}, {"type": "h3", "text": "Enabling inline classes in Gradle"}, {"type": "div", "text": "\n\ncompileKotlin {\n    kotlinOptions.freeCompilerArgs += [\"-Xinline-classes\"]\n}\n\n\n"}, {"type": "div", "text": "\ncompileKotlin {\n    kotlinOptions.freeCompilerArgs += [\"-Xinline-classes\"]\n}\n\n"}, {"type": "pre", "text": "compileKotlin {\n    kotlinOptions.freeCompilerArgs += [\"-Xinline-classes\"]\n}\n"}, {"type": "code", "text": "compileKotlin {\n    kotlinOptions.freeCompilerArgs += [\"-Xinline-classes\"]\n}\n"}, {"type": "div", "text": "\n\ntasks.withType<KotlinCompile> {\n    kotlinOptions.freeCompilerArgs += \"-Xinline-classes\"\n}\n\n\n"}, {"type": "div", "text": "\ntasks.withType<KotlinCompile> {\n    kotlinOptions.freeCompilerArgs += \"-Xinline-classes\"\n}\n\n"}, {"type": "pre", "text": "tasks.withType<KotlinCompile> {\n    kotlinOptions.freeCompilerArgs += \"-Xinline-classes\"\n}\n"}, {"type": "code", "text": "tasks.withType<KotlinCompile> {\n    kotlinOptions.freeCompilerArgs += \"-Xinline-classes\"\n}\n"}, {"type": "p", "text": "See Compiler options in Gradle for details. For Multiplatform Projects settings, see building Multiplatform Projects with Gradle section."}, {"type": "a", "text": "Compiler options in Gradle"}, {"type": "a", "text": "Multiplatform Projects"}, {"type": "a", "text": "building Multiplatform Projects with Gradle"}, {"type": "h3", "text": "Enabling inline classes in Maven"}, {"type": "div", "text": "\n<configuration>\n    <args>\n        <arg>-Xinline-classes</arg> \n    </args>\n</configuration>\n\n"}, {"type": "pre", "text": "<configuration>\n    <args>\n        <arg>-Xinline-classes</arg> \n    </args>\n</configuration>\n"}, {"type": "code", "text": "<configuration>\n    <args>\n        <arg>-Xinline-classes</arg> \n    </args>\n</configuration>\n"}, {"type": "p", "text": "See Compiler options in Maven for details."}, {"type": "a", "text": "Compiler options in Maven"}, {"type": "h2", "text": "Further discussion"}, {"type": "p", "text": "See this language proposal for inline classes for other technical details and discussion."}, {"type": "a", "text": "language proposal for inline classes"}]