[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Calling Kotlin from JavaScript"}, {"type": "p", "text": "Kotlin compiler generates normal JavaScript classes, functions and properties you can freely use from\nJavaScript code. Nevertheless, there are some subtle things you should remember."}, {"type": "h2", "text": "Isolating declarations in a separate JavaScript object"}, {"type": "p", "text": "To prevent spoiling the global object, Kotlin creates an object that contains all Kotlin declarations\nfrom the current module. So if you name your module as myModule, all declarations are available to JavaScript\nvia myModule object. For example:"}, {"type": "code", "text": "myModule"}, {"type": "code", "text": "myModule"}, {"type": "div", "text": "\nfun foo() = \"Hello\"\n\n"}, {"type": "pre", "text": "fun foo() = \"Hello\"\n"}, {"type": "code", "text": "fun foo() = \"Hello\"\n"}, {"type": "p", "text": "Can be called from JavaScript like this:"}, {"type": "div", "text": "\nalert(myModule.foo());\n\n"}, {"type": "pre", "text": "alert(myModule.foo());\n"}, {"type": "code", "text": "alert(myModule.foo());\n"}, {"type": "p", "text": "This is not applicable when you compile your Kotlin module to JavaScript module (see JavaScript Modules for more information on this).\nIn this case there won't be a wrapper object, instead, declarations will be exposed as a JavaScript module of a corresponding kind. For example,\nin case of CommonJS you should write:"}, {"type": "a", "text": "JavaScript Modules"}, {"type": "div", "text": "\nalert(require('myModule').foo());\n\n"}, {"type": "pre", "text": "alert(require('myModule').foo());\n"}, {"type": "code", "text": "alert(require('myModule').foo());\n"}, {"type": "h2", "text": "Package structure"}, {"type": "p", "text": "Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package,\nyou have to use fully-qualified names in JavaScript. For example:"}, {"type": "div", "text": "\npackage my.qualified.packagename\n\nfun foo() = \"Hello\"\n\n"}, {"type": "pre", "text": "package my.qualified.packagename\n\nfun foo() = \"Hello\"\n"}, {"type": "code", "text": "package my.qualified.packagename\n\nfun foo() = \"Hello\"\n"}, {"type": "p", "text": "Can be called from JavaScript like this:"}, {"type": "div", "text": "\nalert(myModule.my.qualified.packagename.foo());\n\n"}, {"type": "pre", "text": "alert(myModule.my.qualified.packagename.foo());\n"}, {"type": "code", "text": "alert(myModule.my.qualified.packagename.foo());\n"}, {"type": "h3", "text": "@JsName annotation"}, {"type": "code", "text": "@JsName"}, {"type": "p", "text": "In some cases (for example, to support overloads), Kotlin compiler mangles names of generated functions and attributes\nin JavaScript code. To control the generated names, you can use the @JsName annotation:"}, {"type": "code", "text": "@JsName"}, {"type": "div", "text": "\n// Module 'kjs'\nclass Person(val name: String) {\n    fun hello() {\n        println(\"Hello $name!\")\n    }\n\n    @JsName(\"helloWithGreeting\")\n    fun hello(greeting: String) {\n        println(\"$greeting $name!\")\n    }\n}\n\n"}, {"type": "pre", "text": "// Module 'kjs'\nclass Person(val name: String) {\n    fun hello() {\n        println(\"Hello $name!\")\n    }\n\n    @JsName(\"helloWithGreeting\")\n    fun hello(greeting: String) {\n        println(\"$greeting $name!\")\n    }\n}\n"}, {"type": "code", "text": "// Module 'kjs'\nclass Person(val name: String) {\n    fun hello() {\n        println(\"Hello $name!\")\n    }\n\n    @JsName(\"helloWithGreeting\")\n    fun hello(greeting: String) {\n        println(\"$greeting $name!\")\n    }\n}\n"}, {"type": "p", "text": "Now you can use this class from JavaScript in the following way:"}, {"type": "div", "text": "\nvar person = new kjs.Person(\"Dmitry\");   // refers to module 'kjs'\nperson.hello();                          // prints \"Hello Dmitry!\"\nperson.helloWithGreeting(\"Servus\");      // prints \"Servus Dmitry!\"\n\n"}, {"type": "pre", "text": "var person = new kjs.Person(\"Dmitry\");   // refers to module 'kjs'\nperson.hello();                          // prints \"Hello Dmitry!\"\nperson.helloWithGreeting(\"Servus\");      // prints \"Servus Dmitry!\"\n"}, {"type": "code", "text": "var person = new kjs.Person(\"Dmitry\");   // refers to module 'kjs'\nperson.hello();                          // prints \"Hello Dmitry!\"\nperson.helloWithGreeting(\"Servus\");      // prints \"Servus Dmitry!\"\n"}, {"type": "p", "text": "If we didn't specify the @JsName annotation, the name of the corresponding function would contain a suffix\ncalculated from the function signature, for example hello_61zpoe$."}, {"type": "code", "text": "@JsName"}, {"type": "code", "text": "hello_61zpoe$"}, {"type": "p", "text": "Note that Kotlin compiler does not apply such mangling to external declarations, so you don't have to\nuse @JsName on them. Another case worth noticing is inheriting non-external classes from external classes.\nIn this case any overridden functions won't be mangled as well."}, {"type": "code", "text": "external"}, {"type": "code", "text": "@JsName"}, {"type": "p", "text": "The parameter of @JsName is required to be a constant string literal which is a valid identifier.\nThe compiler will report an error on any attempt to pass non-identifier string to @JsName.\nThe following example produces a compile-time error:"}, {"type": "code", "text": "@JsName"}, {"type": "code", "text": "@JsName"}, {"type": "div", "text": "\n@JsName(\"new C()\")   // error here\nexternal fun newC()\n\n"}, {"type": "pre", "text": "@JsName(\"new C()\")   // error here\nexternal fun newC()\n"}, {"type": "code", "text": "@JsName(\"new C()\")   // error here\nexternal fun newC()\n"}, {"type": "h2", "text": "Representing Kotlin types in JavaScript"}, {"type": "ul", "text": "\nKotlin numeric types, except for kotlin.Long are mapped to JavaScript Number.\nkotlin.Char is mapped to JavaScript Number representing character code.\nKotlin can't distinguish between numeric types at run time (except for kotlin.Long), i.e. the following code works:\n    \nfun f() {\n    val x: Int = 23\n    val y: Any = x\n    println(y as Float)\n}\n\n\n\nKotlin preserves overflow semantics for kotlin.Int, kotlin.Byte, kotlin.Short, kotlin.Char and kotlin.Long.\nThere's no 64 bit integer number in JavaScript, so kotlin.Long is not mapped to any JavaScript object,\nit's emulated by a Kotlin class.\nkotlin.String is mapped to JavaScript String.\nkotlin.Any is mapped to JavaScript Object (i.e. new Object(), {}, etc).\nkotlin.Array is mapped to JavaScript Array.\nKotlin collections (i.e. List, Set, Map, etc) are not mapped to any specific JavaScript type.\nkotlin.Throwable is mapped to JavaScript Error.\nKotlin preserves lazy object initialization in JavaScript.\nKotlin does not implement lazy initialization of top-level properties in JavaScript.\n"}, {"type": "li", "text": "Kotlin numeric types, except for kotlin.Long are mapped to JavaScript Number."}, {"type": "code", "text": "kotlin.Long"}, {"type": "li", "text": "kotlin.Char is mapped to JavaScript Number representing character code."}, {"type": "code", "text": "kotlin.Char"}, {"type": "li", "text": "Kotlin can't distinguish between numeric types at run time (except for kotlin.Long), i.e. the following code works:\n    \nfun f() {\n    val x: Int = 23\n    val y: Any = x\n    println(y as Float)\n}\n\n\n"}, {"type": "code", "text": "kotlin.Long"}, {"type": "div", "text": "\nfun f() {\n    val x: Int = 23\n    val y: Any = x\n    println(y as Float)\n}\n\n"}, {"type": "pre", "text": "fun f() {\n    val x: Int = 23\n    val y: Any = x\n    println(y as Float)\n}\n"}, {"type": "code", "text": "fun f() {\n    val x: Int = 23\n    val y: Any = x\n    println(y as Float)\n}\n"}, {"type": "li", "text": "Kotlin preserves overflow semantics for kotlin.Int, kotlin.Byte, kotlin.Short, kotlin.Char and kotlin.Long."}, {"type": "code", "text": "kotlin.Int"}, {"type": "code", "text": "kotlin.Byte"}, {"type": "code", "text": "kotlin.Short"}, {"type": "code", "text": "kotlin.Char"}, {"type": "code", "text": "kotlin.Long"}, {"type": "li", "text": "There's no 64 bit integer number in JavaScript, so kotlin.Long is not mapped to any JavaScript object,\nit's emulated by a Kotlin class."}, {"type": "code", "text": "kotlin.Long"}, {"type": "li", "text": "kotlin.String is mapped to JavaScript String."}, {"type": "code", "text": "kotlin.String"}, {"type": "li", "text": "kotlin.Any is mapped to JavaScript Object (i.e. new Object(), {}, etc)."}, {"type": "code", "text": "kotlin.Any"}, {"type": "code", "text": "new Object()"}, {"type": "code", "text": "{}"}, {"type": "li", "text": "kotlin.Array is mapped to JavaScript Array."}, {"type": "code", "text": "kotlin.Array"}, {"type": "li", "text": "Kotlin collections (i.e. List, Set, Map, etc) are not mapped to any specific JavaScript type."}, {"type": "code", "text": "List"}, {"type": "code", "text": "Set"}, {"type": "code", "text": "Map"}, {"type": "li", "text": "kotlin.Throwable is mapped to JavaScript Error."}, {"type": "code", "text": "kotlin.Throwable"}, {"type": "li", "text": "Kotlin preserves lazy object initialization in JavaScript."}, {"type": "li", "text": "Kotlin does not implement lazy initialization of top-level properties in JavaScript."}, {"type": "p", "text": "Starting with version 1.1.50 primitive array translation utilizes JavaScript TypedArray:"}, {"type": "ul", "text": "\nkotlin.ByteArray, -.ShortArray, -.IntArray, -.FloatArray, and -.DoubleArray are mapped to\n JavaScript Int8Array, Int16Array, Int32Array, Float32Array, and Float64Array correspondingly.\nkotlin.BooleanArray is mapped to JavaScript Int8Array with a property $type$ == \"BooleanArray\"\nkotlin.CharArray is mapped to JavaScript UInt16Array with a property $type$ == \"CharArray\"\nkotlin.LongArray is mapped to JavaScript Array of kotlin.Long with a property $type$ == \"LongArray\".\n"}, {"type": "li", "text": "kotlin.ByteArray, -.ShortArray, -.IntArray, -.FloatArray, and -.DoubleArray are mapped to\n JavaScript Int8Array, Int16Array, Int32Array, Float32Array, and Float64Array correspondingly."}, {"type": "code", "text": "kotlin.ByteArray"}, {"type": "code", "text": "-.ShortArray"}, {"type": "code", "text": "-.IntArray"}, {"type": "code", "text": "-.FloatArray"}, {"type": "code", "text": "-.DoubleArray"}, {"type": "li", "text": "kotlin.BooleanArray is mapped to JavaScript Int8Array with a property $type$ == \"BooleanArray\""}, {"type": "code", "text": "kotlin.BooleanArray"}, {"type": "code", "text": "$type$ == \"BooleanArray\""}, {"type": "li", "text": "kotlin.CharArray is mapped to JavaScript UInt16Array with a property $type$ == \"CharArray\""}, {"type": "code", "text": "kotlin.CharArray"}, {"type": "code", "text": "$type$ == \"CharArray\""}, {"type": "li", "text": "kotlin.LongArray is mapped to JavaScript Array of kotlin.Long with a property $type$ == \"LongArray\"."}, {"type": "code", "text": "kotlin.LongArray"}, {"type": "code", "text": "kotlin.Long"}, {"type": "code", "text": "$type$ == \"LongArray\""}]