[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Higher-Order Functions and Lambdas"}, {"type": "p", "text": "Kotlin functions are first-class, which means that they can \nbe stored in variables and data structures, passed as arguments to and returned from other \nhigher-order functions. You can operate with functions in any way that is possible for other \nnon-function values."}, {"type": "a", "text": "first-class"}, {"type": "em", "text": "first-class"}, {"type": "a", "text": "higher-order functions"}, {"type": "p", "text": "To facilitate this, Kotlin, as a statically typed programming language, uses a family of \nfunction types to represent functions and provides a set of specialized language constructs, such as lambda expressions."}, {"type": "a", "text": "function types"}, {"type": "a", "text": "lambda expressions"}, {"type": "h2", "text": "Higher-Order Functions"}, {"type": "p", "text": "A higher-order function is a function that takes functions as parameters, or returns a function."}, {"type": "p", "text": "A good example is the functional programming idiom fold \nfor collections, which takes an initial accumulator value and a combining function and builds its return value by \nconsecutively combining current accumulator value with each collection element, replacing the accumulator:"}, {"type": "a", "text": "functional programming idiom fold"}, {"type": "code", "text": "fold"}, {"type": "div", "text": "\nfun <T, R> Collection<T>.fold(\n    initial: R, \n    combine: (acc: R, nextElement: T) -> R\n): R {\n    var accumulator: R = initial\n    for (element: T in this) {\n        accumulator = combine(accumulator, element)\n    }\n    return accumulator\n}\n\n"}, {"type": "pre", "text": "fun <T, R> Collection<T>.fold(\n    initial: R, \n    combine: (acc: R, nextElement: T) -> R\n): R {\n    var accumulator: R = initial\n    for (element: T in this) {\n        accumulator = combine(accumulator, element)\n    }\n    return accumulator\n}\n"}, {"type": "code", "text": "fun <T, R> Collection<T>.fold(\n    initial: R, \n    combine: (acc: R, nextElement: T) -> R\n): R {\n    var accumulator: R = initial\n    for (element: T in this) {\n        accumulator = combine(accumulator, element)\n    }\n    return accumulator\n}\n"}, {"type": "p", "text": "In the code above, the parameter combine has a function type (R, T) -> R, so it accepts a function that \ntakes two arguments of types R and T and returns a value of type R. \nIt is invoked inside the for-loop, and the return value is \nthen assigned to accumulator."}, {"type": "code", "text": "combine"}, {"type": "a", "text": "function type"}, {"type": "code", "text": "(R, T) -> R"}, {"type": "code", "text": "R"}, {"type": "code", "text": "T"}, {"type": "code", "text": "R"}, {"type": "a", "text": "invoked"}, {"type": "em", "text": "for"}, {"type": "code", "text": "accumulator"}, {"type": "p", "text": "To call fold, we need to pass it an instance of the function type as an argument, and lambda expressions (described in more detail below) are widely used for \nthis purpose at higher-order function call sites:"}, {"type": "code", "text": "fold"}, {"type": "a", "text": "instance of the function type"}, {"type": "a", "text": "described in more detail below"}, {"type": "div", "text": "\nfun main() {\n    //sampleStart\n    val items = listOf(1, 2, 3, 4, 5)\n    \n    // Lambdas are code blocks enclosed in curly braces.\n    items.fold(0, { \n        // When a lambda has parameters, they go first, followed by '->'\n        acc: Int, i: Int -> \n        print(\"acc = $acc, i = $i, \") \n        val result = acc + i\n        println(\"result = $result\")\n        // The last expression in a lambda is considered the return value:\n        result\n    })\n    \n    // Parameter types in a lambda are optional if they can be inferred:\n    val joinedToString = items.fold(\"Elements:\", { acc, i -> acc + \" \" + i })\n    \n    // Function references can also be used for higher-order function calls:\n    val product = items.fold(1, Int::times)\n    //sampleEnd\n    println(\"joinedToString = $joinedToString\")\n    println(\"product = $product\")\n}\n\n"}, {"type": "pre", "text": "fun main() {\n    //sampleStart\n    val items = listOf(1, 2, 3, 4, 5)\n    \n    // Lambdas are code blocks enclosed in curly braces.\n    items.fold(0, { \n        // When a lambda has parameters, they go first, followed by '->'\n        acc: Int, i: Int -> \n        print(\"acc = $acc, i = $i, \") \n        val result = acc + i\n        println(\"result = $result\")\n        // The last expression in a lambda is considered the return value:\n        result\n    })\n    \n    // Parameter types in a lambda are optional if they can be inferred:\n    val joinedToString = items.fold(\"Elements:\", { acc, i -> acc + \" \" + i })\n    \n    // Function references can also be used for higher-order function calls:\n    val product = items.fold(1, Int::times)\n    //sampleEnd\n    println(\"joinedToString = $joinedToString\")\n    println(\"product = $product\")\n}\n"}, {"type": "code", "text": "fun main() {\n    //sampleStart\n    val items = listOf(1, 2, 3, 4, 5)\n    \n    // Lambdas are code blocks enclosed in curly braces.\n    items.fold(0, { \n        // When a lambda has parameters, they go first, followed by '->'\n        acc: Int, i: Int -> \n        print(\"acc = $acc, i = $i, \") \n        val result = acc + i\n        println(\"result = $result\")\n        // The last expression in a lambda is considered the return value:\n        result\n    })\n    \n    // Parameter types in a lambda are optional if they can be inferred:\n    val joinedToString = items.fold(\"Elements:\", { acc, i -> acc + \" \" + i })\n    \n    // Function references can also be used for higher-order function calls:\n    val product = items.fold(1, Int::times)\n    //sampleEnd\n    println(\"joinedToString = $joinedToString\")\n    println(\"product = $product\")\n}\n"}, {"type": "p", "text": "The following sections explain in more detail the concepts mentioned so far."}, {"type": "h2", "text": "Function types"}, {"type": "p", "text": "Kotlin uses a family of function types like (Int) -> String for declarations that deal with functions: val onClick: () -> Unit = ...."}, {"type": "code", "text": "(Int) -> String"}, {"type": "code", "text": "val onClick: () -> Unit = ..."}, {"type": "p", "text": "These types have a special notation that corresponds to the signatures of the functions, i.e. their parameters and return values:"}, {"type": "ul", "text": "\n\nAll function types have a parenthesized parameter types list and a return type: (A, B) -> C denotes a type that\n represents functions taking two arguments of types A and B and returning a value of type C. \n The parameter types list may be empty, as in () -> A. The Unit return type \n cannot be omitted.\n\n\nFunction types can optionally have an additional receiver type, which is specified before a dot in the notation:\n the type A.(B) -> C represents functions that can be called on a receiver object of A with a parameter of B and\n return a value of C.\n Function literals with receiver are often used along with these types.\n\n\nSuspending functions belong to function types of a special kind, which have a suspend modifier in the \n notation, such as suspend () -> Unit or suspend A.(B) -> C.\n\n"}, {"type": "li", "text": "\nAll function types have a parenthesized parameter types list and a return type: (A, B) -> C denotes a type that\n represents functions taking two arguments of types A and B and returning a value of type C. \n The parameter types list may be empty, as in () -> A. The Unit return type \n cannot be omitted.\n"}, {"type": "p", "text": "All function types have a parenthesized parameter types list and a return type: (A, B) -> C denotes a type that\n represents functions taking two arguments of types A and B and returning a value of type C. \n The parameter types list may be empty, as in () -> A. The Unit return type \n cannot be omitted."}, {"type": "code", "text": "(A, B) -> C"}, {"type": "code", "text": "A"}, {"type": "code", "text": "B"}, {"type": "code", "text": "C"}, {"type": "code", "text": "() -> A"}, {"type": "a", "text": "Unit return type"}, {"type": "code", "text": "Unit"}, {"type": "li", "text": "\nFunction types can optionally have an additional receiver type, which is specified before a dot in the notation:\n the type A.(B) -> C represents functions that can be called on a receiver object of A with a parameter of B and\n return a value of C.\n Function literals with receiver are often used along with these types.\n"}, {"type": "p", "text": "Function types can optionally have an additional receiver type, which is specified before a dot in the notation:\n the type A.(B) -> C represents functions that can be called on a receiver object of A with a parameter of B and\n return a value of C.\n Function literals with receiver are often used along with these types."}, {"type": "em", "text": "receiver"}, {"type": "code", "text": "A.(B) -> C"}, {"type": "code", "text": "A"}, {"type": "code", "text": "B"}, {"type": "code", "text": "C"}, {"type": "a", "text": "Function literals with receiver"}, {"type": "li", "text": "\nSuspending functions belong to function types of a special kind, which have a suspend modifier in the \n notation, such as suspend () -> Unit or suspend A.(B) -> C.\n"}, {"type": "p", "text": "Suspending functions belong to function types of a special kind, which have a suspend modifier in the \n notation, such as suspend () -> Unit or suspend A.(B) -> C."}, {"type": "a", "text": "Suspending functions"}, {"type": "em", "text": "suspend"}, {"type": "code", "text": "suspend () -> Unit"}, {"type": "code", "text": "suspend A.(B) -> C"}, {"type": "p", "text": "The function type notation can optionally include names for the function parameters: (x: Int, y: Int) -> Point.\nThese names can be used for documenting the meaning of the parameters."}, {"type": "code", "text": "(x: Int, y: Int) -> Point"}, {"type": "blockquote", "text": "\nTo specify that a function type is nullable, use parentheses: ((Int, Int) -> Int)?.\nFunction types can be combined using parentheses: (Int) -> ((Int) -> Unit)\nThe arrow notation is right-associative, (Int) -> (Int) -> Unit is equivalent to the previous example, but not to \n((Int) -> (Int)) -> Unit.\n"}, {"type": "p", "text": "To specify that a function type is nullable, use parentheses: ((Int, Int) -> Int)?."}, {"type": "a", "text": "nullable"}, {"type": "code", "text": "((Int, Int) -> Int)?"}, {"type": "p", "text": "Function types can be combined using parentheses: (Int) -> ((Int) -> Unit)"}, {"type": "code", "text": "(Int) -> ((Int) -> Unit)"}, {"type": "p", "text": "The arrow notation is right-associative, (Int) -> (Int) -> Unit is equivalent to the previous example, but not to \n((Int) -> (Int)) -> Unit."}, {"type": "code", "text": "(Int) -> (Int) -> Unit"}, {"type": "code", "text": "((Int) -> (Int)) -> Unit"}, {"type": "p", "text": "You can also give a function type an alternative name by using a type alias:"}, {"type": "a", "text": "a type alias"}, {"type": "div", "text": "\ntypealias ClickHandler = (Button, ClickEvent) -> Unit\n\n"}, {"type": "pre", "text": "typealias ClickHandler = (Button, ClickEvent) -> Unit\n"}, {"type": "code", "text": "typealias ClickHandler = (Button, ClickEvent) -> Unit\n"}, {"type": "h3", "text": "Instantiating a function type"}, {"type": "p", "text": "There are several ways to obtain an instance of a function type:"}, {"type": "ul", "text": "\nUsing a code block within a function literal, in one of the forms:\n    \na lambda expression: { a, b -> a + b },\nan anonymous function: fun(s: String): Int { return s.toIntOrNull() ?: 0 }\n\nFunction literals with receiver can be used as values of function types with receiver.\n\nUsing a callable reference to an existing declaration:\n    \na top-level, local, member, or extension function: ::isOdd, String::toInt,\na top-level, member, or extension property: List<Int>::size,\na constructor: ::Regex\n\nThese include bound callable references that point to a member of a particular instance: foo::toString.\n\nUsing instances of a custom class that implements a function type as an interface:\n"}, {"type": "li", "text": "Using a code block within a function literal, in one of the forms:\n    \na lambda expression: { a, b -> a + b },\nan anonymous function: fun(s: String): Int { return s.toIntOrNull() ?: 0 }\n\nFunction literals with receiver can be used as values of function types with receiver.\n"}, {"type": "ul", "text": "\na lambda expression: { a, b -> a + b },\nan anonymous function: fun(s: String): Int { return s.toIntOrNull() ?: 0 }\n"}, {"type": "li", "text": "a lambda expression: { a, b -> a + b },"}, {"type": "a", "text": "lambda expression"}, {"type": "code", "text": "{ a, b -> a + b }"}, {"type": "li", "text": "an anonymous function: fun(s: String): Int { return s.toIntOrNull() ?: 0 }"}, {"type": "a", "text": "anonymous function"}, {"type": "code", "text": "fun(s: String): Int { return s.toIntOrNull() ?: 0 }"}, {"type": "p", "text": "Function literals with receiver can be used as values of function types with receiver."}, {"type": "a", "text": "Function literals with receiver"}, {"type": "li", "text": "Using a callable reference to an existing declaration:\n    \na top-level, local, member, or extension function: ::isOdd, String::toInt,\na top-level, member, or extension property: List<Int>::size,\na constructor: ::Regex\n\nThese include bound callable references that point to a member of a particular instance: foo::toString.\n"}, {"type": "ul", "text": "\na top-level, local, member, or extension function: ::isOdd, String::toInt,\na top-level, member, or extension property: List<Int>::size,\na constructor: ::Regex\n"}, {"type": "li", "text": "a top-level, local, member, or extension function: ::isOdd, String::toInt,"}, {"type": "a", "text": "function"}, {"type": "code", "text": "::isOdd"}, {"type": "code", "text": "String::toInt"}, {"type": "li", "text": "a top-level, member, or extension property: List<Int>::size,"}, {"type": "a", "text": "property"}, {"type": "code", "text": "List<Int>::size"}, {"type": "li", "text": "a constructor: ::Regex"}, {"type": "a", "text": "constructor"}, {"type": "code", "text": "::Regex"}, {"type": "p", "text": "These include bound callable references that point to a member of a particular instance: foo::toString."}, {"type": "a", "text": "bound callable references"}, {"type": "code", "text": "foo::toString"}, {"type": "li", "text": "Using instances of a custom class that implements a function type as an interface:"}, {"type": "div", "text": "\nclass IntTransformer: (Int) -> Int {\n    override operator fun invoke(x: Int): Int = TODO()\n}\n\nval intFunction: (Int) -> Int = IntTransformer()\n\n"}, {"type": "pre", "text": "class IntTransformer: (Int) -> Int {\n    override operator fun invoke(x: Int): Int = TODO()\n}\n\nval intFunction: (Int) -> Int = IntTransformer()\n"}, {"type": "code", "text": "class IntTransformer: (Int) -> Int {\n    override operator fun invoke(x: Int): Int = TODO()\n}\n\nval intFunction: (Int) -> Int = IntTransformer()\n"}, {"type": "p", "text": "The compiler can infer the function types for variables if there is enough information:"}, {"type": "div", "text": "\nval a = { i: Int -> i + 1 } // The inferred type is (Int) -> Int\n\n"}, {"type": "pre", "text": "val a = { i: Int -> i + 1 } // The inferred type is (Int) -> Int\n"}, {"type": "code", "text": "val a = { i: Int -> i + 1 } // The inferred type is (Int) -> Int\n"}, {"type": "p", "text": "Non-literal values of function types with and without receiver are interchangeable, so that the receiver can stand in \nfor the first parameter, and vice versa. For instance, a value of type (A, B) -> C can be passed or assigned \n where a A.(B) -> C is expected and the other way around:"}, {"type": "em", "text": "Non-literal"}, {"type": "code", "text": "(A, B) -> C"}, {"type": "code", "text": "A.(B) -> C"}, {"type": "div", "text": "\nfun main() {\n    //sampleStart\n    val repeatFun: String.(Int) -> String = { times -> this.repeat(times) }\n    val twoParameters: (String, Int) -> String = repeatFun // OK\n    \n    fun runTransformation(f: (String, Int) -> String): String {\n        return f(\"hello\", 3)\n    }\n    val result = runTransformation(repeatFun) // OK\n    //sampleEnd\n    println(\"result = $result\")\n}\n\n"}, {"type": "pre", "text": "fun main() {\n    //sampleStart\n    val repeatFun: String.(Int) -> String = { times -> this.repeat(times) }\n    val twoParameters: (String, Int) -> String = repeatFun // OK\n    \n    fun runTransformation(f: (String, Int) -> String): String {\n        return f(\"hello\", 3)\n    }\n    val result = runTransformation(repeatFun) // OK\n    //sampleEnd\n    println(\"result = $result\")\n}\n"}, {"type": "code", "text": "fun main() {\n    //sampleStart\n    val repeatFun: String.(Int) -> String = { times -> this.repeat(times) }\n    val twoParameters: (String, Int) -> String = repeatFun // OK\n    \n    fun runTransformation(f: (String, Int) -> String): String {\n        return f(\"hello\", 3)\n    }\n    val result = runTransformation(repeatFun) // OK\n    //sampleEnd\n    println(\"result = $result\")\n}\n"}, {"type": "blockquote", "text": "\nNote that a function type with no receiver is inferred by default, even if a variable is initialized with a reference\nto an extension function. \nTo alter that, specify the variable type explicitly.\n"}, {"type": "p", "text": "Note that a function type with no receiver is inferred by default, even if a variable is initialized with a reference\nto an extension function. \nTo alter that, specify the variable type explicitly."}, {"type": "h3", "text": "Invoking a function type instance"}, {"type": "p", "text": "A value of a function type can be invoked by using its invoke(...) operator: f.invoke(x) or just f(x)."}, {"type": "a", "text": "invoke(...) operator"}, {"type": "code", "text": "invoke(...)"}, {"type": "code", "text": "f.invoke(x)"}, {"type": "code", "text": "f(x)"}, {"type": "p", "text": "If the value has a receiver type, the receiver object should be passed as the first argument.\nAnother way to invoke a value of a function type with receiver is to prepend it with the receiver object,\nas if the value were an extension function: 1.foo(2),"}, {"type": "a", "text": "extension function"}, {"type": "code", "text": "1.foo(2)"}, {"type": "p", "text": "Example:"}, {"type": "div", "text": "\nfun main() {\n    //sampleStart\n    val stringPlus: (String, String) -> String = String::plus\n    val intPlus: Int.(Int) -> Int = Int::plus\n    \n    println(stringPlus.invoke(\"<-\", \"->\"))\n    println(stringPlus(\"Hello, \", \"world!\")) \n    \n    println(intPlus.invoke(1, 1))\n    println(intPlus(1, 2))\n    println(2.intPlus(3)) // extension-like call\n    //sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n    //sampleStart\n    val stringPlus: (String, String) -> String = String::plus\n    val intPlus: Int.(Int) -> Int = Int::plus\n    \n    println(stringPlus.invoke(\"<-\", \"->\"))\n    println(stringPlus(\"Hello, \", \"world!\")) \n    \n    println(intPlus.invoke(1, 1))\n    println(intPlus(1, 2))\n    println(2.intPlus(3)) // extension-like call\n    //sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n    //sampleStart\n    val stringPlus: (String, String) -> String = String::plus\n    val intPlus: Int.(Int) -> Int = Int::plus\n    \n    println(stringPlus.invoke(\"<-\", \"->\"))\n    println(stringPlus(\"Hello, \", \"world!\")) \n    \n    println(intPlus.invoke(1, 1))\n    println(intPlus(1, 2))\n    println(2.intPlus(3)) // extension-like call\n    //sampleEnd\n}\n"}, {"type": "h3", "text": "Inline functions"}, {"type": "p", "text": "Sometimes it is beneficial to use inline functions, which provide flexible control flow,\nfor higher-order functions."}, {"type": "a", "text": "inline functions"}, {"type": "h2", "text": "Lambda Expressions and Anonymous Functions"}, {"type": "p", "text": "Lambda expressions and anonymous functions are 'function literals', i.e. functions that are not declared,\nbut passed immediately as an expression. Consider the following example:"}, {"type": "div", "text": "\nmax(strings, { a, b -> a.length < b.length })\n\n"}, {"type": "pre", "text": "max(strings, { a, b -> a.length < b.length })\n"}, {"type": "code", "text": "max(strings, { a, b -> a.length < b.length })\n"}, {"type": "p", "text": "Function max is a higher-order function, it takes a function value as the second argument.\nThis second argument is an expression that is itself a function, i.e. a function literal, which is equivalent to\nthe following named function:"}, {"type": "code", "text": "max"}, {"type": "div", "text": "\nfun compare(a: String, b: String): Boolean = a.length < b.length\n\n"}, {"type": "pre", "text": "fun compare(a: String, b: String): Boolean = a.length < b.length\n"}, {"type": "code", "text": "fun compare(a: String, b: String): Boolean = a.length < b.length\n"}, {"type": "h3", "text": "Lambda expression syntax"}, {"type": "p", "text": "The full syntactic form of lambda expressions is as follows:"}, {"type": "div", "text": "\nval sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y }\n\n"}, {"type": "pre", "text": "val sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y }\n"}, {"type": "code", "text": "val sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y }\n"}, {"type": "p", "text": "A lambda expression is always surrounded by curly braces,\nparameter declarations in the full syntactic form go inside curly braces and have optional type annotations,\nthe body goes after an -> sign. If the inferred return type of the lambda is not Unit, the last (or possibly single)\nexpression inside the lambda body is treated as the return value."}, {"type": "code", "text": "->"}, {"type": "code", "text": "Unit"}, {"type": "p", "text": "If we leave all the optional annotations out, what's left looks like this:"}, {"type": "div", "text": "\nval sum = { x: Int, y: Int -> x + y }\n\n"}, {"type": "pre", "text": "val sum = { x: Int, y: Int -> x + y }\n"}, {"type": "code", "text": "val sum = { x: Int, y: Int -> x + y }\n"}, {"type": "h3", "text": "Passing trailing lambdas"}, {"type": "p", "text": "In Kotlin, there is a convention: if the last parameter of a function is a function, then a lambda expression \npassed as the corresponding argument can be placed outside the parentheses:"}, {"type": "div", "text": "\nval product = items.fold(1) { acc, e -> acc * e }\n\n"}, {"type": "pre", "text": "val product = items.fold(1) { acc, e -> acc * e }\n"}, {"type": "code", "text": "val product = items.fold(1) { acc, e -> acc * e }\n"}, {"type": "p", "text": "Such syntax is also known as trailing lambda."}, {"type": "em", "text": "trailing lambda"}, {"type": "p", "text": "If the lambda is the only argument to that call, the parentheses can be omitted entirely:"}, {"type": "div", "text": "\nrun { println(\"...\") }\n\n"}, {"type": "pre", "text": "run { println(\"...\") }\n"}, {"type": "code", "text": "run { println(\"...\") }\n"}, {"type": "h3", "text": "it: implicit name of a single parameter"}, {"type": "code", "text": "it"}, {"type": "p", "text": "It's very common that a lambda expression has only one parameter."}, {"type": "p", "text": "If the compiler can figure the signature out itself, it is allowed not to declare the only parameter and omit ->. \nThe parameter will be implicitly declared under the name it:"}, {"type": "code", "text": "->"}, {"type": "code", "text": "it"}, {"type": "div", "text": "\nints.filter { it > 0 } // this literal is of type '(it: Int) -> Boolean'\n\n"}, {"type": "pre", "text": "ints.filter { it > 0 } // this literal is of type '(it: Int) -> Boolean'\n"}, {"type": "code", "text": "ints.filter { it > 0 } // this literal is of type '(it: Int) -> Boolean'\n"}, {"type": "h3", "text": "Returning a value from a lambda expression"}, {"type": "p", "text": "We can explicitly return a value from the lambda using the qualified return syntax. \nOtherwise, the value of the last expression is implicitly returned."}, {"type": "a", "text": "qualified return"}, {"type": "p", "text": "Therefore, the two following snippets are equivalent:"}, {"type": "div", "text": "\nints.filter {\n    val shouldFilter = it > 0 \n    shouldFilter\n}\n\nints.filter {\n    val shouldFilter = it > 0 \n    return@filter shouldFilter\n}\n\n"}, {"type": "pre", "text": "ints.filter {\n    val shouldFilter = it > 0 \n    shouldFilter\n}\n\nints.filter {\n    val shouldFilter = it > 0 \n    return@filter shouldFilter\n}\n"}, {"type": "code", "text": "ints.filter {\n    val shouldFilter = it > 0 \n    shouldFilter\n}\n\nints.filter {\n    val shouldFilter = it > 0 \n    return@filter shouldFilter\n}\n"}, {"type": "p", "text": "This convention, along with passing a lambda expression outside parentheses, allows for \nLINQ-style code:"}, {"type": "a", "text": "passing a lambda expression outside parentheses"}, {"type": "a", "text": "LINQ-style"}, {"type": "div", "text": "\nstrings.filter { it.length == 5 }.sortedBy { it }.map { it.toUpperCase() }\n\n"}, {"type": "pre", "text": "strings.filter { it.length == 5 }.sortedBy { it }.map { it.toUpperCase() }\n"}, {"type": "code", "text": "strings.filter { it.length == 5 }.sortedBy { it }.map { it.toUpperCase() }\n"}, {"type": "h3", "text": "Underscore for unused variables (since 1.1)"}, {"type": "p", "text": "If the lambda parameter is unused, you can place an underscore instead of its name:"}, {"type": "div", "text": "\nmap.forEach { _, value -> println(\"$value!\") }\n\n"}, {"type": "pre", "text": "map.forEach { _, value -> println(\"$value!\") }\n"}, {"type": "code", "text": "map.forEach { _, value -> println(\"$value!\") }\n"}, {"type": "h3", "text": "Destructuring in lambdas (since 1.1)"}, {"type": "p", "text": "Destructuring in lambdas is described as a part of destructuring declarations."}, {"type": "a", "text": "destructuring declarations"}, {"type": "h3", "text": "Anonymous functions"}, {"type": "p", "text": "One thing missing from the lambda expression syntax presented above is the ability to specify the return type of the\nfunction. In most cases, this is unnecessary because the return type can be inferred automatically. However, if you\ndo need to specify it explicitly, you can use an alternative syntax: an anonymous function."}, {"type": "em", "text": "anonymous function"}, {"type": "div", "text": "\nfun(x: Int, y: Int): Int = x + y\n\n"}, {"type": "pre", "text": "fun(x: Int, y: Int): Int = x + y\n"}, {"type": "code", "text": "fun(x: Int, y: Int): Int = x + y\n"}, {"type": "p", "text": "An anonymous function looks very much like a regular function declaration, except that its name is omitted. Its body\ncan be either an expression (as shown above) or a block:"}, {"type": "div", "text": "\nfun(x: Int, y: Int): Int {\n    return x + y\n}\n\n"}, {"type": "pre", "text": "fun(x: Int, y: Int): Int {\n    return x + y\n}\n"}, {"type": "code", "text": "fun(x: Int, y: Int): Int {\n    return x + y\n}\n"}, {"type": "p", "text": "The parameters and the return type are specified in the same way as for regular functions, except that the parameter\ntypes can be omitted if they can be inferred from context:"}, {"type": "div", "text": "\nints.filter(fun(item) = item > 0)\n\n"}, {"type": "pre", "text": "ints.filter(fun(item) = item > 0)\n"}, {"type": "code", "text": "ints.filter(fun(item) = item > 0)\n"}, {"type": "p", "text": "The return type inference for anonymous functions works just like for normal functions: the return type is inferred\nautomatically for anonymous functions with an expression body and has to be specified explicitly (or is assumed to be\nUnit) for anonymous functions with a block body."}, {"type": "code", "text": "Unit"}, {"type": "p", "text": "Note that anonymous function parameters are always passed inside the parentheses. The shorthand syntax allowing\nto leave the function outside the parentheses works only for lambda expressions."}, {"type": "p", "text": "One other difference between lambda expressions and anonymous functions is the behavior of\nnon-local returns. A return  statement without a label\nalways returns from the function declared with the fun keyword. This means that a return\ninside a lambda expression will return from the enclosing function, whereas a return inside\nan anonymous function will return from the anonymous function itself."}, {"type": "a", "text": "non-local returns"}, {"type": "em", "text": "return"}, {"type": "em", "text": "fun"}, {"type": "em", "text": "return"}, {"type": "em", "text": "return"}, {"type": "h3", "text": "Closures"}, {"type": "p", "text": "A lambda expression or anonymous function (as well as a local function and an object expression)\ncan access its closure, i.e. the variables declared in the outer scope. The variables captured in the closure can be modified in the lambda:"}, {"type": "a", "text": "local function"}, {"type": "a", "text": "object expression"}, {"type": "em", "text": "closure"}, {"type": "div", "text": "\nvar sum = 0\nints.filter { it > 0 }.forEach {\n    sum += it\n}\nprint(sum)\n\n"}, {"type": "pre", "text": "var sum = 0\nints.filter { it > 0 }.forEach {\n    sum += it\n}\nprint(sum)\n"}, {"type": "code", "text": "var sum = 0\nints.filter { it > 0 }.forEach {\n    sum += it\n}\nprint(sum)\n"}, {"type": "h3", "text": "Function literals with receiver"}, {"type": "p", "text": "Function types with receiver, such as A.(B) -> C, can be instantiated with a special form of function literals \u2013 \nfunction literals with receiver."}, {"type": "a", "text": "Function types"}, {"type": "code", "text": "A.(B) -> C"}, {"type": "p", "text": "As said above, Kotlin provides the ability to call an instance of a function type with receiver providing the receiver object."}, {"type": "a", "text": "to call an instance"}, {"type": "em", "text": "receiver object"}, {"type": "p", "text": "Inside the body of the function literal, the receiver object passed to a call becomes an implicit this, so that you \ncan access the members of that receiver object without any additional qualifiers, or access the receiver object \nusing a this expression."}, {"type": "em", "text": "implicit"}, {"type": "em", "text": "this"}, {"type": "a", "text": "this expression"}, {"type": "code", "text": "this"}, {"type": "p", "text": "This behavior is similar to extension functions, which also allow you to access the members of the receiver object \ninside the body of the function."}, {"type": "a", "text": "extension functions"}, {"type": "p", "text": "Here is an example of a function literal with receiver along with its type, where plus is called on the \nreceiver object:"}, {"type": "code", "text": "plus"}, {"type": "div", "text": "\nval sum: Int.(Int) -> Int = { other -> plus(other) } \n\n"}, {"type": "pre", "text": "val sum: Int.(Int) -> Int = { other -> plus(other) } \n"}, {"type": "code", "text": "val sum: Int.(Int) -> Int = { other -> plus(other) } \n"}, {"type": "p", "text": "The anonymous function syntax allows you to specify the receiver type of a function literal directly.\nThis can be useful if you need to declare a variable of a function type with receiver, and to use it later."}, {"type": "div", "text": "\nval sum = fun Int.(other: Int): Int = this + other\n\n"}, {"type": "pre", "text": "val sum = fun Int.(other: Int): Int = this + other\n"}, {"type": "code", "text": "val sum = fun Int.(other: Int): Int = this + other\n"}, {"type": "p", "text": "Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context.\nOne of the most important examples of their usage is type-safe builders:"}, {"type": "a", "text": "type-safe builders"}, {"type": "div", "text": "\nclass HTML {\n    fun body() { ... }\n}\n\nfun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()  // create the receiver object\n    html.init()        // pass the receiver object to the lambda\n    return html\n}\n\nhtml {       // lambda with receiver begins here\n    body()   // calling a method on the receiver object\n}\n\n"}, {"type": "pre", "text": "class HTML {\n    fun body() { ... }\n}\n\nfun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()  // create the receiver object\n    html.init()        // pass the receiver object to the lambda\n    return html\n}\n\nhtml {       // lambda with receiver begins here\n    body()   // calling a method on the receiver object\n}\n"}, {"type": "code", "text": "class HTML {\n    fun body() { ... }\n}\n\nfun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()  // create the receiver object\n    html.init()        // pass the receiver object to the lambda\n    return html\n}\n\nhtml {       // lambda with receiver begins here\n    body()   // calling a method on the receiver object\n}\n"}]