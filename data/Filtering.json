[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Filtering"}, {"type": "p", "text": "Filtering is one of the most popular tasks in the collection processing.\nIn Kotlin, filtering conditions are defined by predicates \u2013 lambda functions that take a collection element and return a boolean value: true means that the given element matches the predicate, false means the opposite."}, {"type": "em", "text": "predicates"}, {"type": "code", "text": "true"}, {"type": "code", "text": "false"}, {"type": "p", "text": "The standard library contains a group of extension functions that let you filter collections in a single call.\nThese functions leave the original collection unchanged, so they are available for both mutable and read-only collections.\nTo operate the filtering result, you should assign it to a variable or chain the functions after filtering."}, {"type": "a", "text": "mutable and read-only"}, {"type": "h2", "text": "Filtering by predicate"}, {"type": "p", "text": "The basic filtering function is filter().\nWhen called with a predicate, filter() returns the collection elements that match it.\nFor both List and Set, the resulting collection is a List, for Map it's a Map as well."}, {"type": "a", "text": "filter()"}, {"type": "code", "text": "filter()"}, {"type": "code", "text": "filter()"}, {"type": "code", "text": "List"}, {"type": "code", "text": "Set"}, {"type": "code", "text": "List"}, {"type": "code", "text": "Map"}, {"type": "code", "text": "Map"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")  \n    val longerThan3 = numbers.filter { it.length > 3 }\n    println(longerThan3)\n\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}\n    println(filteredMap)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")  \n    val longerThan3 = numbers.filter { it.length > 3 }\n    println(longerThan3)\n\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}\n    println(filteredMap)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")  \n    val longerThan3 = numbers.filter { it.length > 3 }\n    println(longerThan3)\n\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}\n    println(filteredMap)\n//sampleEnd\n}\n"}, {"type": "p", "text": "The predicates in filter() can only check the values of the elements.\nIf you want to use element positions in the filter, use filterIndexed().\nIt takes a predicate with two arguments: the index and the value of an element."}, {"type": "code", "text": "filter()"}, {"type": "a", "text": "filterIndexed()"}, {"type": "code", "text": "filterIndexed()"}, {"type": "p", "text": "To filter collections by negative conditions, use filterNot().\nIt returns a list of elements for which the predicate yields false."}, {"type": "a", "text": "filterNot()"}, {"type": "code", "text": "filterNot()"}, {"type": "code", "text": "false"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    \n    val filteredIdx = numbers.filterIndexed { index, s -> (index != 0) && (s.length < 5)  }\n    val filteredNot = numbers.filterNot { it.length <= 3 }\n\n    println(filteredIdx)\n    println(filteredNot)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    \n    val filteredIdx = numbers.filterIndexed { index, s -> (index != 0) && (s.length < 5)  }\n    val filteredNot = numbers.filterNot { it.length <= 3 }\n\n    println(filteredIdx)\n    println(filteredNot)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    \n    val filteredIdx = numbers.filterIndexed { index, s -> (index != 0) && (s.length < 5)  }\n    val filteredNot = numbers.filterNot { it.length <= 3 }\n\n    println(filteredIdx)\n    println(filteredNot)\n//sampleEnd\n}\n"}, {"type": "p", "text": "There are also functions that narrow the element type by filtering elements of a given type:"}, {"type": "ul", "text": "\nfilterIsInstance() returns collection elements of a given type. Being called on a List<Any>, filterIsInstance<T>() returns a List<T>, thus allowing you to call functions of the  T type on its items.\n"}, {"type": "li", "text": "filterIsInstance() returns collection elements of a given type. Being called on a List<Any>, filterIsInstance<T>() returns a List<T>, thus allowing you to call functions of the  T type on its items."}, {"type": "a", "text": "filterIsInstance()"}, {"type": "code", "text": "filterIsInstance()"}, {"type": "code", "text": "List<Any>"}, {"type": "code", "text": "filterIsInstance<T>()"}, {"type": "code", "text": "List<T>"}, {"type": "code", "text": "T"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(null, 1, \"two\", 3.0, \"four\")\n    println(\"All String elements in upper case:\")\n    numbers.filterIsInstance<String>().forEach {\n        println(it.toUpperCase())\n    }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(null, 1, \"two\", 3.0, \"four\")\n    println(\"All String elements in upper case:\")\n    numbers.filterIsInstance<String>().forEach {\n        println(it.toUpperCase())\n    }\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(null, 1, \"two\", 3.0, \"four\")\n    println(\"All String elements in upper case:\")\n    numbers.filterIsInstance<String>().forEach {\n        println(it.toUpperCase())\n    }\n//sampleEnd\n}\n"}, {"type": "ul", "text": "\nfilterNotNull() returns all non-null elements. Being called on a List<T?>, filterNotNull() returns a List<T: Any>, thus allowing you to treat the elements as non-null objects.\n"}, {"type": "li", "text": "filterNotNull() returns all non-null elements. Being called on a List<T?>, filterNotNull() returns a List<T: Any>, thus allowing you to treat the elements as non-null objects."}, {"type": "a", "text": "filterNotNull()"}, {"type": "code", "text": "filterNotNull()"}, {"type": "code", "text": "List<T?>"}, {"type": "code", "text": "filterNotNull()"}, {"type": "code", "text": "List<T: Any>"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(null, \"one\", \"two\", null)\n    numbers.filterNotNull().forEach {\n        println(it.length)   // length is unavailable for nullable Strings\n    }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(null, \"one\", \"two\", null)\n    numbers.filterNotNull().forEach {\n        println(it.length)   // length is unavailable for nullable Strings\n    }\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(null, \"one\", \"two\", null)\n    numbers.filterNotNull().forEach {\n        println(it.length)   // length is unavailable for nullable Strings\n    }\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Partitioning"}, {"type": "p", "text": "Another filtering function \u2013 partition() \u2013 filters a collection by a predicate and keeps the elements that don't match it in a separate list.\nSo, you have a Pair of Lists as a return value: the first list containing elements that match the predicate and the second one containing everything else from the original collection."}, {"type": "a", "text": "partition()"}, {"type": "code", "text": "partition()"}, {"type": "code", "text": "Pair"}, {"type": "code", "text": "List"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val (match, rest) = numbers.partition { it.length > 3 }\n\n    println(match)\n    println(rest)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val (match, rest) = numbers.partition { it.length > 3 }\n\n    println(match)\n    println(rest)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val (match, rest) = numbers.partition { it.length > 3 }\n\n    println(match)\n    println(rest)\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Testing predicates"}, {"type": "p", "text": "Finally, there are functions that simply test a predicate against collection elements:"}, {"type": "ul", "text": "\nany() returns true if at least one element matches the given predicate.\nnone() returns true if none of the elements match the given predicate.\nall() returns true if all elements match the given predicate. Note that all() returns true when called with any valid predicate on an empty collection. Such behavior is known in logic as vacuous truth.\n"}, {"type": "li", "text": "any() returns true if at least one element matches the given predicate."}, {"type": "a", "text": "any()"}, {"type": "code", "text": "any()"}, {"type": "code", "text": "true"}, {"type": "li", "text": "none() returns true if none of the elements match the given predicate."}, {"type": "a", "text": "none()"}, {"type": "code", "text": "none()"}, {"type": "code", "text": "true"}, {"type": "li", "text": "all() returns true if all elements match the given predicate. Note that all() returns true when called with any valid predicate on an empty collection. Such behavior is known in logic as vacuous truth."}, {"type": "a", "text": "all()"}, {"type": "code", "text": "all()"}, {"type": "code", "text": "true"}, {"type": "code", "text": "all()"}, {"type": "code", "text": "true"}, {"type": "a", "text": "vacuous truth"}, {"type": "em", "text": "vacuous truth"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(numbers.any { it.endsWith(\"e\") })\n    println(numbers.none { it.endsWith(\"a\") })\n    println(numbers.all { it.endsWith(\"e\") })\n\n    println(emptyList<Int>().all { it > 5 })   // vacuous truth\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(numbers.any { it.endsWith(\"e\") })\n    println(numbers.none { it.endsWith(\"a\") })\n    println(numbers.all { it.endsWith(\"e\") })\n\n    println(emptyList<Int>().all { it > 5 })   // vacuous truth\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(numbers.any { it.endsWith(\"e\") })\n    println(numbers.none { it.endsWith(\"a\") })\n    println(numbers.all { it.endsWith(\"e\") })\n\n    println(emptyList<Int>().all { it > 5 })   // vacuous truth\n//sampleEnd\n}\n"}, {"type": "p", "text": "any() and none() can also be used without a predicate: in this case they just check the collection emptiness.\nany() returns true if there are elements and false if there aren't; none() does the opposite."}, {"type": "code", "text": "any()"}, {"type": "code", "text": "none()"}, {"type": "code", "text": "any()"}, {"type": "code", "text": "true"}, {"type": "code", "text": "false"}, {"type": "code", "text": "none()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val empty = emptyList<String>()\n\n    println(numbers.any())\n    println(empty.any())\n    \n    println(numbers.none())\n    println(empty.none())\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val empty = emptyList<String>()\n\n    println(numbers.any())\n    println(empty.any())\n    \n    println(numbers.none())\n    println(empty.none())\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val empty = emptyList<String>()\n\n    println(numbers.any())\n    println(empty.any())\n    \n    println(numbers.none())\n    println(empty.none())\n//sampleEnd\n}\n"}]