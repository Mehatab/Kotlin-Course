[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Annotations"}, {"type": "h2", "text": "Annotation Declaration"}, {"type": "p", "text": "Annotations are means of attaching metadata to code. To declare an annotation, put the annotation modifier in front of a class:"}, {"type": "em", "text": "annotation"}, {"type": "div", "text": "\nannotation class Fancy\n\n"}, {"type": "pre", "text": "annotation class Fancy\n"}, {"type": "code", "text": "annotation class Fancy\n"}, {"type": "p", "text": "Additional attributes of the annotation can be specified by annotating the annotation class with meta-annotations:"}, {"type": "ul", "text": "\n@Target specifies the possible kinds of\nelements which can be annotated with the annotation (classes, functions, properties, expressions etc.);\n@Retention specifies whether the\nannotation is stored in the compiled class files and whether it's visible through reflection at runtime\n(by default, both are true);\n@Repeatable allows using the same annotation\non a single element multiple times;\n@MustBeDocumented specifies that the\nannotation is part of the public API and should be included in the class or method signature shown in the\ngenerated API documentation.\n"}, {"type": "li", "text": "@Target specifies the possible kinds of\nelements which can be annotated with the annotation (classes, functions, properties, expressions etc.);"}, {"type": "a", "text": "@Target"}, {"type": "code", "text": "@Target"}, {"type": "li", "text": "@Retention specifies whether the\nannotation is stored in the compiled class files and whether it's visible through reflection at runtime\n(by default, both are true);"}, {"type": "a", "text": "@Retention"}, {"type": "code", "text": "@Retention"}, {"type": "li", "text": "@Repeatable allows using the same annotation\non a single element multiple times;"}, {"type": "a", "text": "@Repeatable"}, {"type": "code", "text": "@Repeatable"}, {"type": "li", "text": "@MustBeDocumented specifies that the\nannotation is part of the public API and should be included in the class or method signature shown in the\ngenerated API documentation."}, {"type": "a", "text": "@MustBeDocumented"}, {"type": "code", "text": "@MustBeDocumented"}, {"type": "div", "text": "\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION,\n        AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\n@MustBeDocumented\nannotation class Fancy\n\n"}, {"type": "pre", "text": "@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION,\n        AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\n@MustBeDocumented\nannotation class Fancy\n"}, {"type": "code", "text": "@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION,\n        AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\n@MustBeDocumented\nannotation class Fancy\n"}, {"type": "h3", "text": "Usage"}, {"type": "div", "text": "\n@Fancy class Foo {\n    @Fancy fun baz(@Fancy foo: Int): Int {\n        return (@Fancy 1)\n    }\n}\n\n"}, {"type": "pre", "text": "@Fancy class Foo {\n    @Fancy fun baz(@Fancy foo: Int): Int {\n        return (@Fancy 1)\n    }\n}\n"}, {"type": "code", "text": "@Fancy class Foo {\n    @Fancy fun baz(@Fancy foo: Int): Int {\n        return (@Fancy 1)\n    }\n}\n"}, {"type": "p", "text": "If you need to annotate the primary constructor of a class, you need to add the constructor keyword\nto the constructor declaration, and add the annotations before it:"}, {"type": "em", "text": "constructor"}, {"type": "div", "text": "\nclass Foo @Inject constructor(dependency: MyDependency) { ... }\n\n"}, {"type": "pre", "text": "class Foo @Inject constructor(dependency: MyDependency) { ... }\n"}, {"type": "code", "text": "class Foo @Inject constructor(dependency: MyDependency) { ... }\n"}, {"type": "p", "text": "You can also annotate property accessors:"}, {"type": "div", "text": "\nclass Foo {\n    var x: MyDependency? = null\n        @Inject set\n}\n\n"}, {"type": "pre", "text": "class Foo {\n    var x: MyDependency? = null\n        @Inject set\n}\n"}, {"type": "code", "text": "class Foo {\n    var x: MyDependency? = null\n        @Inject set\n}\n"}, {"type": "h3", "text": "Constructors"}, {"type": "p", "text": "Annotations may have constructors that take parameters."}, {"type": "div", "text": "\nannotation class Special(val why: String)\n\n@Special(\"example\") class Foo {}\n\n"}, {"type": "pre", "text": "annotation class Special(val why: String)\n\n@Special(\"example\") class Foo {}\n"}, {"type": "code", "text": "annotation class Special(val why: String)\n\n@Special(\"example\") class Foo {}\n"}, {"type": "p", "text": "Allowed parameter types are:"}, {"type": "ul", "text": "\ntypes that correspond to Java primitive types (Int, Long etc.);\nstrings;\nclasses (Foo::class);\nenums;\nother annotations;\narrays of the types listed above.\n"}, {"type": "li", "text": "types that correspond to Java primitive types (Int, Long etc.);"}, {"type": "li", "text": "strings;"}, {"type": "li", "text": "classes (Foo::class);"}, {"type": "code", "text": "Foo::class"}, {"type": "li", "text": "enums;"}, {"type": "li", "text": "other annotations;"}, {"type": "li", "text": "arrays of the types listed above."}, {"type": "p", "text": "Annotation parameters cannot have nullable types, because the JVM does not support storing null as a value\nof an annotation attribute."}, {"type": "code", "text": "null"}, {"type": "p", "text": "If an annotation is used as a parameter of another annotation, its name is not prefixed with the @ character:"}, {"type": "div", "text": "\nannotation class ReplaceWith(val expression: String)\n\nannotation class Deprecated(\n        val message: String,\n        val replaceWith: ReplaceWith = ReplaceWith(\"\"))\n\n@Deprecated(\"This function is deprecated, use === instead\", ReplaceWith(\"this === other\"))\n\n"}, {"type": "pre", "text": "annotation class ReplaceWith(val expression: String)\n\nannotation class Deprecated(\n        val message: String,\n        val replaceWith: ReplaceWith = ReplaceWith(\"\"))\n\n@Deprecated(\"This function is deprecated, use === instead\", ReplaceWith(\"this === other\"))\n"}, {"type": "code", "text": "annotation class ReplaceWith(val expression: String)\n\nannotation class Deprecated(\n        val message: String,\n        val replaceWith: ReplaceWith = ReplaceWith(\"\"))\n\n@Deprecated(\"This function is deprecated, use === instead\", ReplaceWith(\"this === other\"))\n"}, {"type": "p", "text": "If you need to specify a class as an argument of an annotation, use a Kotlin class\n(KClass). The Kotlin compiler will\nautomatically convert it to a Java class, so that the Java code can access the annotations and arguments\nnormally."}, {"type": "a", "text": "KClass"}, {"type": "div", "text": "\n\nimport kotlin.reflect.KClass\n\nannotation class Ann(val arg1: KClass<*>, val arg2: KClass<out Any>)\n\n@Ann(String::class, Int::class) class MyClass\n\n"}, {"type": "pre", "text": "\nimport kotlin.reflect.KClass\n\nannotation class Ann(val arg1: KClass<*>, val arg2: KClass<out Any>)\n\n@Ann(String::class, Int::class) class MyClass\n"}, {"type": "code", "text": "\nimport kotlin.reflect.KClass\n\nannotation class Ann(val arg1: KClass<*>, val arg2: KClass<out Any>)\n\n@Ann(String::class, Int::class) class MyClass\n"}, {"type": "h3", "text": "Lambdas"}, {"type": "p", "text": "Annotations can also be used on lambdas. They will be applied to the invoke() method into which the body\nof the lambda is generated. This is useful for frameworks like Quasar,\nwhich uses annotations for concurrency control."}, {"type": "code", "text": "invoke()"}, {"type": "a", "text": "Quasar"}, {"type": "div", "text": "\nannotation class Suspendable\n\nval f = @Suspendable { Fiber.sleep(10) }\n\n"}, {"type": "pre", "text": "annotation class Suspendable\n\nval f = @Suspendable { Fiber.sleep(10) }\n"}, {"type": "code", "text": "annotation class Suspendable\n\nval f = @Suspendable { Fiber.sleep(10) }\n"}, {"type": "h2", "text": "Annotation Use-site Targets"}, {"type": "p", "text": "When you're annotating a property or a primary constructor parameter, there are multiple Java elements which are\ngenerated from the corresponding Kotlin element, and therefore multiple possible locations for the annotation in\nthe generated Java bytecode. To specify how exactly the annotation should be generated, use the following syntax:"}, {"type": "div", "text": "\nclass Example(@field:Ann val foo,    // annotate Java field\n              @get:Ann val bar,      // annotate Java getter\n              @param:Ann val quux)   // annotate Java constructor parameter\n\n"}, {"type": "pre", "text": "class Example(@field:Ann val foo,    // annotate Java field\n              @get:Ann val bar,      // annotate Java getter\n              @param:Ann val quux)   // annotate Java constructor parameter\n"}, {"type": "code", "text": "class Example(@field:Ann val foo,    // annotate Java field\n              @get:Ann val bar,      // annotate Java getter\n              @param:Ann val quux)   // annotate Java constructor parameter\n"}, {"type": "p", "text": "The same syntax can be used to annotate the entire file. To do this, put an annotation with the target file at\nthe top level of a file, before the package directive or before all imports if the file is in the default package:"}, {"type": "code", "text": "file"}, {"type": "div", "text": "\n@file:JvmName(\"Foo\")\n\npackage org.jetbrains.demo\n\n"}, {"type": "pre", "text": "@file:JvmName(\"Foo\")\n\npackage org.jetbrains.demo\n"}, {"type": "code", "text": "@file:JvmName(\"Foo\")\n\npackage org.jetbrains.demo\n"}, {"type": "p", "text": "If you have multiple annotations with the same target, you can avoid repeating the target by adding brackets after the\ntarget and putting all the annotations inside the brackets:"}, {"type": "div", "text": "\nclass Example {\n     @set:[Inject VisibleForTesting]\n     var collaborator: Collaborator\n}\n\n"}, {"type": "pre", "text": "class Example {\n     @set:[Inject VisibleForTesting]\n     var collaborator: Collaborator\n}\n"}, {"type": "code", "text": "class Example {\n     @set:[Inject VisibleForTesting]\n     var collaborator: Collaborator\n}\n"}, {"type": "p", "text": "The full list of supported use-site targets is:"}, {"type": "ul", "text": "\nfile;\nproperty (annotations with this target are not visible to Java);\nfield;\nget (property getter);\nset (property setter);\nreceiver (receiver parameter of an extension function or property);\nparam (constructor parameter);\nsetparam (property setter parameter);\ndelegate (the field storing the delegate instance for a delegated property).\n"}, {"type": "li", "text": "file;"}, {"type": "code", "text": "file"}, {"type": "li", "text": "property (annotations with this target are not visible to Java);"}, {"type": "code", "text": "property"}, {"type": "li", "text": "field;"}, {"type": "code", "text": "field"}, {"type": "li", "text": "get (property getter);"}, {"type": "code", "text": "get"}, {"type": "li", "text": "set (property setter);"}, {"type": "code", "text": "set"}, {"type": "li", "text": "receiver (receiver parameter of an extension function or property);"}, {"type": "code", "text": "receiver"}, {"type": "li", "text": "param (constructor parameter);"}, {"type": "code", "text": "param"}, {"type": "li", "text": "setparam (property setter parameter);"}, {"type": "code", "text": "setparam"}, {"type": "li", "text": "delegate (the field storing the delegate instance for a delegated property)."}, {"type": "code", "text": "delegate"}, {"type": "p", "text": "To annotate the receiver parameter of an extension function, use the following syntax:"}, {"type": "div", "text": "\nfun @receiver:Fancy String.myExtension() { ... }\n\n"}, {"type": "pre", "text": "fun @receiver:Fancy String.myExtension() { ... }\n"}, {"type": "code", "text": "fun @receiver:Fancy String.myExtension() { ... }\n"}, {"type": "p", "text": "If you don't specify a use-site target, the target is chosen according to the @Target annotation of the annotation\nbeing used. If there are multiple applicable targets, the first applicable target from the following list is used:"}, {"type": "code", "text": "@Target"}, {"type": "ul", "text": "\nparam;\nproperty;\nfield.\n"}, {"type": "li", "text": "param;"}, {"type": "code", "text": "param"}, {"type": "li", "text": "property;"}, {"type": "code", "text": "property"}, {"type": "li", "text": "field."}, {"type": "code", "text": "field"}, {"type": "h2", "text": "Java Annotations"}, {"type": "p", "text": "Java annotations are 100% compatible with Kotlin:"}, {"type": "div", "text": "\nimport org.junit.Test\nimport org.junit.Assert.*\nimport org.junit.Rule\nimport org.junit.rules.*\n\nclass Tests {\n    // apply @Rule annotation to property getter\n    @get:Rule val tempFolder = TemporaryFolder()\n\n    @Test fun simple() {\n        val f = tempFolder.newFile()\n        assertEquals(42, getTheAnswer())\n    }\n}\n\n"}, {"type": "pre", "text": "import org.junit.Test\nimport org.junit.Assert.*\nimport org.junit.Rule\nimport org.junit.rules.*\n\nclass Tests {\n    // apply @Rule annotation to property getter\n    @get:Rule val tempFolder = TemporaryFolder()\n\n    @Test fun simple() {\n        val f = tempFolder.newFile()\n        assertEquals(42, getTheAnswer())\n    }\n}\n"}, {"type": "code", "text": "import org.junit.Test\nimport org.junit.Assert.*\nimport org.junit.Rule\nimport org.junit.rules.*\n\nclass Tests {\n    // apply @Rule annotation to property getter\n    @get:Rule val tempFolder = TemporaryFolder()\n\n    @Test fun simple() {\n        val f = tempFolder.newFile()\n        assertEquals(42, getTheAnswer())\n    }\n}\n"}, {"type": "p", "text": "Since the order of parameters for an annotation written in Java is not defined, you can't use a regular function\ncall syntax for passing the arguments. Instead, you need to use the named argument syntax:"}, {"type": "div", "text": "\n// Java\npublic @interface Ann {\n    int intValue();\n    String stringValue();\n}\n\n"}, {"type": "pre", "text": "// Java\npublic @interface Ann {\n    int intValue();\n    String stringValue();\n}\n"}, {"type": "code", "text": "// Java\npublic @interface Ann {\n    int intValue();\n    String stringValue();\n}\n"}, {"type": "div", "text": "\n// Kotlin\n@Ann(intValue = 1, stringValue = \"abc\") class C\n\n"}, {"type": "pre", "text": "// Kotlin\n@Ann(intValue = 1, stringValue = \"abc\") class C\n"}, {"type": "code", "text": "// Kotlin\n@Ann(intValue = 1, stringValue = \"abc\") class C\n"}, {"type": "p", "text": "Just like in Java, a special case is the value parameter; its value can be specified without an explicit name:"}, {"type": "code", "text": "value"}, {"type": "div", "text": "\n// Java\npublic @interface AnnWithValue {\n    String value();\n}\n\n"}, {"type": "pre", "text": "// Java\npublic @interface AnnWithValue {\n    String value();\n}\n"}, {"type": "code", "text": "// Java\npublic @interface AnnWithValue {\n    String value();\n}\n"}, {"type": "div", "text": "\n// Kotlin\n@AnnWithValue(\"abc\") class C\n\n"}, {"type": "pre", "text": "// Kotlin\n@AnnWithValue(\"abc\") class C\n"}, {"type": "code", "text": "// Kotlin\n@AnnWithValue(\"abc\") class C\n"}, {"type": "h3", "text": "Arrays as annotation parameters"}, {"type": "p", "text": "If the value argument in Java has an array type, it becomes a vararg parameter in Kotlin:"}, {"type": "code", "text": "value"}, {"type": "code", "text": "vararg"}, {"type": "div", "text": "\n// Java\npublic @interface AnnWithArrayValue {\n    String[] value();\n}\n\n"}, {"type": "pre", "text": "// Java\npublic @interface AnnWithArrayValue {\n    String[] value();\n}\n"}, {"type": "code", "text": "// Java\npublic @interface AnnWithArrayValue {\n    String[] value();\n}\n"}, {"type": "div", "text": "\n// Kotlin\n@AnnWithArrayValue(\"abc\", \"foo\", \"bar\") class C\n\n"}, {"type": "pre", "text": "// Kotlin\n@AnnWithArrayValue(\"abc\", \"foo\", \"bar\") class C\n"}, {"type": "code", "text": "// Kotlin\n@AnnWithArrayValue(\"abc\", \"foo\", \"bar\") class C\n"}, {"type": "p", "text": "For other arguments that have an array type, you need to use the array literal syntax (since Kotlin 1.2) or \narrayOf(...):"}, {"type": "code", "text": "arrayOf(...)"}, {"type": "div", "text": "\n// Java\npublic @interface AnnWithArrayMethod {\n    String[] names();\n}\n\n"}, {"type": "pre", "text": "// Java\npublic @interface AnnWithArrayMethod {\n    String[] names();\n}\n"}, {"type": "code", "text": "// Java\npublic @interface AnnWithArrayMethod {\n    String[] names();\n}\n"}, {"type": "div", "text": "\n// Kotlin 1.2+:\n@AnnWithArrayMethod(names = [\"abc\", \"foo\", \"bar\"]) \nclass C\n\n// Older Kotlin versions:\n@AnnWithArrayMethod(names = arrayOf(\"abc\", \"foo\", \"bar\")) \nclass D\n\n"}, {"type": "pre", "text": "// Kotlin 1.2+:\n@AnnWithArrayMethod(names = [\"abc\", \"foo\", \"bar\"]) \nclass C\n\n// Older Kotlin versions:\n@AnnWithArrayMethod(names = arrayOf(\"abc\", \"foo\", \"bar\")) \nclass D\n"}, {"type": "code", "text": "// Kotlin 1.2+:\n@AnnWithArrayMethod(names = [\"abc\", \"foo\", \"bar\"]) \nclass C\n\n// Older Kotlin versions:\n@AnnWithArrayMethod(names = arrayOf(\"abc\", \"foo\", \"bar\")) \nclass D\n"}, {"type": "h3", "text": "Accessing properties of an annotation instance"}, {"type": "p", "text": "Values of an annotation instance are exposed as properties to Kotlin code:"}, {"type": "div", "text": "\n// Java\npublic @interface Ann {\n    int value();\n}\n\n"}, {"type": "pre", "text": "// Java\npublic @interface Ann {\n    int value();\n}\n"}, {"type": "code", "text": "// Java\npublic @interface Ann {\n    int value();\n}\n"}, {"type": "div", "text": "\n// Kotlin\nfun foo(ann: Ann) {\n    val i = ann.value\n}\n\n"}, {"type": "pre", "text": "// Kotlin\nfun foo(ann: Ann) {\n    val i = ann.value\n}\n"}, {"type": "code", "text": "// Kotlin\nfun foo(ann: Ann) {\n    val i = ann.value\n}\n"}]