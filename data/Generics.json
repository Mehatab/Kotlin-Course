[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Generics"}, {"type": "p", "text": "As in Java, classes in Kotlin may have type parameters:"}, {"type": "div", "text": "\nclass Box<T>(t: T) {\n    var value = t\n}\n\n"}, {"type": "pre", "text": "class Box<T>(t: T) {\n    var value = t\n}\n"}, {"type": "code", "text": "class Box<T>(t: T) {\n    var value = t\n}\n"}, {"type": "p", "text": "In general, to create an instance of such a class, we need to provide the type arguments:"}, {"type": "div", "text": "\nval box: Box<Int> = Box<Int>(1)\n\n"}, {"type": "pre", "text": "val box: Box<Int> = Box<Int>(1)\n"}, {"type": "code", "text": "val box: Box<Int> = Box<Int>(1)\n"}, {"type": "p", "text": "But if the parameters may be inferred, e.g. from the constructor arguments or by some other means, one is allowed to omit the type arguments:"}, {"type": "div", "text": "\nval box = Box(1) // 1 has type Int, so the compiler figures out that we are talking about Box<Int>\n\n"}, {"type": "pre", "text": "val box = Box(1) // 1 has type Int, so the compiler figures out that we are talking about Box<Int>\n"}, {"type": "code", "text": "val box = Box(1) // 1 has type Int, so the compiler figures out that we are talking about Box<Int>\n"}, {"type": "h2", "text": "Variance"}, {"type": "p", "text": "One of the most tricky parts of Java's type system is wildcard types (see Java Generics FAQ).\nAnd Kotlin doesn't have any. Instead, it has two other things: declaration-site variance and type projections."}, {"type": "a", "text": "Java Generics FAQ"}, {"type": "p", "text": "First, let's think about why Java needs those mysterious wildcards. The problem is explained in Effective Java, 3rd Edition, Item 31: Use bounded wildcards to increase API flexibility.\nFirst, generic types in Java are invariant, meaning that List<String> is not a subtype of List<Object>. \nWhy so? If List was not invariant, it would have been no \nbetter than Java's arrays, since the following code would have compiled and caused an exception at runtime:"}, {"type": "a", "text": "Effective Java, 3rd Edition"}, {"type": "em", "text": "Use bounded wildcards to increase API flexibility"}, {"type": "strong", "text": "invariant"}, {"type": "code", "text": "List<String>"}, {"type": "strong", "text": "not"}, {"type": "code", "text": "List<Object>"}, {"type": "strong", "text": "invariant"}, {"type": "div", "text": "\n// Java\nList<String> strs = new ArrayList<String>();\nList<Object> objs = strs; // !!! The cause of the upcoming problem sits here. Java prohibits this!\nobjs.add(1); // Here we put an Integer into a list of Strings\nString s = strs.get(0); // !!! ClassCastException: Cannot cast Integer to String\n\n"}, {"type": "pre", "text": "// Java\nList<String> strs = new ArrayList<String>();\nList<Object> objs = strs; // !!! The cause of the upcoming problem sits here. Java prohibits this!\nobjs.add(1); // Here we put an Integer into a list of Strings\nString s = strs.get(0); // !!! ClassCastException: Cannot cast Integer to String\n"}, {"type": "code", "text": "// Java\nList<String> strs = new ArrayList<String>();\nList<Object> objs = strs; // !!! The cause of the upcoming problem sits here. Java prohibits this!\nobjs.add(1); // Here we put an Integer into a list of Strings\nString s = strs.get(0); // !!! ClassCastException: Cannot cast Integer to String\n"}, {"type": "p", "text": "So, Java prohibits such things in order to guarantee run-time safety. But this has some implications. For example, consider the addAll() method from Collection \ninterface. What's the signature of this method? Intuitively, we'd put it this way:"}, {"type": "code", "text": "addAll()"}, {"type": "code", "text": "Collection"}, {"type": "div", "text": "\n// Java\ninterface Collection<E> ... {\n  void addAll(Collection<E> items);\n}\n\n"}, {"type": "pre", "text": "// Java\ninterface Collection<E> ... {\n  void addAll(Collection<E> items);\n}\n"}, {"type": "code", "text": "// Java\ninterface Collection<E> ... {\n  void addAll(Collection<E> items);\n}\n"}, {"type": "p", "text": "But then, we can't do the following simple thing (which is perfectly safe):"}, {"type": "div", "text": "\n// Java\nvoid copyAll(Collection<Object> to, Collection<String> from) {\n  to.addAll(from);\n  // !!! Would not compile with the naive declaration of addAll:\n  // Collection<String> is not a subtype of Collection<Object>\n}\n\n"}, {"type": "pre", "text": "// Java\nvoid copyAll(Collection<Object> to, Collection<String> from) {\n  to.addAll(from);\n  // !!! Would not compile with the naive declaration of addAll:\n  // Collection<String> is not a subtype of Collection<Object>\n}\n"}, {"type": "code", "text": "// Java\nvoid copyAll(Collection<Object> to, Collection<String> from) {\n  to.addAll(from);\n  // !!! Would not compile with the naive declaration of addAll:\n  // Collection<String> is not a subtype of Collection<Object>\n}\n"}, {"type": "p", "text": "(In Java, we learned this lesson the hard way, see Effective Java, 3rd Edition, Item 28: Prefer lists to arrays)"}, {"type": "a", "text": "Effective Java, 3rd Edition"}, {"type": "em", "text": "Prefer lists to arrays"}, {"type": "p", "text": "That's why the actual signature of addAll() is the following:"}, {"type": "code", "text": "addAll()"}, {"type": "div", "text": "\n// Java\ninterface Collection<E> ... {\n  void addAll(Collection<? extends E> items);\n}\n\n"}, {"type": "pre", "text": "// Java\ninterface Collection<E> ... {\n  void addAll(Collection<? extends E> items);\n}\n"}, {"type": "code", "text": "// Java\ninterface Collection<E> ... {\n  void addAll(Collection<? extends E> items);\n}\n"}, {"type": "p", "text": "The wildcard type argument ? extends E indicates that this method accepts a collection of objects of E or some subtype of E, not just E itself. \nThis means that we can safely read E's from items (elements of this collection are instances of a subclass of E), but cannot write to \nit since we do not know what objects comply to that unknown subtype of E. \nIn return for this limitation, we have the desired behaviour: Collection<String> is a subtype of Collection<? extends Object>. \nIn \"clever words\", the wildcard with an extends-bound (upper bound) makes the type covariant."}, {"type": "strong", "text": "wildcard type argument"}, {"type": "code", "text": "? extends E"}, {"type": "code", "text": "E"}, {"type": "em", "text": "or some subtype of"}, {"type": "code", "text": "E"}, {"type": "code", "text": "E"}, {"type": "strong", "text": "read"}, {"type": "code", "text": "E"}, {"type": "strong", "text": "cannot write"}, {"type": "code", "text": "E"}, {"type": "code", "text": "Collection<String>"}, {"type": "em", "text": "is"}, {"type": "code", "text": "Collection<? extends Object>"}, {"type": "strong", "text": "extends"}, {"type": "strong", "text": "upper"}, {"type": "strong", "text": "covariant"}, {"type": "p", "text": "The key to understanding why this trick works is rather simple: if you can only take items from a collection, then using a collection of Strings\nand reading Objects from it is fine. Conversely, if you can only put items into the collection, it's OK to take a collection of\nObjects and put Strings into it: in Java we have List<? super String> a supertype of List<Object>."}, {"type": "strong", "text": "take"}, {"type": "code", "text": "String"}, {"type": "code", "text": "Object"}, {"type": "em", "text": "put"}, {"type": "code", "text": "Object"}, {"type": "code", "text": "String"}, {"type": "code", "text": "List<? super String>"}, {"type": "strong", "text": "supertype"}, {"type": "code", "text": "List<Object>"}, {"type": "p", "text": "The latter is called contravariance, and you can only call methods that take String as an argument on List<? super String> \n(e.g., you can call add(String) or set(int, String)), while \nif you call something that returns T in List<T>, you don't get a String, but an Object."}, {"type": "strong", "text": "contravariance"}, {"type": "code", "text": "List<? super String>"}, {"type": "code", "text": "add(String)"}, {"type": "code", "text": "set(int, String)"}, {"type": "code", "text": "T"}, {"type": "code", "text": "List<T>"}, {"type": "code", "text": "String"}, {"type": "code", "text": "Object"}, {"type": "p", "text": "Joshua Bloch calls those objects you only read from Producers, and those you only write to Consumers. He recommends: \"For maximum flexibility, use wildcard types on input parameters that represent producers or consumers\", and proposes the following mnemonic:"}, {"type": "strong", "text": "read"}, {"type": "strong", "text": "Producers"}, {"type": "strong", "text": "write"}, {"type": "strong", "text": "Consumers"}, {"type": "em", "text": "For maximum flexibility, use wildcard types on input parameters that represent producers or consumers"}, {"type": "p", "text": "PECS stands for Producer-Extends, Consumer-Super."}, {"type": "em", "text": "PECS stands for Producer-Extends, Consumer-Super."}, {"type": "p", "text": "NOTE: if you use a producer-object, say, List<? extends Foo>, you are not allowed to call add() or set() on this object, but this does not mean \nthat this object is immutable: for example, nothing prevents you from calling clear() to remove all items from the list, since clear() \ndoes not take any parameters at all. The only thing guaranteed by wildcards (or other types of variance) is type safety. Immutability is a completely different story."}, {"type": "em", "text": "NOTE"}, {"type": "code", "text": "List<? extends Foo>"}, {"type": "code", "text": "add()"}, {"type": "code", "text": "set()"}, {"type": "strong", "text": "immutable"}, {"type": "code", "text": "clear()"}, {"type": "code", "text": "clear()"}, {"type": "strong", "text": "type safety"}, {"type": "h3", "text": "Declaration-site variance"}, {"type": "p", "text": "Suppose we have a generic interface Source<T> that does not have any methods that take T as a parameter, only methods that return T:"}, {"type": "code", "text": "Source<T>"}, {"type": "code", "text": "T"}, {"type": "code", "text": "T"}, {"type": "div", "text": "\n// Java\ninterface Source<T> {\n  T nextT();\n}\n\n"}, {"type": "pre", "text": "// Java\ninterface Source<T> {\n  T nextT();\n}\n"}, {"type": "code", "text": "// Java\ninterface Source<T> {\n  T nextT();\n}\n"}, {"type": "p", "text": "Then, it would be perfectly safe to store a reference to an instance of Source<String> in a variable of type Source<Object> \u2013 there are no consumer-methods to call. But Java does not know this, and still prohibits it:"}, {"type": "code", "text": "Source<String>"}, {"type": "code", "text": "Source<Object>"}, {"type": "div", "text": "\n// Java\nvoid demo(Source<String> strs) {\n  Source<Object> objects = strs; // !!! Not allowed in Java\n  // ...\n}\n\n"}, {"type": "pre", "text": "// Java\nvoid demo(Source<String> strs) {\n  Source<Object> objects = strs; // !!! Not allowed in Java\n  // ...\n}\n"}, {"type": "code", "text": "// Java\nvoid demo(Source<String> strs) {\n  Source<Object> objects = strs; // !!! Not allowed in Java\n  // ...\n}\n"}, {"type": "p", "text": "To fix this, we have to declare objects of type Source<? extends Object>, which is sort of meaningless, because we can call all the same methods on such a variable as before, so there's no value added by the more complex type. But the compiler does not know that."}, {"type": "code", "text": "Source<? extends Object>"}, {"type": "p", "text": "In Kotlin, there is a way to explain this sort of thing to the compiler. This is called declaration-site variance: we can annotate the type parameter T of Source to make sure that it is only returned (produced) from members of Source<T>, and never consumed. \nTo do this we provide the out modifier:"}, {"type": "strong", "text": "declaration-site variance"}, {"type": "strong", "text": "type parameter"}, {"type": "code", "text": "T"}, {"type": "strong", "text": "returned"}, {"type": "code", "text": "Source<T>"}, {"type": "strong", "text": "out"}, {"type": "div", "text": "\ninterface Source<out T> {\n    fun nextT(): T\n}\n\nfun demo(strs: Source<String>) {\n    val objects: Source<Any> = strs // This is OK, since T is an out-parameter\n    // ...\n}\n\n"}, {"type": "pre", "text": "interface Source<out T> {\n    fun nextT(): T\n}\n\nfun demo(strs: Source<String>) {\n    val objects: Source<Any> = strs // This is OK, since T is an out-parameter\n    // ...\n}\n"}, {"type": "code", "text": "interface Source<out T> {\n    fun nextT(): T\n}\n\nfun demo(strs: Source<String>) {\n    val objects: Source<Any> = strs // This is OK, since T is an out-parameter\n    // ...\n}\n"}, {"type": "p", "text": "The general rule is: when a type parameter T of a class C is declared out, it may occur only in out-position in the members of C, but in return C<Base> can safely be a supertype \nof C<Derived>."}, {"type": "code", "text": "T"}, {"type": "code", "text": "C"}, {"type": "strong", "text": "out"}, {"type": "strong", "text": "out"}, {"type": "code", "text": "C"}, {"type": "code", "text": "C<Base>"}, {"type": "code", "text": "C<Derived>"}, {"type": "p", "text": "In \"clever words\" they say that the class C is covariant in the parameter T, or that T is a covariant type parameter. \nYou can think of C as being a producer of T's, and NOT a consumer of T's."}, {"type": "code", "text": "C"}, {"type": "strong", "text": "covariant"}, {"type": "code", "text": "T"}, {"type": "code", "text": "T"}, {"type": "strong", "text": "covariant"}, {"type": "code", "text": "C"}, {"type": "strong", "text": "producer"}, {"type": "code", "text": "T"}, {"type": "strong", "text": "consumer"}, {"type": "code", "text": "T"}, {"type": "p", "text": "The out modifier is called a variance annotation, and  since it is provided at the type parameter declaration site, we talk about declaration-site variance. \nThis is in contrast with Java's use-site variance where wildcards in the type usages make the types covariant."}, {"type": "strong", "text": "out"}, {"type": "strong", "text": "variance annotation"}, {"type": "strong", "text": "declaration-site variance"}, {"type": "strong", "text": "use-site variance"}, {"type": "p", "text": "In addition to out, Kotlin provides a complementary variance annotation: in. It makes a type parameter contravariant: it can only be consumed and never \nproduced. A good example of a contravariant type is Comparable:"}, {"type": "strong", "text": "out"}, {"type": "strong", "text": "in"}, {"type": "strong", "text": "contravariant"}, {"type": "code", "text": "Comparable"}, {"type": "div", "text": "\ninterface Comparable<in T> {\n    operator fun compareTo(other: T): Int\n}\n\nfun demo(x: Comparable<Number>) {\n    x.compareTo(1.0) // 1.0 has type Double, which is a subtype of Number\n    // Thus, we can assign x to a variable of type Comparable<Double>\n    val y: Comparable<Double> = x // OK!\n}\n\n"}, {"type": "pre", "text": "interface Comparable<in T> {\n    operator fun compareTo(other: T): Int\n}\n\nfun demo(x: Comparable<Number>) {\n    x.compareTo(1.0) // 1.0 has type Double, which is a subtype of Number\n    // Thus, we can assign x to a variable of type Comparable<Double>\n    val y: Comparable<Double> = x // OK!\n}\n"}, {"type": "code", "text": "interface Comparable<in T> {\n    operator fun compareTo(other: T): Int\n}\n\nfun demo(x: Comparable<Number>) {\n    x.compareTo(1.0) // 1.0 has type Double, which is a subtype of Number\n    // Thus, we can assign x to a variable of type Comparable<Double>\n    val y: Comparable<Double> = x // OK!\n}\n"}, {"type": "p", "text": "We believe that the words in and out are self-explaining (as they were successfully used in C# for quite some time already), \nthus the mnemonic mentioned above is not really needed, and one can rephrase it for a higher purpose:"}, {"type": "strong", "text": "in"}, {"type": "strong", "text": "out"}, {"type": "p", "text": "The Existential Transformation: Consumer in, Producer out! :-)"}, {"type": "strong", "text": "The Existential Transformation: Consumer in, Producer out!"}, {"type": "a", "text": "The Existential"}, {"type": "h2", "text": "Type projections"}, {"type": "h3", "text": "Use-site variance: Type projections"}, {"type": "p", "text": "It is very convenient to declare a type parameter T as out and avoid trouble with subtyping on the use site, but some classes can't actually be restricted to only return T's! \nA good example of this is Array:"}, {"type": "em", "text": "out"}, {"type": "strong", "text": "can't"}, {"type": "code", "text": "T"}, {"type": "div", "text": "\nclass Array<T>(val size: Int) {\n    fun get(index: Int): T { ... }\n    fun set(index: Int, value: T) { ... }\n}\n\n"}, {"type": "pre", "text": "class Array<T>(val size: Int) {\n    fun get(index: Int): T { ... }\n    fun set(index: Int, value: T) { ... }\n}\n"}, {"type": "code", "text": "class Array<T>(val size: Int) {\n    fun get(index: Int): T { ... }\n    fun set(index: Int, value: T) { ... }\n}\n"}, {"type": "p", "text": "This class cannot be either co- or contravariant in T. And this imposes certain inflexibilities. Consider the following function:"}, {"type": "code", "text": "T"}, {"type": "div", "text": "\nfun copy(from: Array<Any>, to: Array<Any>) {\n    assert(from.size == to.size)\n    for (i in from.indices)\n        to[i] = from[i]\n}\n\n"}, {"type": "pre", "text": "fun copy(from: Array<Any>, to: Array<Any>) {\n    assert(from.size == to.size)\n    for (i in from.indices)\n        to[i] = from[i]\n}\n"}, {"type": "code", "text": "fun copy(from: Array<Any>, to: Array<Any>) {\n    assert(from.size == to.size)\n    for (i in from.indices)\n        to[i] = from[i]\n}\n"}, {"type": "p", "text": "This function is supposed to copy items from one array to another. Let's try to apply it in practice:"}, {"type": "div", "text": "\nval ints: Array<Int> = arrayOf(1, 2, 3)\nval any = Array<Any>(3) { \"\" } \ncopy(ints, any)\n//   ^ type is Array<Int> but Array<Any> was expected\n\n"}, {"type": "pre", "text": "val ints: Array<Int> = arrayOf(1, 2, 3)\nval any = Array<Any>(3) { \"\" } \ncopy(ints, any)\n//   ^ type is Array<Int> but Array<Any> was expected\n"}, {"type": "code", "text": "val ints: Array<Int> = arrayOf(1, 2, 3)\nval any = Array<Any>(3) { \"\" } \ncopy(ints, any)\n//   ^ type is Array<Int> but Array<Any> was expected\n"}, {"type": "p", "text": "Here we run into the same familiar problem: Array<T> is invariant in T, thus neither of Array<Int> and Array<Any> \nis a subtype of the other. Why? Again, because copy might be doing bad things, i.e. it might attempt to write, say, a String to from,\nand if we actually passed an array of Int there, a ClassCastException would have been thrown sometime later."}, {"type": "code", "text": "Array<T>"}, {"type": "strong", "text": "invariant"}, {"type": "code", "text": "T"}, {"type": "code", "text": "Array<Int>"}, {"type": "code", "text": "Array<Any>"}, {"type": "strong", "text": "might"}, {"type": "strong", "text": "write"}, {"type": "code", "text": "from"}, {"type": "code", "text": "Int"}, {"type": "code", "text": "ClassCastException"}, {"type": "p", "text": "Then, the only thing we want to ensure is that copy() does not do any bad things. We want to prohibit it from writing to from, and we can:"}, {"type": "code", "text": "copy()"}, {"type": "strong", "text": "writing"}, {"type": "code", "text": "from"}, {"type": "div", "text": "\nfun copy(from: Array<out Any>, to: Array<Any>) { ... }\n\n"}, {"type": "pre", "text": "fun copy(from: Array<out Any>, to: Array<Any>) { ... }\n"}, {"type": "code", "text": "fun copy(from: Array<out Any>, to: Array<Any>) { ... }\n"}, {"type": "p", "text": "What has happened here is called type projection: we said that from is not simply an array, but a restricted (projected) one: we can only call those methods that return the type parameter \nT, in this case it means that we can only call get(). This is our approach to use-site variance, and corresponds to Java's Array<? extends Object>, \nbut in a slightly simpler way."}, {"type": "strong", "text": "type projection"}, {"type": "code", "text": "from"}, {"type": "strong", "text": "projected"}, {"type": "code", "text": "T"}, {"type": "code", "text": "get()"}, {"type": "strong", "text": "use-site variance"}, {"type": "code", "text": "Array<? extends Object>"}, {"type": "p", "text": "You can project a type with in as well:"}, {"type": "strong", "text": "in"}, {"type": "div", "text": "\nfun fill(dest: Array<in String>, value: String) { ... }\n\n"}, {"type": "pre", "text": "fun fill(dest: Array<in String>, value: String) { ... }\n"}, {"type": "code", "text": "fun fill(dest: Array<in String>, value: String) { ... }\n"}, {"type": "p", "text": "Array<in String> corresponds to Java's Array<? super String>, i.e. you can pass an array of CharSequence or an array of Object to the fill() function."}, {"type": "code", "text": "Array<in String>"}, {"type": "code", "text": "Array<? super String>"}, {"type": "code", "text": "CharSequence"}, {"type": "code", "text": "Object"}, {"type": "code", "text": "fill()"}, {"type": "h3", "text": "Star-projections"}, {"type": "p", "text": "Sometimes you want to say that you know nothing about the type argument, but still want to use it in a safe way.\nThe safe way here is to define such a projection of the generic type, that every concrete instantiation of that generic type would be a subtype of that projection."}, {"type": "p", "text": "Kotlin provides so called star-projection syntax for this:"}, {"type": "strong", "text": "star-projection"}, {"type": "ul", "text": "\nFor Foo<out T : TUpper>, where T is a covariant type parameter with the upper bound TUpper, Foo<*> is equivalent to Foo<out TUpper>. It means that when the T is unknown you can safely read values of TUpper from Foo<*>.\nFor Foo<in T>, where T is a contravariant type parameter, Foo<*> is equivalent to Foo<in Nothing>. It means there is nothing you can write to Foo<*> in a safe way when T is unknown.\nFor Foo<T : TUpper>, where T is an invariant type parameter with the upper bound TUpper, Foo<*> is equivalent to Foo<out TUpper> for reading values and to Foo<in Nothing> for writing values.\n"}, {"type": "li", "text": "For Foo<out T : TUpper>, where T is a covariant type parameter with the upper bound TUpper, Foo<*> is equivalent to Foo<out TUpper>. It means that when the T is unknown you can safely read values of TUpper from Foo<*>."}, {"type": "code", "text": "Foo<out T : TUpper>"}, {"type": "code", "text": "T"}, {"type": "code", "text": "TUpper"}, {"type": "code", "text": "Foo<*>"}, {"type": "code", "text": "Foo<out TUpper>"}, {"type": "code", "text": "T"}, {"type": "em", "text": "read"}, {"type": "code", "text": "TUpper"}, {"type": "code", "text": "Foo<*>"}, {"type": "li", "text": "For Foo<in T>, where T is a contravariant type parameter, Foo<*> is equivalent to Foo<in Nothing>. It means there is nothing you can write to Foo<*> in a safe way when T is unknown."}, {"type": "code", "text": "Foo<in T>"}, {"type": "code", "text": "T"}, {"type": "code", "text": "Foo<*>"}, {"type": "code", "text": "Foo<in Nothing>"}, {"type": "em", "text": "write"}, {"type": "code", "text": "Foo<*>"}, {"type": "code", "text": "T"}, {"type": "li", "text": "For Foo<T : TUpper>, where T is an invariant type parameter with the upper bound TUpper, Foo<*> is equivalent to Foo<out TUpper> for reading values and to Foo<in Nothing> for writing values."}, {"type": "code", "text": "Foo<T : TUpper>"}, {"type": "code", "text": "T"}, {"type": "code", "text": "TUpper"}, {"type": "code", "text": "Foo<*>"}, {"type": "code", "text": "Foo<out TUpper>"}, {"type": "code", "text": "Foo<in Nothing>"}, {"type": "p", "text": "If a generic type has several type parameters each of them can be projected independently.\nFor example, if the type is declared as interface Function<in T, out U> we can imagine the following star-projections:"}, {"type": "code", "text": "interface Function<in T, out U>"}, {"type": "ul", "text": "\nFunction<*, String> means Function<in Nothing, String>;\nFunction<Int, *> means Function<Int, out Any?>;\nFunction<*, *> means Function<in Nothing, out Any?>.\n"}, {"type": "li", "text": "Function<*, String> means Function<in Nothing, String>;"}, {"type": "code", "text": "Function<*, String>"}, {"type": "code", "text": "Function<in Nothing, String>"}, {"type": "li", "text": "Function<Int, *> means Function<Int, out Any?>;"}, {"type": "code", "text": "Function<Int, *>"}, {"type": "code", "text": "Function<Int, out Any?>"}, {"type": "li", "text": "Function<*, *> means Function<in Nothing, out Any?>."}, {"type": "code", "text": "Function<*, *>"}, {"type": "code", "text": "Function<in Nothing, out Any?>"}, {"type": "p", "text": "Note: star-projections are very much like Java's raw types, but safe."}, {"type": "em", "text": "Note"}, {"type": "h2", "text": "Generic functions"}, {"type": "p", "text": "Not only classes can have type parameters. Functions can, too. Type parameters are placed before the name of the function:"}, {"type": "strong", "text": "before"}, {"type": "div", "text": "\nfun <T> singletonList(item: T): List<T> {\n    // ...\n}\n\nfun <T> T.basicToString(): String {  // extension function\n    // ...\n}\n\n"}, {"type": "pre", "text": "fun <T> singletonList(item: T): List<T> {\n    // ...\n}\n\nfun <T> T.basicToString(): String {  // extension function\n    // ...\n}\n"}, {"type": "code", "text": "fun <T> singletonList(item: T): List<T> {\n    // ...\n}\n\nfun <T> T.basicToString(): String {  // extension function\n    // ...\n}\n"}, {"type": "p", "text": "To call a generic function, specify the type arguments at the call site after the name of the function:"}, {"type": "strong", "text": "after"}, {"type": "div", "text": "\nval l = singletonList<Int>(1)\n\n"}, {"type": "pre", "text": "val l = singletonList<Int>(1)\n"}, {"type": "code", "text": "val l = singletonList<Int>(1)\n"}, {"type": "p", "text": "Type arguments can be omitted if they can be inferred from the context, so the following example works as well:"}, {"type": "div", "text": "\nval l = singletonList(1)\n\n"}, {"type": "pre", "text": "val l = singletonList(1)\n"}, {"type": "code", "text": "val l = singletonList(1)\n"}, {"type": "h2", "text": "Generic constraints"}, {"type": "p", "text": "The set of all possible types that can be substituted for a given type parameter may be restricted by generic constraints."}, {"type": "strong", "text": "generic constraints"}, {"type": "h3", "text": "Upper bounds"}, {"type": "p", "text": "The most common type of constraint is an upper bound that corresponds to Java's extends keyword:"}, {"type": "strong", "text": "upper bound"}, {"type": "em", "text": "extends"}, {"type": "div", "text": "\nfun <T : Comparable<T>> sort(list: List<T>) {  ... }\n\n"}, {"type": "pre", "text": "fun <T : Comparable<T>> sort(list: List<T>) {  ... }\n"}, {"type": "code", "text": "fun <T : Comparable<T>> sort(list: List<T>) {  ... }\n"}, {"type": "p", "text": "The type specified after a colon is the upper bound: only a subtype of Comparable<T> may be substituted for T. For example:"}, {"type": "strong", "text": "upper bound"}, {"type": "code", "text": "Comparable<T>"}, {"type": "code", "text": "T"}, {"type": "div", "text": "\nsort(listOf(1, 2, 3)) // OK. Int is a subtype of Comparable<Int>\nsort(listOf(HashMap<Int, String>())) // Error: HashMap<Int, String> is not a subtype of Comparable<HashMap<Int, String>>\n\n"}, {"type": "pre", "text": "sort(listOf(1, 2, 3)) // OK. Int is a subtype of Comparable<Int>\nsort(listOf(HashMap<Int, String>())) // Error: HashMap<Int, String> is not a subtype of Comparable<HashMap<Int, String>>\n"}, {"type": "code", "text": "sort(listOf(1, 2, 3)) // OK. Int is a subtype of Comparable<Int>\nsort(listOf(HashMap<Int, String>())) // Error: HashMap<Int, String> is not a subtype of Comparable<HashMap<Int, String>>\n"}, {"type": "p", "text": "The default upper bound (if none specified) is Any?. Only one upper bound can be specified inside the angle brackets.\nIf the same type parameter needs more than one upper bound, we need a separate where-clause:"}, {"type": "code", "text": "Any?"}, {"type": "strong", "text": "where"}, {"type": "div", "text": "\nfun <T> copyWhenGreater(list: List<T>, threshold: T): List<String>\n    where T : CharSequence,\n          T : Comparable<T> {\n    return list.filter { it > threshold }.map { it.toString() }\n}\n\n"}, {"type": "pre", "text": "fun <T> copyWhenGreater(list: List<T>, threshold: T): List<String>\n    where T : CharSequence,\n          T : Comparable<T> {\n    return list.filter { it > threshold }.map { it.toString() }\n}\n"}, {"type": "code", "text": "fun <T> copyWhenGreater(list: List<T>, threshold: T): List<String>\n    where T : CharSequence,\n          T : Comparable<T> {\n    return list.filter { it > threshold }.map { it.toString() }\n}\n"}, {"type": "p", "text": "The passed type must satisfy all conditions of the where clause simultaneously. In the above example, the T type must implement both CharSequence and Comparable."}, {"type": "code", "text": "where"}, {"type": "code", "text": "T"}, {"type": "em", "text": "both"}, {"type": "code", "text": "CharSequence"}, {"type": "code", "text": "Comparable"}, {"type": "h2", "text": "Type erasure"}, {"type": "p", "text": "The type safety checks that Kotlin performs for generic declaration usages are only done at compile time.\nAt runtime, the instances of generic types do not hold any information about their actual type arguments.\nThe type information is said to be erased. For example, the instances of Foo<Bar> and Foo<Baz?> are erased to\njust Foo<*>."}, {"type": "em", "text": "erased"}, {"type": "code", "text": "Foo<Bar>"}, {"type": "code", "text": "Foo<Baz?>"}, {"type": "code", "text": "Foo<*>"}, {"type": "p", "text": "Therefore, there is no general way to check whether an instance of a generic type was created with certain type\narguments at runtime, and the compiler prohibits such is-checks."}, {"type": "a", "text": "prohibits such is-checks"}, {"type": "em", "text": "is"}, {"type": "p", "text": "Type casts to generic types with concrete type arguments, e.g. foo as List<String>, cannot be checked at runtime.\nThese unchecked casts can be used when type safety is implied by the high-level \nprogram logic but cannot be inferred directly by the compiler. The compiler issues a warning on unchecked casts, and at \nruntime, only the non-generic part is checked (equivalent to foo as List<*>)."}, {"type": "code", "text": "foo as List<String>"}, {"type": "br", "text": ""}, {"type": "a", "text": "unchecked casts"}, {"type": "code", "text": "foo as List<*>"}, {"type": "p", "text": "The type arguments of generic function calls are also only checked at compile time. Inside the function bodies, \nthe type parameters cannot be used for type checks, and type casts to type parameters (foo as T) are unchecked. However,\nreified type parameters of inline functions are substituted by the actual \ntype arguments in the inlined function body at the call sites and thus can be used for type checks and casts,\nwith the same restrictions for instances of generic types as described above."}, {"type": "code", "text": "foo as T"}, {"type": "a", "text": "reified type parameters"}]