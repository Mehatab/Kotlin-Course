[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "What's New in Kotlin 1.1"}, {"type": "h2", "text": "Table of Contents"}, {"type": "ul", "text": "\nCoroutines\nOther language features\nStandard library\nJVM backend\nJavaScript backend\n"}, {"type": "li", "text": "Coroutines"}, {"type": "a", "text": "Coroutines"}, {"type": "li", "text": "Other language features"}, {"type": "a", "text": "Other language features"}, {"type": "li", "text": "Standard library"}, {"type": "a", "text": "Standard library"}, {"type": "li", "text": "JVM backend"}, {"type": "a", "text": "JVM backend"}, {"type": "li", "text": "JavaScript backend"}, {"type": "a", "text": "JavaScript backend"}, {"type": "h2", "text": "JavaScript"}, {"type": "p", "text": "Starting with Kotlin 1.1, the JavaScript target is no longer considered experimental. All language features are supported,\nand there are many new tools for integration with the front-end development environment. See below for\na more detailed list of changes."}, {"type": "a", "text": "below"}, {"type": "h2", "text": "Coroutines (experimental)"}, {"type": "p", "text": "The key new feature in Kotlin 1.1 is coroutines, bringing the support of async/await, yield and similar programming\npatterns. The key feature of Kotlin's design is that the implementation of coroutine execution is part of the libraries,\nnot the language, so you aren't bound to any specific programming paradigm or concurrency library."}, {"type": "em", "text": "coroutines"}, {"type": "code", "text": "async"}, {"type": "code", "text": "await"}, {"type": "code", "text": "yield"}, {"type": "p", "text": "A coroutine is effectively a light-weight thread that can be suspended and resumed later. Coroutines are supported through suspending functions: a call to such a function can potentially suspend a coroutine, and to start a new coroutine we usually use an anonymous suspending functions (i.e. suspending lambdas)."}, {"type": "a", "text": "suspending functions"}, {"type": "em", "text": "suspending functions"}, {"type": "p", "text": "Let's look at async/await which is implemented in an external library, kotlinx.coroutines:"}, {"type": "code", "text": "async"}, {"type": "code", "text": "await"}, {"type": "a", "text": "kotlinx.coroutines"}, {"type": "div", "text": "\n// runs the code in the background thread pool\nfun asyncOverlay() = async(CommonPool) {\n    // start two async operations\n    val original = asyncLoadImage(\"original\")\n    val overlay = asyncLoadImage(\"overlay\")\n    // and then apply overlay to both results\n    applyOverlay(original.await(), overlay.await())\n}\n\n// launches new coroutine in UI context\nlaunch(UI) {\n    // wait for async overlay to complete\n    val image = asyncOverlay().await()\n    // and then show it in UI\n    showImage(image)\n}\n\n"}, {"type": "pre", "text": "// runs the code in the background thread pool\nfun asyncOverlay() = async(CommonPool) {\n    // start two async operations\n    val original = asyncLoadImage(\"original\")\n    val overlay = asyncLoadImage(\"overlay\")\n    // and then apply overlay to both results\n    applyOverlay(original.await(), overlay.await())\n}\n\n// launches new coroutine in UI context\nlaunch(UI) {\n    // wait for async overlay to complete\n    val image = asyncOverlay().await()\n    // and then show it in UI\n    showImage(image)\n}\n"}, {"type": "code", "text": "// runs the code in the background thread pool\nfun asyncOverlay() = async(CommonPool) {\n    // start two async operations\n    val original = asyncLoadImage(\"original\")\n    val overlay = asyncLoadImage(\"overlay\")\n    // and then apply overlay to both results\n    applyOverlay(original.await(), overlay.await())\n}\n\n// launches new coroutine in UI context\nlaunch(UI) {\n    // wait for async overlay to complete\n    val image = asyncOverlay().await()\n    // and then show it in UI\n    showImage(image)\n}\n"}, {"type": "p", "text": "Here, async { ... } starts a coroutine and, when we use await(), the execution of the coroutine is suspended while the operation being awaited is executed, and is resumed (possibly on a different thread) when the operation being awaited completes."}, {"type": "code", "text": "async { ... }"}, {"type": "code", "text": "await()"}, {"type": "p", "text": "The standard library uses coroutines to support lazily generated sequences with yield and yieldAll functions.\nIn such a sequence, the block of code that returns sequence elements is suspended after each element has been retrieved,\nand resumed when the next element is requested. Here's an example:"}, {"type": "em", "text": "lazily generated sequences"}, {"type": "code", "text": "yield"}, {"type": "code", "text": "yieldAll"}, {"type": "div", "text": "\nimport kotlin.coroutines.experimental.*\n\nfun main(args: Array<String>) {\n//sampleStart\n    val seq = buildSequence {\n      for (i in 1..5) {\n          // yield a square of i\n          yield(i * i)\n      }\n      // yield a range\n      yieldAll(26..28)\n    }\n\n    // print the sequence\n  println(seq.toList())\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlin.coroutines.experimental.*\n\nfun main(args: Array<String>) {\n//sampleStart\n    val seq = buildSequence {\n      for (i in 1..5) {\n          // yield a square of i\n          yield(i * i)\n      }\n      // yield a range\n      yieldAll(26..28)\n    }\n\n    // print the sequence\n  println(seq.toList())\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlin.coroutines.experimental.*\n\nfun main(args: Array<String>) {\n//sampleStart\n    val seq = buildSequence {\n      for (i in 1..5) {\n          // yield a square of i\n          yield(i * i)\n      }\n      // yield a range\n      yieldAll(26..28)\n    }\n\n    // print the sequence\n  println(seq.toList())\n//sampleEnd\n}\n"}, {"type": "p", "text": "Run the code above to see the result. Feel free to edit it and run again!"}, {"type": "p", "text": "For more information, please refer to the coroutine documentation and tutorial."}, {"type": "a", "text": "coroutine documentation"}, {"type": "a", "text": "tutorial"}, {"type": "p", "text": "Note that coroutines are currently considered an experimental feature, meaning that the Kotlin team is not committing\nto supporting the backwards compatibility of this feature after the final 1.1 release."}, {"type": "strong", "text": "experimental feature"}, {"type": "h2", "text": "Other Language Features"}, {"type": "h3", "text": "Type aliases"}, {"type": "p", "text": "A type alias allows you to define an alternative name for an existing type.\nThis is most useful for generic types such as collections, as well as for function types.\nHere is an example:"}, {"type": "div", "text": "\n//sampleStart\ntypealias OscarWinners = Map<String, String>\n\nfun countLaLaLand(oscarWinners: OscarWinners) =\n        oscarWinners.count { it.value.contains(\"La La Land\") }\n\n// Note that the type names (initial and the type alias) are interchangeable:\nfun checkLaLaLandIsTheBestMovie(oscarWinners: Map<String, String>) =\n        oscarWinners[\"Best picture\"] == \"La La Land\"\n//sampleEnd\n\nfun oscarWinners(): OscarWinners {\n    return mapOf(\n            \"Best song\" to \"City of Stars (La La Land)\",\n            \"Best actress\" to \"Emma Stone (La La Land)\",\n            \"Best picture\" to \"Moonlight\" /* ... */)\n}\n\nfun main(args: Array<String>) {\n    val oscarWinners = oscarWinners()\n\n    val laLaLandAwards = countLaLaLand(oscarWinners)\n    println(\"LaLaLandAwards = $laLaLandAwards (in our small example), but actually it's 6.\")\n\n    val laLaLandIsTheBestMovie = checkLaLaLandIsTheBestMovie(oscarWinners)\n    println(\"LaLaLandIsTheBestMovie = $laLaLandIsTheBestMovie\")\n}\n\n"}, {"type": "pre", "text": "//sampleStart\ntypealias OscarWinners = Map<String, String>\n\nfun countLaLaLand(oscarWinners: OscarWinners) =\n        oscarWinners.count { it.value.contains(\"La La Land\") }\n\n// Note that the type names (initial and the type alias) are interchangeable:\nfun checkLaLaLandIsTheBestMovie(oscarWinners: Map<String, String>) =\n        oscarWinners[\"Best picture\"] == \"La La Land\"\n//sampleEnd\n\nfun oscarWinners(): OscarWinners {\n    return mapOf(\n            \"Best song\" to \"City of Stars (La La Land)\",\n            \"Best actress\" to \"Emma Stone (La La Land)\",\n            \"Best picture\" to \"Moonlight\" /* ... */)\n}\n\nfun main(args: Array<String>) {\n    val oscarWinners = oscarWinners()\n\n    val laLaLandAwards = countLaLaLand(oscarWinners)\n    println(\"LaLaLandAwards = $laLaLandAwards (in our small example), but actually it's 6.\")\n\n    val laLaLandIsTheBestMovie = checkLaLaLandIsTheBestMovie(oscarWinners)\n    println(\"LaLaLandIsTheBestMovie = $laLaLandIsTheBestMovie\")\n}\n"}, {"type": "code", "text": "//sampleStart\ntypealias OscarWinners = Map<String, String>\n\nfun countLaLaLand(oscarWinners: OscarWinners) =\n        oscarWinners.count { it.value.contains(\"La La Land\") }\n\n// Note that the type names (initial and the type alias) are interchangeable:\nfun checkLaLaLandIsTheBestMovie(oscarWinners: Map<String, String>) =\n        oscarWinners[\"Best picture\"] == \"La La Land\"\n//sampleEnd\n\nfun oscarWinners(): OscarWinners {\n    return mapOf(\n            \"Best song\" to \"City of Stars (La La Land)\",\n            \"Best actress\" to \"Emma Stone (La La Land)\",\n            \"Best picture\" to \"Moonlight\" /* ... */)\n}\n\nfun main(args: Array<String>) {\n    val oscarWinners = oscarWinners()\n\n    val laLaLandAwards = countLaLaLand(oscarWinners)\n    println(\"LaLaLandAwards = $laLaLandAwards (in our small example), but actually it's 6.\")\n\n    val laLaLandIsTheBestMovie = checkLaLaLandIsTheBestMovie(oscarWinners)\n    println(\"LaLaLandIsTheBestMovie = $laLaLandIsTheBestMovie\")\n}\n"}, {"type": "p", "text": "See the documentation and KEEP for more details."}, {"type": "a", "text": "documentation"}, {"type": "a", "text": "KEEP"}, {"type": "h3", "text": "Bound callable references"}, {"type": "p", "text": "You can now use the :: operator to get a member reference pointing to a method or property of a specific object instance.\nPreviously this could only be expressed with a lambda.\nHere's an example:"}, {"type": "code", "text": "::"}, {"type": "a", "text": "member reference"}, {"type": "div", "text": "\n//sampleStart\nval numberRegex = \"\\\\d+\".toRegex()\nval numbers = listOf(\"abc\", \"123\", \"456\").filter(numberRegex::matches)\n//sampleEnd\n\nfun main(args: Array<String>) {\n    println(\"Result is $numbers\")\n}\n\n"}, {"type": "pre", "text": "//sampleStart\nval numberRegex = \"\\\\d+\".toRegex()\nval numbers = listOf(\"abc\", \"123\", \"456\").filter(numberRegex::matches)\n//sampleEnd\n\nfun main(args: Array<String>) {\n    println(\"Result is $numbers\")\n}\n"}, {"type": "code", "text": "//sampleStart\nval numberRegex = \"\\\\d+\".toRegex()\nval numbers = listOf(\"abc\", \"123\", \"456\").filter(numberRegex::matches)\n//sampleEnd\n\nfun main(args: Array<String>) {\n    println(\"Result is $numbers\")\n}\n"}, {"type": "p", "text": "Read the documentation and KEEP for more details."}, {"type": "a", "text": "documentation"}, {"type": "a", "text": "KEEP"}, {"type": "h3", "text": "Sealed and data classes"}, {"type": "p", "text": "Kotlin 1.1 removes some of the restrictions on sealed and data classes that were present in Kotlin 1.0.\nNow you can define subclasses of a top-level sealed class on the top level in the same file, and not just as nested classes of the sealed class.\nData classes can now extend other classes.\nThis can be used to define a hierarchy of expression classes nicely and cleanly:"}, {"type": "div", "text": "\n//sampleStart\nsealed class Expr\n\ndata class Const(val number: Double) : Expr()\ndata class Sum(val e1: Expr, val e2: Expr) : Expr()\nobject NotANumber : Expr()\n\nfun eval(expr: Expr): Double = when (expr) {\n    is Const -> expr.number\n    is Sum -> eval(expr.e1) + eval(expr.e2)\n    NotANumber -> Double.NaN\n}\nval e = eval(Sum(Const(1.0), Const(2.0)))\n//sampleEnd\n\nfun main(args: Array<String>) {\n    println(\"e is $e\") // 3.0\n}\n\n"}, {"type": "pre", "text": "//sampleStart\nsealed class Expr\n\ndata class Const(val number: Double) : Expr()\ndata class Sum(val e1: Expr, val e2: Expr) : Expr()\nobject NotANumber : Expr()\n\nfun eval(expr: Expr): Double = when (expr) {\n    is Const -> expr.number\n    is Sum -> eval(expr.e1) + eval(expr.e2)\n    NotANumber -> Double.NaN\n}\nval e = eval(Sum(Const(1.0), Const(2.0)))\n//sampleEnd\n\nfun main(args: Array<String>) {\n    println(\"e is $e\") // 3.0\n}\n"}, {"type": "code", "text": "//sampleStart\nsealed class Expr\n\ndata class Const(val number: Double) : Expr()\ndata class Sum(val e1: Expr, val e2: Expr) : Expr()\nobject NotANumber : Expr()\n\nfun eval(expr: Expr): Double = when (expr) {\n    is Const -> expr.number\n    is Sum -> eval(expr.e1) + eval(expr.e2)\n    NotANumber -> Double.NaN\n}\nval e = eval(Sum(Const(1.0), Const(2.0)))\n//sampleEnd\n\nfun main(args: Array<String>) {\n    println(\"e is $e\") // 3.0\n}\n"}, {"type": "p", "text": "Read the documentation or\nsealed class and\ndata class KEEPs for more detail."}, {"type": "a", "text": "documentation"}, {"type": "a", "text": "sealed class"}, {"type": "a", "text": "data class"}, {"type": "h3", "text": "Destructuring in lambdas"}, {"type": "p", "text": "You can now use the destructuring declaration syntax to unpack the arguments passed to a lambda.\nHere's an example:"}, {"type": "a", "text": "destructuring declaration"}, {"type": "div", "text": "\nfun main(args: Array<String>) {\n//sampleStart\n    val map = mapOf(1 to \"one\", 2 to \"two\")\n    // before\n    println(map.mapValues { entry ->\n      val (key, value) = entry\n      \"$key -> $value!\"\n    })\n    // now\n    println(map.mapValues { (key, value) -> \"$key -> $value!\" })\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val map = mapOf(1 to \"one\", 2 to \"two\")\n    // before\n    println(map.mapValues { entry ->\n      val (key, value) = entry\n      \"$key -> $value!\"\n    })\n    // now\n    println(map.mapValues { (key, value) -> \"$key -> $value!\" })\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val map = mapOf(1 to \"one\", 2 to \"two\")\n    // before\n    println(map.mapValues { entry ->\n      val (key, value) = entry\n      \"$key -> $value!\"\n    })\n    // now\n    println(map.mapValues { (key, value) -> \"$key -> $value!\" })\n//sampleEnd\n}\n"}, {"type": "p", "text": "Read the documentation and KEEP for more details."}, {"type": "a", "text": "documentation"}, {"type": "a", "text": "KEEP"}, {"type": "h3", "text": "Underscores for unused parameters"}, {"type": "p", "text": "For a lambda with multiple parameters, you can use the _ character to replace the names of the parameters you don't use:"}, {"type": "code", "text": "_"}, {"type": "div", "text": "\nfun main(args: Array<String>) {\n    val map = mapOf(1 to \"one\", 2 to \"two\")\n\n//sampleStart\n    map.forEach { _, value -> println(\"$value!\") }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main(args: Array<String>) {\n    val map = mapOf(1 to \"one\", 2 to \"two\")\n\n//sampleStart\n    map.forEach { _, value -> println(\"$value!\") }\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main(args: Array<String>) {\n    val map = mapOf(1 to \"one\", 2 to \"two\")\n\n//sampleStart\n    map.forEach { _, value -> println(\"$value!\") }\n//sampleEnd\n}\n"}, {"type": "p", "text": "This also works in destructuring declarations:"}, {"type": "a", "text": "destructuring declarations"}, {"type": "div", "text": "\ndata class Result(val value: Any, val status: String)\n\nfun getResult() = Result(42, \"ok\").also { println(\"getResult() returns $it\") }\n\nfun main(args: Array<String>) {\n//sampleStart\n    val (_, status) = getResult()\n//sampleEnd\n    println(\"status is '$status'\")\n}\n\n"}, {"type": "pre", "text": "data class Result(val value: Any, val status: String)\n\nfun getResult() = Result(42, \"ok\").also { println(\"getResult() returns $it\") }\n\nfun main(args: Array<String>) {\n//sampleStart\n    val (_, status) = getResult()\n//sampleEnd\n    println(\"status is '$status'\")\n}\n"}, {"type": "code", "text": "data class Result(val value: Any, val status: String)\n\nfun getResult() = Result(42, \"ok\").also { println(\"getResult() returns $it\") }\n\nfun main(args: Array<String>) {\n//sampleStart\n    val (_, status) = getResult()\n//sampleEnd\n    println(\"status is '$status'\")\n}\n"}, {"type": "p", "text": "Read the KEEP for more details."}, {"type": "a", "text": "KEEP"}, {"type": "h3", "text": "Underscores in numeric literals"}, {"type": "p", "text": "Just as in Java 8, Kotlin now allows to use underscores in numeric literals to separate groups of digits:"}, {"type": "div", "text": "\n//sampleStart\nval oneMillion = 1_000_000\nval hexBytes = 0xFF_EC_DE_5E\nval bytes = 0b11010010_01101001_10010100_10010010\n//sampleEnd\n\nfun main(args: Array<String>) {\n    println(oneMillion)\n    println(hexBytes.toString(16))\n    println(bytes.toString(2))\n}\n\n"}, {"type": "pre", "text": "//sampleStart\nval oneMillion = 1_000_000\nval hexBytes = 0xFF_EC_DE_5E\nval bytes = 0b11010010_01101001_10010100_10010010\n//sampleEnd\n\nfun main(args: Array<String>) {\n    println(oneMillion)\n    println(hexBytes.toString(16))\n    println(bytes.toString(2))\n}\n"}, {"type": "code", "text": "//sampleStart\nval oneMillion = 1_000_000\nval hexBytes = 0xFF_EC_DE_5E\nval bytes = 0b11010010_01101001_10010100_10010010\n//sampleEnd\n\nfun main(args: Array<String>) {\n    println(oneMillion)\n    println(hexBytes.toString(16))\n    println(bytes.toString(2))\n}\n"}, {"type": "p", "text": "Read the KEEP for more details."}, {"type": "a", "text": "KEEP"}, {"type": "h3", "text": "Shorter syntax for properties"}, {"type": "p", "text": "For properties with the getter defined as an expression body, the property type can now be omitted:"}, {"type": "div", "text": "\n//sampleStart\n    data class Person(val name: String, val age: Int) {\n    val isAdult get() = age >= 20 // Property type inferred to be 'Boolean'\n}\n//sampleEnd\nfun main(args: Array<String>) {\n    val akari = Person(\"Akari\", 26)\n    println(\"$akari.isAdult = ${akari.isAdult}\")\n}\n\n"}, {"type": "pre", "text": "//sampleStart\n    data class Person(val name: String, val age: Int) {\n    val isAdult get() = age >= 20 // Property type inferred to be 'Boolean'\n}\n//sampleEnd\nfun main(args: Array<String>) {\n    val akari = Person(\"Akari\", 26)\n    println(\"$akari.isAdult = ${akari.isAdult}\")\n}\n"}, {"type": "code", "text": "//sampleStart\n    data class Person(val name: String, val age: Int) {\n    val isAdult get() = age >= 20 // Property type inferred to be 'Boolean'\n}\n//sampleEnd\nfun main(args: Array<String>) {\n    val akari = Person(\"Akari\", 26)\n    println(\"$akari.isAdult = ${akari.isAdult}\")\n}\n"}, {"type": "h3", "text": "Inline property accessors"}, {"type": "p", "text": "You can now mark property accessors with the inline modifier if the properties don't have a backing field.\nSuch accessors are compiled in the same way as inline functions."}, {"type": "code", "text": "inline"}, {"type": "a", "text": "inline functions"}, {"type": "div", "text": "\n//sampleStart\npublic val <T> List<T>.lastIndex: Int\n    inline get() = this.size - 1\n//sampleEnd\n\nfun main(args: Array<String>) {\n    val list = listOf('a', 'b')\n    // the getter will be inlined\n    println(\"Last index of $list is ${list.lastIndex}\")\n}\n\n"}, {"type": "pre", "text": "//sampleStart\npublic val <T> List<T>.lastIndex: Int\n    inline get() = this.size - 1\n//sampleEnd\n\nfun main(args: Array<String>) {\n    val list = listOf('a', 'b')\n    // the getter will be inlined\n    println(\"Last index of $list is ${list.lastIndex}\")\n}\n"}, {"type": "code", "text": "//sampleStart\npublic val <T> List<T>.lastIndex: Int\n    inline get() = this.size - 1\n//sampleEnd\n\nfun main(args: Array<String>) {\n    val list = listOf('a', 'b')\n    // the getter will be inlined\n    println(\"Last index of $list is ${list.lastIndex}\")\n}\n"}, {"type": "p", "text": "You can also mark the entire property as inline - then the modifier is applied to both accessors."}, {"type": "code", "text": "inline"}, {"type": "p", "text": "Read the documentation and KEEP for more details."}, {"type": "a", "text": "documentation"}, {"type": "a", "text": "KEEP"}, {"type": "h3", "text": "Local delegated properties"}, {"type": "p", "text": "You can now use the delegated property syntax with local variables.\nOne possible use is defining a lazily evaluated local variable:"}, {"type": "a", "text": "delegated property"}, {"type": "div", "text": "\nimport java.util.Random\n\nfun needAnswer() = Random().nextBoolean()\n\nfun main(args: Array<String>) {\n//sampleStart\n    val answer by lazy {\n        println(\"Calculating the answer...\")\n        42\n    }\n    if (needAnswer()) {                     // returns the random value\n        println(\"The answer is $answer.\")   // answer is calculated at this point\n    }\n    else {\n        println(\"Sometimes no answer is the answer...\")\n    }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import java.util.Random\n\nfun needAnswer() = Random().nextBoolean()\n\nfun main(args: Array<String>) {\n//sampleStart\n    val answer by lazy {\n        println(\"Calculating the answer...\")\n        42\n    }\n    if (needAnswer()) {                     // returns the random value\n        println(\"The answer is $answer.\")   // answer is calculated at this point\n    }\n    else {\n        println(\"Sometimes no answer is the answer...\")\n    }\n//sampleEnd\n}\n"}, {"type": "code", "text": "import java.util.Random\n\nfun needAnswer() = Random().nextBoolean()\n\nfun main(args: Array<String>) {\n//sampleStart\n    val answer by lazy {\n        println(\"Calculating the answer...\")\n        42\n    }\n    if (needAnswer()) {                     // returns the random value\n        println(\"The answer is $answer.\")   // answer is calculated at this point\n    }\n    else {\n        println(\"Sometimes no answer is the answer...\")\n    }\n//sampleEnd\n}\n"}, {"type": "p", "text": "Read the KEEP for more details."}, {"type": "a", "text": "KEEP"}, {"type": "h3", "text": "Interception of delegated property binding"}, {"type": "p", "text": "For delegated properties, it is now possible to intercept delegate to property binding using the\nprovideDelegate operator.\nFor example, if we want to check the property name before binding, we can write something like this:"}, {"type": "a", "text": "delegated properties"}, {"type": "code", "text": "provideDelegate"}, {"type": "div", "text": "\nclass ResourceLoader<T>(id: ResourceID<T>) {\n    operator fun provideDelegate(thisRef: MyUI, prop: KProperty<*>): ReadOnlyProperty<MyUI, T> {\n        checkProperty(thisRef, prop.name)\n        ... // property creation\n    }\n\n    private fun checkProperty(thisRef: MyUI, name: String) { ... }\n}\n\nfun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }\n\nclass MyUI {\n    val image by bindResource(ResourceID.image_id)\n    val text by bindResource(ResourceID.text_id)\n}\n\n"}, {"type": "pre", "text": "class ResourceLoader<T>(id: ResourceID<T>) {\n    operator fun provideDelegate(thisRef: MyUI, prop: KProperty<*>): ReadOnlyProperty<MyUI, T> {\n        checkProperty(thisRef, prop.name)\n        ... // property creation\n    }\n\n    private fun checkProperty(thisRef: MyUI, name: String) { ... }\n}\n\nfun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }\n\nclass MyUI {\n    val image by bindResource(ResourceID.image_id)\n    val text by bindResource(ResourceID.text_id)\n}\n"}, {"type": "code", "text": "class ResourceLoader<T>(id: ResourceID<T>) {\n    operator fun provideDelegate(thisRef: MyUI, prop: KProperty<*>): ReadOnlyProperty<MyUI, T> {\n        checkProperty(thisRef, prop.name)\n        ... // property creation\n    }\n\n    private fun checkProperty(thisRef: MyUI, name: String) { ... }\n}\n\nfun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }\n\nclass MyUI {\n    val image by bindResource(ResourceID.image_id)\n    val text by bindResource(ResourceID.text_id)\n}\n"}, {"type": "p", "text": "The provideDelegate method will be called for each property during the creation of a MyUI instance, and it can perform\nthe necessary validation right away."}, {"type": "code", "text": "provideDelegate"}, {"type": "code", "text": "MyUI"}, {"type": "p", "text": "Read the documentation for more details."}, {"type": "a", "text": "documentation"}, {"type": "h3", "text": "Generic enum value access"}, {"type": "p", "text": "It is now possible to enumerate the values of an enum class in a generic way."}, {"type": "div", "text": "\n//sampleStart\nenum class RGB { RED, GREEN, BLUE }\n\ninline fun <reified T : Enum<T>> printAllValues() {\n    print(enumValues<T>().joinToString { it.name })\n}\n//sampleEnd\n\nfun main(args: Array<String>) {\n    printAllValues<RGB>() // prints RED, GREEN, BLUE\n}\n\n"}, {"type": "pre", "text": "//sampleStart\nenum class RGB { RED, GREEN, BLUE }\n\ninline fun <reified T : Enum<T>> printAllValues() {\n    print(enumValues<T>().joinToString { it.name })\n}\n//sampleEnd\n\nfun main(args: Array<String>) {\n    printAllValues<RGB>() // prints RED, GREEN, BLUE\n}\n"}, {"type": "code", "text": "//sampleStart\nenum class RGB { RED, GREEN, BLUE }\n\ninline fun <reified T : Enum<T>> printAllValues() {\n    print(enumValues<T>().joinToString { it.name })\n}\n//sampleEnd\n\nfun main(args: Array<String>) {\n    printAllValues<RGB>() // prints RED, GREEN, BLUE\n}\n"}, {"type": "h3", "text": "Scope control for implicit receivers in DSLs"}, {"type": "p", "text": "The @DslMarker annotation allows to restrict the use of receivers from outer scopes in a DSL context.\nConsider the canonical HTML builder example:"}, {"type": "a", "text": "@DslMarker"}, {"type": "code", "text": "@DslMarker"}, {"type": "a", "text": "HTML builder example"}, {"type": "div", "text": "\ntable {\n    tr {\n        td { + \"Text\" }\n    }\n}\n\n"}, {"type": "pre", "text": "table {\n    tr {\n        td { + \"Text\" }\n    }\n}\n"}, {"type": "code", "text": "table {\n    tr {\n        td { + \"Text\" }\n    }\n}\n"}, {"type": "p", "text": "In Kotlin 1.0, code in the lambda passed to td has access to three implicit receivers: the one passed to table, to tr\nand to td. This allows you to call methods that make no sense in the context - for example to call tr inside td and thus\nto put a <tr> tag in a <td>."}, {"type": "code", "text": "td"}, {"type": "code", "text": "table"}, {"type": "code", "text": "tr"}, {"type": "code", "text": "td"}, {"type": "code", "text": "tr"}, {"type": "code", "text": "td"}, {"type": "code", "text": "<tr>"}, {"type": "code", "text": "<td>"}, {"type": "p", "text": "In Kotlin 1.1, you can restrict that, so that only methods defined on the implicit receiver of td\nwill be available inside the lambda passed to td. You do that by defining your annotation marked with the @DslMarker meta-annotation\nand applying it to the base class of the tag classes."}, {"type": "code", "text": "td"}, {"type": "code", "text": "td"}, {"type": "code", "text": "@DslMarker"}, {"type": "p", "text": "Read the documentation and KEEP for more details."}, {"type": "a", "text": "documentation"}, {"type": "a", "text": "KEEP"}, {"type": "h3", "text": "rem operator"}, {"type": "code", "text": "rem"}, {"type": "p", "text": "The mod operator is now deprecated, and rem is used instead. See this issue for motivation."}, {"type": "code", "text": "mod"}, {"type": "code", "text": "rem"}, {"type": "a", "text": "this issue"}, {"type": "h2", "text": "Standard library"}, {"type": "h3", "text": "String to number conversions"}, {"type": "p", "text": "There is a bunch of new extensions on the String class to convert it to a number without throwing an exception on invalid number:\nString.toIntOrNull(): Int?, String.toDoubleOrNull(): Double? etc."}, {"type": "code", "text": "String.toIntOrNull(): Int?"}, {"type": "code", "text": "String.toDoubleOrNull(): Double?"}, {"type": "div", "text": "\nval port = System.getenv(\"PORT\")?.toIntOrNull() ?: 80\n\n"}, {"type": "pre", "text": "val port = System.getenv(\"PORT\")?.toIntOrNull() ?: 80\n"}, {"type": "code", "text": "val port = System.getenv(\"PORT\")?.toIntOrNull() ?: 80\n"}, {"type": "p", "text": "Also integer conversion functions, like Int.toString(), String.toInt(), String.toIntOrNull(),\neach got an overload with radix parameter, which allows to specify the base of conversion (2 to 36)."}, {"type": "code", "text": "Int.toString()"}, {"type": "code", "text": "String.toInt()"}, {"type": "code", "text": "String.toIntOrNull()"}, {"type": "code", "text": "radix"}, {"type": "h3", "text": "onEach()"}, {"type": "p", "text": "onEach is a small, but useful extension function for collections and sequences, which allows to perform some action,\npossibly with side-effects, on each element of the collection/sequence in a chain of operations.\nOn iterables it behaves like forEach but also returns the iterable instance further. And on sequences it returns a\nwrapping sequence, which applies the given action lazily as the elements are being iterated."}, {"type": "code", "text": "onEach"}, {"type": "code", "text": "forEach"}, {"type": "div", "text": "\ninputDir.walk()\n        .filter { it.isFile && it.name.endsWith(\".txt\") }\n        .onEach { println(\"Moving $it to $outputDir\") }\n        .forEach { moveFile(it, File(outputDir, it.toRelativeString(inputDir))) }\n\n"}, {"type": "pre", "text": "inputDir.walk()\n        .filter { it.isFile && it.name.endsWith(\".txt\") }\n        .onEach { println(\"Moving $it to $outputDir\") }\n        .forEach { moveFile(it, File(outputDir, it.toRelativeString(inputDir))) }\n"}, {"type": "code", "text": "inputDir.walk()\n        .filter { it.isFile && it.name.endsWith(\".txt\") }\n        .onEach { println(\"Moving $it to $outputDir\") }\n        .forEach { moveFile(it, File(outputDir, it.toRelativeString(inputDir))) }\n"}, {"type": "h3", "text": "also(), takeIf() and takeUnless()"}, {"type": "p", "text": "These are three general-purpose extension functions applicable to any receiver."}, {"type": "p", "text": "also is like apply: it takes the receiver, does some action on it, and returns that receiver. \nThe difference is that in the block inside apply the receiver is available as this, \nwhile in the block inside also it's available as it (and you can give it another name if you want).\nThis comes handy when you do not want to shadow this from the outer scope:"}, {"type": "code", "text": "also"}, {"type": "code", "text": "apply"}, {"type": "code", "text": "apply"}, {"type": "code", "text": "this"}, {"type": "code", "text": "also"}, {"type": "code", "text": "it"}, {"type": "code", "text": "this"}, {"type": "div", "text": "\nclass Block {\n    lateinit var content: String\n}\n\n//sampleStart\nfun Block.copy() = Block().also {\n    it.content = this.content\n}\n//sampleEnd\n\n// using 'apply' instead\nfun Block.copy1() = Block().apply {\n    this.content = this@copy1.content\n}\n\nfun main(args: Array<String>) {\n    val block = Block().apply { content = \"content\" }\n    val copy = block.copy()\n    println(\"Testing the content was copied:\")\n    println(block.content == copy.content)\n}\n\n"}, {"type": "pre", "text": "class Block {\n    lateinit var content: String\n}\n\n//sampleStart\nfun Block.copy() = Block().also {\n    it.content = this.content\n}\n//sampleEnd\n\n// using 'apply' instead\nfun Block.copy1() = Block().apply {\n    this.content = this@copy1.content\n}\n\nfun main(args: Array<String>) {\n    val block = Block().apply { content = \"content\" }\n    val copy = block.copy()\n    println(\"Testing the content was copied:\")\n    println(block.content == copy.content)\n}\n"}, {"type": "code", "text": "class Block {\n    lateinit var content: String\n}\n\n//sampleStart\nfun Block.copy() = Block().also {\n    it.content = this.content\n}\n//sampleEnd\n\n// using 'apply' instead\nfun Block.copy1() = Block().apply {\n    this.content = this@copy1.content\n}\n\nfun main(args: Array<String>) {\n    val block = Block().apply { content = \"content\" }\n    val copy = block.copy()\n    println(\"Testing the content was copied:\")\n    println(block.content == copy.content)\n}\n"}, {"type": "p", "text": "takeIf is like filter for a single value. It checks whether the receiver meets the predicate, and\nreturns the receiver, if it does or null if it doesn't. \nCombined with an elvis-operator and early returns it allows to write constructs like:"}, {"type": "code", "text": "takeIf"}, {"type": "code", "text": "filter"}, {"type": "code", "text": "null"}, {"type": "div", "text": "\nval outDirFile = File(outputDir.path).takeIf { it.exists() } ?: return false\n// do something with existing outDirFile\n\n"}, {"type": "pre", "text": "val outDirFile = File(outputDir.path).takeIf { it.exists() } ?: return false\n// do something with existing outDirFile\n"}, {"type": "code", "text": "val outDirFile = File(outputDir.path).takeIf { it.exists() } ?: return false\n// do something with existing outDirFile\n"}, {"type": "div", "text": "\nfun main(args: Array<String>) {\n    val input = \"Kotlin\"\n    val keyword = \"in\"\n\n//sampleStart\n    val index = input.indexOf(keyword).takeIf { it >= 0 } ?: error(\"keyword not found\")\n    // do something with index of keyword in input string, given that it's found\n//sampleEnd\n    \n    println(\"'$keyword' was found in '$input'\")\n    println(input)\n    println(\" \".repeat(index) + \"^\")\n}\n\n"}, {"type": "pre", "text": "fun main(args: Array<String>) {\n    val input = \"Kotlin\"\n    val keyword = \"in\"\n\n//sampleStart\n    val index = input.indexOf(keyword).takeIf { it >= 0 } ?: error(\"keyword not found\")\n    // do something with index of keyword in input string, given that it's found\n//sampleEnd\n    \n    println(\"'$keyword' was found in '$input'\")\n    println(input)\n    println(\" \".repeat(index) + \"^\")\n}\n"}, {"type": "code", "text": "fun main(args: Array<String>) {\n    val input = \"Kotlin\"\n    val keyword = \"in\"\n\n//sampleStart\n    val index = input.indexOf(keyword).takeIf { it >= 0 } ?: error(\"keyword not found\")\n    // do something with index of keyword in input string, given that it's found\n//sampleEnd\n    \n    println(\"'$keyword' was found in '$input'\")\n    println(input)\n    println(\" \".repeat(index) + \"^\")\n}\n"}, {"type": "p", "text": "takeUnless is the same as takeIf, but it takes the inverted predicate. It returns the receiver when it doesn't meet the predicate and null otherwise. So one of the examples above could be rewritten with takeUnless as following:"}, {"type": "code", "text": "takeUnless"}, {"type": "code", "text": "takeIf"}, {"type": "em", "text": "doesn't"}, {"type": "code", "text": "null"}, {"type": "code", "text": "takeUnless"}, {"type": "div", "text": "\nval index = input.indexOf(keyword).takeUnless { it < 0 } ?: error(\"keyword not found\")\n\n"}, {"type": "pre", "text": "val index = input.indexOf(keyword).takeUnless { it < 0 } ?: error(\"keyword not found\")\n"}, {"type": "code", "text": "val index = input.indexOf(keyword).takeUnless { it < 0 } ?: error(\"keyword not found\")\n"}, {"type": "p", "text": "It is also convenient to use when you have a callable reference instead of the lambda:"}, {"type": "div", "text": "\nprivate fun testTakeUnless(string: String) {\n//sampleStart\n    val result = string.takeUnless(String::isEmpty)\n//sampleEnd\n\n    println(\"string = \\\"$string\\\"; result = \\\"$result\\\"\")\n}\n\nfun main(args: Array<String>) {\n    testTakeUnless(\"\")\n    testTakeUnless(\"abc\")\n}\n\n"}, {"type": "pre", "text": "private fun testTakeUnless(string: String) {\n//sampleStart\n    val result = string.takeUnless(String::isEmpty)\n//sampleEnd\n\n    println(\"string = \\\"$string\\\"; result = \\\"$result\\\"\")\n}\n\nfun main(args: Array<String>) {\n    testTakeUnless(\"\")\n    testTakeUnless(\"abc\")\n}\n"}, {"type": "code", "text": "private fun testTakeUnless(string: String) {\n//sampleStart\n    val result = string.takeUnless(String::isEmpty)\n//sampleEnd\n\n    println(\"string = \\\"$string\\\"; result = \\\"$result\\\"\")\n}\n\nfun main(args: Array<String>) {\n    testTakeUnless(\"\")\n    testTakeUnless(\"abc\")\n}\n"}, {"type": "h3", "text": "groupingBy()"}, {"type": "p", "text": "This API can be used to group a collection by key and fold each group simultaneously. For example, it can be used\nto count the number of words starting with each letter:"}, {"type": "div", "text": "\nfun main(args: Array<String>) {\n    val words = \"one two three four five six seven eight nine ten\".split(' ')\n//sampleStart\n    val frequencies = words.groupingBy { it.first() }.eachCount()\n//sampleEnd\n    println(\"Counting first letters: $frequencies.\")\n\n    // The alternative way that uses 'groupBy' and 'mapValues' creates an intermediate map, \n    // while 'groupingBy' way counts on the fly.\n    val groupBy = words.groupBy { it.first() }.mapValues { (_, list) -> list.size }\n    println(\"Comparing the result with using 'groupBy': ${groupBy == frequencies}.\")\n}\n\n"}, {"type": "pre", "text": "fun main(args: Array<String>) {\n    val words = \"one two three four five six seven eight nine ten\".split(' ')\n//sampleStart\n    val frequencies = words.groupingBy { it.first() }.eachCount()\n//sampleEnd\n    println(\"Counting first letters: $frequencies.\")\n\n    // The alternative way that uses 'groupBy' and 'mapValues' creates an intermediate map, \n    // while 'groupingBy' way counts on the fly.\n    val groupBy = words.groupBy { it.first() }.mapValues { (_, list) -> list.size }\n    println(\"Comparing the result with using 'groupBy': ${groupBy == frequencies}.\")\n}\n"}, {"type": "code", "text": "fun main(args: Array<String>) {\n    val words = \"one two three four five six seven eight nine ten\".split(' ')\n//sampleStart\n    val frequencies = words.groupingBy { it.first() }.eachCount()\n//sampleEnd\n    println(\"Counting first letters: $frequencies.\")\n\n    // The alternative way that uses 'groupBy' and 'mapValues' creates an intermediate map, \n    // while 'groupingBy' way counts on the fly.\n    val groupBy = words.groupBy { it.first() }.mapValues { (_, list) -> list.size }\n    println(\"Comparing the result with using 'groupBy': ${groupBy == frequencies}.\")\n}\n"}, {"type": "h3", "text": "Map.toMap() and Map.toMutableMap()"}, {"type": "p", "text": "These functions can be used for easy copying of maps:"}, {"type": "div", "text": "\nclass ImmutablePropertyBag(map: Map<String, Any>) {\n    private val mapCopy = map.toMap()\n}\n\n"}, {"type": "pre", "text": "class ImmutablePropertyBag(map: Map<String, Any>) {\n    private val mapCopy = map.toMap()\n}\n"}, {"type": "code", "text": "class ImmutablePropertyBag(map: Map<String, Any>) {\n    private val mapCopy = map.toMap()\n}\n"}, {"type": "h3", "text": "Map.minus(key)"}, {"type": "p", "text": "The operator plus provides a way to add key-value pair(s) to a read-only map producing a new map, however there was not a simple way to do the opposite: to remove a key from the map you have to resort to less straightforward ways to like Map.filter() or Map.filterKeys().\nNow the operator minus fills this gap. There are 4 overloads available: for removing a single key, a collection of keys, a sequence of keys and an array of keys."}, {"type": "code", "text": "plus"}, {"type": "code", "text": "Map.filter()"}, {"type": "code", "text": "Map.filterKeys()"}, {"type": "code", "text": "minus"}, {"type": "div", "text": "\nfun main(args: Array<String>) {\n//sampleStart\n    val map = mapOf(\"key\" to 42)\n    val emptyMap = map - \"key\"\n//sampleEnd\n    \n    println(\"map: $map\")\n    println(\"emptyMap: $emptyMap\")\n}\n\n"}, {"type": "pre", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val map = mapOf(\"key\" to 42)\n    val emptyMap = map - \"key\"\n//sampleEnd\n    \n    println(\"map: $map\")\n    println(\"emptyMap: $emptyMap\")\n}\n"}, {"type": "code", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val map = mapOf(\"key\" to 42)\n    val emptyMap = map - \"key\"\n//sampleEnd\n    \n    println(\"map: $map\")\n    println(\"emptyMap: $emptyMap\")\n}\n"}, {"type": "h3", "text": "minOf() and maxOf()"}, {"type": "p", "text": "These functions can be used to find the lowest and greatest of two or three given values, where values are primitive numbers or Comparable objects. There is also an overload of each function that take an additional Comparator instance, if you want to compare objects that are not comparable themselves."}, {"type": "code", "text": "Comparable"}, {"type": "code", "text": "Comparator"}, {"type": "div", "text": "\nfun main(args: Array<String>) {\n//sampleStart\n    val list1 = listOf(\"a\", \"b\")\n    val list2 = listOf(\"x\", \"y\", \"z\")\n    val minSize = minOf(list1.size, list2.size)\n    val longestList = maxOf(list1, list2, compareBy { it.size })\n//sampleEnd\n    \n    println(\"minSize = $minSize\")\n    println(\"longestList = $longestList\")\n}\n\n"}, {"type": "pre", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val list1 = listOf(\"a\", \"b\")\n    val list2 = listOf(\"x\", \"y\", \"z\")\n    val minSize = minOf(list1.size, list2.size)\n    val longestList = maxOf(list1, list2, compareBy { it.size })\n//sampleEnd\n    \n    println(\"minSize = $minSize\")\n    println(\"longestList = $longestList\")\n}\n"}, {"type": "code", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val list1 = listOf(\"a\", \"b\")\n    val list2 = listOf(\"x\", \"y\", \"z\")\n    val minSize = minOf(list1.size, list2.size)\n    val longestList = maxOf(list1, list2, compareBy { it.size })\n//sampleEnd\n    \n    println(\"minSize = $minSize\")\n    println(\"longestList = $longestList\")\n}\n"}, {"type": "h3", "text": "Array-like List instantiation functions"}, {"type": "p", "text": "Similar to the Array constructor, there are now functions that create List and MutableList instances and initialize\neach element by calling a lambda:"}, {"type": "code", "text": "Array"}, {"type": "code", "text": "List"}, {"type": "code", "text": "MutableList"}, {"type": "div", "text": "\nfun main(args: Array<String>) {\n//sampleStart\n    val squares = List(10) { index -> index * index }\n    val mutable = MutableList(10) { 0 }\n//sampleEnd\n\n    println(\"squares: $squares\")\n    println(\"mutable: $mutable\")\n}\n\n"}, {"type": "pre", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val squares = List(10) { index -> index * index }\n    val mutable = MutableList(10) { 0 }\n//sampleEnd\n\n    println(\"squares: $squares\")\n    println(\"mutable: $mutable\")\n}\n"}, {"type": "code", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val squares = List(10) { index -> index * index }\n    val mutable = MutableList(10) { 0 }\n//sampleEnd\n\n    println(\"squares: $squares\")\n    println(\"mutable: $mutable\")\n}\n"}, {"type": "h3", "text": "Map.getValue()"}, {"type": "p", "text": "This extension on Map returns an existing value corresponding to the given key or throws an exception, mentioning which key was not found.\nIf the map was produced with withDefault, this function will return the default value instead of throwing an exception."}, {"type": "code", "text": "Map"}, {"type": "code", "text": "withDefault"}, {"type": "div", "text": "\nfun main(args: Array<String>) {\n//sampleStart    \n    val map = mapOf(\"key\" to 42)\n    // returns non-nullable Int value 42\n    val value: Int = map.getValue(\"key\")\n\n    val mapWithDefault = map.withDefault { k -> k.length }\n    // returns 4\n    val value2 = mapWithDefault.getValue(\"key2\")\n\n    // map.getValue(\"anotherKey\") // <- this will throw NoSuchElementException\n//sampleEnd\n    \n    println(\"value is $value\")\n    println(\"value2 is $value2\")\n}\n\n"}, {"type": "pre", "text": "fun main(args: Array<String>) {\n//sampleStart    \n    val map = mapOf(\"key\" to 42)\n    // returns non-nullable Int value 42\n    val value: Int = map.getValue(\"key\")\n\n    val mapWithDefault = map.withDefault { k -> k.length }\n    // returns 4\n    val value2 = mapWithDefault.getValue(\"key2\")\n\n    // map.getValue(\"anotherKey\") // <- this will throw NoSuchElementException\n//sampleEnd\n    \n    println(\"value is $value\")\n    println(\"value2 is $value2\")\n}\n"}, {"type": "code", "text": "fun main(args: Array<String>) {\n//sampleStart    \n    val map = mapOf(\"key\" to 42)\n    // returns non-nullable Int value 42\n    val value: Int = map.getValue(\"key\")\n\n    val mapWithDefault = map.withDefault { k -> k.length }\n    // returns 4\n    val value2 = mapWithDefault.getValue(\"key2\")\n\n    // map.getValue(\"anotherKey\") // <- this will throw NoSuchElementException\n//sampleEnd\n    \n    println(\"value is $value\")\n    println(\"value2 is $value2\")\n}\n"}, {"type": "h3", "text": "Abstract collections"}, {"type": "p", "text": "These abstract classes can be used as base classes when implementing Kotlin collection classes.\nFor implementing read-only collections there are AbstractCollection, AbstractList, AbstractSet and AbstractMap, \nand for mutable collections there are AbstractMutableCollection, AbstractMutableList, AbstractMutableSet and AbstractMutableMap.\nOn JVM these abstract mutable collections inherit most of their functionality from JDK's abstract collections."}, {"type": "code", "text": "AbstractCollection"}, {"type": "code", "text": "AbstractList"}, {"type": "code", "text": "AbstractSet"}, {"type": "code", "text": "AbstractMap"}, {"type": "code", "text": "AbstractMutableCollection"}, {"type": "code", "text": "AbstractMutableList"}, {"type": "code", "text": "AbstractMutableSet"}, {"type": "code", "text": "AbstractMutableMap"}, {"type": "h3", "text": "Array manipulation functions"}, {"type": "p", "text": "The standard library now provides a set of functions for element-by-element operations on arrays: comparison\n(contentEquals and contentDeepEquals), hash code calculation (contentHashCode and contentDeepHashCode),\nand conversion to a string (contentToString and contentDeepToString). They're supported both for the JVM\n(where they act as aliases for the corresponding functions in java.util.Arrays) and for JS (where the implementation\nis provided in the Kotlin standard library)."}, {"type": "code", "text": "contentEquals"}, {"type": "code", "text": "contentDeepEquals"}, {"type": "code", "text": "contentHashCode"}, {"type": "code", "text": "contentDeepHashCode"}, {"type": "code", "text": "contentToString"}, {"type": "code", "text": "contentDeepToString"}, {"type": "code", "text": "java.util.Arrays"}, {"type": "div", "text": "\nfun main(args: Array<String>) {\n//sampleStart\n    val array = arrayOf(\"a\", \"b\", \"c\")\n    println(array.toString())  // JVM implementation: type-and-hash gibberish\n    println(array.contentToString())  // nicely formatted as list\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val array = arrayOf(\"a\", \"b\", \"c\")\n    println(array.toString())  // JVM implementation: type-and-hash gibberish\n    println(array.contentToString())  // nicely formatted as list\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val array = arrayOf(\"a\", \"b\", \"c\")\n    println(array.toString())  // JVM implementation: type-and-hash gibberish\n    println(array.contentToString())  // nicely formatted as list\n//sampleEnd\n}\n"}, {"type": "h2", "text": "JVM Backend"}, {"type": "h3", "text": "Java 8 bytecode support"}, {"type": "p", "text": "Kotlin has now the option of generating Java 8 bytecode (-jvm-target 1.8 command line option or the corresponding options\nin Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces\nand lambdas are generated exactly as in Kotlin 1.0), but we plan to make further use of this later."}, {"type": "code", "text": "-jvm-target 1.8"}, {"type": "h3", "text": "Java 8 standard library support"}, {"type": "p", "text": "There are now separate versions of the standard library supporting the new JDK APIs added in Java 7 and 8.\nIf you need access to the new APIs, use kotlin-stdlib-jre7 and kotlin-stdlib-jre8 maven artifacts instead of the standard kotlin-stdlib.\nThese artifacts are tiny extensions on top of kotlin-stdlib and they bring it to your project as a transitive dependency."}, {"type": "code", "text": "kotlin-stdlib-jre7"}, {"type": "code", "text": "kotlin-stdlib-jre8"}, {"type": "code", "text": "kotlin-stdlib"}, {"type": "code", "text": "kotlin-stdlib"}, {"type": "h3", "text": "Parameter names in the bytecode"}, {"type": "p", "text": "Kotlin now supports storing parameter names in the bytecode. This can be enabled using the -java-parameters command line option."}, {"type": "code", "text": "-java-parameters"}, {"type": "h3", "text": "Constant inlining"}, {"type": "p", "text": "The compiler now inlines values of const val properties into the locations where they are used."}, {"type": "code", "text": "const val"}, {"type": "h3", "text": "Mutable closure variables"}, {"type": "p", "text": "The box classes used for capturing mutable closure variables in lambdas no longer have volatile fields. This change improves\nperformance, but can lead to new race conditions in some rare usage scenarios. If you're affected by this, you need to provide\nyour own synchronization for accessing the variables."}, {"type": "h3", "text": "javax.script support"}, {"type": "p", "text": "Kotlin now integrates with the javax.script API (JSR-223).\nThe API allows to evaluate snippets of code at runtime:"}, {"type": "a", "text": "javax.script API"}, {"type": "div", "text": "\nval engine = ScriptEngineManager().getEngineByExtension(\"kts\")!!\nengine.eval(\"val x = 3\")\nprintln(engine.eval(\"x + 2\"))  // Prints out 5\n\n"}, {"type": "pre", "text": "val engine = ScriptEngineManager().getEngineByExtension(\"kts\")!!\nengine.eval(\"val x = 3\")\nprintln(engine.eval(\"x + 2\"))  // Prints out 5\n"}, {"type": "code", "text": "val engine = ScriptEngineManager().getEngineByExtension(\"kts\")!!\nengine.eval(\"val x = 3\")\nprintln(engine.eval(\"x + 2\"))  // Prints out 5\n"}, {"type": "p", "text": "See here\nfor a larger example project using the API."}, {"type": "a", "text": "here"}, {"type": "h3", "text": "kotlin.reflect.full"}, {"type": "p", "text": "To prepare for Java 9 support, the extension functions and properties in the kotlin-reflect.jar library have been moved\nto the package kotlin.reflect.full. The names in the old package (kotlin.reflect) are deprecated and will be removed in\nKotlin 1.2. Note that the core reflection interfaces (such as KClass) are part of the Kotlin standard library,\nnot kotlin-reflect, and are not affected by the move."}, {"type": "a", "text": "prepare for Java 9 support"}, {"type": "code", "text": "kotlin-reflect.jar"}, {"type": "code", "text": "kotlin.reflect.full"}, {"type": "code", "text": "kotlin.reflect"}, {"type": "code", "text": "KClass"}, {"type": "code", "text": "kotlin-reflect"}, {"type": "h2", "text": "JavaScript Backend"}, {"type": "h3", "text": "Unified standard library"}, {"type": "p", "text": "A much larger part of the Kotlin standard library can now be used from code compiled to JavaScript.\nIn particular, key classes such as collections (ArrayList, HashMap etc.), exceptions (IllegalArgumentException etc.) and a few\nothers (StringBuilder, Comparator) are now defined under the kotlin package. On the JVM, the names are type\naliases for the corresponding JDK classes, and on the JS, the classes are implemented in the Kotlin standard library."}, {"type": "code", "text": "ArrayList"}, {"type": "code", "text": "HashMap"}, {"type": "code", "text": "IllegalArgumentException"}, {"type": "code", "text": "StringBuilder"}, {"type": "code", "text": "Comparator"}, {"type": "code", "text": "kotlin"}, {"type": "h3", "text": "Better code generation"}, {"type": "p", "text": "JavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools,\nlike minifiers, optimisers, linters, etc."}, {"type": "h3", "text": "The external modifier"}, {"type": "code", "text": "external"}, {"type": "p", "text": "If you need to access a class implemented in JavaScript from Kotlin in a typesafe way, you can write a Kotlin\ndeclaration using the external modifier. (In Kotlin 1.0, the @native annotation was used instead.)\nUnlike the JVM target, the JS one permits to use external modifier with classes and properties.\nFor example, here's how you can declare the DOM Node class:"}, {"type": "code", "text": "external"}, {"type": "code", "text": "@native"}, {"type": "code", "text": "Node"}, {"type": "div", "text": "\nexternal class Node {\n    val firstChild: Node\n\n    fun appendChild(child: Node): Node\n\n    fun removeChild(child: Node): Node\n\n    // etc\n}\n\n"}, {"type": "pre", "text": "external class Node {\n    val firstChild: Node\n\n    fun appendChild(child: Node): Node\n\n    fun removeChild(child: Node): Node\n\n    // etc\n}\n"}, {"type": "code", "text": "external class Node {\n    val firstChild: Node\n\n    fun appendChild(child: Node): Node\n\n    fun removeChild(child: Node): Node\n\n    // etc\n}\n"}, {"type": "h3", "text": "Improved import handling"}, {"type": "p", "text": "You can now describe declarations which should be imported from JavaScript modules more precisely.\nIf you add the @JsModule(\"<module-name>\") annotation on an external declaration it will be properly imported\nto a module system (either CommonJS or AMD) during the compilation. For example, with CommonJS the declaration will be\nimported via require(...) function.\nAdditionally, if you want to import a declaration either as a module or as a global JavaScript object,\nyou can use the @JsNonModule annotation."}, {"type": "code", "text": "@JsModule(\"<module-name>\")"}, {"type": "code", "text": "require(...)"}, {"type": "code", "text": "@JsNonModule"}, {"type": "p", "text": "For example, here's how you can import JQuery into a Kotlin module:"}, {"type": "div", "text": "\nexternal interface JQuery {\n    fun toggle(duration: Int = definedExternally): JQuery\n    fun click(handler: (Event) -> Unit): JQuery\n}\n\n@JsModule(\"jquery\")\n@JsNonModule\n@JsName(\"$\")\nexternal fun jquery(selector: String): JQuery\n\n"}, {"type": "pre", "text": "external interface JQuery {\n    fun toggle(duration: Int = definedExternally): JQuery\n    fun click(handler: (Event) -> Unit): JQuery\n}\n\n@JsModule(\"jquery\")\n@JsNonModule\n@JsName(\"$\")\nexternal fun jquery(selector: String): JQuery\n"}, {"type": "code", "text": "external interface JQuery {\n    fun toggle(duration: Int = definedExternally): JQuery\n    fun click(handler: (Event) -> Unit): JQuery\n}\n\n@JsModule(\"jquery\")\n@JsNonModule\n@JsName(\"$\")\nexternal fun jquery(selector: String): JQuery\n"}, {"type": "p", "text": "In this case, JQuery will be imported as a module named jquery. Alternatively, it can be used as a $-object,\ndepending on what module system Kotlin compiler is configured to use."}, {"type": "code", "text": "jquery"}, {"type": "p", "text": "You can use these declarations in your application like this:"}, {"type": "div", "text": "\nfun main(args: Array<String>) {\n    jquery(\".toggle-button\").click {\n        jquery(\".toggle-panel\").toggle(300)\n    }\n}\n\n"}, {"type": "pre", "text": "fun main(args: Array<String>) {\n    jquery(\".toggle-button\").click {\n        jquery(\".toggle-panel\").toggle(300)\n    }\n}\n"}, {"type": "code", "text": "fun main(args: Array<String>) {\n    jquery(\".toggle-button\").click {\n        jquery(\".toggle-panel\").toggle(300)\n    }\n}\n"}]