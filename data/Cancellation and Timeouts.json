[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "p", "text": "Table of contents"}, {"type": "strong", "text": "Table of contents"}, {"type": "ul", "text": "\nCancellation and Timeouts\n\nCancelling coroutine execution\nCancellation is cooperative\nMaking computation code cancellable\nClosing resources with finally\nRun non-cancellable block\nTimeout\n\n\n"}, {"type": "li", "text": "Cancellation and Timeouts\n\nCancelling coroutine execution\nCancellation is cooperative\nMaking computation code cancellable\nClosing resources with finally\nRun non-cancellable block\nTimeout\n\n"}, {"type": "a", "text": "Cancellation and Timeouts"}, {"type": "ul", "text": "\nCancelling coroutine execution\nCancellation is cooperative\nMaking computation code cancellable\nClosing resources with finally\nRun non-cancellable block\nTimeout\n"}, {"type": "li", "text": "Cancelling coroutine execution"}, {"type": "a", "text": "Cancelling coroutine execution"}, {"type": "li", "text": "Cancellation is cooperative"}, {"type": "a", "text": "Cancellation is cooperative"}, {"type": "li", "text": "Making computation code cancellable"}, {"type": "a", "text": "Making computation code cancellable"}, {"type": "li", "text": "Closing resources with finally"}, {"type": "a", "text": "Closing resources with finally"}, {"type": "code", "text": "finally"}, {"type": "li", "text": "Run non-cancellable block"}, {"type": "a", "text": "Run non-cancellable block"}, {"type": "li", "text": "Timeout"}, {"type": "a", "text": "Timeout"}, {"type": "h2", "text": "Cancellation and Timeouts"}, {"type": "p", "text": "This section covers coroutine cancellation and timeouts."}, {"type": "h3", "text": "Cancelling coroutine execution"}, {"type": "p", "text": "In a long-running application you might need fine-grained control on your background coroutines.\nFor example, a user might have closed the page that launched a coroutine and now its result\nis no longer needed and its operation can be cancelled. \nThe launch function returns a Job that can be used to cancel the running coroutine:"}, {"type": "a", "text": "launch"}, {"type": "a", "text": "Job"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        repeat(1000) { i ->\n            println(\"job: I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancel() // cancels the job\n    job.join() // waits for job's completion \n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        repeat(1000) { i ->\n            println(\"job: I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancel() // cancels the job\n    job.join() // waits for job's completion \n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        repeat(1000) { i ->\n            println(\"job: I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancel() // cancels the job\n    job.join() // waits for job's completion \n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It produces the following output:"}, {"type": "pre", "text": "job: I'm sleeping 0 ...\njob: I'm sleeping 1 ...\njob: I'm sleeping 2 ...\nmain: I'm tired of waiting!\nmain: Now I can quit.\n"}, {"type": "code", "text": "job: I'm sleeping 0 ...\njob: I'm sleeping 1 ...\njob: I'm sleeping 2 ...\nmain: I'm tired of waiting!\nmain: Now I can quit.\n"}, {"type": "p", "text": "As soon as main invokes job.cancel, we don't see any output from the other coroutine because it was cancelled. \nThere is also a Job extension function cancelAndJoin \nthat combines cancel and join invocations."}, {"type": "code", "text": "job.cancel"}, {"type": "a", "text": "Job"}, {"type": "a", "text": "cancelAndJoin"}, {"type": "a", "text": "cancel"}, {"type": "a", "text": "join"}, {"type": "h3", "text": "Cancellation is cooperative"}, {"type": "p", "text": "Coroutine cancellation is cooperative. A coroutine code has to cooperate to be cancellable.\nAll the suspending functions in kotlinx.coroutines are cancellable. They check for cancellation of \ncoroutine and throw CancellationException when cancelled. However, if a coroutine is working in \na computation and does not check for cancellation, then it cannot be cancelled, like the following \nexample shows:"}, {"type": "em", "text": "cooperative"}, {"type": "code", "text": "kotlinx.coroutines"}, {"type": "em", "text": "cancellable"}, {"type": "a", "text": "CancellationException"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val startTime = System.currentTimeMillis()\n    val job = launch(Dispatchers.Default) {\n        var nextPrintTime = startTime\n        var i = 0\n        while (i < 5) { // computation loop, just wastes CPU\n            // print a message twice a second\n            if (System.currentTimeMillis() >= nextPrintTime) {\n                println(\"job: I'm sleeping ${i++} ...\")\n                nextPrintTime += 500L\n            }\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val startTime = System.currentTimeMillis()\n    val job = launch(Dispatchers.Default) {\n        var nextPrintTime = startTime\n        var i = 0\n        while (i < 5) { // computation loop, just wastes CPU\n            // print a message twice a second\n            if (System.currentTimeMillis() >= nextPrintTime) {\n                println(\"job: I'm sleeping ${i++} ...\")\n                nextPrintTime += 500L\n            }\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val startTime = System.currentTimeMillis()\n    val job = launch(Dispatchers.Default) {\n        var nextPrintTime = startTime\n        var i = 0\n        while (i < 5) { // computation loop, just wastes CPU\n            // print a message twice a second\n            if (System.currentTimeMillis() >= nextPrintTime) {\n                println(\"job: I'm sleeping ${i++} ...\")\n                nextPrintTime += 500L\n            }\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Run it to see that it continues to print \"I'm sleeping\" even after cancellation\nuntil the job completes by itself after five iterations."}, {"type": "h3", "text": "Making computation code cancellable"}, {"type": "p", "text": "There are two approaches to making computation code cancellable. The first one is to periodically \ninvoke a suspending function that checks for cancellation. There is a yield function that is a good choice for that purpose.\nThe other one is to explicitly check the cancellation status. Let us try the latter approach."}, {"type": "a", "text": "yield"}, {"type": "p", "text": "Replace while (i < 5) in the previous example with while (isActive) and rerun it."}, {"type": "code", "text": "while (i < 5)"}, {"type": "code", "text": "while (isActive)"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val startTime = System.currentTimeMillis()\n    val job = launch(Dispatchers.Default) {\n        var nextPrintTime = startTime\n        var i = 0\n        while (isActive) { // cancellable computation loop\n            // print a message twice a second\n            if (System.currentTimeMillis() >= nextPrintTime) {\n                println(\"job: I'm sleeping ${i++} ...\")\n                nextPrintTime += 500L\n            }\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val startTime = System.currentTimeMillis()\n    val job = launch(Dispatchers.Default) {\n        var nextPrintTime = startTime\n        var i = 0\n        while (isActive) { // cancellable computation loop\n            // print a message twice a second\n            if (System.currentTimeMillis() >= nextPrintTime) {\n                println(\"job: I'm sleeping ${i++} ...\")\n                nextPrintTime += 500L\n            }\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val startTime = System.currentTimeMillis()\n    val job = launch(Dispatchers.Default) {\n        var nextPrintTime = startTime\n        var i = 0\n        while (isActive) { // cancellable computation loop\n            // print a message twice a second\n            if (System.currentTimeMillis() >= nextPrintTime) {\n                println(\"job: I'm sleeping ${i++} ...\")\n                nextPrintTime += 500L\n            }\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "As you can see, now this loop is cancelled. isActive is an extension property \navailable inside the coroutine via the CoroutineScope object."}, {"type": "a", "text": "isActive"}, {"type": "a", "text": "CoroutineScope"}, {"type": "h3", "text": "Closing resources with finally"}, {"type": "code", "text": "finally"}, {"type": "p", "text": "Cancellable suspending functions throw CancellationException on cancellation which can be handled in \nthe usual way. For example, try {...} finally {...} expression and Kotlin use function execute their\nfinalization actions normally when a coroutine is cancelled:"}, {"type": "a", "text": "CancellationException"}, {"type": "code", "text": "try {...} finally {...}"}, {"type": "code", "text": "use"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        try {\n            repeat(1000) { i ->\n                println(\"job: I'm sleeping $i ...\")\n                delay(500L)\n            }\n        } finally {\n            println(\"job: I'm running finally\")\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        try {\n            repeat(1000) { i ->\n                println(\"job: I'm sleeping $i ...\")\n                delay(500L)\n            }\n        } finally {\n            println(\"job: I'm running finally\")\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        try {\n            repeat(1000) { i ->\n                println(\"job: I'm sleeping $i ...\")\n                delay(500L)\n            }\n        } finally {\n            println(\"job: I'm running finally\")\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Both join and cancelAndJoin wait for all finalization actions to complete, \nso the example above produces the following output:"}, {"type": "a", "text": "join"}, {"type": "a", "text": "cancelAndJoin"}, {"type": "pre", "text": "job: I'm sleeping 0 ...\njob: I'm sleeping 1 ...\njob: I'm sleeping 2 ...\nmain: I'm tired of waiting!\njob: I'm running finally\nmain: Now I can quit.\n"}, {"type": "code", "text": "job: I'm sleeping 0 ...\njob: I'm sleeping 1 ...\njob: I'm sleeping 2 ...\nmain: I'm tired of waiting!\njob: I'm running finally\nmain: Now I can quit.\n"}, {"type": "h3", "text": "Run non-cancellable block"}, {"type": "p", "text": "Any attempt to use a suspending function in the finally block of the previous example causes\nCancellationException, because the coroutine running this code is cancelled. Usually, this is not a \nproblem, since all well-behaving closing operations (closing a file, cancelling a job, or closing any kind of a \ncommunication channel) are usually non-blocking and do not involve any suspending functions. However, in the \nrare case when you need to suspend in a cancelled coroutine you can wrap the corresponding code in\nwithContext(NonCancellable) {...} using withContext function and NonCancellable context as the following example shows:"}, {"type": "code", "text": "finally"}, {"type": "a", "text": "CancellationException"}, {"type": "code", "text": "withContext(NonCancellable) {...}"}, {"type": "a", "text": "withContext"}, {"type": "a", "text": "NonCancellable"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        try {\n            repeat(1000) { i ->\n                println(\"job: I'm sleeping $i ...\")\n                delay(500L)\n            }\n        } finally {\n            withContext(NonCancellable) {\n                println(\"job: I'm running finally\")\n                delay(1000L)\n                println(\"job: And I've just delayed for 1 sec because I'm non-cancellable\")\n            }\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        try {\n            repeat(1000) { i ->\n                println(\"job: I'm sleeping $i ...\")\n                delay(500L)\n            }\n        } finally {\n            withContext(NonCancellable) {\n                println(\"job: I'm running finally\")\n                delay(1000L)\n                println(\"job: And I've just delayed for 1 sec because I'm non-cancellable\")\n            }\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        try {\n            repeat(1000) { i ->\n                println(\"job: I'm sleeping $i ...\")\n                delay(500L)\n            }\n        } finally {\n            withContext(NonCancellable) {\n                println(\"job: I'm running finally\")\n                delay(1000L)\n                println(\"job: And I've just delayed for 1 sec because I'm non-cancellable\")\n            }\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "h3", "text": "Timeout"}, {"type": "p", "text": "The most obvious practical reason to cancel execution of a coroutine \nis because its execution time has exceeded some timeout.\nWhile you can manually track the reference to the corresponding Job and launch a separate coroutine to cancel \nthe tracked one after delay, there is a ready to use withTimeout function that does it.\nLook at the following example:"}, {"type": "a", "text": "Job"}, {"type": "a", "text": "withTimeout"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    withTimeout(1300L) {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    withTimeout(1300L) {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    withTimeout(1300L) {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It produces the following output:"}, {"type": "pre", "text": "I'm sleeping 0 ...\nI'm sleeping 1 ...\nI'm sleeping 2 ...\nException in thread \"main\" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms\n"}, {"type": "code", "text": "I'm sleeping 0 ...\nI'm sleeping 1 ...\nI'm sleeping 2 ...\nException in thread \"main\" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms\n"}, {"type": "p", "text": "The TimeoutCancellationException that is thrown by withTimeout is a subclass of CancellationException.\nWe have not seen its stack trace printed on the console before. That is because\ninside a cancelled coroutine CancellationException is considered to be a normal reason for coroutine completion. \nHowever, in this example we have used withTimeout right inside the main function."}, {"type": "code", "text": "TimeoutCancellationException"}, {"type": "a", "text": "withTimeout"}, {"type": "a", "text": "CancellationException"}, {"type": "code", "text": "CancellationException"}, {"type": "code", "text": "withTimeout"}, {"type": "code", "text": "main"}, {"type": "p", "text": "Since cancellation is just an exception, all resources are closed in the usual way. \nYou can wrap the code with timeout in a try {...} catch (e: TimeoutCancellationException) {...} block if \nyou need to do some additional action specifically on any kind of timeout or use the withTimeoutOrNull function\nthat is similar to withTimeout but returns null on timeout instead of throwing an exception:"}, {"type": "code", "text": "try {...} catch (e: TimeoutCancellationException) {...}"}, {"type": "a", "text": "withTimeoutOrNull"}, {"type": "a", "text": "withTimeout"}, {"type": "code", "text": "null"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val result = withTimeoutOrNull(1300L) {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n        \"Done\" // will get cancelled before it produces this result\n    }\n    println(\"Result is $result\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val result = withTimeoutOrNull(1300L) {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n        \"Done\" // will get cancelled before it produces this result\n    }\n    println(\"Result is $result\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val result = withTimeoutOrNull(1300L) {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n        \"Done\" // will get cancelled before it produces this result\n    }\n    println(\"Result is $result\")\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "There is no longer an exception when running this code:"}, {"type": "pre", "text": "I'm sleeping 0 ...\nI'm sleeping 1 ...\nI'm sleeping 2 ...\nResult is null\n"}, {"type": "code", "text": "I'm sleeping 0 ...\nI'm sleeping 1 ...\nI'm sleeping 2 ...\nResult is null\n"}]