[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Idioms"}, {"type": "p", "text": "A collection of random and frequently used idioms in Kotlin. If you have a favorite idiom, contribute it by sending a pull request."}, {"type": "h3", "text": "Creating DTOs (POJOs/POCOs)"}, {"type": "div", "text": "\ndata class Customer(val name: String, val email: String)\n\n"}, {"type": "pre", "text": "data class Customer(val name: String, val email: String)\n"}, {"type": "code", "text": "data class Customer(val name: String, val email: String)\n"}, {"type": "p", "text": "provides a Customer class with the following functionality:"}, {"type": "code", "text": "Customer"}, {"type": "ul", "text": "\ngetters (and setters in case of vars) for all properties\nequals()\nhashCode()\ntoString()\ncopy()\ncomponent1(), component2(), \u2026, for all properties (see Data classes)\n"}, {"type": "li", "text": "getters (and setters in case of vars) for all properties"}, {"type": "em", "text": "var"}, {"type": "li", "text": "equals()"}, {"type": "code", "text": "equals()"}, {"type": "li", "text": "hashCode()"}, {"type": "code", "text": "hashCode()"}, {"type": "li", "text": "toString()"}, {"type": "code", "text": "toString()"}, {"type": "li", "text": "copy()"}, {"type": "code", "text": "copy()"}, {"type": "li", "text": "component1(), component2(), \u2026, for all properties (see Data classes)"}, {"type": "code", "text": "component1()"}, {"type": "code", "text": "component2()"}, {"type": "a", "text": "Data classes"}, {"type": "h3", "text": "Default values for function parameters"}, {"type": "div", "text": "\nfun foo(a: Int = 0, b: String = \"\") { ... }\n\n"}, {"type": "pre", "text": "fun foo(a: Int = 0, b: String = \"\") { ... }\n"}, {"type": "code", "text": "fun foo(a: Int = 0, b: String = \"\") { ... }\n"}, {"type": "h3", "text": "Filtering a list"}, {"type": "div", "text": "\nval positives = list.filter { x -> x > 0 }\n\n"}, {"type": "pre", "text": "val positives = list.filter { x -> x > 0 }\n"}, {"type": "code", "text": "val positives = list.filter { x -> x > 0 }\n"}, {"type": "p", "text": "Or alternatively, even shorter:"}, {"type": "div", "text": "\nval positives = list.filter { it > 0 }\n\n"}, {"type": "pre", "text": "val positives = list.filter { it > 0 }\n"}, {"type": "code", "text": "val positives = list.filter { it > 0 }\n"}, {"type": "h3", "text": "Checking element presence in a collection."}, {"type": "div", "text": "\nif (\"john@example.com\" in emailsList) { ... }\n\nif (\"jane@example.com\" !in emailsList) { ... }\n\n"}, {"type": "pre", "text": "if (\"john@example.com\" in emailsList) { ... }\n\nif (\"jane@example.com\" !in emailsList) { ... }\n"}, {"type": "code", "text": "if (\"john@example.com\" in emailsList) { ... }\n\nif (\"jane@example.com\" !in emailsList) { ... }\n"}, {"type": "h3", "text": "String Interpolation"}, {"type": "div", "text": "\nprintln(\"Name $name\")\n\n"}, {"type": "pre", "text": "println(\"Name $name\")\n"}, {"type": "code", "text": "println(\"Name $name\")\n"}, {"type": "h3", "text": "Instance Checks"}, {"type": "div", "text": "\nwhen (x) {\n    is Foo -> ...\n    is Bar -> ...\n    else   -> ...\n}\n\n"}, {"type": "pre", "text": "when (x) {\n    is Foo -> ...\n    is Bar -> ...\n    else   -> ...\n}\n"}, {"type": "code", "text": "when (x) {\n    is Foo -> ...\n    is Bar -> ...\n    else   -> ...\n}\n"}, {"type": "h3", "text": "Traversing a map/list of pairs"}, {"type": "div", "text": "\nfor ((k, v) in map) {\n    println(\"$k -> $v\")\n}\n\n"}, {"type": "pre", "text": "for ((k, v) in map) {\n    println(\"$k -> $v\")\n}\n"}, {"type": "code", "text": "for ((k, v) in map) {\n    println(\"$k -> $v\")\n}\n"}, {"type": "p", "text": "k, v can be called anything."}, {"type": "code", "text": "k"}, {"type": "code", "text": "v"}, {"type": "h3", "text": "Using ranges"}, {"type": "div", "text": "\nfor (i in 1..100) { ... }  // closed range: includes 100\nfor (i in 1 until 100) { ... } // half-open range: does not include 100\nfor (x in 2..10 step 2) { ... }\nfor (x in 10 downTo 1) { ... }\nif (x in 1..10) { ... }\n\n"}, {"type": "pre", "text": "for (i in 1..100) { ... }  // closed range: includes 100\nfor (i in 1 until 100) { ... } // half-open range: does not include 100\nfor (x in 2..10 step 2) { ... }\nfor (x in 10 downTo 1) { ... }\nif (x in 1..10) { ... }\n"}, {"type": "code", "text": "for (i in 1..100) { ... }  // closed range: includes 100\nfor (i in 1 until 100) { ... } // half-open range: does not include 100\nfor (x in 2..10 step 2) { ... }\nfor (x in 10 downTo 1) { ... }\nif (x in 1..10) { ... }\n"}, {"type": "h3", "text": "Read-only list"}, {"type": "div", "text": "\nval list = listOf(\"a\", \"b\", \"c\")\n\n"}, {"type": "pre", "text": "val list = listOf(\"a\", \"b\", \"c\")\n"}, {"type": "code", "text": "val list = listOf(\"a\", \"b\", \"c\")\n"}, {"type": "h3", "text": "Read-only map"}, {"type": "div", "text": "\nval map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3)\n\n"}, {"type": "pre", "text": "val map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3)\n"}, {"type": "code", "text": "val map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3)\n"}, {"type": "h3", "text": "Accessing a map"}, {"type": "div", "text": "\nprintln(map[\"key\"])\nmap[\"key\"] = value\n\n"}, {"type": "pre", "text": "println(map[\"key\"])\nmap[\"key\"] = value\n"}, {"type": "code", "text": "println(map[\"key\"])\nmap[\"key\"] = value\n"}, {"type": "h3", "text": "Lazy property"}, {"type": "div", "text": "\nval p: String by lazy {\n    // compute the string\n}\n\n"}, {"type": "pre", "text": "val p: String by lazy {\n    // compute the string\n}\n"}, {"type": "code", "text": "val p: String by lazy {\n    // compute the string\n}\n"}, {"type": "h3", "text": "Extension Functions"}, {"type": "div", "text": "\nfun String.spaceToCamelCase() { ... }\n\n\"Convert this to camelcase\".spaceToCamelCase()\n\n"}, {"type": "pre", "text": "fun String.spaceToCamelCase() { ... }\n\n\"Convert this to camelcase\".spaceToCamelCase()\n"}, {"type": "code", "text": "fun String.spaceToCamelCase() { ... }\n\n\"Convert this to camelcase\".spaceToCamelCase()\n"}, {"type": "h3", "text": "Creating a singleton"}, {"type": "div", "text": "\nobject Resource {\n    val name = \"Name\"\n}\n\n"}, {"type": "pre", "text": "object Resource {\n    val name = \"Name\"\n}\n"}, {"type": "code", "text": "object Resource {\n    val name = \"Name\"\n}\n"}, {"type": "h3", "text": "If not null shorthand"}, {"type": "div", "text": "\nval files = File(\"Test\").listFiles()\n\nprintln(files?.size)\n\n"}, {"type": "pre", "text": "val files = File(\"Test\").listFiles()\n\nprintln(files?.size)\n"}, {"type": "code", "text": "val files = File(\"Test\").listFiles()\n\nprintln(files?.size)\n"}, {"type": "h3", "text": "If not null and else shorthand"}, {"type": "div", "text": "\nval files = File(\"Test\").listFiles()\n\nprintln(files?.size ?: \"empty\")\n\n"}, {"type": "pre", "text": "val files = File(\"Test\").listFiles()\n\nprintln(files?.size ?: \"empty\")\n"}, {"type": "code", "text": "val files = File(\"Test\").listFiles()\n\nprintln(files?.size ?: \"empty\")\n"}, {"type": "h3", "text": "Executing a statement if null"}, {"type": "div", "text": "\nval values = ...\nval email = values[\"email\"] ?: throw IllegalStateException(\"Email is missing!\")\n\n"}, {"type": "pre", "text": "val values = ...\nval email = values[\"email\"] ?: throw IllegalStateException(\"Email is missing!\")\n"}, {"type": "code", "text": "val values = ...\nval email = values[\"email\"] ?: throw IllegalStateException(\"Email is missing!\")\n"}, {"type": "h3", "text": "Get first item of a possibly empty collection"}, {"type": "div", "text": "\nval emails = ... // might be empty\nval mainEmail = emails.firstOrNull() ?: \"\"\n\n"}, {"type": "pre", "text": "val emails = ... // might be empty\nval mainEmail = emails.firstOrNull() ?: \"\"\n"}, {"type": "code", "text": "val emails = ... // might be empty\nval mainEmail = emails.firstOrNull() ?: \"\"\n"}, {"type": "h3", "text": "Execute if not null"}, {"type": "div", "text": "\nval value = ...\n\nvalue?.let {\n    ... // execute this block if not null\n}\n\n"}, {"type": "pre", "text": "val value = ...\n\nvalue?.let {\n    ... // execute this block if not null\n}\n"}, {"type": "code", "text": "val value = ...\n\nvalue?.let {\n    ... // execute this block if not null\n}\n"}, {"type": "h3", "text": "Map nullable value if not null"}, {"type": "div", "text": "\nval value = ...\n\nval mapped = value?.let { transformValue(it) } ?: defaultValue \n// defaultValue is returned if the value or the transform result is null.\n\n"}, {"type": "pre", "text": "val value = ...\n\nval mapped = value?.let { transformValue(it) } ?: defaultValue \n// defaultValue is returned if the value or the transform result is null.\n"}, {"type": "code", "text": "val value = ...\n\nval mapped = value?.let { transformValue(it) } ?: defaultValue \n// defaultValue is returned if the value or the transform result is null.\n"}, {"type": "h3", "text": "Return on when statement"}, {"type": "div", "text": "\nfun transform(color: String): Int {\n    return when (color) {\n        \"Red\" -> 0\n        \"Green\" -> 1\n        \"Blue\" -> 2\n        else -> throw IllegalArgumentException(\"Invalid color param value\")\n    }\n}\n\n"}, {"type": "pre", "text": "fun transform(color: String): Int {\n    return when (color) {\n        \"Red\" -> 0\n        \"Green\" -> 1\n        \"Blue\" -> 2\n        else -> throw IllegalArgumentException(\"Invalid color param value\")\n    }\n}\n"}, {"type": "code", "text": "fun transform(color: String): Int {\n    return when (color) {\n        \"Red\" -> 0\n        \"Green\" -> 1\n        \"Blue\" -> 2\n        else -> throw IllegalArgumentException(\"Invalid color param value\")\n    }\n}\n"}, {"type": "h3", "text": "'try/catch' expression"}, {"type": "div", "text": "\nfun test() {\n    val result = try {\n        count()\n    } catch (e: ArithmeticException) {\n        throw IllegalStateException(e)\n    }\n\n    // Working with result\n}\n\n"}, {"type": "pre", "text": "fun test() {\n    val result = try {\n        count()\n    } catch (e: ArithmeticException) {\n        throw IllegalStateException(e)\n    }\n\n    // Working with result\n}\n"}, {"type": "code", "text": "fun test() {\n    val result = try {\n        count()\n    } catch (e: ArithmeticException) {\n        throw IllegalStateException(e)\n    }\n\n    // Working with result\n}\n"}, {"type": "h3", "text": "'if' expression"}, {"type": "div", "text": "\nfun foo(param: Int) {\n    val result = if (param == 1) {\n        \"one\"\n    } else if (param == 2) {\n        \"two\"\n    } else {\n        \"three\"\n    }\n}\n\n"}, {"type": "pre", "text": "fun foo(param: Int) {\n    val result = if (param == 1) {\n        \"one\"\n    } else if (param == 2) {\n        \"two\"\n    } else {\n        \"three\"\n    }\n}\n"}, {"type": "code", "text": "fun foo(param: Int) {\n    val result = if (param == 1) {\n        \"one\"\n    } else if (param == 2) {\n        \"two\"\n    } else {\n        \"three\"\n    }\n}\n"}, {"type": "h3", "text": "Builder-style usage of methods that return Unit"}, {"type": "code", "text": "Unit"}, {"type": "div", "text": "\nfun arrayOfMinusOnes(size: Int): IntArray {\n    return IntArray(size).apply { fill(-1) }\n}\n\n"}, {"type": "pre", "text": "fun arrayOfMinusOnes(size: Int): IntArray {\n    return IntArray(size).apply { fill(-1) }\n}\n"}, {"type": "code", "text": "fun arrayOfMinusOnes(size: Int): IntArray {\n    return IntArray(size).apply { fill(-1) }\n}\n"}, {"type": "h3", "text": "Single-expression functions"}, {"type": "div", "text": "\nfun theAnswer() = 42\n\n"}, {"type": "pre", "text": "fun theAnswer() = 42\n"}, {"type": "code", "text": "fun theAnswer() = 42\n"}, {"type": "p", "text": "This is equivalent to"}, {"type": "div", "text": "\nfun theAnswer(): Int {\n    return 42\n}\n\n"}, {"type": "pre", "text": "fun theAnswer(): Int {\n    return 42\n}\n"}, {"type": "code", "text": "fun theAnswer(): Int {\n    return 42\n}\n"}, {"type": "p", "text": "This can be effectively combined with other idioms, leading to shorter code. E.g. with the when-expression:"}, {"type": "em", "text": "when"}, {"type": "div", "text": "\nfun transform(color: String): Int = when (color) {\n    \"Red\" -> 0\n    \"Green\" -> 1\n    \"Blue\" -> 2\n    else -> throw IllegalArgumentException(\"Invalid color param value\")\n}\n\n"}, {"type": "pre", "text": "fun transform(color: String): Int = when (color) {\n    \"Red\" -> 0\n    \"Green\" -> 1\n    \"Blue\" -> 2\n    else -> throw IllegalArgumentException(\"Invalid color param value\")\n}\n"}, {"type": "code", "text": "fun transform(color: String): Int = when (color) {\n    \"Red\" -> 0\n    \"Green\" -> 1\n    \"Blue\" -> 2\n    else -> throw IllegalArgumentException(\"Invalid color param value\")\n}\n"}, {"type": "h3", "text": "Calling multiple methods on an object instance (with)"}, {"type": "code", "text": "with"}, {"type": "div", "text": "\nclass Turtle {\n    fun penDown()\n    fun penUp()\n    fun turn(degrees: Double)\n    fun forward(pixels: Double)\n}\n\nval myTurtle = Turtle()\nwith(myTurtle) { //draw a 100 pix square\n    penDown()\n    for (i in 1..4) {\n        forward(100.0)\n        turn(90.0)\n    }\n    penUp()\n}\n\n"}, {"type": "pre", "text": "class Turtle {\n    fun penDown()\n    fun penUp()\n    fun turn(degrees: Double)\n    fun forward(pixels: Double)\n}\n\nval myTurtle = Turtle()\nwith(myTurtle) { //draw a 100 pix square\n    penDown()\n    for (i in 1..4) {\n        forward(100.0)\n        turn(90.0)\n    }\n    penUp()\n}\n"}, {"type": "code", "text": "class Turtle {\n    fun penDown()\n    fun penUp()\n    fun turn(degrees: Double)\n    fun forward(pixels: Double)\n}\n\nval myTurtle = Turtle()\nwith(myTurtle) { //draw a 100 pix square\n    penDown()\n    for (i in 1..4) {\n        forward(100.0)\n        turn(90.0)\n    }\n    penUp()\n}\n"}, {"type": "h3", "text": "Configuring properties of an object (apply)"}, {"type": "code", "text": "apply"}, {"type": "div", "text": "\nval myRectangle = Rectangle().apply {\n    length = 4\n    breadth = 5\n    color = 0xFAFAFA\n}\n\n"}, {"type": "pre", "text": "val myRectangle = Rectangle().apply {\n    length = 4\n    breadth = 5\n    color = 0xFAFAFA\n}\n"}, {"type": "code", "text": "val myRectangle = Rectangle().apply {\n    length = 4\n    breadth = 5\n    color = 0xFAFAFA\n}\n"}, {"type": "p", "text": "This is useful for configuring properties that aren't present in the object constructor."}, {"type": "h3", "text": "Java 7's try with resources"}, {"type": "div", "text": "\nval stream = Files.newInputStream(Paths.get(\"/some/file.txt\"))\nstream.buffered().reader().use { reader ->\n    println(reader.readText())\n}\n\n"}, {"type": "pre", "text": "val stream = Files.newInputStream(Paths.get(\"/some/file.txt\"))\nstream.buffered().reader().use { reader ->\n    println(reader.readText())\n}\n"}, {"type": "code", "text": "val stream = Files.newInputStream(Paths.get(\"/some/file.txt\"))\nstream.buffered().reader().use { reader ->\n    println(reader.readText())\n}\n"}, {"type": "h3", "text": "Convenient form for a generic function that requires the generic type information"}, {"type": "div", "text": "\n//  public final class Gson {\n//     ...\n//     public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {\n//     ...\n\ninline fun <reified T: Any> Gson.fromJson(json: JsonElement): T = this.fromJson(json, T::class.java)\n\n"}, {"type": "pre", "text": "//  public final class Gson {\n//     ...\n//     public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {\n//     ...\n\ninline fun <reified T: Any> Gson.fromJson(json: JsonElement): T = this.fromJson(json, T::class.java)\n"}, {"type": "code", "text": "//  public final class Gson {\n//     ...\n//     public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {\n//     ...\n\ninline fun <reified T: Any> Gson.fromJson(json: JsonElement): T = this.fromJson(json, T::class.java)\n"}, {"type": "h3", "text": "Consuming a nullable Boolean"}, {"type": "div", "text": "\nval b: Boolean? = ...\nif (b == true) {\n    ...\n} else {\n    // `b` is false or null\n}\n\n"}, {"type": "pre", "text": "val b: Boolean? = ...\nif (b == true) {\n    ...\n} else {\n    // `b` is false or null\n}\n"}, {"type": "code", "text": "val b: Boolean? = ...\nif (b == true) {\n    ...\n} else {\n    // `b` is false or null\n}\n"}, {"type": "h3", "text": "Swapping two variables"}, {"type": "div", "text": "\nvar a = 1\nvar b = 2\na = b.also { b = a }\n\n"}, {"type": "pre", "text": "var a = 1\nvar b = 2\na = b.also { b = a }\n"}, {"type": "code", "text": "var a = 1\nvar b = 2\na = b.also { b = a }\n"}, {"type": "h3", "text": "TODO(): Marking code as incomplete"}, {"type": "p", "text": "Kotlin's standard library has a TODO() function that will always throw a NotImplementedError.\nIts return type is Nothing so it can be used regardless of expected type.\nThere's also an overload that accepts a reason parameter:"}, {"type": "code", "text": "TODO()"}, {"type": "code", "text": "NotImplementedError"}, {"type": "code", "text": "Nothing"}, {"type": "pre", "text": "fun calcTaxes(): BigDecimal = TODO(\"Waiting for feedback from accounting\")\n"}, {"type": "code", "text": "fun calcTaxes(): BigDecimal = TODO(\"Waiting for feedback from accounting\")\n"}, {"type": "p", "text": "IntelliJ IDEA's kotlin plugin understands the semantics of TODO() and automatically adds a code pointer in the TODO toolwindow."}, {"type": "code", "text": "TODO()"}]