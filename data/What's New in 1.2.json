[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "What's New in Kotlin 1.2"}, {"type": "h2", "text": "Table of Contents"}, {"type": "ul", "text": "\nMultiplatform projects\nOther language features\nStandard library\nJVM backend\nJavaScript backend\n"}, {"type": "li", "text": "Multiplatform projects"}, {"type": "a", "text": "Multiplatform projects"}, {"type": "li", "text": "Other language features"}, {"type": "a", "text": "Other language features"}, {"type": "li", "text": "Standard library"}, {"type": "a", "text": "Standard library"}, {"type": "li", "text": "JVM backend"}, {"type": "a", "text": "JVM backend"}, {"type": "li", "text": "JavaScript backend"}, {"type": "a", "text": "JavaScript backend"}, {"type": "h2", "text": "Multiplatform Projects (experimental)"}, {"type": "p", "text": "Multiplatform projects are a new experimental feature in Kotlin 1.2, allowing you to reuse code between target platforms supported by Kotlin \u2013 JVM, JavaScript and (in the future) Native. In a multiplatform project, you have three kinds of modules:"}, {"type": "strong", "text": "experimental"}, {"type": "ul", "text": "\nA common module contains code that is not specific to any platform, as well as declarations without implementation of platform-dependent APIs.\nA platform module contains implementations of platform-dependent declarations in the common module for a specific platform, as well as other platform-dependent code.\nA regular module targets a specific platform and can either be a dependency of platform modules or depend on platform modules.\n"}, {"type": "li", "text": "A common module contains code that is not specific to any platform, as well as declarations without implementation of platform-dependent APIs."}, {"type": "em", "text": "common"}, {"type": "li", "text": "A platform module contains implementations of platform-dependent declarations in the common module for a specific platform, as well as other platform-dependent code."}, {"type": "em", "text": "platform"}, {"type": "li", "text": "A regular module targets a specific platform and can either be a dependency of platform modules or depend on platform modules."}, {"type": "p", "text": "When you compile a multiplatform project for a specific platform, the code for both the common and platform-specific parts is generated."}, {"type": "p", "text": "A key feature of the multiplatform project support is the possibility to express dependencies of common code on platform-specific parts through expected and actual declarations. An expected declaration specifies an API (class, interface, annotation, top-level declaration etc.). An actual declaration is either a platform-dependent implementation of the API or a typealias referring to an existing implementation of the API in an external library. Here's an example:"}, {"type": "strong", "text": "expected and actual declarations"}, {"type": "p", "text": "In common code:"}, {"type": "div", "text": "\n// expected platform-specific API:\nexpect fun hello(world: String): String\n\nfun greet() {\n    // usage of the expected API:\n    val greeting = hello(\"multi-platform world\")\n    println(greeting)\n}\n\nexpect class URL(spec: String) {\n    open fun getHost(): String\n    open fun getPath(): String\n}\n\n"}, {"type": "pre", "text": "// expected platform-specific API:\nexpect fun hello(world: String): String\n\nfun greet() {\n    // usage of the expected API:\n    val greeting = hello(\"multi-platform world\")\n    println(greeting)\n}\n\nexpect class URL(spec: String) {\n    open fun getHost(): String\n    open fun getPath(): String\n}\n"}, {"type": "code", "text": "// expected platform-specific API:\nexpect fun hello(world: String): String\n\nfun greet() {\n    // usage of the expected API:\n    val greeting = hello(\"multi-platform world\")\n    println(greeting)\n}\n\nexpect class URL(spec: String) {\n    open fun getHost(): String\n    open fun getPath(): String\n}\n"}, {"type": "p", "text": "In JVM platform code:"}, {"type": "div", "text": "\nactual fun hello(world: String): String =\n    \"Hello, $world, on the JVM platform!\"\n\n// using existing platform-specific implementation:\nactual typealias URL = java.net.URL\n\n"}, {"type": "pre", "text": "actual fun hello(world: String): String =\n    \"Hello, $world, on the JVM platform!\"\n\n// using existing platform-specific implementation:\nactual typealias URL = java.net.URL\n"}, {"type": "code", "text": "actual fun hello(world: String): String =\n    \"Hello, $world, on the JVM platform!\"\n\n// using existing platform-specific implementation:\nactual typealias URL = java.net.URL\n"}, {"type": "p", "text": "See the documentation for details and steps to build a \nmultiplatform project."}, {"type": "a", "text": "documentation"}, {"type": "h2", "text": "Other Language Features"}, {"type": "h3", "text": "Array literals in annotations"}, {"type": "p", "text": "Starting with Kotlin 1.2, array arguments for annotations can be passed with the new array literal syntax instead \nof the arrayOf function:"}, {"type": "code", "text": "arrayOf"}, {"type": "div", "text": "\n@CacheConfig(cacheNames = [\"books\", \"default\"])\npublic class BookRepositoryImpl {\n    // ...\n}\n\n"}, {"type": "pre", "text": "@CacheConfig(cacheNames = [\"books\", \"default\"])\npublic class BookRepositoryImpl {\n    // ...\n}\n"}, {"type": "code", "text": "@CacheConfig(cacheNames = [\"books\", \"default\"])\npublic class BookRepositoryImpl {\n    // ...\n}\n"}, {"type": "p", "text": "The array literal syntax is constrained to annotation arguments."}, {"type": "h3", "text": "Lateinit top-level properties and local variables"}, {"type": "p", "text": "The lateinit modifier can now be used on top-level properties and local variables. The latter can be used, \nfor example, when a lambda passed as a constructor argument to one object refers to another object \nwhich has to be defined later:"}, {"type": "code", "text": "lateinit"}, {"type": "div", "text": "\nclass Node<T>(val value: T, val next: () -> Node<T>)\n\nfun main(args: Array<String>) {\n    // A cycle of three nodes:\n    lateinit var third: Node<Int>\n\n    val second = Node(2, next = { third })\n    val first = Node(1, next = { second })\n\n    third = Node(3, next = { first })\n\n    val nodes = generateSequence(first) { it.next() }\n    println(\"Values in the cycle: ${nodes.take(7).joinToString { it.value.toString() }}, ...\")\n}\n\n"}, {"type": "pre", "text": "class Node<T>(val value: T, val next: () -> Node<T>)\n\nfun main(args: Array<String>) {\n    // A cycle of three nodes:\n    lateinit var third: Node<Int>\n\n    val second = Node(2, next = { third })\n    val first = Node(1, next = { second })\n\n    third = Node(3, next = { first })\n\n    val nodes = generateSequence(first) { it.next() }\n    println(\"Values in the cycle: ${nodes.take(7).joinToString { it.value.toString() }}, ...\")\n}\n"}, {"type": "code", "text": "class Node<T>(val value: T, val next: () -> Node<T>)\n\nfun main(args: Array<String>) {\n    // A cycle of three nodes:\n    lateinit var third: Node<Int>\n\n    val second = Node(2, next = { third })\n    val first = Node(1, next = { second })\n\n    third = Node(3, next = { first })\n\n    val nodes = generateSequence(first) { it.next() }\n    println(\"Values in the cycle: ${nodes.take(7).joinToString { it.value.toString() }}, ...\")\n}\n"}, {"type": "h3", "text": "Checking whether a lateinit var is initialized"}, {"type": "p", "text": "You can now check whether a lateinit var has been initialized using isInitialized on the property reference:"}, {"type": "code", "text": "isInitialized"}, {"type": "div", "text": "\nclass Foo {\n    lateinit var lateinitVar: String\n\n    fun initializationLogic() {\n//sampleStart\n        println(\"isInitialized before assignment: \" + this::lateinitVar.isInitialized)\n        lateinitVar = \"value\"\n        println(\"isInitialized after assignment: \" + this::lateinitVar.isInitialized)\n//sampleEnd\n    }\n}\n\nfun main(args: Array<String>) {\n\tFoo().initializationLogic()\n}\n\n"}, {"type": "pre", "text": "class Foo {\n    lateinit var lateinitVar: String\n\n    fun initializationLogic() {\n//sampleStart\n        println(\"isInitialized before assignment: \" + this::lateinitVar.isInitialized)\n        lateinitVar = \"value\"\n        println(\"isInitialized after assignment: \" + this::lateinitVar.isInitialized)\n//sampleEnd\n    }\n}\n\nfun main(args: Array<String>) {\n\tFoo().initializationLogic()\n}\n"}, {"type": "code", "text": "class Foo {\n    lateinit var lateinitVar: String\n\n    fun initializationLogic() {\n//sampleStart\n        println(\"isInitialized before assignment: \" + this::lateinitVar.isInitialized)\n        lateinitVar = \"value\"\n        println(\"isInitialized after assignment: \" + this::lateinitVar.isInitialized)\n//sampleEnd\n    }\n}\n\nfun main(args: Array<String>) {\n\tFoo().initializationLogic()\n}\n"}, {"type": "h3", "text": "Inline functions with default functional parameters"}, {"type": "p", "text": "Inline functions are now allowed to have default values for their inlined functional parameters:"}, {"type": "div", "text": "\n//sampleStart\ninline fun <E> Iterable<E>.strings(transform: (E) -> String = { it.toString() }) =\n    map { transform(it) }\n\nval defaultStrings = listOf(1, 2, 3).strings()\nval customStrings = listOf(1, 2, 3).strings { \"($it)\" } \n//sampleEnd\n\nfun main(args: Array<String>) {\n    println(\"defaultStrings = $defaultStrings\")\n    println(\"customStrings = $customStrings\")\n}\n\n"}, {"type": "pre", "text": "//sampleStart\ninline fun <E> Iterable<E>.strings(transform: (E) -> String = { it.toString() }) =\n    map { transform(it) }\n\nval defaultStrings = listOf(1, 2, 3).strings()\nval customStrings = listOf(1, 2, 3).strings { \"($it)\" } \n//sampleEnd\n\nfun main(args: Array<String>) {\n    println(\"defaultStrings = $defaultStrings\")\n    println(\"customStrings = $customStrings\")\n}\n"}, {"type": "code", "text": "//sampleStart\ninline fun <E> Iterable<E>.strings(transform: (E) -> String = { it.toString() }) =\n    map { transform(it) }\n\nval defaultStrings = listOf(1, 2, 3).strings()\nval customStrings = listOf(1, 2, 3).strings { \"($it)\" } \n//sampleEnd\n\nfun main(args: Array<String>) {\n    println(\"defaultStrings = $defaultStrings\")\n    println(\"customStrings = $customStrings\")\n}\n"}, {"type": "h3", "text": "Information from explicit casts is used for type inference"}, {"type": "p", "text": "The Kotlin compiler can now use information from type casts in type inference. If you\u2019re calling a generic method\nthat returns a type parameter T and casting the return value to a specific type Foo, the compiler now understands\nthat T for this call needs to be bound to the type Foo."}, {"type": "code", "text": "T"}, {"type": "code", "text": "Foo"}, {"type": "code", "text": "T"}, {"type": "code", "text": "Foo"}, {"type": "p", "text": "This is particularly important for Android developers, since the compiler can now correctly analyze generic\nfindViewById calls in Android API level 26:"}, {"type": "code", "text": "findViewById"}, {"type": "div", "text": "\nval button = findViewById(R.id.button) as Button\n\n"}, {"type": "pre", "text": "val button = findViewById(R.id.button) as Button\n"}, {"type": "code", "text": "val button = findViewById(R.id.button) as Button\n"}, {"type": "h3", "text": "Smart cast improvements"}, {"type": "p", "text": "When a variable is assigned from a safe call expression and checked for null, the smart cast is now applied to\nthe safe call receiver as well:"}, {"type": "div", "text": "\nfun countFirst(s: Any): Int {\n//sampleStart\n    val firstChar = (s as? CharSequence)?.firstOrNull()\n    if (firstChar != null)\n    return s.count { it == firstChar } // s: Any is smart cast to CharSequence\n\n    val firstItem = (s as? Iterable<*>)?.firstOrNull()\n    if (firstItem != null)\n    return s.count { it == firstItem } // s: Any is smart cast to Iterable<*>\n//sampleEnd\n    return -1\n}\n\nfun main(args: Array<String>) {\n  val string = \"abacaba\"\n  val countInString = countFirst(string)\n  println(\"called on \\\"$string\\\": $countInString\")\n\n  val list = listOf(1, 2, 3, 1, 2)\n  val countInList = countFirst(list)\n  println(\"called on $list: $countInList\")\n}\n\n"}, {"type": "pre", "text": "fun countFirst(s: Any): Int {\n//sampleStart\n    val firstChar = (s as? CharSequence)?.firstOrNull()\n    if (firstChar != null)\n    return s.count { it == firstChar } // s: Any is smart cast to CharSequence\n\n    val firstItem = (s as? Iterable<*>)?.firstOrNull()\n    if (firstItem != null)\n    return s.count { it == firstItem } // s: Any is smart cast to Iterable<*>\n//sampleEnd\n    return -1\n}\n\nfun main(args: Array<String>) {\n  val string = \"abacaba\"\n  val countInString = countFirst(string)\n  println(\"called on \\\"$string\\\": $countInString\")\n\n  val list = listOf(1, 2, 3, 1, 2)\n  val countInList = countFirst(list)\n  println(\"called on $list: $countInList\")\n}\n"}, {"type": "code", "text": "fun countFirst(s: Any): Int {\n//sampleStart\n    val firstChar = (s as? CharSequence)?.firstOrNull()\n    if (firstChar != null)\n    return s.count { it == firstChar } // s: Any is smart cast to CharSequence\n\n    val firstItem = (s as? Iterable<*>)?.firstOrNull()\n    if (firstItem != null)\n    return s.count { it == firstItem } // s: Any is smart cast to Iterable<*>\n//sampleEnd\n    return -1\n}\n\nfun main(args: Array<String>) {\n  val string = \"abacaba\"\n  val countInString = countFirst(string)\n  println(\"called on \\\"$string\\\": $countInString\")\n\n  val list = listOf(1, 2, 3, 1, 2)\n  val countInList = countFirst(list)\n  println(\"called on $list: $countInList\")\n}\n"}, {"type": "p", "text": "Also, smart casts in a lambda are now allowed for local variables that are only modified before the lambda:"}, {"type": "div", "text": "\nfun main(args: Array<String>) {\n//sampleStart\n    val flag = args.size == 0\n    var x: String? = null\n    if (flag) x = \"Yahoo!\"\n\n    run {\n        if (x != null) {\n            println(x.length) // x is smart cast to String\n        }\n    }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val flag = args.size == 0\n    var x: String? = null\n    if (flag) x = \"Yahoo!\"\n\n    run {\n        if (x != null) {\n            println(x.length) // x is smart cast to String\n        }\n    }\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val flag = args.size == 0\n    var x: String? = null\n    if (flag) x = \"Yahoo!\"\n\n    run {\n        if (x != null) {\n            println(x.length) // x is smart cast to String\n        }\n    }\n//sampleEnd\n}\n"}, {"type": "h3", "text": "Support for  ::foo as a shorthand for this::foo"}, {"type": "p", "text": "A bound callable reference to a member of this can now be written without explicit receiver, ::foo instead\nof this::foo. This also makes callable references more convenient to use in lambdas where you refer to a member\nof the outer receiver."}, {"type": "code", "text": "this"}, {"type": "code", "text": "::foo"}, {"type": "code", "text": "this::foo"}, {"type": "h3", "text": "Breaking change: sound smart casts after try blocks"}, {"type": "p", "text": "Earlier, Kotlin used assignments made inside a try block for smart casts after the block, which could break type- and null-safety\nand lead to runtime failures. This release fixes this issue, making the smart casts more strict, but breaking some code\nthat relied on such smart casts."}, {"type": "code", "text": "try"}, {"type": "p", "text": "To switch to the old smart casts behavior, pass the fallback flag -Xlegacy-smart-cast-after-try as the compiler\nargument. It will become deprecated in Kotlin 1.3."}, {"type": "code", "text": "-Xlegacy-smart-cast-after-try"}, {"type": "h3", "text": "Deprecation: data classes overriding copy"}, {"type": "p", "text": "When a data class derived from a type that already had the copy function with the same signature, the copy\nimplementation generated for the data class used the defaults from the supertype, leading to counter-intuitive behavior,\nor failed at runtime if there were no default parameters in the supertype."}, {"type": "code", "text": "copy"}, {"type": "code", "text": "copy"}, {"type": "p", "text": "Inheritance that leads to a copy conflict has become deprecated with a warning in Kotlin 1.2\nand will be an error in Kotlin 1.3."}, {"type": "code", "text": "copy"}, {"type": "h3", "text": "Deprecation: nested types in enum entries"}, {"type": "p", "text": "Inside enum entries, defining a nested type that is not an inner class has been deprecated due to issues in the\ninitialization logic. This causes a warning in Kotlin 1.2 and will become an error in Kotlin 1.3."}, {"type": "code", "text": "inner class"}, {"type": "h3", "text": "Deprecation: single named argument for vararg"}, {"type": "p", "text": "For consistency with array literals in annotations, passing a single item for a vararg parameter in the named\nform (foo(items = i)) has been deprecated. Please use the spread operator with the corresponding\narray factory functions:"}, {"type": "code", "text": "foo(items = i)"}, {"type": "div", "text": "\nfoo(items = *intArrayOf(1))\n\n"}, {"type": "pre", "text": "foo(items = *intArrayOf(1))\n"}, {"type": "code", "text": "foo(items = *intArrayOf(1))\n"}, {"type": "p", "text": "There is an optimization that removes redundant arrays creation in such cases, which prevents performance degradation.\nThe single-argument form produces warnings in Kotlin 1.2 and is to be dropped in Kotlin 1.3."}, {"type": "h3", "text": "Deprecation: inner classes of generic classes extending Throwable"}, {"type": "p", "text": "Inner classes of generic types that inherit from Throwable could violate type-safety in a throw-catch scenario and\nthus have been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3."}, {"type": "code", "text": "Throwable"}, {"type": "h3", "text": "Deprecation: mutating backing field of a read-only property"}, {"type": "p", "text": "Mutating the backing field of a read-only property by assigning field = ... in the custom getter has been\ndeprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3."}, {"type": "code", "text": "field = ..."}, {"type": "h2", "text": "Standard Library"}, {"type": "h3", "text": "Kotlin standard library artifacts and split packages"}, {"type": "p", "text": "The Kotlin standard library is now fully compatible with the Java 9 module system, which forbids split packages\n(multiple jar files declaring classes in the same package). In order to support that, new artifacts kotlin-stdlib-jdk7\nand kotlin-stdlib-jdk8 are introduced, which replace the old kotlin-stdlib-jre7 and kotlin-stdlib-jre8."}, {"type": "code", "text": "kotlin-stdlib-jdk7"}, {"type": "code", "text": "kotlin-stdlib-jdk8"}, {"type": "code", "text": "kotlin-stdlib-jre7"}, {"type": "code", "text": "kotlin-stdlib-jre8"}, {"type": "p", "text": "The declarations in the new artifacts are visible under the same package names from the Kotlin point of view, but have\ndifferent package names for Java. Therefore, switching to the new artifacts will not require any changes to\nyour source code."}, {"type": "p", "text": "Another change made to ensure compatibility with the new module system is removing the deprecated\ndeclarations in the kotlin.reflect package from the kotlin-reflect library. If you were using them, you need\nto switch to using the declarations in the kotlin.reflect.full package, which is supported since Kotlin 1.1."}, {"type": "code", "text": "kotlin.reflect"}, {"type": "code", "text": "kotlin-reflect"}, {"type": "code", "text": "kotlin.reflect.full"}, {"type": "h3", "text": "windowed, chunked, zipWithNext"}, {"type": "p", "text": "New extensions for Iterable<T>, Sequence<T>, and CharSequence cover such use cases as buffering or\nbatch processing (chunked), sliding window and computing sliding average (windowed) , and processing pairs\nof subsequent items (zipWithNext):"}, {"type": "code", "text": "Iterable<T>"}, {"type": "code", "text": "Sequence<T>"}, {"type": "code", "text": "CharSequence"}, {"type": "code", "text": "chunked"}, {"type": "code", "text": "windowed"}, {"type": "code", "text": "zipWithNext"}, {"type": "div", "text": "\nfun main(args: Array<String>) {\n//sampleStart\n    val items = (1..9).map { it * it }\n\n    val chunkedIntoLists = items.chunked(4)\n    val points3d = items.chunked(3) { (x, y, z) -> Triple(x, y, z) }\n    val windowed = items.windowed(4)\n    val slidingAverage = items.windowed(4) { it.average() }\n    val pairwiseDifferences = items.zipWithNext { a, b -> b - a }\n//sampleEnd\n\n    println(\"items: $items\\n\")\n\n    println(\"chunked into lists: $chunkedIntoLists\")\n    println(\"3D points: $points3d\")\n    println(\"windowed by 4: $windowed\")\n    println(\"sliding average by 4: $slidingAverage\")\n    println(\"pairwise differences: $pairwiseDifferences\")\n}\n\n"}, {"type": "pre", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val items = (1..9).map { it * it }\n\n    val chunkedIntoLists = items.chunked(4)\n    val points3d = items.chunked(3) { (x, y, z) -> Triple(x, y, z) }\n    val windowed = items.windowed(4)\n    val slidingAverage = items.windowed(4) { it.average() }\n    val pairwiseDifferences = items.zipWithNext { a, b -> b - a }\n//sampleEnd\n\n    println(\"items: $items\\n\")\n\n    println(\"chunked into lists: $chunkedIntoLists\")\n    println(\"3D points: $points3d\")\n    println(\"windowed by 4: $windowed\")\n    println(\"sliding average by 4: $slidingAverage\")\n    println(\"pairwise differences: $pairwiseDifferences\")\n}\n"}, {"type": "code", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val items = (1..9).map { it * it }\n\n    val chunkedIntoLists = items.chunked(4)\n    val points3d = items.chunked(3) { (x, y, z) -> Triple(x, y, z) }\n    val windowed = items.windowed(4)\n    val slidingAverage = items.windowed(4) { it.average() }\n    val pairwiseDifferences = items.zipWithNext { a, b -> b - a }\n//sampleEnd\n\n    println(\"items: $items\\n\")\n\n    println(\"chunked into lists: $chunkedIntoLists\")\n    println(\"3D points: $points3d\")\n    println(\"windowed by 4: $windowed\")\n    println(\"sliding average by 4: $slidingAverage\")\n    println(\"pairwise differences: $pairwiseDifferences\")\n}\n"}, {"type": "h3", "text": "fill, replaceAll, shuffle/shuffled"}, {"type": "p", "text": "A set of extension functions was added for manipulating lists: fill, replaceAll and shuffle for MutableList,\nand shuffled for read-only List:"}, {"type": "code", "text": "fill"}, {"type": "code", "text": "replaceAll"}, {"type": "code", "text": "shuffle"}, {"type": "code", "text": "MutableList"}, {"type": "code", "text": "shuffled"}, {"type": "code", "text": "List"}, {"type": "div", "text": "\nfun main(args: Array<String>) {\n//sampleStart\n    val items = (1..5).toMutableList()\n    \n    items.shuffle()\n    println(\"Shuffled items: $items\")\n    \n    items.replaceAll { it * 2 }\n    println(\"Items doubled: $items\")\n    \n    items.fill(5)\n    println(\"Items filled with 5: $items\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val items = (1..5).toMutableList()\n    \n    items.shuffle()\n    println(\"Shuffled items: $items\")\n    \n    items.replaceAll { it * 2 }\n    println(\"Items doubled: $items\")\n    \n    items.fill(5)\n    println(\"Items filled with 5: $items\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main(args: Array<String>) {\n//sampleStart\n    val items = (1..5).toMutableList()\n    \n    items.shuffle()\n    println(\"Shuffled items: $items\")\n    \n    items.replaceAll { it * 2 }\n    println(\"Items doubled: $items\")\n    \n    items.fill(5)\n    println(\"Items filled with 5: $items\")\n//sampleEnd\n}\n"}, {"type": "h3", "text": "Math operations in kotlin-stdlib"}, {"type": "p", "text": "Satisfying the longstanding request, Kotlin 1.2 adds the kotlin.math API for math operations that is common \nfor JVM and JS and contains the following:"}, {"type": "code", "text": "kotlin.math"}, {"type": "ul", "text": "\nConstants: PI and E;\nTrigonometric: cos, sin, tan and inverse of them: acos, asin, atan, atan2;\nHyperbolic: cosh, sinh, tanh and their inverse: acosh, asinh, atanh\nExponentation: pow (an extension function), sqrt, hypot, exp, expm1;\nLogarithms: log, log2, log10, ln, ln1p;\nRounding:\n    \nceil, floor, truncate, round (half to even) functions;\nroundToInt, roundToLong (half to integer) extension functions;\n\n\nSign and absolute value:\n    \nabs and sign functions;\nabsoluteValue and sign extension properties;\nwithSign extension function;\n\n\nmax and min of two values;\nBinary representation:\n    \nulp extension property;\nnextUp, nextDown, nextTowards extension functions;\ntoBits, toRawBits, Double.fromBits (these are in the kotlin package).\n\n\n"}, {"type": "li", "text": "Constants: PI and E;"}, {"type": "code", "text": "PI"}, {"type": "code", "text": "E"}, {"type": "li", "text": "Trigonometric: cos, sin, tan and inverse of them: acos, asin, atan, atan2;"}, {"type": "code", "text": "cos"}, {"type": "code", "text": "sin"}, {"type": "code", "text": "tan"}, {"type": "code", "text": "acos"}, {"type": "code", "text": "asin"}, {"type": "code", "text": "atan"}, {"type": "code", "text": "atan2"}, {"type": "li", "text": "Hyperbolic: cosh, sinh, tanh and their inverse: acosh, asinh, atanh"}, {"type": "code", "text": "cosh"}, {"type": "code", "text": "sinh"}, {"type": "code", "text": "tanh"}, {"type": "code", "text": "acosh"}, {"type": "code", "text": "asinh"}, {"type": "code", "text": "atanh"}, {"type": "li", "text": "Exponentation: pow (an extension function), sqrt, hypot, exp, expm1;"}, {"type": "code", "text": "pow"}, {"type": "code", "text": "sqrt"}, {"type": "code", "text": "hypot"}, {"type": "code", "text": "exp"}, {"type": "code", "text": "expm1"}, {"type": "li", "text": "Logarithms: log, log2, log10, ln, ln1p;"}, {"type": "code", "text": "log"}, {"type": "code", "text": "log2"}, {"type": "code", "text": "log10"}, {"type": "code", "text": "ln"}, {"type": "code", "text": "ln1p"}, {"type": "li", "text": "Rounding:\n    \nceil, floor, truncate, round (half to even) functions;\nroundToInt, roundToLong (half to integer) extension functions;\n\n"}, {"type": "ul", "text": "\nceil, floor, truncate, round (half to even) functions;\nroundToInt, roundToLong (half to integer) extension functions;\n"}, {"type": "li", "text": "ceil, floor, truncate, round (half to even) functions;"}, {"type": "code", "text": "ceil"}, {"type": "code", "text": "floor"}, {"type": "code", "text": "truncate"}, {"type": "code", "text": "round"}, {"type": "li", "text": "roundToInt, roundToLong (half to integer) extension functions;"}, {"type": "code", "text": "roundToInt"}, {"type": "code", "text": "roundToLong"}, {"type": "li", "text": "Sign and absolute value:\n    \nabs and sign functions;\nabsoluteValue and sign extension properties;\nwithSign extension function;\n\n"}, {"type": "ul", "text": "\nabs and sign functions;\nabsoluteValue and sign extension properties;\nwithSign extension function;\n"}, {"type": "li", "text": "abs and sign functions;"}, {"type": "code", "text": "abs"}, {"type": "code", "text": "sign"}, {"type": "li", "text": "absoluteValue and sign extension properties;"}, {"type": "code", "text": "absoluteValue"}, {"type": "code", "text": "sign"}, {"type": "li", "text": "withSign extension function;"}, {"type": "code", "text": "withSign"}, {"type": "li", "text": "max and min of two values;"}, {"type": "code", "text": "max"}, {"type": "code", "text": "min"}, {"type": "li", "text": "Binary representation:\n    \nulp extension property;\nnextUp, nextDown, nextTowards extension functions;\ntoBits, toRawBits, Double.fromBits (these are in the kotlin package).\n\n"}, {"type": "ul", "text": "\nulp extension property;\nnextUp, nextDown, nextTowards extension functions;\ntoBits, toRawBits, Double.fromBits (these are in the kotlin package).\n"}, {"type": "li", "text": "ulp extension property;"}, {"type": "code", "text": "ulp"}, {"type": "li", "text": "nextUp, nextDown, nextTowards extension functions;"}, {"type": "code", "text": "nextUp"}, {"type": "code", "text": "nextDown"}, {"type": "code", "text": "nextTowards"}, {"type": "li", "text": "toBits, toRawBits, Double.fromBits (these are in the kotlin package)."}, {"type": "code", "text": "toBits"}, {"type": "code", "text": "toRawBits"}, {"type": "code", "text": "Double.fromBits"}, {"type": "code", "text": "kotlin"}, {"type": "p", "text": "The same set of functions (but without constants) is also available for Float arguments."}, {"type": "code", "text": "Float"}, {"type": "h3", "text": "Operators and conversions for BigInteger and BigDecimal"}, {"type": "p", "text": "Kotlin 1.2 introduces a set of functions for operating with BigInteger and BigDecimal and creating them \nfrom other numeric types. These are:"}, {"type": "code", "text": "BigInteger"}, {"type": "code", "text": "BigDecimal"}, {"type": "ul", "text": "\ntoBigInteger for Int and Long;\ntoBigDecimal for Int, Long, Float, Double, and BigInteger;\nArithmetic and bitwise operator functions:\n    \nBinary operators  +, -, *, /, % and infix functions and, or, xor, shl, shr;\nUnary operators -, ++, --, and a function inv.\n\n\n"}, {"type": "li", "text": "toBigInteger for Int and Long;"}, {"type": "code", "text": "toBigInteger"}, {"type": "code", "text": "Int"}, {"type": "code", "text": "Long"}, {"type": "li", "text": "toBigDecimal for Int, Long, Float, Double, and BigInteger;"}, {"type": "code", "text": "toBigDecimal"}, {"type": "code", "text": "Int"}, {"type": "code", "text": "Long"}, {"type": "code", "text": "Float"}, {"type": "code", "text": "Double"}, {"type": "code", "text": "BigInteger"}, {"type": "li", "text": "Arithmetic and bitwise operator functions:\n    \nBinary operators  +, -, *, /, % and infix functions and, or, xor, shl, shr;\nUnary operators -, ++, --, and a function inv.\n\n"}, {"type": "ul", "text": "\nBinary operators  +, -, *, /, % and infix functions and, or, xor, shl, shr;\nUnary operators -, ++, --, and a function inv.\n"}, {"type": "li", "text": "Binary operators  +, -, *, /, % and infix functions and, or, xor, shl, shr;"}, {"type": "code", "text": "+"}, {"type": "code", "text": "-"}, {"type": "code", "text": "*"}, {"type": "code", "text": "/"}, {"type": "code", "text": "%"}, {"type": "code", "text": "and"}, {"type": "code", "text": "or"}, {"type": "code", "text": "xor"}, {"type": "code", "text": "shl"}, {"type": "code", "text": "shr"}, {"type": "li", "text": "Unary operators -, ++, --, and a function inv."}, {"type": "code", "text": "-"}, {"type": "code", "text": "++"}, {"type": "code", "text": "--"}, {"type": "code", "text": "inv"}, {"type": "h3", "text": "Floating point to bits conversions"}, {"type": "p", "text": "New functions were added for converting Double and Float to and from their bit representations:"}, {"type": "code", "text": "Double"}, {"type": "code", "text": "Float"}, {"type": "ul", "text": "\ntoBits and toRawBits returning Long for Double and Int for Float;\nDouble.fromBits and Float.fromBits for creating floating point numbers from the bit representation.\n"}, {"type": "li", "text": "toBits and toRawBits returning Long for Double and Int for Float;"}, {"type": "code", "text": "toBits"}, {"type": "code", "text": "toRawBits"}, {"type": "code", "text": "Long"}, {"type": "code", "text": "Double"}, {"type": "code", "text": "Int"}, {"type": "code", "text": "Float"}, {"type": "li", "text": "Double.fromBits and Float.fromBits for creating floating point numbers from the bit representation."}, {"type": "code", "text": "Double.fromBits"}, {"type": "code", "text": "Float.fromBits"}, {"type": "h3", "text": "Regex is now serializable"}, {"type": "p", "text": "The kotlin.text.Regex class has become Serializable and can now be used in serializable hierarchies."}, {"type": "code", "text": "kotlin.text.Regex"}, {"type": "code", "text": "Serializable"}, {"type": "h3", "text": "Closeable.use calls Throwable.addSuppressed if available"}, {"type": "p", "text": "The Closeable.use function calls Throwable.addSuppressed when an exception is thrown during closing the resource \nafter some other exception."}, {"type": "code", "text": "Closeable.use"}, {"type": "code", "text": "Throwable.addSuppressed"}, {"type": "p", "text": "To enable this behavior you need to have kotlin-stdlib-jdk7 in your dependencies."}, {"type": "code", "text": "kotlin-stdlib-jdk7"}, {"type": "h2", "text": "JVM Backend"}, {"type": "h3", "text": "Constructor calls normalization"}, {"type": "p", "text": "Ever since version 1.0, Kotlin supported expressions with complex control flow, such as try-catch expressions and \ninline function calls. Such code is valid according to the Java Virtual Machine specification. Unfortunately, some \nbytecode processing tools do not handle such code quite well when such expressions are present in the arguments \nof constructor calls."}, {"type": "p", "text": "To mitigate this problem for the users of such bytecode processing tools, we\u2019ve added a command-line \noption (-Xnormalize-constructor-calls=MODE) that tells the compiler to generate more Java-like bytecode for such \nconstructs. Here MODE is one of:"}, {"type": "code", "text": "-Xnormalize-constructor-calls=MODE"}, {"type": "code", "text": "MODE"}, {"type": "ul", "text": "\ndisable (default) \u2013 generate bytecode in the same way as in Kotlin 1.0 and 1.1;\nenable \u2013 generate Java-like bytecode for constructor calls. This can change the order in which the classes are \n loaded and initialized;\npreserve-class-initialization \u2013 generate Java-like bytecode for constructor calls, ensuring that the class \ninitialization order is preserved. This can affect overall performance of your application; use it only if you have \nsome complex state shared between multiple classes and updated on class initialization.\n"}, {"type": "li", "text": "disable (default) \u2013 generate bytecode in the same way as in Kotlin 1.0 and 1.1;"}, {"type": "code", "text": "disable"}, {"type": "li", "text": "enable \u2013 generate Java-like bytecode for constructor calls. This can change the order in which the classes are \n loaded and initialized;"}, {"type": "code", "text": "enable"}, {"type": "li", "text": "preserve-class-initialization \u2013 generate Java-like bytecode for constructor calls, ensuring that the class \ninitialization order is preserved. This can affect overall performance of your application; use it only if you have \nsome complex state shared between multiple classes and updated on class initialization."}, {"type": "code", "text": "preserve-class-initialization"}, {"type": "p", "text": "The \u201cmanual\u201d workaround is to store the values of sub-expressions with control flow in variables, instead of \nevaluating them directly inside the call arguments. It\u2019s similar to -Xnormalize-constructor-calls=enable."}, {"type": "code", "text": "-Xnormalize-constructor-calls=enable"}, {"type": "h3", "text": "Java-default method calls"}, {"type": "p", "text": "Before Kotlin 1.2, interface members overriding Java-default methods while targeting JVM 1.6 produced a warning on \nsuper calls: Super calls to Java default methods are deprecated in JVM target 1.6. Recompile with '-jvm-target 1.8'. \nIn Kotlin 1.2, there's an error instead, thus requiring any such code to be compiled with JVM target 1.8."}, {"type": "code", "text": "Super calls to Java default methods are deprecated in JVM target 1.6. Recompile with '-jvm-target 1.8'"}, {"type": "strong", "text": "error"}, {"type": "h3", "text": "Breaking change: consistent behavior of x.equals(null) for platform types"}, {"type": "p", "text": "Calling x.equals(null) on a platform type that is mapped to a Java primitive \n(Int!, Boolean!, Short!, Long!, Float!, Double!, Char!) incorrectly returned true when x was null. \nStarting with Kotlin 1.2, calling x.equals(...) on a null value of a platform type throws an NPE \n(but x == ... does not)."}, {"type": "code", "text": "x.equals(null)"}, {"type": "code", "text": "Int!"}, {"type": "code", "text": "Boolean!"}, {"type": "code", "text": "Short"}, {"type": "code", "text": "Long!"}, {"type": "code", "text": "Float!"}, {"type": "code", "text": "Double!"}, {"type": "code", "text": "Char!"}, {"type": "code", "text": "true"}, {"type": "code", "text": "x"}, {"type": "code", "text": "x.equals(...)"}, {"type": "strong", "text": "throws an NPE"}, {"type": "code", "text": "x == ..."}, {"type": "p", "text": "To return to the pre-1.2 behavior, pass the flag -Xno-exception-on-explicit-equals-for-boxed-null to the compiler."}, {"type": "code", "text": "-Xno-exception-on-explicit-equals-for-boxed-null"}, {"type": "h3", "text": "Breaking change: fix for platform null escaping through an inlined extension receiver"}, {"type": "p", "text": "Inline extension functions that were called on a null value of a platform type did not check the receiver for null and \nwould thus allow null to escape into the other code. Kotlin 1.2 forces this check at the call sites, throwing an exception\nif the receiver is null."}, {"type": "p", "text": "To switch to the old behavior, pass the fallback flag -Xno-receiver-assertions to the compiler."}, {"type": "code", "text": "-Xno-receiver-assertions"}, {"type": "h2", "text": "JavaScript Backend"}, {"type": "h3", "text": "TypedArrays support enabled by default"}, {"type": "p", "text": "The JS typed arrays support that translates Kotlin primitive arrays, such as IntArray, DoubleArray, \ninto JavaScript typed arrays, that was \npreviously an opt-in feature, has been enabled by default."}, {"type": "code", "text": "IntArray"}, {"type": "code", "text": "DoubleArray"}, {"type": "a", "text": "JavaScript typed arrays"}, {"type": "h2", "text": "Tools"}, {"type": "h3", "text": "Warnings as errors"}, {"type": "p", "text": "The compiler now provides an option to treat all warnings as errors. Use -Werror on the command line, or the \nfollowing Gradle snippet:"}, {"type": "code", "text": "-Werror"}, {"type": "div", "text": "\ncompileKotlin {\n    kotlinOptions.allWarningsAsErrors = true\n}\n\n"}, {"type": "pre", "text": "compileKotlin {\n    kotlinOptions.allWarningsAsErrors = true\n}\n"}, {"type": "code", "text": "compileKotlin {\n    kotlinOptions.allWarningsAsErrors = true\n}\n"}]