[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Kotlin/Native interoperability"}, {"type": "em", "text": "Kotlin/Native"}, {"type": "h2", "text": "Introduction"}, {"type": "p", "text": "Kotlin/Native follows the general tradition of Kotlin to provide excellent\nexisting platform software interoperability. In the case of a native platform,\nthe most important interoperability target is a C library. So Kotlin/Native\ncomes with a cinterop tool, which can be used to quickly generate\neverything needed to interact with an external library."}, {"type": "em", "text": "Kotlin/Native"}, {"type": "em", "text": "Kotlin/Native"}, {"type": "code", "text": "cinterop"}, {"type": "p", "text": "The following workflow is expected when interacting with the native library."}, {"type": "ul", "text": "\ncreate a .def file describing what to include into bindings\nuse the cinterop tool to produce Kotlin bindings\nrun Kotlin/Native compiler on an application to produce the final executable\n"}, {"type": "li", "text": "create a .def file describing what to include into bindings"}, {"type": "code", "text": ".def"}, {"type": "li", "text": "use the cinterop tool to produce Kotlin bindings"}, {"type": "code", "text": "cinterop"}, {"type": "li", "text": "run Kotlin/Native compiler on an application to produce the final executable"}, {"type": "em", "text": "Kotlin/Native"}, {"type": "p", "text": "The interoperability tool analyses C headers and produces a \"natural\" mapping of\nthe types, functions, and constants into the Kotlin world. The generated stubs can be\nimported into an IDE for the purpose of code completion and navigation."}, {"type": "p", "text": "Interoperability with Swift/Objective-C is provided too and covered in a\nseparate document OBJC_INTEROP.md."}, {"type": "a", "text": "OBJC_INTEROP.md"}, {"type": "h2", "text": "Platform libraries"}, {"type": "p", "text": "Note that in many cases there's no need to use custom interoperability library creation mechanisms described below,\nas for APIs available on the platform standardized bindings called platform libraries\ncould be used. For example, POSIX on Linux/macOS platforms, Win32 on Windows platform, or Apple frameworks\non macOS/iOS are available this way."}, {"type": "a", "text": "platform libraries"}, {"type": "h2", "text": "Simple example"}, {"type": "p", "text": "Install libgit2 and prepare stubs for the git library:"}, {"type": "div", "text": "\n\ncd samples/gitchurn\n../../dist/bin/cinterop -def src/main/c_interop/libgit2.def \\\n -compiler-option -I/usr/local/include -o libgit2\n\n"}, {"type": "pre", "text": "\ncd samples/gitchurn\n../../dist/bin/cinterop -def src/main/c_interop/libgit2.def \\\n -compiler-option -I/usr/local/include -o libgit2\n"}, {"type": "code", "text": "\ncd samples/gitchurn\n../../dist/bin/cinterop -def src/main/c_interop/libgit2.def \\\n -compiler-option -I/usr/local/include -o libgit2\n"}, {"type": "p", "text": "Compile the client:"}, {"type": "div", "text": "\n../../dist/bin/kotlinc src/main/kotlin \\\n -library libgit2 -o GitChurn\n\n"}, {"type": "pre", "text": "../../dist/bin/kotlinc src/main/kotlin \\\n -library libgit2 -o GitChurn\n"}, {"type": "code", "text": "../../dist/bin/kotlinc src/main/kotlin \\\n -library libgit2 -o GitChurn\n"}, {"type": "p", "text": "Run the client:"}, {"type": "div", "text": "\n./GitChurn.kexe ../..\n\n"}, {"type": "pre", "text": "./GitChurn.kexe ../..\n"}, {"type": "code", "text": "./GitChurn.kexe ../..\n"}, {"type": "h2", "text": "Creating bindings for a new library"}, {"type": "p", "text": "To create bindings for a new library, start by creating a .def file.\nStructurally it's a simple property file, which looks like this:"}, {"type": "code", "text": ".def"}, {"type": "div", "text": "\nheaders = png.h\nheaderFilter = png.h\npackage = png\n\n"}, {"type": "pre", "text": "headers = png.h\nheaderFilter = png.h\npackage = png\n"}, {"type": "code", "text": "headers = png.h\nheaderFilter = png.h\npackage = png\n"}, {"type": "p", "text": "Then run the cinterop tool with something like this (note that for host libraries that are not included\nin the sysroot search paths, headers may be needed):"}, {"type": "code", "text": "cinterop"}, {"type": "div", "text": "\ncinterop -def png.def -compiler-option -I/usr/local/include -o png\n\n"}, {"type": "pre", "text": "cinterop -def png.def -compiler-option -I/usr/local/include -o png\n"}, {"type": "code", "text": "cinterop -def png.def -compiler-option -I/usr/local/include -o png\n"}, {"type": "p", "text": "This command will produce a png.klib compiled library and\npng-build/kotlin directory containing Kotlin source code for the library."}, {"type": "code", "text": "png.klib"}, {"type": "code", "text": "png-build/kotlin"}, {"type": "p", "text": "If the behavior for a certain platform needs to be modified, you can use a format like\ncompilerOpts.osx or compilerOpts.linux to provide platform-specific values\nto the options."}, {"type": "code", "text": "compilerOpts.osx"}, {"type": "code", "text": "compilerOpts.linux"}, {"type": "p", "text": "Note, that the generated bindings are generally platform-specific, so if you are developing for\nmultiple targets, the bindings need to be regenerated."}, {"type": "p", "text": "After the generation of bindings, they can be used by the IDE as a proxy view of the\nnative library."}, {"type": "p", "text": "For a typical Unix library with a config script, the compilerOpts will likely contain\nthe output of a config script with the --cflags flag (maybe without exact paths)."}, {"type": "code", "text": "compilerOpts"}, {"type": "code", "text": "--cflags"}, {"type": "p", "text": "The output of a config script with --libs will be passed as a -linkedArgs kotlinc\nflag value (quoted) when compiling."}, {"type": "code", "text": "--libs"}, {"type": "code", "text": "-linkedArgs"}, {"type": "code", "text": "kotlinc"}, {"type": "h3", "text": "Selecting library headers"}, {"type": "p", "text": "When library headers are imported to a C program with the #include directive,\nall of the headers included by these headers are also included in the program.\nSo all header dependencies are included in generated stubs as well."}, {"type": "code", "text": "#include"}, {"type": "p", "text": "This behavior is correct but it can be very inconvenient for some libraries. So\nit is possible to specify in the .def file which of the included headers are to\nbe imported. The separate declarations from other headers can also be imported\nin case of direct dependencies."}, {"type": "code", "text": ".def"}, {"type": "h4", "text": "Filtering headers by globs"}, {"type": "p", "text": "It is possible to filter headers by globs. The headerFilter property value\nfrom the .def file is treated as a space-separated list of globs. If the\nincluded header matches any of the globs, then the declarations from this header\nare included into the bindings."}, {"type": "code", "text": "headerFilter"}, {"type": "code", "text": ".def"}, {"type": "p", "text": "The globs are applied to the header paths relative to the appropriate include\npath elements, e.g. time.h or curl/curl.h. So if the library is usually\nincluded with #include <SomeLbrary/Header.h>, then it would probably be\ncorrect to filter headers with"}, {"type": "code", "text": "time.h"}, {"type": "code", "text": "curl/curl.h"}, {"type": "code", "text": "#include <SomeLbrary/Header.h>"}, {"type": "div", "text": "\nheaderFilter = SomeLibrary/**\n\n"}, {"type": "pre", "text": "headerFilter = SomeLibrary/**\n"}, {"type": "code", "text": "headerFilter = SomeLibrary/**\n"}, {"type": "p", "text": "If a headerFilter is not specified, then all headers are included."}, {"type": "code", "text": "headerFilter"}, {"type": "h4", "text": "Filtering by module maps"}, {"type": "p", "text": "Some libraries have proper module.modulemap or module.map files in its\nheaders. For example, macOS and iOS system libraries and frameworks do.\nThe module map file\ndescribes the correspondence between header files and modules. When the module\nmaps are available, the headers from the modules that are not included directly\ncan be filtered out using the experimental excludeDependentModules option of the\n.def file:"}, {"type": "code", "text": "module.modulemap"}, {"type": "code", "text": "module.map"}, {"type": "a", "text": "module map file"}, {"type": "code", "text": "excludeDependentModules"}, {"type": "code", "text": ".def"}, {"type": "div", "text": "\nheaders = OpenGL/gl.h OpenGL/glu.h GLUT/glut.h\ncompilerOpts = -framework OpenGL -framework GLUT\nexcludeDependentModules = true\n\n"}, {"type": "pre", "text": "headers = OpenGL/gl.h OpenGL/glu.h GLUT/glut.h\ncompilerOpts = -framework OpenGL -framework GLUT\nexcludeDependentModules = true\n"}, {"type": "code", "text": "headers = OpenGL/gl.h OpenGL/glu.h GLUT/glut.h\ncompilerOpts = -framework OpenGL -framework GLUT\nexcludeDependentModules = true\n"}, {"type": "p", "text": "When both excludeDependentModules and headerFilter are used, they are\napplied as an intersection."}, {"type": "code", "text": "excludeDependentModules"}, {"type": "code", "text": "headerFilter"}, {"type": "h3", "text": "C compiler and linker options"}, {"type": "p", "text": "Options passed to the C compiler (used to analyze headers, such as preprocessor definitions) and the linker\n(used to link final executables) can be passed in the definition file as compilerOpts and linkerOpts\nrespectively. For example"}, {"type": "code", "text": "compilerOpts"}, {"type": "code", "text": "linkerOpts"}, {"type": "div", "text": "\ncompilerOpts = -DFOO=bar\nlinkerOpts = -lpng\n\n"}, {"type": "pre", "text": "compilerOpts = -DFOO=bar\nlinkerOpts = -lpng\n"}, {"type": "code", "text": "compilerOpts = -DFOO=bar\nlinkerOpts = -lpng\n"}, {"type": "p", "text": "Target-specific options, only applicable to the certain target can be specified as well, such as"}, {"type": "div", "text": "\n compilerOpts = -DBAR=bar\n compilerOpts.linux_x64 = -DFOO=foo1\n compilerOpts.mac_x64 = -DFOO=foo2\n\n"}, {"type": "pre", "text": " compilerOpts = -DBAR=bar\n compilerOpts.linux_x64 = -DFOO=foo1\n compilerOpts.mac_x64 = -DFOO=foo2\n"}, {"type": "code", "text": " compilerOpts = -DBAR=bar\n compilerOpts.linux_x64 = -DFOO=foo1\n compilerOpts.mac_x64 = -DFOO=foo2\n"}, {"type": "p", "text": "and so, C headers on Linux will be analyzed with -DBAR=bar -DFOO=foo1 and on macOS with -DBAR=bar -DFOO=foo2.\nNote that any definition file option can have both common and the platform-specific part."}, {"type": "code", "text": "-DBAR=bar -DFOO=foo1"}, {"type": "code", "text": "-DBAR=bar -DFOO=foo2"}, {"type": "h3", "text": "Adding custom declarations"}, {"type": "p", "text": "Sometimes it is required to add custom C declarations to the library before\ngenerating bindings (e.g., for macros). Instead of creating an\nadditional header file with these declarations, you can include them directly\nto the end of the .def file, after a separating line, containing only the\nseparator sequence ---:"}, {"type": "a", "text": "macros"}, {"type": "code", "text": ".def"}, {"type": "code", "text": "---"}, {"type": "div", "text": "\nheaders = errno.h\n\n---\n\nstatic inline int getErrno() {\n    return errno;\n}\n\n"}, {"type": "pre", "text": "headers = errno.h\n\n---\n\nstatic inline int getErrno() {\n    return errno;\n}\n"}, {"type": "code", "text": "headers = errno.h\n\n---\n\nstatic inline int getErrno() {\n    return errno;\n}\n"}, {"type": "p", "text": "Note that this part of the .def file is treated as part of the header file, so\nfunctions with the body should be declared as static.\nThe declarations are parsed after including the files from the headers list."}, {"type": "code", "text": ".def"}, {"type": "code", "text": "static"}, {"type": "code", "text": "headers"}, {"type": "h3", "text": "Including static library in your klib"}, {"type": "p", "text": "Sometimes it is more convenient to ship a static library with your product,\nrather than assume it is available within the user's environment.\nTo include a static library into .klib use staticLibrary and libraryPaths\nclauses. For example:"}, {"type": "code", "text": ".klib"}, {"type": "code", "text": "staticLibrary"}, {"type": "code", "text": "libraryPaths"}, {"type": "div", "text": "\nheaders = foo.h\nstaticLibraries = libfoo.a \nlibraryPaths = /opt/local/lib /usr/local/opt/curl/lib\n\n"}, {"type": "pre", "text": "headers = foo.h\nstaticLibraries = libfoo.a \nlibraryPaths = /opt/local/lib /usr/local/opt/curl/lib\n"}, {"type": "code", "text": "headers = foo.h\nstaticLibraries = libfoo.a \nlibraryPaths = /opt/local/lib /usr/local/opt/curl/lib\n"}, {"type": "p", "text": "When given the above snippet the cinterop tool will search libfoo.a in \n/opt/local/lib and /usr/local/opt/curl/lib, and if it is found include the \nlibrary binary into klib."}, {"type": "code", "text": "cinterop"}, {"type": "code", "text": "libfoo.a"}, {"type": "code", "text": "/opt/local/lib"}, {"type": "code", "text": "/usr/local/opt/curl/lib"}, {"type": "code", "text": "klib"}, {"type": "p", "text": "When using such klib in your program, the library is linked automatically."}, {"type": "code", "text": "klib"}, {"type": "h2", "text": "Using bindings"}, {"type": "h3", "text": "Basic interop types"}, {"type": "p", "text": "All the supported C types have corresponding representations in Kotlin:"}, {"type": "ul", "text": "\nSigned, unsigned integral, and floating point types are mapped to their\nKotlin counterpart with the same width.\nPointers and arrays are mapped to CPointer<T>?.\nEnums can be mapped to either Kotlin enum or integral values, depending on\nheuristics and the definition file hints.\nStructs / unions are mapped to types having fields available via the dot notation,\ni.e. someStructInstance.field1.\ntypedef are represented as typealias.\n"}, {"type": "li", "text": "Signed, unsigned integral, and floating point types are mapped to their\nKotlin counterpart with the same width."}, {"type": "li", "text": "Pointers and arrays are mapped to CPointer<T>?."}, {"type": "code", "text": "CPointer<T>?"}, {"type": "li", "text": "Enums can be mapped to either Kotlin enum or integral values, depending on\nheuristics and the definition file hints."}, {"type": "a", "text": "definition file hints"}, {"type": "li", "text": "Structs / unions are mapped to types having fields available via the dot notation,\ni.e. someStructInstance.field1."}, {"type": "code", "text": "someStructInstance.field1"}, {"type": "li", "text": "typedef are represented as typealias."}, {"type": "code", "text": "typedef"}, {"type": "code", "text": "typealias"}, {"type": "p", "text": "Also, any C type has the Kotlin type representing the lvalue of this type,\ni.e., the value located in memory rather than a simple immutable self-contained\nvalue. Think C++ references, as a similar concept.\nFor structs (and typedefs to structs) this representation is the main one\nand has the same name as the struct itself, for Kotlin enums it is named\n${type}Var, for CPointer<T> it is CPointerVar<T>, and for most other\ntypes it is ${type}Var."}, {"type": "code", "text": "typedef"}, {"type": "code", "text": "${type}Var"}, {"type": "code", "text": "CPointer<T>"}, {"type": "code", "text": "CPointerVar<T>"}, {"type": "code", "text": "${type}Var"}, {"type": "p", "text": "For types that have both representations, the one with a \"lvalue\" has a mutable\n.value property for accessing the value."}, {"type": "code", "text": ".value"}, {"type": "h4", "text": "Pointer types"}, {"type": "p", "text": "The type argument T of CPointer<T> must be one of the \"lvalue\" types\ndescribed above, e.g., the C type struct S* is mapped to CPointer<S>,\nint8_t* is mapped to CPointer<int_8tVar>, and char** is mapped to\nCPointer<CPointerVar<ByteVar>>."}, {"type": "code", "text": "T"}, {"type": "code", "text": "CPointer<T>"}, {"type": "code", "text": "struct S*"}, {"type": "code", "text": "CPointer<S>"}, {"type": "code", "text": "int8_t*"}, {"type": "code", "text": "CPointer<int_8tVar>"}, {"type": "code", "text": "char**"}, {"type": "code", "text": "CPointer<CPointerVar<ByteVar>>"}, {"type": "p", "text": "C null pointer is represented as Kotlin's null, and the pointer type\nCPointer<T> is not nullable, but the CPointer<T>? is. The values of this\ntype support all the Kotlin operations related to handling null, e.g. ?:, ?.,\n!! etc.:"}, {"type": "code", "text": "null"}, {"type": "code", "text": "CPointer<T>"}, {"type": "code", "text": "CPointer<T>?"}, {"type": "code", "text": "null"}, {"type": "code", "text": "?:"}, {"type": "code", "text": "?."}, {"type": "code", "text": "!!"}, {"type": "div", "text": "\nval path = getenv(\"PATH\")?.toKString() ?: \"\"\n\n"}, {"type": "pre", "text": "val path = getenv(\"PATH\")?.toKString() ?: \"\"\n"}, {"type": "code", "text": "val path = getenv(\"PATH\")?.toKString() ?: \"\"\n"}, {"type": "p", "text": "Since the arrays are also mapped to CPointer<T>, it supports the [] operator\nfor accessing values by index:"}, {"type": "code", "text": "CPointer<T>"}, {"type": "code", "text": "[]"}, {"type": "div", "text": "\nfun shift(ptr: CPointer<BytePtr>, length: Int) {\n    for (index in 0 .. length - 2) {\n        ptr[index] = ptr[index + 1]\n    }\n}\n\n"}, {"type": "pre", "text": "fun shift(ptr: CPointer<BytePtr>, length: Int) {\n    for (index in 0 .. length - 2) {\n        ptr[index] = ptr[index + 1]\n    }\n}\n"}, {"type": "code", "text": "fun shift(ptr: CPointer<BytePtr>, length: Int) {\n    for (index in 0 .. length - 2) {\n        ptr[index] = ptr[index + 1]\n    }\n}\n"}, {"type": "p", "text": "The .pointed property for CPointer<T> returns the lvalue of type T,\npointed by this pointer. The reverse operation is .ptr: it takes the lvalue\nand returns the pointer to it."}, {"type": "code", "text": ".pointed"}, {"type": "code", "text": "CPointer<T>"}, {"type": "code", "text": "T"}, {"type": "code", "text": ".ptr"}, {"type": "p", "text": "void* is mapped to COpaquePointer \u2013 the special pointer type which is the\nsupertype for any other pointer type. So if the C function takes void*, then\nthe Kotlin binding accepts any CPointer."}, {"type": "code", "text": "void*"}, {"type": "code", "text": "COpaquePointer"}, {"type": "code", "text": "void*"}, {"type": "code", "text": "CPointer"}, {"type": "p", "text": "Casting a pointer (including COpaquePointer) can be done with\n.reinterpret<T>, e.g.:"}, {"type": "code", "text": "COpaquePointer"}, {"type": "code", "text": ".reinterpret<T>"}, {"type": "div", "text": "\nval intPtr = bytePtr.reinterpret<IntVar>()\n\n"}, {"type": "pre", "text": "val intPtr = bytePtr.reinterpret<IntVar>()\n"}, {"type": "code", "text": "val intPtr = bytePtr.reinterpret<IntVar>()\n"}, {"type": "p", "text": "or"}, {"type": "div", "text": "\nval intPtr: CPointer<IntVar> = bytePtr.reinterpret()\n\n"}, {"type": "pre", "text": "val intPtr: CPointer<IntVar> = bytePtr.reinterpret()\n"}, {"type": "code", "text": "val intPtr: CPointer<IntVar> = bytePtr.reinterpret()\n"}, {"type": "p", "text": "As is with C, these reinterpret casts are unsafe and can potentially lead to\nsubtle memory problems in the application."}, {"type": "p", "text": "Also there are unsafe casts between CPointer<T>? and Long available,\nprovided by the .toLong() and .toCPointer<T>() extension methods:"}, {"type": "code", "text": "CPointer<T>?"}, {"type": "code", "text": "Long"}, {"type": "code", "text": ".toLong()"}, {"type": "code", "text": ".toCPointer<T>()"}, {"type": "div", "text": "\nval longValue = ptr.toLong()\nval originalPtr = longValue.toCPointer<T>()\n\n"}, {"type": "pre", "text": "val longValue = ptr.toLong()\nval originalPtr = longValue.toCPointer<T>()\n"}, {"type": "code", "text": "val longValue = ptr.toLong()\nval originalPtr = longValue.toCPointer<T>()\n"}, {"type": "p", "text": "Note that if the type of the result is known from the context, the type argument\ncan be omitted as usual due to the type inference."}, {"type": "h3", "text": "Memory allocation"}, {"type": "p", "text": "The native memory can be allocated using the NativePlacement interface, e.g."}, {"type": "code", "text": "NativePlacement"}, {"type": "div", "text": "\nval byteVar = placement.alloc<ByteVar>()\n\n"}, {"type": "pre", "text": "val byteVar = placement.alloc<ByteVar>()\n"}, {"type": "code", "text": "val byteVar = placement.alloc<ByteVar>()\n"}, {"type": "p", "text": "or"}, {"type": "div", "text": "\nval bytePtr = placement.allocArray<ByteVar>(5)\n\n"}, {"type": "pre", "text": "val bytePtr = placement.allocArray<ByteVar>(5)\n"}, {"type": "code", "text": "val bytePtr = placement.allocArray<ByteVar>(5)\n"}, {"type": "p", "text": "The most \"natural\" placement is in the object nativeHeap.\nIt corresponds to allocating native memory with malloc and provides an additional\n.free() operation to free allocated memory:"}, {"type": "code", "text": "nativeHeap"}, {"type": "code", "text": "malloc"}, {"type": "code", "text": ".free()"}, {"type": "div", "text": "\nval buffer = nativeHeap.allocArray<ByteVar>(size)\n<use buffer>\nnativeHeap.free(buffer)\n\n"}, {"type": "pre", "text": "val buffer = nativeHeap.allocArray<ByteVar>(size)\n<use buffer>\nnativeHeap.free(buffer)\n"}, {"type": "code", "text": "val buffer = nativeHeap.allocArray<ByteVar>(size)\n<use buffer>\nnativeHeap.free(buffer)\n"}, {"type": "p", "text": "However, the lifetime of allocated memory is often bound to the lexical scope.\nIt is possible to define such scope with memScoped { ... }.\nInside the braces, the temporary placement is available as an implicit receiver,\nso it is possible to allocate native memory with alloc and allocArray,\nand the allocated memory will be automatically freed after leaving the scope."}, {"type": "code", "text": "memScoped { ... }"}, {"type": "code", "text": "alloc"}, {"type": "code", "text": "allocArray"}, {"type": "p", "text": "For example, the C function returning values through pointer parameters can be\nused like"}, {"type": "div", "text": "\nval fileSize = memScoped {\n    val statBuf = alloc<stat>()\n    val error = stat(\"/\", statBuf.ptr)\n    statBuf.st_size\n}\n\n"}, {"type": "pre", "text": "val fileSize = memScoped {\n    val statBuf = alloc<stat>()\n    val error = stat(\"/\", statBuf.ptr)\n    statBuf.st_size\n}\n"}, {"type": "code", "text": "val fileSize = memScoped {\n    val statBuf = alloc<stat>()\n    val error = stat(\"/\", statBuf.ptr)\n    statBuf.st_size\n}\n"}, {"type": "h3", "text": "Passing pointers to bindings"}, {"type": "p", "text": "Although C pointers are mapped to the CPointer<T> type, the C function\npointer-typed parameters are mapped to CValuesRef<T>. When passing\nCPointer<T> as the value of such a parameter, it is passed to the C function as is.\nHowever, the sequence of values can be passed instead of a pointer. In this case\nthe sequence is passed \"by value\", i.e., the C function receives the pointer to\nthe temporary copy of that sequence, which is valid only until the function returns."}, {"type": "code", "text": "CPointer<T>"}, {"type": "code", "text": "CValuesRef<T>"}, {"type": "code", "text": "CPointer<T>"}, {"type": "p", "text": "The CValuesRef<T> representation of pointer parameters is designed to support\nC array literals without explicit native memory allocation.\nTo construct the immutable self-contained sequence of C values, the following\nmethods are provided:"}, {"type": "code", "text": "CValuesRef<T>"}, {"type": "ul", "text": "\n${type}Array.toCValues(), where type is the Kotlin primitive type\nArray<CPointer<T>?>.toCValues(), List<CPointer<T>?>.toCValues()\ncValuesOf(vararg elements: ${type}), where type is a primitive or pointer\n"}, {"type": "li", "text": "${type}Array.toCValues(), where type is the Kotlin primitive type"}, {"type": "code", "text": "${type}Array.toCValues()"}, {"type": "code", "text": "type"}, {"type": "li", "text": "Array<CPointer<T>?>.toCValues(), List<CPointer<T>?>.toCValues()"}, {"type": "code", "text": "Array<CPointer<T>?>.toCValues()"}, {"type": "code", "text": "List<CPointer<T>?>.toCValues()"}, {"type": "li", "text": "cValuesOf(vararg elements: ${type}), where type is a primitive or pointer"}, {"type": "code", "text": "cValuesOf(vararg elements: ${type})"}, {"type": "code", "text": "type"}, {"type": "p", "text": "For example:"}, {"type": "p", "text": "C:"}, {"type": "div", "text": "\nvoid foo(int* elements, int count);\n...\nint elements[] = {1, 2, 3};\nfoo(elements, 3);\n\n"}, {"type": "pre", "text": "void foo(int* elements, int count);\n...\nint elements[] = {1, 2, 3};\nfoo(elements, 3);\n"}, {"type": "code", "text": "void foo(int* elements, int count);\n...\nint elements[] = {1, 2, 3};\nfoo(elements, 3);\n"}, {"type": "p", "text": "Kotlin:"}, {"type": "div", "text": "\nfoo(cValuesOf(1, 2, 3), 3)\n\n"}, {"type": "pre", "text": "foo(cValuesOf(1, 2, 3), 3)\n"}, {"type": "code", "text": "foo(cValuesOf(1, 2, 3), 3)\n"}, {"type": "h3", "text": "Working with the strings"}, {"type": "p", "text": "Unlike other pointers, the parameters of type const char* are represented as\na Kotlin String. So it is possible to pass any Kotlin string to a binding\nexpecting a C string."}, {"type": "code", "text": "const char*"}, {"type": "code", "text": "String"}, {"type": "p", "text": "There are also some tools available to convert between Kotlin and C strings\nmanually:"}, {"type": "ul", "text": "\nfun CPointer<ByteVar>.toKString(): String\n\nval String.cstr: CValuesRef<ByteVar>.\nTo get the pointer, .cstr should be allocated in native memory, e.g.\n\nval cString = kotlinString.cstr.getPointer(nativeHeap)\n\n\n\n"}, {"type": "li", "text": "fun CPointer<ByteVar>.toKString(): String"}, {"type": "code", "text": "fun CPointer<ByteVar>.toKString(): String"}, {"type": "li", "text": "\nval String.cstr: CValuesRef<ByteVar>.\nTo get the pointer, .cstr should be allocated in native memory, e.g.\n\nval cString = kotlinString.cstr.getPointer(nativeHeap)\n\n\n"}, {"type": "p", "text": "val String.cstr: CValuesRef<ByteVar>."}, {"type": "code", "text": "val String.cstr: CValuesRef<ByteVar>"}, {"type": "p", "text": "To get the pointer, .cstr should be allocated in native memory, e.g."}, {"type": "code", "text": ".cstr"}, {"type": "div", "text": "\nval cString = kotlinString.cstr.getPointer(nativeHeap)\n\n"}, {"type": "pre", "text": "val cString = kotlinString.cstr.getPointer(nativeHeap)\n"}, {"type": "code", "text": "val cString = kotlinString.cstr.getPointer(nativeHeap)\n"}, {"type": "p", "text": "In all cases, the C string is supposed to be encoded as UTF-8."}, {"type": "p", "text": "To skip automatic conversion and ensure raw pointers are used in the bindings, a noStringConversion\nstatement in the .def file could be used, i.e."}, {"type": "code", "text": "noStringConversion"}, {"type": "code", "text": ".def"}, {"type": "div", "text": "\nnoStringConversion = LoadCursorA LoadCursorW\n\n"}, {"type": "pre", "text": "noStringConversion = LoadCursorA LoadCursorW\n"}, {"type": "code", "text": "noStringConversion = LoadCursorA LoadCursorW\n"}, {"type": "p", "text": "This way any value of type CPointer<ByteVar> can be passed as an argument of const char* type.\nIf a Kotlin string should be passed, code like this could be used:"}, {"type": "code", "text": "CPointer<ByteVar>"}, {"type": "code", "text": "const char*"}, {"type": "div", "text": "\nmemScoped {\n    LoadCursorA(null, \"cursor.bmp\".cstr.ptr)   // for ASCII version\n    LoadCursorW(null, \"cursor.bmp\".wcstr.ptr)  // for Unicode version\n}\n\n"}, {"type": "pre", "text": "memScoped {\n    LoadCursorA(null, \"cursor.bmp\".cstr.ptr)   // for ASCII version\n    LoadCursorW(null, \"cursor.bmp\".wcstr.ptr)  // for Unicode version\n}\n"}, {"type": "code", "text": "memScoped {\n    LoadCursorA(null, \"cursor.bmp\".cstr.ptr)   // for ASCII version\n    LoadCursorW(null, \"cursor.bmp\".wcstr.ptr)  // for Unicode version\n}\n"}, {"type": "h3", "text": "Scope-local pointers"}, {"type": "p", "text": "It is possible to create a scope-stable pointer of C representation of CValues<T>\ninstance using the CValues<T>.ptr extension property, available under memScoped { ... }.\nIt allows using the APIs which require C pointers with a lifetime bound to a certain MemScope. For example:"}, {"type": "code", "text": "CValues<T>"}, {"type": "code", "text": "CValues<T>.ptr"}, {"type": "code", "text": "memScoped { ... }"}, {"type": "code", "text": "MemScope"}, {"type": "div", "text": "\nmemScoped {\n    items = arrayOfNulls<CPointer<ITEM>?>(6)\n    arrayOf(\"one\", \"two\").forEachIndexed { index, value -> items[index] = value.cstr.ptr }\n    menu = new_menu(\"Menu\".cstr.ptr, items.toCValues().ptr)\n    ...\n}\n\n"}, {"type": "pre", "text": "memScoped {\n    items = arrayOfNulls<CPointer<ITEM>?>(6)\n    arrayOf(\"one\", \"two\").forEachIndexed { index, value -> items[index] = value.cstr.ptr }\n    menu = new_menu(\"Menu\".cstr.ptr, items.toCValues().ptr)\n    ...\n}\n"}, {"type": "code", "text": "memScoped {\n    items = arrayOfNulls<CPointer<ITEM>?>(6)\n    arrayOf(\"one\", \"two\").forEachIndexed { index, value -> items[index] = value.cstr.ptr }\n    menu = new_menu(\"Menu\".cstr.ptr, items.toCValues().ptr)\n    ...\n}\n"}, {"type": "p", "text": "In this example, all values passed to the C API new_menu() have a lifetime of the innermost memScope\nit belongs to. Once the control flow leaves the memScoped scope the C pointers become invalid."}, {"type": "code", "text": "new_menu()"}, {"type": "code", "text": "memScope"}, {"type": "code", "text": "memScoped"}, {"type": "h3", "text": "Passing and receiving structs by value"}, {"type": "p", "text": "When a C function takes or returns a struct / union T by value, the corresponding\nargument type or return type is represented as CValue<T>."}, {"type": "code", "text": "T"}, {"type": "code", "text": "CValue<T>"}, {"type": "p", "text": "CValue<T> is an opaque type, so the structure fields cannot be accessed with\nthe appropriate Kotlin properties. It should be possible, if an API uses structures\nas handles, but if field access is required, there are the following conversion\nmethods available:"}, {"type": "code", "text": "CValue<T>"}, {"type": "ul", "text": "\n\nfun T.readValue(): CValue<T>. Converts (the lvalue) T to a CValue<T>.\nSo to construct the CValue<T>, T can be allocated, filled, and then\nconverted to CValue<T>.\n\n\nCValue<T>.useContents(block: T.() -> R): R. Temporarily places the\nCValue<T> to memory, and then runs the passed lambda with this placed\nvalue T as receiver. So to read a single field, the following code can be\nused:\n\nval fieldValue = structValue.useContents { field }\n\n\n\n"}, {"type": "li", "text": "\nfun T.readValue(): CValue<T>. Converts (the lvalue) T to a CValue<T>.\nSo to construct the CValue<T>, T can be allocated, filled, and then\nconverted to CValue<T>.\n"}, {"type": "p", "text": "fun T.readValue(): CValue<T>. Converts (the lvalue) T to a CValue<T>.\nSo to construct the CValue<T>, T can be allocated, filled, and then\nconverted to CValue<T>."}, {"type": "code", "text": "fun T.readValue(): CValue<T>"}, {"type": "code", "text": "T"}, {"type": "code", "text": "CValue<T>"}, {"type": "code", "text": "CValue<T>"}, {"type": "code", "text": "T"}, {"type": "code", "text": "CValue<T>"}, {"type": "li", "text": "\nCValue<T>.useContents(block: T.() -> R): R. Temporarily places the\nCValue<T> to memory, and then runs the passed lambda with this placed\nvalue T as receiver. So to read a single field, the following code can be\nused:\n\nval fieldValue = structValue.useContents { field }\n\n\n"}, {"type": "p", "text": "CValue<T>.useContents(block: T.() -> R): R. Temporarily places the\nCValue<T> to memory, and then runs the passed lambda with this placed\nvalue T as receiver. So to read a single field, the following code can be\nused:"}, {"type": "code", "text": "CValue<T>.useContents(block: T.() -> R): R"}, {"type": "code", "text": "CValue<T>"}, {"type": "code", "text": "T"}, {"type": "div", "text": "\nval fieldValue = structValue.useContents { field }\n\n"}, {"type": "pre", "text": "val fieldValue = structValue.useContents { field }\n"}, {"type": "code", "text": "val fieldValue = structValue.useContents { field }\n"}, {"type": "h3", "text": "Callbacks"}, {"type": "p", "text": "To convert a Kotlin function to a pointer to a C function,\nstaticCFunction(::kotlinFunction) can be used. It is also able to provide\nthe lambda instead of a function reference. The function or lambda must not\ncapture any values."}, {"type": "code", "text": "staticCFunction(::kotlinFunction)"}, {"type": "p", "text": "If the callback doesn't run in the main thread, it is mandatory to init the Kotlin/Native\nruntime by calling kotlin.native.initRuntimeIfNeeded()."}, {"type": "em", "text": "Kotlin/Native"}, {"type": "code", "text": "kotlin.native.initRuntimeIfNeeded()"}, {"type": "h4", "text": "Passing user data to callbacks"}, {"type": "p", "text": "Often C APIs allow passing some user data to callbacks. Such data is usually\nprovided by the user when configuring the callback. It is passed to some C function\n(or written to the struct) as e.g. void*.\nHowever, references to Kotlin objects can't be directly passed to C.\nSo they require wrapping before configuring the callback and then unwrapping in\nthe callback itself, to safely swim from Kotlin to Kotlin through the C world.\nSuch wrapping is possible with StableRef class."}, {"type": "code", "text": "void*"}, {"type": "code", "text": "StableRef"}, {"type": "p", "text": "To wrap the reference:"}, {"type": "div", "text": "\nval stableRef = StableRef.create(kotlinReference)\nval voidPtr = stableRef.asCPointer()\n\n"}, {"type": "pre", "text": "val stableRef = StableRef.create(kotlinReference)\nval voidPtr = stableRef.asCPointer()\n"}, {"type": "code", "text": "val stableRef = StableRef.create(kotlinReference)\nval voidPtr = stableRef.asCPointer()\n"}, {"type": "p", "text": "where the voidPtr is a COpaquePointer and can be passed to the C function."}, {"type": "code", "text": "voidPtr"}, {"type": "code", "text": "COpaquePointer"}, {"type": "p", "text": "To unwrap the reference:"}, {"type": "div", "text": "\nval stableRef = voidPtr.asStableRef<KotlinClass>()\nval kotlinReference = stableRef.get()\n\n"}, {"type": "pre", "text": "val stableRef = voidPtr.asStableRef<KotlinClass>()\nval kotlinReference = stableRef.get()\n"}, {"type": "code", "text": "val stableRef = voidPtr.asStableRef<KotlinClass>()\nval kotlinReference = stableRef.get()\n"}, {"type": "p", "text": "where kotlinReference is the original wrapped reference."}, {"type": "code", "text": "kotlinReference"}, {"type": "p", "text": "The created StableRef should eventually be manually disposed using\nthe .dispose() method to prevent memory leaks:"}, {"type": "code", "text": "StableRef"}, {"type": "code", "text": ".dispose()"}, {"type": "div", "text": "\nstableRef.dispose()\n\n"}, {"type": "pre", "text": "stableRef.dispose()\n"}, {"type": "code", "text": "stableRef.dispose()\n"}, {"type": "p", "text": "After that it becomes invalid, so voidPtr can't be unwrapped anymore."}, {"type": "code", "text": "voidPtr"}, {"type": "p", "text": "See the samples/libcurl for more details."}, {"type": "code", "text": "samples/libcurl"}, {"type": "h3", "text": "Macros"}, {"type": "p", "text": "Every C macro that expands to a constant is represented as a Kotlin property.\nOther macros are not supported. However, they can be exposed manually by\nwrapping them with supported declarations. E.g. function-like macro FOO can be\nexposed as function foo by\nadding the custom declaration to the library:"}, {"type": "code", "text": "FOO"}, {"type": "code", "text": "foo"}, {"type": "a", "text": "adding the custom declaration"}, {"type": "div", "text": "\nheaders = library/base.h\n\n---\n\nstatic inline int foo(int arg) {\n    return FOO(arg);\n}\n\n"}, {"type": "pre", "text": "headers = library/base.h\n\n---\n\nstatic inline int foo(int arg) {\n    return FOO(arg);\n}\n"}, {"type": "code", "text": "headers = library/base.h\n\n---\n\nstatic inline int foo(int arg) {\n    return FOO(arg);\n}\n"}, {"type": "h3", "text": "Definition file hints"}, {"type": "p", "text": "The .def file supports several options for adjusting the generated bindings."}, {"type": "code", "text": ".def"}, {"type": "ul", "text": "\n\nexcludedFunctions property value specifies a space-separated list of the names\nof functions that should be ignored. This may be required because a function\ndeclared in the C header is not generally guaranteed to be really callable, and\nit is often hard or impossible to figure this out automatically. This option\ncan also be used to workaround a bug in the interop itself.\n\n\nstrictEnums and nonStrictEnums properties values are space-separated\nlists of the enums that should be generated as a Kotlin enum or as integral\nvalues correspondingly. If the enum is not included into any of these lists,\nthen it is generated according to the heuristics.\n\n\nnoStringConversion property value is space-separated lists of the functions whose\nconst char* parameters shall not be autoconverted as Kotlin string\n\n"}, {"type": "li", "text": "\nexcludedFunctions property value specifies a space-separated list of the names\nof functions that should be ignored. This may be required because a function\ndeclared in the C header is not generally guaranteed to be really callable, and\nit is often hard or impossible to figure this out automatically. This option\ncan also be used to workaround a bug in the interop itself.\n"}, {"type": "p", "text": "excludedFunctions property value specifies a space-separated list of the names\nof functions that should be ignored. This may be required because a function\ndeclared in the C header is not generally guaranteed to be really callable, and\nit is often hard or impossible to figure this out automatically. This option\ncan also be used to workaround a bug in the interop itself."}, {"type": "code", "text": "excludedFunctions"}, {"type": "li", "text": "\nstrictEnums and nonStrictEnums properties values are space-separated\nlists of the enums that should be generated as a Kotlin enum or as integral\nvalues correspondingly. If the enum is not included into any of these lists,\nthen it is generated according to the heuristics.\n"}, {"type": "p", "text": "strictEnums and nonStrictEnums properties values are space-separated\nlists of the enums that should be generated as a Kotlin enum or as integral\nvalues correspondingly. If the enum is not included into any of these lists,\nthen it is generated according to the heuristics."}, {"type": "code", "text": "strictEnums"}, {"type": "code", "text": "nonStrictEnums"}, {"type": "li", "text": "\nnoStringConversion property value is space-separated lists of the functions whose\nconst char* parameters shall not be autoconverted as Kotlin string\n"}, {"type": "p", "text": "noStringConversion property value is space-separated lists of the functions whose\nconst char* parameters shall not be autoconverted as Kotlin string"}, {"type": "code", "text": "noStringConversion"}, {"type": "code", "text": "const char*"}, {"type": "h3", "text": "Portability"}, {"type": "p", "text": "Sometimes the C libraries have function parameters or struct fields of a\nplatform-dependent type, e.g. long or size_t. Kotlin itself doesn't provide\nneither implicit integer casts nor C-style integer casts (e.g.\n(size_t) intValue), so to make writing portable code in such cases easier,\nthe convert method is provided:"}, {"type": "code", "text": "long"}, {"type": "code", "text": "size_t"}, {"type": "code", "text": "(size_t) intValue"}, {"type": "code", "text": "convert"}, {"type": "div", "text": "\nfun ${type1}.convert<${type2}>(): ${type2}\n\n"}, {"type": "pre", "text": "fun ${type1}.convert<${type2}>(): ${type2}\n"}, {"type": "code", "text": "fun ${type1}.convert<${type2}>(): ${type2}\n"}, {"type": "p", "text": "where each of type1 and type2 must be an integral type, either signed or unsigned."}, {"type": "code", "text": "type1"}, {"type": "code", "text": "type2"}, {"type": "p", "text": ".convert<${type}> has the same semantics as one of the\n.toByte, .toShort, .toInt, .toLong,\n.toUByte, .toUShort, .toUInt or .toULong\nmethods, depending on type."}, {"type": "code", "text": ".convert<${type}>"}, {"type": "code", "text": ".toByte"}, {"type": "code", "text": ".toShort"}, {"type": "code", "text": ".toInt"}, {"type": "code", "text": ".toLong"}, {"type": "code", "text": ".toUByte"}, {"type": "code", "text": ".toUShort"}, {"type": "code", "text": ".toUInt"}, {"type": "code", "text": ".toULong"}, {"type": "code", "text": "type"}, {"type": "p", "text": "The example of using convert:"}, {"type": "code", "text": "convert"}, {"type": "div", "text": "\nfun zeroMemory(buffer: COpaquePointer, size: Int) {\n    memset(buffer, 0, size.convert<size_t>())\n}\n\n"}, {"type": "pre", "text": "fun zeroMemory(buffer: COpaquePointer, size: Int) {\n    memset(buffer, 0, size.convert<size_t>())\n}\n"}, {"type": "code", "text": "fun zeroMemory(buffer: COpaquePointer, size: Int) {\n    memset(buffer, 0, size.convert<size_t>())\n}\n"}, {"type": "p", "text": "Also, the type parameter can be inferred automatically and so may be omitted\nin some cases."}, {"type": "h3", "text": "Object pinning"}, {"type": "p", "text": "Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable\nuntil unpinned, and pointers to such objects inner data could be passed to the C functions. For example"}, {"type": "div", "text": "\nfun readData(fd: Int): String {\n    val buffer = ByteArray(1024)\n    buffer.usePinned { pinned ->\n        while (true) {\n            val length = recv(fd, pinned.addressOf(0), buffer.size.convert(), 0).toInt()\n\n            if (length <= 0) {\n               break\n            }\n            // Now `buffer` has raw data obtained from the `recv()` call.\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "fun readData(fd: Int): String {\n    val buffer = ByteArray(1024)\n    buffer.usePinned { pinned ->\n        while (true) {\n            val length = recv(fd, pinned.addressOf(0), buffer.size.convert(), 0).toInt()\n\n            if (length <= 0) {\n               break\n            }\n            // Now `buffer` has raw data obtained from the `recv()` call.\n        }\n    }\n}\n"}, {"type": "code", "text": "fun readData(fd: Int): String {\n    val buffer = ByteArray(1024)\n    buffer.usePinned { pinned ->\n        while (true) {\n            val length = recv(fd, pinned.addressOf(0), buffer.size.convert(), 0).toInt()\n\n            if (length <= 0) {\n               break\n            }\n            // Now `buffer` has raw data obtained from the `recv()` call.\n        }\n    }\n}\n"}, {"type": "p", "text": "Here we use service function usePinned, which pins an object, executes block and unpins it on normal and\nexception paths."}, {"type": "code", "text": "usePinned"}]