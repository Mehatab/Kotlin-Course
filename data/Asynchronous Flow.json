[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "p", "text": "Table of contents"}, {"type": "strong", "text": "Table of contents"}, {"type": "ul", "text": "\nAsynchronous Flow\n\nRepresenting multiple values\n\nSequences\nSuspending functions\nFlows\n\n\nFlows are cold\nFlow cancellation\nFlow builders\nIntermediate flow operators\n\nTransform operator\nSize-limiting operators\n\n\nTerminal flow operators\nFlows are sequential\nFlow context\n\nWrong emission withContext\nflowOn operator\n\n\nBuffering\n\nConflation\nProcessing the latest value\n\n\nComposing multiple flows\n\nZip\nCombine\n\n\nFlattening flows\n\nflatMapConcat\nflatMapMerge\nflatMapLatest\n\n\nFlow exceptions\n\nCollector try and catch\nEverything is caught\n\n\nException transparency\n\nTransparent catch\nCatching declaratively\n\n\nFlow completion\n\nImperative finally block\nDeclarative handling\nSuccessful completion\n\n\nImperative versus declarative\nLaunching flow\nFlow and Reactive Streams\n\n\n"}, {"type": "li", "text": "Asynchronous Flow\n\nRepresenting multiple values\n\nSequences\nSuspending functions\nFlows\n\n\nFlows are cold\nFlow cancellation\nFlow builders\nIntermediate flow operators\n\nTransform operator\nSize-limiting operators\n\n\nTerminal flow operators\nFlows are sequential\nFlow context\n\nWrong emission withContext\nflowOn operator\n\n\nBuffering\n\nConflation\nProcessing the latest value\n\n\nComposing multiple flows\n\nZip\nCombine\n\n\nFlattening flows\n\nflatMapConcat\nflatMapMerge\nflatMapLatest\n\n\nFlow exceptions\n\nCollector try and catch\nEverything is caught\n\n\nException transparency\n\nTransparent catch\nCatching declaratively\n\n\nFlow completion\n\nImperative finally block\nDeclarative handling\nSuccessful completion\n\n\nImperative versus declarative\nLaunching flow\nFlow and Reactive Streams\n\n"}, {"type": "a", "text": "Asynchronous Flow"}, {"type": "ul", "text": "\nRepresenting multiple values\n\nSequences\nSuspending functions\nFlows\n\n\nFlows are cold\nFlow cancellation\nFlow builders\nIntermediate flow operators\n\nTransform operator\nSize-limiting operators\n\n\nTerminal flow operators\nFlows are sequential\nFlow context\n\nWrong emission withContext\nflowOn operator\n\n\nBuffering\n\nConflation\nProcessing the latest value\n\n\nComposing multiple flows\n\nZip\nCombine\n\n\nFlattening flows\n\nflatMapConcat\nflatMapMerge\nflatMapLatest\n\n\nFlow exceptions\n\nCollector try and catch\nEverything is caught\n\n\nException transparency\n\nTransparent catch\nCatching declaratively\n\n\nFlow completion\n\nImperative finally block\nDeclarative handling\nSuccessful completion\n\n\nImperative versus declarative\nLaunching flow\nFlow and Reactive Streams\n"}, {"type": "li", "text": "Representing multiple values\n\nSequences\nSuspending functions\nFlows\n\n"}, {"type": "a", "text": "Representing multiple values"}, {"type": "ul", "text": "\nSequences\nSuspending functions\nFlows\n"}, {"type": "li", "text": "Sequences"}, {"type": "a", "text": "Sequences"}, {"type": "li", "text": "Suspending functions"}, {"type": "a", "text": "Suspending functions"}, {"type": "li", "text": "Flows"}, {"type": "a", "text": "Flows"}, {"type": "li", "text": "Flows are cold"}, {"type": "a", "text": "Flows are cold"}, {"type": "li", "text": "Flow cancellation"}, {"type": "a", "text": "Flow cancellation"}, {"type": "li", "text": "Flow builders"}, {"type": "a", "text": "Flow builders"}, {"type": "li", "text": "Intermediate flow operators\n\nTransform operator\nSize-limiting operators\n\n"}, {"type": "a", "text": "Intermediate flow operators"}, {"type": "ul", "text": "\nTransform operator\nSize-limiting operators\n"}, {"type": "li", "text": "Transform operator"}, {"type": "a", "text": "Transform operator"}, {"type": "li", "text": "Size-limiting operators"}, {"type": "a", "text": "Size-limiting operators"}, {"type": "li", "text": "Terminal flow operators"}, {"type": "a", "text": "Terminal flow operators"}, {"type": "li", "text": "Flows are sequential"}, {"type": "a", "text": "Flows are sequential"}, {"type": "li", "text": "Flow context\n\nWrong emission withContext\nflowOn operator\n\n"}, {"type": "a", "text": "Flow context"}, {"type": "ul", "text": "\nWrong emission withContext\nflowOn operator\n"}, {"type": "li", "text": "Wrong emission withContext"}, {"type": "a", "text": "Wrong emission withContext"}, {"type": "li", "text": "flowOn operator"}, {"type": "a", "text": "flowOn operator"}, {"type": "li", "text": "Buffering\n\nConflation\nProcessing the latest value\n\n"}, {"type": "a", "text": "Buffering"}, {"type": "ul", "text": "\nConflation\nProcessing the latest value\n"}, {"type": "li", "text": "Conflation"}, {"type": "a", "text": "Conflation"}, {"type": "li", "text": "Processing the latest value"}, {"type": "a", "text": "Processing the latest value"}, {"type": "li", "text": "Composing multiple flows\n\nZip\nCombine\n\n"}, {"type": "a", "text": "Composing multiple flows"}, {"type": "ul", "text": "\nZip\nCombine\n"}, {"type": "li", "text": "Zip"}, {"type": "a", "text": "Zip"}, {"type": "li", "text": "Combine"}, {"type": "a", "text": "Combine"}, {"type": "li", "text": "Flattening flows\n\nflatMapConcat\nflatMapMerge\nflatMapLatest\n\n"}, {"type": "a", "text": "Flattening flows"}, {"type": "ul", "text": "\nflatMapConcat\nflatMapMerge\nflatMapLatest\n"}, {"type": "li", "text": "flatMapConcat"}, {"type": "a", "text": "flatMapConcat"}, {"type": "li", "text": "flatMapMerge"}, {"type": "a", "text": "flatMapMerge"}, {"type": "li", "text": "flatMapLatest"}, {"type": "a", "text": "flatMapLatest"}, {"type": "li", "text": "Flow exceptions\n\nCollector try and catch\nEverything is caught\n\n"}, {"type": "a", "text": "Flow exceptions"}, {"type": "ul", "text": "\nCollector try and catch\nEverything is caught\n"}, {"type": "li", "text": "Collector try and catch"}, {"type": "a", "text": "Collector try and catch"}, {"type": "li", "text": "Everything is caught"}, {"type": "a", "text": "Everything is caught"}, {"type": "li", "text": "Exception transparency\n\nTransparent catch\nCatching declaratively\n\n"}, {"type": "a", "text": "Exception transparency"}, {"type": "ul", "text": "\nTransparent catch\nCatching declaratively\n"}, {"type": "li", "text": "Transparent catch"}, {"type": "a", "text": "Transparent catch"}, {"type": "li", "text": "Catching declaratively"}, {"type": "a", "text": "Catching declaratively"}, {"type": "li", "text": "Flow completion\n\nImperative finally block\nDeclarative handling\nSuccessful completion\n\n"}, {"type": "a", "text": "Flow completion"}, {"type": "ul", "text": "\nImperative finally block\nDeclarative handling\nSuccessful completion\n"}, {"type": "li", "text": "Imperative finally block"}, {"type": "a", "text": "Imperative finally block"}, {"type": "li", "text": "Declarative handling"}, {"type": "a", "text": "Declarative handling"}, {"type": "li", "text": "Successful completion"}, {"type": "a", "text": "Successful completion"}, {"type": "li", "text": "Imperative versus declarative"}, {"type": "a", "text": "Imperative versus declarative"}, {"type": "li", "text": "Launching flow"}, {"type": "a", "text": "Launching flow"}, {"type": "li", "text": "Flow and Reactive Streams"}, {"type": "a", "text": "Flow and Reactive Streams"}, {"type": "h2", "text": "Asynchronous Flow"}, {"type": "p", "text": "Suspending functions asynchronously returns a single value, but how can we return\nmultiple asynchronously computed values? This is where Kotlin Flows come in."}, {"type": "h3", "text": "Representing multiple values"}, {"type": "p", "text": "Multiple values can be represented in Kotlin using collections. \nFor example, we can have a function foo() that returns a List \nof three numbers and then print them all using forEach:"}, {"type": "a", "text": "collections"}, {"type": "code", "text": "foo()"}, {"type": "a", "text": "List"}, {"type": "a", "text": "forEach"}, {"type": "div", "text": "\nfun foo(): List<Int> = listOf(1, 2, 3)\n \nfun main() {\n    foo().forEach { value -> println(value) } \n}\n\n"}, {"type": "pre", "text": "fun foo(): List<Int> = listOf(1, 2, 3)\n \nfun main() {\n    foo().forEach { value -> println(value) } \n}\n"}, {"type": "code", "text": "fun foo(): List<Int> = listOf(1, 2, 3)\n \nfun main() {\n    foo().forEach { value -> println(value) } \n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "This code outputs:"}, {"type": "pre", "text": "1\n2\n3\n"}, {"type": "code", "text": "1\n2\n3\n"}, {"type": "h4", "text": "Sequences"}, {"type": "p", "text": "If we are computing the numbers with some CPU-consuming blocking code \n(each computation taking 100ms), then we can represent the numbers using a Sequence:"}, {"type": "a", "text": "Sequence"}, {"type": "div", "text": "\nfun foo(): Sequence<Int> = sequence { // sequence builder\n    for (i in 1..3) {\n        Thread.sleep(100) // pretend we are computing it\n        yield(i) // yield next value\n    }\n}\n\nfun main() {\n    foo().forEach { value -> println(value) } \n}\n\n"}, {"type": "pre", "text": "fun foo(): Sequence<Int> = sequence { // sequence builder\n    for (i in 1..3) {\n        Thread.sleep(100) // pretend we are computing it\n        yield(i) // yield next value\n    }\n}\n\nfun main() {\n    foo().forEach { value -> println(value) } \n}\n"}, {"type": "code", "text": "fun foo(): Sequence<Int> = sequence { // sequence builder\n    for (i in 1..3) {\n        Thread.sleep(100) // pretend we are computing it\n        yield(i) // yield next value\n    }\n}\n\nfun main() {\n    foo().forEach { value -> println(value) } \n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "This code outputs the same numbers, but it waits 100ms before printing each one."}, {"type": "h4", "text": "Suspending functions"}, {"type": "p", "text": "However, this computation blocks the main thread that is running the code. \nWhen these values are computed by asynchronous code we can mark the function foo with a suspend modifier,\nso that it can perform its work without blocking and return the result as a list:"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "suspend"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*                 \n                           \n//sampleStart\nsuspend fun foo(): List<Int> {\n    delay(1000) // pretend we are doing something asynchronous here\n    return listOf(1, 2, 3)\n}\n\nfun main() = runBlocking<Unit> {\n    foo().forEach { value -> println(value) } \n}\n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*                 \n                           \n//sampleStart\nsuspend fun foo(): List<Int> {\n    delay(1000) // pretend we are doing something asynchronous here\n    return listOf(1, 2, 3)\n}\n\nfun main() = runBlocking<Unit> {\n    foo().forEach { value -> println(value) } \n}\n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*                 \n                           \n//sampleStart\nsuspend fun foo(): List<Int> {\n    delay(1000) // pretend we are doing something asynchronous here\n    return listOf(1, 2, 3)\n}\n\nfun main() = runBlocking<Unit> {\n    foo().forEach { value -> println(value) } \n}\n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "This code prints the numbers after waiting for a second."}, {"type": "h4", "text": "Flows"}, {"type": "p", "text": "Using the List<Int> result type, means we can only return all the values at once. To represent\nthe stream of values that are being asynchronously computed, we can use a Flow<Int> type just like we would the Sequence<Int> type for synchronously computed values:"}, {"type": "code", "text": "List<Int>"}, {"type": "a", "text": "Flow<Int>"}, {"type": "code", "text": "Flow<Int>"}, {"type": "code", "text": "Sequence<Int>"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart               \nfun foo(): Flow<Int> = flow { // flow builder\n    for (i in 1..3) {\n        delay(100) // pretend we are doing something useful here\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    // Launch a concurrent coroutine to check if the main thread is blocked\n    launch {\n        for (k in 1..3) {\n            println(\"I'm not blocked $k\")\n            delay(100)\n        }\n    }\n    // Collect the flow\n    foo().collect { value -> println(value) } \n}\n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart               \nfun foo(): Flow<Int> = flow { // flow builder\n    for (i in 1..3) {\n        delay(100) // pretend we are doing something useful here\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    // Launch a concurrent coroutine to check if the main thread is blocked\n    launch {\n        for (k in 1..3) {\n            println(\"I'm not blocked $k\")\n            delay(100)\n        }\n    }\n    // Collect the flow\n    foo().collect { value -> println(value) } \n}\n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart               \nfun foo(): Flow<Int> = flow { // flow builder\n    for (i in 1..3) {\n        delay(100) // pretend we are doing something useful here\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    // Launch a concurrent coroutine to check if the main thread is blocked\n    launch {\n        for (k in 1..3) {\n            println(\"I'm not blocked $k\")\n            delay(100)\n        }\n    }\n    // Collect the flow\n    foo().collect { value -> println(value) } \n}\n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "This code waits 100ms before printing each number without blocking the main thread. This is verified\nby printing \"I'm not blocked\" every 100ms from a separate coroutine that is running in the main thread:"}, {"type": "pre", "text": "I'm not blocked 1\n1\nI'm not blocked 2\n2\nI'm not blocked 3\n3\n"}, {"type": "code", "text": "I'm not blocked 1\n1\nI'm not blocked 2\n2\nI'm not blocked 3\n3\n"}, {"type": "p", "text": "Notice the following differences in the code with the Flow from the earlier examples:"}, {"type": "a", "text": "Flow"}, {"type": "ul", "text": "\nA builder function for Flow type is called flow.\nCode inside the flow { ... } builder block can suspend.\nThe function foo() is no longer marked with suspend modifier.\nValues are emitted from the flow using emit function.\nValues are collected from the flow using collect function.\n"}, {"type": "li", "text": "A builder function for Flow type is called flow."}, {"type": "a", "text": "Flow"}, {"type": "a", "text": "flow"}, {"type": "li", "text": "Code inside the flow { ... } builder block can suspend."}, {"type": "code", "text": "flow { ... }"}, {"type": "li", "text": "The function foo() is no longer marked with suspend modifier."}, {"type": "code", "text": "foo()"}, {"type": "code", "text": "suspend"}, {"type": "li", "text": "Values are emitted from the flow using emit function."}, {"type": "em", "text": "emitted"}, {"type": "a", "text": "emit"}, {"type": "li", "text": "Values are collected from the flow using collect function."}, {"type": "em", "text": "collected"}, {"type": "a", "text": "collect"}, {"type": "blockquote", "text": "\nWe can replace delay with Thread.sleep in the body of foo's flow { ... } and see that the main\nthread is blocked in this case.\n"}, {"type": "p", "text": "We can replace delay with Thread.sleep in the body of foo's flow { ... } and see that the main\nthread is blocked in this case."}, {"type": "a", "text": "delay"}, {"type": "code", "text": "Thread.sleep"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "flow { ... }"}, {"type": "h3", "text": "Flows are cold"}, {"type": "p", "text": "Flows are cold streams similar to sequences \u2014 the code inside a flow builder does not\nrun until the flow is collected. This becomes clear in the following example:"}, {"type": "em", "text": "cold"}, {"type": "a", "text": "flow"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart      \nfun foo(): Flow<Int> = flow { \n    println(\"Flow started\")\n    for (i in 1..3) {\n        delay(100)\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    println(\"Calling foo...\")\n    val flow = foo()\n    println(\"Calling collect...\")\n    flow.collect { value -> println(value) } \n    println(\"Calling collect again...\")\n    flow.collect { value -> println(value) } \n}\n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart      \nfun foo(): Flow<Int> = flow { \n    println(\"Flow started\")\n    for (i in 1..3) {\n        delay(100)\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    println(\"Calling foo...\")\n    val flow = foo()\n    println(\"Calling collect...\")\n    flow.collect { value -> println(value) } \n    println(\"Calling collect again...\")\n    flow.collect { value -> println(value) } \n}\n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart      \nfun foo(): Flow<Int> = flow { \n    println(\"Flow started\")\n    for (i in 1..3) {\n        delay(100)\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    println(\"Calling foo...\")\n    val flow = foo()\n    println(\"Calling collect...\")\n    flow.collect { value -> println(value) } \n    println(\"Calling collect again...\")\n    flow.collect { value -> println(value) } \n}\n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Which prints:"}, {"type": "pre", "text": "Calling foo...\nCalling collect...\nFlow started\n1\n2\n3\nCalling collect again...\nFlow started\n1\n2\n3\n"}, {"type": "code", "text": "Calling foo...\nCalling collect...\nFlow started\n1\n2\n3\nCalling collect again...\nFlow started\n1\n2\n3\n"}, {"type": "p", "text": "This is a key reason the foo() function (which returns a flow) is not marked with suspend modifier.\nBy itself, foo() returns quickly and does not wait for anything. The flow starts every time it is collected,\nthat is why we see \"Flow started\" when we call collect again."}, {"type": "code", "text": "foo()"}, {"type": "code", "text": "suspend"}, {"type": "code", "text": "foo()"}, {"type": "code", "text": "collect"}, {"type": "h3", "text": "Flow cancellation"}, {"type": "p", "text": "Flow adheres to the general cooperative cancellation of coroutines. However, flow infrastructure does not introduce\nadditional cancellation points. It is fully transparent for cancellation. As usual, flow collection can be \ncancelled when the flow is suspended in a cancellable suspending function (like delay), and cannot be cancelled otherwise."}, {"type": "a", "text": "delay"}, {"type": "p", "text": "The following example shows how the flow gets cancelled on a timeout when running in a withTimeoutOrNull block \nand stops executing its code:"}, {"type": "a", "text": "withTimeoutOrNull"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart           \nfun foo(): Flow<Int> = flow { \n    for (i in 1..3) {\n        delay(100)          \n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    withTimeoutOrNull(250) { // Timeout after 250ms \n        foo().collect { value -> println(value) } \n    }\n    println(\"Done\")\n}\n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart           \nfun foo(): Flow<Int> = flow { \n    for (i in 1..3) {\n        delay(100)          \n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    withTimeoutOrNull(250) { // Timeout after 250ms \n        foo().collect { value -> println(value) } \n    }\n    println(\"Done\")\n}\n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart           \nfun foo(): Flow<Int> = flow { \n    for (i in 1..3) {\n        delay(100)          \n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    withTimeoutOrNull(250) { // Timeout after 250ms \n        foo().collect { value -> println(value) } \n    }\n    println(\"Done\")\n}\n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Notice how only two numbers get emitted by the flow in foo() function, producing the following output:"}, {"type": "code", "text": "foo()"}, {"type": "pre", "text": "Emitting 1\n1\nEmitting 2\n2\nDone\n"}, {"type": "code", "text": "Emitting 1\n1\nEmitting 2\n2\nDone\n"}, {"type": "h3", "text": "Flow builders"}, {"type": "p", "text": "The flow { ... } builder from the previous examples is the most basic one. There are other builders for\neasier declaration of flows:"}, {"type": "code", "text": "flow { ... }"}, {"type": "ul", "text": "\nflowOf builder that defines a flow emitting a fixed set of values.\nVarious collections and sequences can be converted to flows using .asFlow() extension functions.\n"}, {"type": "li", "text": "flowOf builder that defines a flow emitting a fixed set of values."}, {"type": "a", "text": "flowOf"}, {"type": "li", "text": "Various collections and sequences can be converted to flows using .asFlow() extension functions."}, {"type": "code", "text": ".asFlow()"}, {"type": "p", "text": "So, the example that prints the numbers from 1 to 3 from a flow can be written as:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    // Convert an integer range to a flow\n    (1..3).asFlow().collect { value -> println(value) }\n//sampleEnd \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    // Convert an integer range to a flow\n    (1..3).asFlow().collect { value -> println(value) }\n//sampleEnd \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    // Convert an integer range to a flow\n    (1..3).asFlow().collect { value -> println(value) }\n//sampleEnd \n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "h3", "text": "Intermediate flow operators"}, {"type": "p", "text": "Flows can be transformed with operators, just as you would with collections and sequences. \nIntermediate operators are applied to an upstream flow and return a downstream flow. \nThese operators are cold, just like flows are. A call to such an operator is not\na suspending function itself. It works quickly, returning the definition of a new transformed flow."}, {"type": "p", "text": "The basic operators have familiar names like map and filter. \nThe important difference to sequences is that blocks of \ncode inside these operators can call suspending functions."}, {"type": "a", "text": "map"}, {"type": "a", "text": "filter"}, {"type": "p", "text": "For example, a flow of incoming requests can be\nmapped to the results with the map operator, even when performing a request is a long-running\noperation that is implemented by a suspending function:"}, {"type": "a", "text": "map"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart           \nsuspend fun performRequest(request: Int): String {\n    delay(1000) // imitate long-running asynchronous work\n    return \"response $request\"\n}\n\nfun main() = runBlocking<Unit> {\n    (1..3).asFlow() // a flow of requests\n        .map { request -> performRequest(request) }\n        .collect { response -> println(response) }\n}\n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart           \nsuspend fun performRequest(request: Int): String {\n    delay(1000) // imitate long-running asynchronous work\n    return \"response $request\"\n}\n\nfun main() = runBlocking<Unit> {\n    (1..3).asFlow() // a flow of requests\n        .map { request -> performRequest(request) }\n        .collect { response -> println(response) }\n}\n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart           \nsuspend fun performRequest(request: Int): String {\n    delay(1000) // imitate long-running asynchronous work\n    return \"response $request\"\n}\n\nfun main() = runBlocking<Unit> {\n    (1..3).asFlow() // a flow of requests\n        .map { request -> performRequest(request) }\n        .collect { response -> println(response) }\n}\n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It produces the following three lines, each line appearing after each second:"}, {"type": "pre", "text": "response 1\nresponse 2\nresponse 3\n"}, {"type": "code", "text": "response 1\nresponse 2\nresponse 3\n"}, {"type": "h4", "text": "Transform operator"}, {"type": "p", "text": "Among the flow transformation operators, the most general one is called transform. It can be used to imitate\nsimple transformations like map and filter, as well as implement more complex transformations. \nUsing the transform operator, we can emit arbitrary values an arbitrary number of times."}, {"type": "a", "text": "transform"}, {"type": "a", "text": "map"}, {"type": "a", "text": "filter"}, {"type": "code", "text": "transform"}, {"type": "a", "text": "emit"}, {"type": "p", "text": "For example, using transform we can emit a string before performing a long-running asynchronous request \nand follow it with a response:"}, {"type": "code", "text": "transform"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nsuspend fun performRequest(request: Int): String {\n    delay(1000) // imitate long-running asynchronous work\n    return \"response $request\"\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    (1..3).asFlow() // a flow of requests\n        .transform { request ->\n            emit(\"Making request $request\") \n            emit(performRequest(request)) \n        }\n        .collect { response -> println(response) }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nsuspend fun performRequest(request: Int): String {\n    delay(1000) // imitate long-running asynchronous work\n    return \"response $request\"\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    (1..3).asFlow() // a flow of requests\n        .transform { request ->\n            emit(\"Making request $request\") \n            emit(performRequest(request)) \n        }\n        .collect { response -> println(response) }\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nsuspend fun performRequest(request: Int): String {\n    delay(1000) // imitate long-running asynchronous work\n    return \"response $request\"\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    (1..3).asFlow() // a flow of requests\n        .transform { request ->\n            emit(\"Making request $request\") \n            emit(performRequest(request)) \n        }\n        .collect { response -> println(response) }\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code is:"}, {"type": "pre", "text": "Making request 1\nresponse 1\nMaking request 2\nresponse 2\nMaking request 3\nresponse 3\n"}, {"type": "code", "text": "Making request 1\nresponse 1\nMaking request 2\nresponse 2\nMaking request 3\nresponse 3\n"}, {"type": "h4", "text": "Size-limiting operators"}, {"type": "p", "text": "Size-limiting intermediate operators like take cancel the execution of the flow when the corresponding limit\nis reached. Cancellation in coroutines is always performed by throwing an exception, so that all the resource-management\nfunctions (like try { ... } finally { ... } blocks) operate normally in case of cancellation:"}, {"type": "a", "text": "take"}, {"type": "code", "text": "try { ... } finally { ... }"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun numbers(): Flow<Int> = flow {\n    try {                          \n        emit(1)\n        emit(2) \n        println(\"This line will not execute\")\n        emit(3)    \n    } finally {\n        println(\"Finally in numbers\")\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    numbers() \n        .take(2) // take only the first two\n        .collect { value -> println(value) }\n}            \n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun numbers(): Flow<Int> = flow {\n    try {                          \n        emit(1)\n        emit(2) \n        println(\"This line will not execute\")\n        emit(3)    \n    } finally {\n        println(\"Finally in numbers\")\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    numbers() \n        .take(2) // take only the first two\n        .collect { value -> println(value) }\n}            \n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun numbers(): Flow<Int> = flow {\n    try {                          \n        emit(1)\n        emit(2) \n        println(\"This line will not execute\")\n        emit(3)    \n    } finally {\n        println(\"Finally in numbers\")\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    numbers() \n        .take(2) // take only the first two\n        .collect { value -> println(value) }\n}            \n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code clearly shows that the execution of the flow { ... } body in the numbers() function\nstopped after emitting the second number:"}, {"type": "code", "text": "flow { ... }"}, {"type": "code", "text": "numbers()"}, {"type": "pre", "text": "1\n2\nFinally in numbers\n"}, {"type": "code", "text": "1\n2\nFinally in numbers\n"}, {"type": "h3", "text": "Terminal flow operators"}, {"type": "p", "text": "Terminal operators on flows are suspending functions that start a collection of the flow.\nThe collect operator is the most basic one, but there are other terminal operators, which can make it easier:"}, {"type": "em", "text": "suspending functions"}, {"type": "a", "text": "collect"}, {"type": "ul", "text": "\nConversion to various collections like toList and toSet.\nOperators to get the first value and to ensure that a flow emits a single value.\nReducing a flow to a value with reduce and fold.\n"}, {"type": "li", "text": "Conversion to various collections like toList and toSet."}, {"type": "a", "text": "toList"}, {"type": "a", "text": "toSet"}, {"type": "li", "text": "Operators to get the first value and to ensure that a flow emits a single value."}, {"type": "a", "text": "first"}, {"type": "a", "text": "single"}, {"type": "li", "text": "Reducing a flow to a value with reduce and fold."}, {"type": "a", "text": "reduce"}, {"type": "a", "text": "fold"}, {"type": "p", "text": "For example:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart         \n    val sum = (1..5).asFlow()\n        .map { it * it } // squares of numbers from 1 to 5                           \n        .reduce { a, b -> a + b } // sum them (terminal operator)\n    println(sum)\n//sampleEnd     \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart         \n    val sum = (1..5).asFlow()\n        .map { it * it } // squares of numbers from 1 to 5                           \n        .reduce { a, b -> a + b } // sum them (terminal operator)\n    println(sum)\n//sampleEnd     \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart         \n    val sum = (1..5).asFlow()\n        .map { it * it } // squares of numbers from 1 to 5                           \n        .reduce { a, b -> a + b } // sum them (terminal operator)\n    println(sum)\n//sampleEnd     \n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Prints a single number:"}, {"type": "pre", "text": "55\n"}, {"type": "code", "text": "55\n"}, {"type": "h3", "text": "Flows are sequential"}, {"type": "p", "text": "Each individual collection of a flow is performed sequentially unless special operators that operate\non multiple flows are used. The collection works directly in the coroutine that calls a terminal operator. \nNo new coroutines are launched by default. \nEach emitted value is processed by all the intermediate operators from \nupstream to downstream and is then delivered to the terminal operator after."}, {"type": "p", "text": "See the following example that filters the even integers and maps them to strings:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart         \n    (1..5).asFlow()\n        .filter {\n            println(\"Filter $it\")\n            it % 2 == 0              \n        }              \n        .map { \n            println(\"Map $it\")\n            \"string $it\"\n        }.collect { \n            println(\"Collect $it\")\n        }    \n//sampleEnd                  \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart         \n    (1..5).asFlow()\n        .filter {\n            println(\"Filter $it\")\n            it % 2 == 0              \n        }              \n        .map { \n            println(\"Map $it\")\n            \"string $it\"\n        }.collect { \n            println(\"Collect $it\")\n        }    \n//sampleEnd                  \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart         \n    (1..5).asFlow()\n        .filter {\n            println(\"Filter $it\")\n            it % 2 == 0              \n        }              \n        .map { \n            println(\"Map $it\")\n            \"string $it\"\n        }.collect { \n            println(\"Collect $it\")\n        }    \n//sampleEnd                  \n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Producing:"}, {"type": "pre", "text": "Filter 1\nFilter 2\nMap 2\nCollect string 2\nFilter 3\nFilter 4\nMap 4\nCollect string 4\nFilter 5\n"}, {"type": "code", "text": "Filter 1\nFilter 2\nMap 2\nCollect string 2\nFilter 3\nFilter 4\nMap 4\nCollect string 4\nFilter 5\n"}, {"type": "h3", "text": "Flow context"}, {"type": "p", "text": "Collection of a flow always happens in the context of the calling coroutine. For example, if there is \na foo flow, then the following code runs in the context specified\nby the author of this code, regardless of the implementation details of the foo flow:"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "foo"}, {"type": "div", "text": "\nwithContext(context) {\n    foo.collect { value ->\n        println(value) // run in the specified context \n    }\n}\n\n"}, {"type": "pre", "text": "withContext(context) {\n    foo.collect { value ->\n        println(value) // run in the specified context \n    }\n}\n"}, {"type": "code", "text": "withContext(context) {\n    foo.collect { value ->\n        println(value) // run in the specified context \n    }\n}\n"}, {"type": "p", "text": "This property of a flow is called context preservation."}, {"type": "em", "text": "context preservation"}, {"type": "p", "text": "So, by default, code in the flow { ... } builder runs in the context that is provided by a collector\nof the corresponding flow. For example, consider the implementation of foo that prints the thread\nit is called on and emits three numbers:"}, {"type": "code", "text": "flow { ... }"}, {"type": "code", "text": "foo"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \n//sampleStart\nfun foo(): Flow<Int> = flow {\n    log(\"Started foo flow\")\n    for (i in 1..3) {\n        emit(i)\n    }\n}  \n\nfun main() = runBlocking<Unit> {\n    foo().collect { value -> log(\"Collected $value\") } \n}            \n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \n//sampleStart\nfun foo(): Flow<Int> = flow {\n    log(\"Started foo flow\")\n    for (i in 1..3) {\n        emit(i)\n    }\n}  \n\nfun main() = runBlocking<Unit> {\n    foo().collect { value -> log(\"Collected $value\") } \n}            \n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \n//sampleStart\nfun foo(): Flow<Int> = flow {\n    log(\"Started foo flow\")\n    for (i in 1..3) {\n        emit(i)\n    }\n}  \n\nfun main() = runBlocking<Unit> {\n    foo().collect { value -> log(\"Collected $value\") } \n}            \n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Running this code produces:"}, {"type": "pre", "text": "[main @coroutine#1] Started foo flow\n[main @coroutine#1] Collected 1\n[main @coroutine#1] Collected 2\n[main @coroutine#1] Collected 3\n"}, {"type": "code", "text": "[main @coroutine#1] Started foo flow\n[main @coroutine#1] Collected 1\n[main @coroutine#1] Collected 2\n[main @coroutine#1] Collected 3\n"}, {"type": "p", "text": "Since foo().collect is called from the main thread, the body of foo's flow is also called in the main thread.\nThis is the perfect default for fast-running or asynchronous code that does not care about the execution context and\ndoes not block the caller."}, {"type": "code", "text": "foo().collect"}, {"type": "code", "text": "foo"}, {"type": "h4", "text": "Wrong emission withContext"}, {"type": "p", "text": "However, the long-running CPU-consuming code might need to be executed in the context of Dispatchers.Default and UI-updating\ncode might need to be executed in the context of Dispatchers.Main. Usually, withContext is used\nto change the context in the code using Kotlin coroutines, but code in the flow { ... } builder has to honor the context\npreservation property and is not allowed to emit from a different context."}, {"type": "a", "text": "Dispatchers.Default"}, {"type": "a", "text": "Dispatchers.Main"}, {"type": "a", "text": "withContext"}, {"type": "code", "text": "flow { ... }"}, {"type": "a", "text": "emit"}, {"type": "p", "text": "Try running the following code:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n                      \n//sampleStart\nfun foo(): Flow<Int> = flow {\n    // The WRONG way to change context for CPU-consuming code in flow builder\n    kotlinx.coroutines.withContext(Dispatchers.Default) {\n        for (i in 1..3) {\n            Thread.sleep(100) // pretend we are computing it in CPU-consuming way\n            emit(i) // emit next value\n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    foo().collect { value -> println(value) } \n}            \n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n                      \n//sampleStart\nfun foo(): Flow<Int> = flow {\n    // The WRONG way to change context for CPU-consuming code in flow builder\n    kotlinx.coroutines.withContext(Dispatchers.Default) {\n        for (i in 1..3) {\n            Thread.sleep(100) // pretend we are computing it in CPU-consuming way\n            emit(i) // emit next value\n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    foo().collect { value -> println(value) } \n}            \n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n                      \n//sampleStart\nfun foo(): Flow<Int> = flow {\n    // The WRONG way to change context for CPU-consuming code in flow builder\n    kotlinx.coroutines.withContext(Dispatchers.Default) {\n        for (i in 1..3) {\n            Thread.sleep(100) // pretend we are computing it in CPU-consuming way\n            emit(i) // emit next value\n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    foo().collect { value -> println(value) } \n}            \n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "This code produces the following exception:"}, {"type": "pre", "text": "Exception in thread \"main\" java.lang.IllegalStateException: Flow invariant is violated:\n\t\tFlow was collected in [CoroutineId(1), \"coroutine#1\":BlockingCoroutine{Active}@5511c7f8, BlockingEventLoop@2eac3323],\n\t\tbut emission happened in [CoroutineId(1), \"coroutine#1\":DispatchedCoroutine{Active}@2dae0000, DefaultDispatcher].\n\t\tPlease refer to 'flow' documentation or use 'flowOn' instead\n\tat ...\n"}, {"type": "code", "text": "Exception in thread \"main\" java.lang.IllegalStateException: Flow invariant is violated:\n\t\tFlow was collected in [CoroutineId(1), \"coroutine#1\":BlockingCoroutine{Active}@5511c7f8, BlockingEventLoop@2eac3323],\n\t\tbut emission happened in [CoroutineId(1), \"coroutine#1\":DispatchedCoroutine{Active}@2dae0000, DefaultDispatcher].\n\t\tPlease refer to 'flow' documentation or use 'flowOn' instead\n\tat ...\n"}, {"type": "h4", "text": "flowOn operator"}, {"type": "p", "text": "The exception refers to the flowOn function that shall be used to change the context of the flow emission.\nThe correct way to change the context of a flow is shown in the example below, which also prints the \nnames of the corresponding threads to show how it all works:"}, {"type": "a", "text": "flowOn"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \n//sampleStart\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        Thread.sleep(100) // pretend we are computing it in CPU-consuming way\n        log(\"Emitting $i\")\n        emit(i) // emit next value\n    }\n}.flowOn(Dispatchers.Default) // RIGHT way to change context for CPU-consuming code in flow builder\n\nfun main() = runBlocking<Unit> {\n    foo().collect { value ->\n        log(\"Collected $value\") \n    } \n}            \n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \n//sampleStart\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        Thread.sleep(100) // pretend we are computing it in CPU-consuming way\n        log(\"Emitting $i\")\n        emit(i) // emit next value\n    }\n}.flowOn(Dispatchers.Default) // RIGHT way to change context for CPU-consuming code in flow builder\n\nfun main() = runBlocking<Unit> {\n    foo().collect { value ->\n        log(\"Collected $value\") \n    } \n}            \n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \n//sampleStart\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        Thread.sleep(100) // pretend we are computing it in CPU-consuming way\n        log(\"Emitting $i\")\n        emit(i) // emit next value\n    }\n}.flowOn(Dispatchers.Default) // RIGHT way to change context for CPU-consuming code in flow builder\n\nfun main() = runBlocking<Unit> {\n    foo().collect { value ->\n        log(\"Collected $value\") \n    } \n}            \n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Notice how flow { ... } works in the background thread, while collection happens in the main thread:"}, {"type": "code", "text": "flow { ... }"}, {"type": "p", "text": "Another thing to observe here is that the flowOn operator has changed the default sequential nature of the flow.\nNow collection happens in one coroutine (\"coroutine#1\") and emission happens in another coroutine\n(\"coroutine#2\") that is running in another thread concurrently with the collecting coroutine. The flowOn operator\ncreates another coroutine for an upstream flow when it has to change the CoroutineDispatcher in its context."}, {"type": "a", "text": "flowOn"}, {"type": "a", "text": "flowOn"}, {"type": "a", "text": "CoroutineDispatcher"}, {"type": "h3", "text": "Buffering"}, {"type": "p", "text": "Running different parts of a flow in different coroutines can be helpful from the standpoint of the overall time it takes \nto collect the flow, especially when long-running asynchronous operations are involved. For example, consider a case when\nthe emission by foo() flow is slow, taking 100 ms to produce an element; and collector is also slow, \ntaking 300 ms to process an element. Let's see how long it takes to collect such a flow with three numbers:"}, {"type": "code", "text": "foo()"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\n//sampleStart\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n    val time = measureTimeMillis {\n        foo().collect { value -> \n            delay(300) // pretend we are processing it for 300 ms\n            println(value) \n        } \n    }   \n    println(\"Collected in $time ms\")\n}\n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\n//sampleStart\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n    val time = measureTimeMillis {\n        foo().collect { value -> \n            delay(300) // pretend we are processing it for 300 ms\n            println(value) \n        } \n    }   \n    println(\"Collected in $time ms\")\n}\n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\n//sampleStart\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n    val time = measureTimeMillis {\n        foo().collect { value -> \n            delay(300) // pretend we are processing it for 300 ms\n            println(value) \n        } \n    }   \n    println(\"Collected in $time ms\")\n}\n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It produces something like this, with the whole collection taking around 1200 ms (three numbers, 400 ms for each):"}, {"type": "pre", "text": "1\n2\n3\nCollected in 1220 ms\n"}, {"type": "code", "text": "1\n2\n3\nCollected in 1220 ms\n"}, {"type": "p", "text": "We can use a buffer operator on a flow to run emitting code of foo() concurrently with collecting code,\nas opposed to running them sequentially:"}, {"type": "a", "text": "buffer"}, {"type": "code", "text": "foo()"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val time = measureTimeMillis {\n        foo()\n            .buffer() // buffer emissions, don't wait\n            .collect { value -> \n                delay(300) // pretend we are processing it for 300 ms\n                println(value) \n            } \n    }   \n    println(\"Collected in $time ms\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val time = measureTimeMillis {\n        foo()\n            .buffer() // buffer emissions, don't wait\n            .collect { value -> \n                delay(300) // pretend we are processing it for 300 ms\n                println(value) \n            } \n    }   \n    println(\"Collected in $time ms\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val time = measureTimeMillis {\n        foo()\n            .buffer() // buffer emissions, don't wait\n            .collect { value -> \n                delay(300) // pretend we are processing it for 300 ms\n                println(value) \n            } \n    }   \n    println(\"Collected in $time ms\")\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It produces the same numbers just faster, as we have effectively created a processing pipeline,\nhaving to only wait 100 ms for the first number and then spending only 300 ms to process\neach number. This way it takes around 1000 ms to run:"}, {"type": "pre", "text": "1\n2\n3\nCollected in 1071 ms\n"}, {"type": "code", "text": "1\n2\n3\nCollected in 1071 ms\n"}, {"type": "blockquote", "text": "\nNote that the flowOn operator uses the same buffering mechanism when it has to change a CoroutineDispatcher,\nbut here we explicitly request buffering without changing the execution context.\n"}, {"type": "p", "text": "Note that the flowOn operator uses the same buffering mechanism when it has to change a CoroutineDispatcher,\nbut here we explicitly request buffering without changing the execution context."}, {"type": "a", "text": "flowOn"}, {"type": "a", "text": "CoroutineDispatcher"}, {"type": "h4", "text": "Conflation"}, {"type": "p", "text": "When a flow represents partial results of the operation or operation status updates, it may not be necessary\nto process each value, but instead, only most recent ones. In this case, the conflate operator can be used to skip\nintermediate values when a collector is too slow to process them. Building on the previous example:"}, {"type": "a", "text": "conflate"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val time = measureTimeMillis {\n        foo()\n            .conflate() // conflate emissions, don't process each one\n            .collect { value -> \n                delay(300) // pretend we are processing it for 300 ms\n                println(value) \n            } \n    }   \n    println(\"Collected in $time ms\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val time = measureTimeMillis {\n        foo()\n            .conflate() // conflate emissions, don't process each one\n            .collect { value -> \n                delay(300) // pretend we are processing it for 300 ms\n                println(value) \n            } \n    }   \n    println(\"Collected in $time ms\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val time = measureTimeMillis {\n        foo()\n            .conflate() // conflate emissions, don't process each one\n            .collect { value -> \n                delay(300) // pretend we are processing it for 300 ms\n                println(value) \n            } \n    }   \n    println(\"Collected in $time ms\")\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "We see that while the first number was still being processed the second, and third were already produced, so\nthe second one was conflated and only the most recent (the third one) was delivered to the collector:"}, {"type": "em", "text": "conflated"}, {"type": "pre", "text": "1\n3\nCollected in 758 ms\n"}, {"type": "code", "text": "1\n3\nCollected in 758 ms\n"}, {"type": "h4", "text": "Processing the latest value"}, {"type": "p", "text": "Conflation is one way to speed up processing when both the emitter and collector are slow. It does it by dropping emitted values.\nThe other way is to cancel a slow collector and restart it every time a new value is emitted. There is\na family of xxxLatest operators that perform the same essential logic of a xxx operator, but cancel the\ncode in their block on a new value. Let's try changing conflate to collectLatest in the previous example:"}, {"type": "code", "text": "xxxLatest"}, {"type": "code", "text": "xxx"}, {"type": "a", "text": "conflate"}, {"type": "a", "text": "collectLatest"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val time = measureTimeMillis {\n        foo()\n            .collectLatest { value -> // cancel & restart on the latest value\n                println(\"Collecting $value\") \n                delay(300) // pretend we are processing it for 300 ms\n                println(\"Done $value\") \n            } \n    }   \n    println(\"Collected in $time ms\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val time = measureTimeMillis {\n        foo()\n            .collectLatest { value -> // cancel & restart on the latest value\n                println(\"Collecting $value\") \n                delay(300) // pretend we are processing it for 300 ms\n                println(\"Done $value\") \n            } \n    }   \n    println(\"Collected in $time ms\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val time = measureTimeMillis {\n        foo()\n            .collectLatest { value -> // cancel & restart on the latest value\n                println(\"Collecting $value\") \n                delay(300) // pretend we are processing it for 300 ms\n                println(\"Done $value\") \n            } \n    }   \n    println(\"Collected in $time ms\")\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Since the body of collectLatest takes 300 ms, but new values are emitted every 100 ms, we see that the block\nis run on every value, but completes only for the last value:"}, {"type": "a", "text": "collectLatest"}, {"type": "pre", "text": "Collecting 1\nCollecting 2\nCollecting 3\nDone 3\nCollected in 741 ms\n"}, {"type": "code", "text": "Collecting 1\nCollecting 2\nCollecting 3\nDone 3\nCollected in 741 ms\n"}, {"type": "h3", "text": "Composing multiple flows"}, {"type": "p", "text": "There are lots of ways to compose multiple flows."}, {"type": "h4", "text": "Zip"}, {"type": "p", "text": "Just like the Sequence.zip extension function in the Kotlin standard library, \nflows have a zip operator that combines the corresponding values of two flows:"}, {"type": "a", "text": "Sequence.zip"}, {"type": "a", "text": "zip"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n//sampleStart                                                                           \n    val nums = (1..3).asFlow() // numbers 1..3\n    val strs = flowOf(\"one\", \"two\", \"three\") // strings \n    nums.zip(strs) { a, b -> \"$a -> $b\" } // compose a single string\n        .collect { println(it) } // collect and print\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n//sampleStart                                                                           \n    val nums = (1..3).asFlow() // numbers 1..3\n    val strs = flowOf(\"one\", \"two\", \"three\") // strings \n    nums.zip(strs) { a, b -> \"$a -> $b\" } // compose a single string\n        .collect { println(it) } // collect and print\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n//sampleStart                                                                           \n    val nums = (1..3).asFlow() // numbers 1..3\n    val strs = flowOf(\"one\", \"two\", \"three\") // strings \n    nums.zip(strs) { a, b -> \"$a -> $b\" } // compose a single string\n        .collect { println(it) } // collect and print\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "This example prints:"}, {"type": "pre", "text": "1 -> one\n2 -> two\n3 -> three\n"}, {"type": "code", "text": "1 -> one\n2 -> two\n3 -> three\n"}, {"type": "h4", "text": "Combine"}, {"type": "p", "text": "When flow represents the most recent value of a variable or operation (see also the related \nsection on conflation), it might be needed to perform a computation that depends on\nthe most recent values of the corresponding flows and to recompute it whenever any of the upstream\nflows emit a value. The corresponding family of operators is called combine."}, {"type": "a", "text": "conflation"}, {"type": "a", "text": "combine"}, {"type": "p", "text": "For example, if the numbers in the previous example update every 300ms, but strings update every 400 ms, \nthen zipping them using the zip operator will still produce the same result, \nalbeit results that are printed every 400 ms:"}, {"type": "a", "text": "zip"}, {"type": "blockquote", "text": "\nWe use a onEach intermediate operator in this example to delay each element and make the code \nthat emits sample flows more declarative and shorter.\n"}, {"type": "p", "text": "We use a onEach intermediate operator in this example to delay each element and make the code \nthat emits sample flows more declarative and shorter."}, {"type": "a", "text": "onEach"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n//sampleStart                                                                           \n    val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms\n    val strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(400) } // strings every 400 ms\n    val startTime = System.currentTimeMillis() // remember the start time \n    nums.zip(strs) { a, b -> \"$a -> $b\" } // compose a single string with \"zip\"\n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n//sampleStart                                                                           \n    val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms\n    val strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(400) } // strings every 400 ms\n    val startTime = System.currentTimeMillis() // remember the start time \n    nums.zip(strs) { a, b -> \"$a -> $b\" } // compose a single string with \"zip\"\n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n//sampleStart                                                                           \n    val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms\n    val strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(400) } // strings every 400 ms\n    val startTime = System.currentTimeMillis() // remember the start time \n    nums.zip(strs) { a, b -> \"$a -> $b\" } // compose a single string with \"zip\"\n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "However, when using a combine operator here instead of a zip:"}, {"type": "a", "text": "combine"}, {"type": "a", "text": "zip"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n//sampleStart                                                                           \n    val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms\n    val strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(400) } // strings every 400 ms          \n    val startTime = System.currentTimeMillis() // remember the start time \n    nums.combine(strs) { a, b -> \"$a -> $b\" } // compose a single string with \"combine\"\n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n//sampleStart                                                                           \n    val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms\n    val strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(400) } // strings every 400 ms          \n    val startTime = System.currentTimeMillis() // remember the start time \n    nums.combine(strs) { a, b -> \"$a -> $b\" } // compose a single string with \"combine\"\n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n//sampleStart                                                                           \n    val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms\n    val strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(400) } // strings every 400 ms          \n    val startTime = System.currentTimeMillis() // remember the start time \n    nums.combine(strs) { a, b -> \"$a -> $b\" } // compose a single string with \"combine\"\n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "We get quite a different output, where a line is printed at each emission from either nums or strs flows:"}, {"type": "code", "text": "nums"}, {"type": "code", "text": "strs"}, {"type": "pre", "text": "1 -> one at 452 ms from start\n2 -> one at 651 ms from start\n2 -> two at 854 ms from start\n3 -> two at 952 ms from start\n3 -> three at 1256 ms from start\n"}, {"type": "code", "text": "1 -> one at 452 ms from start\n2 -> one at 651 ms from start\n2 -> two at 854 ms from start\n3 -> two at 952 ms from start\n3 -> three at 1256 ms from start\n"}, {"type": "h3", "text": "Flattening flows"}, {"type": "p", "text": "Flows represent asynchronously received sequences of values, so it is quite easy to get in a situation where \neach value triggers a request for another sequence of values. For example, we can have the following\nfunction that returns a flow of two strings 500 ms apart:"}, {"type": "div", "text": "\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n\n"}, {"type": "pre", "text": "fun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n"}, {"type": "code", "text": "fun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n"}, {"type": "p", "text": "Now if we have a flow of three integers and call requestFlow for each of them like this:"}, {"type": "code", "text": "requestFlow"}, {"type": "div", "text": "\n(1..3).asFlow().map { requestFlow(it) }\n\n"}, {"type": "pre", "text": "(1..3).asFlow().map { requestFlow(it) }\n"}, {"type": "code", "text": "(1..3).asFlow().map { requestFlow(it) }\n"}, {"type": "p", "text": "Then we end up with a flow of flows (Flow<Flow<String>>) that needs to be flattened into a single flow for \nfurther processing. Collections and sequences have flatten and flatMap\noperators for this. However, due the asynchronous nature of flows they call for different modes of flattening, \nas such, there is a family of flattening operators on flows."}, {"type": "code", "text": "Flow<Flow<String>>"}, {"type": "em", "text": "flattened"}, {"type": "a", "text": "flatten"}, {"type": "a", "text": "flatMap"}, {"type": "em", "text": "modes"}, {"type": "h4", "text": "flatMapConcat"}, {"type": "p", "text": "Concatenating mode is implemented by flatMapConcat and flattenConcat operators. They are the most direct\nanalogues of the corresponding sequence operators. They wait for the inner flow to complete before\nstarting to collect the next one as the following example shows:"}, {"type": "a", "text": "flatMapConcat"}, {"type": "a", "text": "flattenConcat"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val startTime = System.currentTimeMillis() // remember the start time \n    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n        .flatMapConcat { requestFlow(it) }                                                                           \n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val startTime = System.currentTimeMillis() // remember the start time \n    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n        .flatMapConcat { requestFlow(it) }                                                                           \n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val startTime = System.currentTimeMillis() // remember the start time \n    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n        .flatMapConcat { requestFlow(it) }                                                                           \n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The sequential nature of flatMapConcat is clearly seen in the output:"}, {"type": "a", "text": "flatMapConcat"}, {"type": "pre", "text": "1: First at 121 ms from start\n1: Second at 622 ms from start\n2: First at 727 ms from start\n2: Second at 1227 ms from start\n3: First at 1328 ms from start\n3: Second at 1829 ms from start\n"}, {"type": "code", "text": "1: First at 121 ms from start\n1: Second at 622 ms from start\n2: First at 727 ms from start\n2: Second at 1227 ms from start\n3: First at 1328 ms from start\n3: Second at 1829 ms from start\n"}, {"type": "h4", "text": "flatMapMerge"}, {"type": "p", "text": "Another flattening mode is to concurrently collect all the incoming flows and merge their values into\na single flow so that values are emitted as soon as possible.\nIt is implemented by flatMapMerge and flattenMerge operators. They both accept an optional \nconcurrency parameter that limits the number of concurrent flows that are collected at the same time\n(it is equal to DEFAULT_CONCURRENCY by default)."}, {"type": "a", "text": "flatMapMerge"}, {"type": "a", "text": "flattenMerge"}, {"type": "code", "text": "concurrency"}, {"type": "a", "text": "DEFAULT_CONCURRENCY"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val startTime = System.currentTimeMillis() // remember the start time \n    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n        .flatMapMerge { requestFlow(it) }                                                                           \n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val startTime = System.currentTimeMillis() // remember the start time \n    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n        .flatMapMerge { requestFlow(it) }                                                                           \n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val startTime = System.currentTimeMillis() // remember the start time \n    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n        .flatMapMerge { requestFlow(it) }                                                                           \n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The concurrent nature of flatMapMerge is obvious:"}, {"type": "a", "text": "flatMapMerge"}, {"type": "pre", "text": "1: First at 136 ms from start\n2: First at 231 ms from start\n3: First at 333 ms from start\n1: Second at 639 ms from start\n2: Second at 732 ms from start\n3: Second at 833 ms from start\n"}, {"type": "code", "text": "1: First at 136 ms from start\n2: First at 231 ms from start\n3: First at 333 ms from start\n1: Second at 639 ms from start\n2: Second at 732 ms from start\n3: Second at 833 ms from start\n"}, {"type": "blockquote", "text": "\nNote that the flatMapMerge calls its block of code ({ requestFlow(it) } in this example) sequentially, but \ncollects the resulting flows concurrently, it is the equivalent of performing a sequential \nmap { requestFlow(it) } first and then calling flattenMerge on the result.\n"}, {"type": "p", "text": "Note that the flatMapMerge calls its block of code ({ requestFlow(it) } in this example) sequentially, but \ncollects the resulting flows concurrently, it is the equivalent of performing a sequential \nmap { requestFlow(it) } first and then calling flattenMerge on the result."}, {"type": "a", "text": "flatMapMerge"}, {"type": "code", "text": "{ requestFlow(it) }"}, {"type": "code", "text": "map { requestFlow(it) }"}, {"type": "a", "text": "flattenMerge"}, {"type": "h4", "text": "flatMapLatest"}, {"type": "p", "text": "In a similar way to the collectLatest operator, that was shown in \n\"Processing the latest value\" section, there is the corresponding \"Latest\" \nflattening mode where a collection of the previous flow is cancelled as soon as new flow is emitted. \nIt is implemented by the flatMapLatest operator."}, {"type": "a", "text": "collectLatest"}, {"type": "a", "text": "\"Processing the latest value\""}, {"type": "a", "text": "flatMapLatest"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val startTime = System.currentTimeMillis() // remember the start time \n    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n        .flatMapLatest { requestFlow(it) }                                                                           \n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val startTime = System.currentTimeMillis() // remember the start time \n    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n        .flatMapLatest { requestFlow(it) }                                                                           \n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val startTime = System.currentTimeMillis() // remember the start time \n    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n        .flatMapLatest { requestFlow(it) }                                                                           \n        .collect { value -> // collect and print \n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output here in this example is a good demonstration of how flatMapLatest works:"}, {"type": "a", "text": "flatMapLatest"}, {"type": "pre", "text": "1: First at 142 ms from start\n2: First at 322 ms from start\n3: First at 425 ms from start\n3: Second at 931 ms from start\n"}, {"type": "code", "text": "1: First at 142 ms from start\n2: First at 322 ms from start\n3: First at 425 ms from start\n3: Second at 931 ms from start\n"}, {"type": "blockquote", "text": "\nNote that flatMapLatest cancels all the code in its block ({ requestFlow(it) } in this example) on a new value. \nIt makes no difference in this particular example, because the call to requestFlow itself is fast, not-suspending,\nand cannot be cancelled. However, it would show up if we were to use suspending functions like delay in there.\n"}, {"type": "p", "text": "Note that flatMapLatest cancels all the code in its block ({ requestFlow(it) } in this example) on a new value. \nIt makes no difference in this particular example, because the call to requestFlow itself is fast, not-suspending,\nand cannot be cancelled. However, it would show up if we were to use suspending functions like delay in there."}, {"type": "a", "text": "flatMapLatest"}, {"type": "code", "text": "{ requestFlow(it) }"}, {"type": "code", "text": "requestFlow"}, {"type": "code", "text": "delay"}, {"type": "h3", "text": "Flow exceptions"}, {"type": "p", "text": "Flow collection can complete with an exception when an emitter or code inside the operators throw an exception. \nThere are several ways to handle these exceptions."}, {"type": "h4", "text": "Collector try and catch"}, {"type": "p", "text": "A collector can use Kotlin's try/catch block to handle exceptions:"}, {"type": "a", "text": "try/catch"}, {"type": "code", "text": "try/catch"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    try {\n        foo().collect { value ->         \n            println(value)\n            check(value <= 1) { \"Collected $value\" }\n        }\n    } catch (e: Throwable) {\n        println(\"Caught $e\")\n    } \n}            \n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    try {\n        foo().collect { value ->         \n            println(value)\n            check(value <= 1) { \"Collected $value\" }\n        }\n    } catch (e: Throwable) {\n        println(\"Caught $e\")\n    } \n}            \n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    try {\n        foo().collect { value ->         \n            println(value)\n            check(value <= 1) { \"Collected $value\" }\n        }\n    } catch (e: Throwable) {\n        println(\"Caught $e\")\n    } \n}            \n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "This code successfully catches an exception in collect terminal operator and, \nas we see, no more values are emitted after that:"}, {"type": "a", "text": "collect"}, {"type": "pre", "text": "Emitting 1\n1\nEmitting 2\n2\nCaught java.lang.IllegalStateException: Collected 2\n"}, {"type": "code", "text": "Emitting 1\n1\nEmitting 2\n2\nCaught java.lang.IllegalStateException: Collected 2\n"}, {"type": "h4", "text": "Everything is caught"}, {"type": "p", "text": "The previous example actually catches any exception happening in the emitter or in any intermediate or terminal operators.\nFor example, let's change the code so that emitted values are mapped to strings,\nbut the corresponding code produces an exception:"}, {"type": "a", "text": "mapped"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<String> = \n    flow {\n        for (i in 1..3) {\n            println(\"Emitting $i\")\n            emit(i) // emit next value\n        }\n    }\n    .map { value ->\n        check(value <= 1) { \"Crashed on $value\" }                 \n        \"string $value\"\n    }\n\nfun main() = runBlocking<Unit> {\n    try {\n        foo().collect { value -> println(value) }\n    } catch (e: Throwable) {\n        println(\"Caught $e\")\n    } \n}            \n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<String> = \n    flow {\n        for (i in 1..3) {\n            println(\"Emitting $i\")\n            emit(i) // emit next value\n        }\n    }\n    .map { value ->\n        check(value <= 1) { \"Crashed on $value\" }                 \n        \"string $value\"\n    }\n\nfun main() = runBlocking<Unit> {\n    try {\n        foo().collect { value -> println(value) }\n    } catch (e: Throwable) {\n        println(\"Caught $e\")\n    } \n}            \n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<String> = \n    flow {\n        for (i in 1..3) {\n            println(\"Emitting $i\")\n            emit(i) // emit next value\n        }\n    }\n    .map { value ->\n        check(value <= 1) { \"Crashed on $value\" }                 \n        \"string $value\"\n    }\n\nfun main() = runBlocking<Unit> {\n    try {\n        foo().collect { value -> println(value) }\n    } catch (e: Throwable) {\n        println(\"Caught $e\")\n    } \n}            \n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "This exception is still caught and collection is stopped:"}, {"type": "pre", "text": "Emitting 1\nstring 1\nEmitting 2\nCaught java.lang.IllegalStateException: Crashed on 2\n"}, {"type": "code", "text": "Emitting 1\nstring 1\nEmitting 2\nCaught java.lang.IllegalStateException: Crashed on 2\n"}, {"type": "h3", "text": "Exception transparency"}, {"type": "p", "text": "But how can code of the emitter encapsulate its exception handling behavior?"}, {"type": "p", "text": "Flows must be transparent to exceptions and it is a violation of the exception transparency to emit values in the \nflow { ... } builder from inside of a try/catch block. This guarantees that a collector throwing an exception\ncan always catch it using try/catch as in the previous example."}, {"type": "em", "text": "transparent to exceptions"}, {"type": "a", "text": "emit"}, {"type": "code", "text": "flow { ... }"}, {"type": "code", "text": "try/catch"}, {"type": "code", "text": "try/catch"}, {"type": "p", "text": "The emitter can use a catch operator that preserves this exception transparency and allows encapsulation\nof its exception handling. The body of the catch operator can analyze an exception\nand react to it in different ways depending on which exception was caught:"}, {"type": "a", "text": "catch"}, {"type": "code", "text": "catch"}, {"type": "ul", "text": "\nExceptions can be rethrown using throw.\nExceptions can be turned into emission of values using emit from the body of catch.\nExceptions can be ignored, logged, or processed by some other code.\n"}, {"type": "li", "text": "Exceptions can be rethrown using throw."}, {"type": "code", "text": "throw"}, {"type": "li", "text": "Exceptions can be turned into emission of values using emit from the body of catch."}, {"type": "a", "text": "emit"}, {"type": "a", "text": "catch"}, {"type": "li", "text": "Exceptions can be ignored, logged, or processed by some other code."}, {"type": "p", "text": "For example, let us emit the text on catching an exception:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<String> = \n    flow {\n        for (i in 1..3) {\n            println(\"Emitting $i\")\n            emit(i) // emit next value\n        }\n    }\n    .map { value ->\n        check(value <= 1) { \"Crashed on $value\" }                 \n        \"string $value\"\n    }\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    foo()\n        .catch { e -> emit(\"Caught $e\") } // emit on exception\n        .collect { value -> println(value) }\n//sampleEnd\n}            \n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<String> = \n    flow {\n        for (i in 1..3) {\n            println(\"Emitting $i\")\n            emit(i) // emit next value\n        }\n    }\n    .map { value ->\n        check(value <= 1) { \"Crashed on $value\" }                 \n        \"string $value\"\n    }\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    foo()\n        .catch { e -> emit(\"Caught $e\") } // emit on exception\n        .collect { value -> println(value) }\n//sampleEnd\n}            \n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<String> = \n    flow {\n        for (i in 1..3) {\n            println(\"Emitting $i\")\n            emit(i) // emit next value\n        }\n    }\n    .map { value ->\n        check(value <= 1) { \"Crashed on $value\" }                 \n        \"string $value\"\n    }\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    foo()\n        .catch { e -> emit(\"Caught $e\") } // emit on exception\n        .collect { value -> println(value) }\n//sampleEnd\n}            \n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of the example is the same, even though we do not have try/catch around the code anymore."}, {"type": "code", "text": "try/catch"}, {"type": "h4", "text": "Transparent catch"}, {"type": "p", "text": "The catch intermediate operator, honoring exception transparency, catches only upstream exceptions\n(that is an exception from all the operators above catch, but not below it).\nIf the block in collect { ... } (placed below catch) throws an exception then it escapes:"}, {"type": "a", "text": "catch"}, {"type": "code", "text": "catch"}, {"type": "code", "text": "collect { ... }"}, {"type": "code", "text": "catch"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    foo()\n        .catch { e -> println(\"Caught $e\") } // does not catch downstream exceptions\n        .collect { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n}            \n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    foo()\n        .catch { e -> println(\"Caught $e\") } // does not catch downstream exceptions\n        .collect { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n}            \n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    foo()\n        .catch { e -> println(\"Caught $e\") } // does not catch downstream exceptions\n        .collect { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n}            \n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "A \"Caught \u2026\" message is not printed despite there being a catch operator:"}, {"type": "code", "text": "catch"}, {"type": "h4", "text": "Catching declaratively"}, {"type": "p", "text": "We can combine the declarative nature of the catch operator with a desire to handle all the exceptions, by moving the body\nof the collect operator into onEach and putting it before the catch operator. Collection of this flow must\nbe triggered by a call to collect() without parameters:"}, {"type": "a", "text": "catch"}, {"type": "a", "text": "collect"}, {"type": "a", "text": "onEach"}, {"type": "code", "text": "catch"}, {"type": "code", "text": "collect()"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    foo()\n        .onEach { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n        .catch { e -> println(\"Caught $e\") }\n        .collect()\n//sampleEnd\n}            \n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    foo()\n        .onEach { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n        .catch { e -> println(\"Caught $e\") }\n        .collect()\n//sampleEnd\n}            \n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    foo()\n        .onEach { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n        .catch { e -> println(\"Caught $e\") }\n        .collect()\n//sampleEnd\n}            \n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Now we can see that a \"Caught \u2026\" message is printed and so we can catch all the exceptions without explicitly\nusing a try/catch block:"}, {"type": "code", "text": "try/catch"}, {"type": "h3", "text": "Flow completion"}, {"type": "p", "text": "When flow collection completes (normally or exceptionally) it may need to execute an action. \nAs you may have already noticed, it can be done in two ways: imperative or declarative."}, {"type": "h4", "text": "Imperative finally block"}, {"type": "p", "text": "In addition to try/catch, a collector can also use a finally block to execute an action \nupon collect completion."}, {"type": "code", "text": "try"}, {"type": "code", "text": "catch"}, {"type": "code", "text": "finally"}, {"type": "code", "text": "collect"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n    try {\n        foo().collect { value -> println(value) }\n    } finally {\n        println(\"Done\")\n    }\n}            \n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n    try {\n        foo().collect { value -> println(value) }\n    } finally {\n        println(\"Done\")\n    }\n}            \n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n    try {\n        foo().collect { value -> println(value) }\n    } finally {\n        println(\"Done\")\n    }\n}            \n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "This code prints three numbers produced by the foo() flow followed by a \"Done\" string:"}, {"type": "code", "text": "foo()"}, {"type": "pre", "text": "1\n2\n3\nDone\n"}, {"type": "code", "text": "1\n2\n3\nDone\n"}, {"type": "h4", "text": "Declarative handling"}, {"type": "p", "text": "For the declarative approach, flow has onCompletion intermediate operator that is invoked\nwhen the flow has completely collected."}, {"type": "a", "text": "onCompletion"}, {"type": "p", "text": "The previous example can be rewritten using an onCompletion operator and produces the same output:"}, {"type": "a", "text": "onCompletion"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    foo()\n        .onCompletion { println(\"Done\") }\n        .collect { value -> println(value) }\n//sampleEnd\n}            \n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    foo()\n        .onCompletion { println(\"Done\") }\n        .collect { value -> println(value) }\n//sampleEnd\n}            \n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    foo()\n        .onCompletion { println(\"Done\") }\n        .collect { value -> println(value) }\n//sampleEnd\n}            \n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The key advantage of onCompletion is a nullable Throwable parameter of the lambda that can be used\nto determine whether the flow collection was completed normally or exceptionally. In the following\nexample the foo() flow throws an exception after emitting the number 1:"}, {"type": "a", "text": "onCompletion"}, {"type": "code", "text": "Throwable"}, {"type": "code", "text": "foo()"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = flow {\n    emit(1)\n    throw RuntimeException()\n}\n\nfun main() = runBlocking<Unit> {\n    foo()\n        .onCompletion { cause -> if (cause != null) println(\"Flow completed exceptionally\") }\n        .catch { cause -> println(\"Caught exception\") }\n        .collect { value -> println(value) }\n}            \n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = flow {\n    emit(1)\n    throw RuntimeException()\n}\n\nfun main() = runBlocking<Unit> {\n    foo()\n        .onCompletion { cause -> if (cause != null) println(\"Flow completed exceptionally\") }\n        .catch { cause -> println(\"Caught exception\") }\n        .collect { value -> println(value) }\n}            \n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = flow {\n    emit(1)\n    throw RuntimeException()\n}\n\nfun main() = runBlocking<Unit> {\n    foo()\n        .onCompletion { cause -> if (cause != null) println(\"Flow completed exceptionally\") }\n        .catch { cause -> println(\"Caught exception\") }\n        .collect { value -> println(value) }\n}            \n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "As you may expect, it prints:"}, {"type": "pre", "text": "1\nFlow completed exceptionally\nCaught exception\n"}, {"type": "code", "text": "1\nFlow completed exceptionally\nCaught exception\n"}, {"type": "p", "text": "The onCompletion operator, unlike catch, does not handle the exception. As we can see from the above\nexample code, the exception still flows downstream. It will be delivered to further onCompletion operators\nand can be handled with a catch operator."}, {"type": "a", "text": "onCompletion"}, {"type": "a", "text": "catch"}, {"type": "code", "text": "onCompletion"}, {"type": "code", "text": "catch"}, {"type": "h4", "text": "Successful completion"}, {"type": "p", "text": "Another difference with catch operator is that onCompletion sees all exceptions and receives\na null exception only on successful completion of the upstream flow (without cancellation or failure)."}, {"type": "a", "text": "catch"}, {"type": "a", "text": "onCompletion"}, {"type": "code", "text": "null"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n    foo()\n        .onCompletion { cause -> println(\"Flow completed with $cause\") }\n        .collect { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n}\n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n    foo()\n        .onCompletion { cause -> println(\"Flow completed with $cause\") }\n        .collect { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n}\n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun foo(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n    foo()\n        .onCompletion { cause -> println(\"Flow completed with $cause\") }\n        .collect { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n}\n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "We can see the completion cause is not null, because the flow was aborted due to downstream exception:"}, {"type": "pre", "text": "1\nFlow completed with java.lang.IllegalStateException: Collected 2\nException in thread \"main\" java.lang.IllegalStateException: Collected 2\n"}, {"type": "code", "text": "1\nFlow completed with java.lang.IllegalStateException: Collected 2\nException in thread \"main\" java.lang.IllegalStateException: Collected 2\n"}, {"type": "h3", "text": "Imperative versus declarative"}, {"type": "p", "text": "Now we know how to collect flow, and handle its completion and exceptions in both imperative and declarative ways.\nThe natural question here is, which approach is preferred and why?\nAs a library, we do not advocate for any particular approach and believe that both options\nare valid and should be selected according to your own preferences and code style."}, {"type": "h3", "text": "Launching flow"}, {"type": "p", "text": "It is easy to use flows to represent asynchronous events that are coming from some source.\nIn this case, we need an analogue of the addEventListener function that registers a piece of code with a reaction\nfor incoming events and continues further work. The onEach operator can serve this role. \nHowever, onEach is an intermediate operator. We also need a terminal operator to collect the flow. \nOtherwise, just calling onEach has no effect."}, {"type": "code", "text": "addEventListener"}, {"type": "a", "text": "onEach"}, {"type": "code", "text": "onEach"}, {"type": "code", "text": "onEach"}, {"type": "p", "text": "If we use the collect terminal operator after onEach, then the code after it will wait until the flow is collected:"}, {"type": "a", "text": "collect"}, {"type": "code", "text": "onEach"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\n// Imitate a flow of events\nfun events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }\n\nfun main() = runBlocking<Unit> {\n    events()\n        .onEach { event -> println(\"Event: $event\") }\n        .collect() // <--- Collecting the flow waits\n    println(\"Done\")\n}            \n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\n// Imitate a flow of events\nfun events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }\n\nfun main() = runBlocking<Unit> {\n    events()\n        .onEach { event -> println(\"Event: $event\") }\n        .collect() // <--- Collecting the flow waits\n    println(\"Done\")\n}            \n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\n// Imitate a flow of events\nfun events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }\n\nfun main() = runBlocking<Unit> {\n    events()\n        .onEach { event -> println(\"Event: $event\") }\n        .collect() // <--- Collecting the flow waits\n    println(\"Done\")\n}            \n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "As you can see, it prints:"}, {"type": "pre", "text": "Event: 1\nEvent: 2\nEvent: 3\nDone\n"}, {"type": "code", "text": "Event: 1\nEvent: 2\nEvent: 3\nDone\n"}, {"type": "p", "text": "The launchIn terminal operator comes in handy here. By replacing collect with launchIn we can\nlaunch a collection of the flow in a separate coroutine, so that execution of further code \nimmediately continues:"}, {"type": "a", "text": "launchIn"}, {"type": "code", "text": "collect"}, {"type": "code", "text": "launchIn"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n// Imitate a flow of events\nfun events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }\n\n//sampleStart\nfun main() = runBlocking<Unit> {\n    events()\n        .onEach { event -> println(\"Event: $event\") }\n        .launchIn(this) // <--- Launching the flow in a separate coroutine\n    println(\"Done\")\n}            \n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n// Imitate a flow of events\nfun events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }\n\n//sampleStart\nfun main() = runBlocking<Unit> {\n    events()\n        .onEach { event -> println(\"Event: $event\") }\n        .launchIn(this) // <--- Launching the flow in a separate coroutine\n    println(\"Done\")\n}            \n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n// Imitate a flow of events\nfun events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }\n\n//sampleStart\nfun main() = runBlocking<Unit> {\n    events()\n        .onEach { event -> println(\"Event: $event\") }\n        .launchIn(this) // <--- Launching the flow in a separate coroutine\n    println(\"Done\")\n}            \n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get the full code from here.\n"}, {"type": "p", "text": "You can get the full code from here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It prints:"}, {"type": "pre", "text": "Done\nEvent: 1\nEvent: 2\nEvent: 3\n"}, {"type": "code", "text": "Done\nEvent: 1\nEvent: 2\nEvent: 3\n"}, {"type": "p", "text": "The required parameter to launchIn must specify a CoroutineScope in which the coroutine to collect the flow is \nlaunched. In the above example this scope comes from the runBlocking\ncoroutine builder, so while the flow is running, this runBlocking scope waits for completion of its child coroutine\nand keeps the main function from returning and terminating this example."}, {"type": "code", "text": "launchIn"}, {"type": "a", "text": "CoroutineScope"}, {"type": "a", "text": "runBlocking"}, {"type": "a", "text": "runBlocking"}, {"type": "p", "text": "In actual applications a scope will come from an entity with a limited \nlifetime. As soon as the lifetime of this entity is terminated the corresponding scope is cancelled, cancelling\nthe collection of the corresponding flow. This way the pair of onEach { ... }.launchIn(scope) works\nlike the addEventListener. However, there is no need for the corresponding removeEventListener function, \nas cancellation and structured concurrency serve this purpose."}, {"type": "code", "text": "onEach { ... }.launchIn(scope)"}, {"type": "code", "text": "addEventListener"}, {"type": "code", "text": "removeEventListener"}, {"type": "p", "text": "Note that launchIn also returns a Job, which can be used to cancel the corresponding flow collection\ncoroutine only without cancelling the whole scope or to join it."}, {"type": "a", "text": "launchIn"}, {"type": "a", "text": "Job"}, {"type": "a", "text": "cancel"}, {"type": "a", "text": "join"}, {"type": "h3", "text": "Flow and Reactive Streams"}, {"type": "p", "text": "For those who are familiar with Reactive Streams or reactive frameworks such as RxJava and project Reactor, \ndesign of the Flow may look very familiar."}, {"type": "a", "text": "Reactive Streams"}, {"type": "p", "text": "Indeed, its design was inspired by Reactive Streams and its various implementations. But Flow main goal is to have as simple design as possible, \nbe Kotlin and suspension friendly and respect structured concurrency. Achieving this goal would be impossible without reactive pioneers and their tremendous work. You can read the complete story in Reactive Streams and Kotlin Flows article."}, {"type": "a", "text": "Reactive Streams and Kotlin Flows"}, {"type": "p", "text": "While being different, conceptually, Flow is a reactive stream and it is possible to convert it to the reactive (spec and TCK compliant) Publisher and vice versa.\nSuch converters are provided by kotlinx.coroutines out-of-the-box and can be found in corresponding reactive modules (kotlinx-coroutines-reactive for Reactive Streams, kotlinx-coroutines-reactor for Project Reactor and kotlinx-coroutines-rx2/kotlinx-coroutines-rx3 for RxJava2/RxJava3).\nIntegration modules include conversions from and to Flow, integration with Reactor's Context and suspension-friendly ways to work with various reactive entities."}, {"type": "em", "text": "is"}, {"type": "code", "text": "kotlinx.coroutines"}, {"type": "code", "text": "kotlinx-coroutines-reactive"}, {"type": "code", "text": "kotlinx-coroutines-reactor"}, {"type": "code", "text": "kotlinx-coroutines-rx2"}, {"type": "code", "text": "kotlinx-coroutines-rx3"}, {"type": "code", "text": "Flow"}, {"type": "code", "text": "Context"}]