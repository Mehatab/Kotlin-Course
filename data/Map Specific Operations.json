[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Map Specific Operations"}, {"type": "p", "text": "In maps, types of both keys and values are user-defined.\nKey-based access to map entries enables various map-specific processing capabilities from getting a value by key to separate filtering of keys and values.\nOn this page, we provide descriptions of the map processing functions from the standard library."}, {"type": "a", "text": "maps"}, {"type": "h2", "text": "Retrieving keys and values"}, {"type": "p", "text": "For retrieving a value from a map, you must provide its key as an argument of the get() function.\nThe shorthand [key] syntax is also supported. If the given key is not found, it returns null.\nThere is also the function getValue() which has slightly different behavior: it throws an exception if the key is not found in the map.\nAdditionally, you have two more options to handle the key absence:"}, {"type": "a", "text": "get()"}, {"type": "code", "text": "get()"}, {"type": "code", "text": "[key]"}, {"type": "code", "text": "null"}, {"type": "a", "text": "getValue()"}, {"type": "code", "text": "getValue()"}, {"type": "ul", "text": "\ngetOrElse() works the same way as for lists: the values for non-existent keys are returned from the given lambda function.\ngetOrDefault() returns the specified default value if the key is not found.\n"}, {"type": "li", "text": "getOrElse() works the same way as for lists: the values for non-existent keys are returned from the given lambda function."}, {"type": "a", "text": "getOrElse()"}, {"type": "code", "text": "getOrElse()"}, {"type": "li", "text": "getOrDefault() returns the specified default value if the key is not found."}, {"type": "a", "text": "getOrDefault()"}, {"type": "code", "text": "getOrDefault()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap.get(\"one\"))\n    println(numbersMap[\"one\"])\n    println(numbersMap.getOrDefault(\"four\", 10))\n    println(numbersMap[\"five\"])               // null\n    //numbersMap.getValue(\"six\")      // exception!\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap.get(\"one\"))\n    println(numbersMap[\"one\"])\n    println(numbersMap.getOrDefault(\"four\", 10))\n    println(numbersMap[\"five\"])               // null\n    //numbersMap.getValue(\"six\")      // exception!\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap.get(\"one\"))\n    println(numbersMap[\"one\"])\n    println(numbersMap.getOrDefault(\"four\", 10))\n    println(numbersMap[\"five\"])               // null\n    //numbersMap.getValue(\"six\")      // exception!\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "To perform operations on all keys or all values of a map, you can retrieve them from the properties keys and values accordingly. keys is a set of all map keys and values is a collection of all map values."}, {"type": "code", "text": "keys"}, {"type": "code", "text": "values"}, {"type": "code", "text": "keys"}, {"type": "code", "text": "values"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap.keys)\n    println(numbersMap.values)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap.keys)\n    println(numbersMap.values)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap.keys)\n    println(numbersMap.values)\n//sampleEnd\n}\n\n"}, {"type": "h2", "text": "Filtering"}, {"type": "p", "text": "You can filter maps with the filter() function as well as other collections.\nWhen calling filter() on a map, pass to it a predicate with a Pair as an argument.\nThis enables you to use both the key and the value in the filtering predicate."}, {"type": "a", "text": "filter"}, {"type": "a", "text": "filter()"}, {"type": "code", "text": "filter()"}, {"type": "code", "text": "filter()"}, {"type": "code", "text": "Pair"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}\n    println(filteredMap)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}\n    println(filteredMap)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}\n    println(filteredMap)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "There are also two specific ways for filtering maps: by keys and by values.\nFor each way, there is a function: filterKeys() and filterValues().\nBoth return a new map of entries which match the given predicate.\nThe predicate for filterKeys() checks only the element keys, the one for filterValues() checks only values."}, {"type": "a", "text": "filterKeys()"}, {"type": "code", "text": "filterKeys()"}, {"type": "a", "text": "filterValues()"}, {"type": "code", "text": "filterValues()"}, {"type": "code", "text": "filterKeys()"}, {"type": "code", "text": "filterValues()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredKeysMap = numbersMap.filterKeys { it.endsWith(\"1\") }\n    val filteredValuesMap = numbersMap.filterValues { it < 10 }\n\n    println(filteredKeysMap)\n    println(filteredValuesMap)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredKeysMap = numbersMap.filterKeys { it.endsWith(\"1\") }\n    val filteredValuesMap = numbersMap.filterValues { it < 10 }\n\n    println(filteredKeysMap)\n    println(filteredValuesMap)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredKeysMap = numbersMap.filterKeys { it.endsWith(\"1\") }\n    val filteredValuesMap = numbersMap.filterValues { it < 10 }\n\n    println(filteredKeysMap)\n    println(filteredValuesMap)\n//sampleEnd\n}\n\n"}, {"type": "h2", "text": "plus and minus operators"}, {"type": "code", "text": "plus"}, {"type": "code", "text": "minus"}, {"type": "p", "text": "Due to the key access to elements, plus (+) and minus (-) operators work for maps differently than for other collections. \nplus returns a Map that contains elements of its both operands: a Map on the left and a Pair or another Map on the right.\nWhen the right-hand side operand contains entries with keys present in the left-hand side Map, the result map contains the entries from the right side."}, {"type": "a", "text": "plus"}, {"type": "code", "text": "plus"}, {"type": "code", "text": "+"}, {"type": "a", "text": "minus"}, {"type": "code", "text": "minus"}, {"type": "code", "text": "-"}, {"type": "code", "text": "plus"}, {"type": "code", "text": "Map"}, {"type": "code", "text": "Map"}, {"type": "code", "text": "Pair"}, {"type": "code", "text": "Map"}, {"type": "code", "text": "Map"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap + Pair(\"four\", 4))\n    println(numbersMap + Pair(\"one\", 10))\n    println(numbersMap + mapOf(\"five\" to 5, \"one\" to 11))\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap + Pair(\"four\", 4))\n    println(numbersMap + Pair(\"one\", 10))\n    println(numbersMap + mapOf(\"five\" to 5, \"one\" to 11))\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap + Pair(\"four\", 4))\n    println(numbersMap + Pair(\"one\", 10))\n    println(numbersMap + mapOf(\"five\" to 5, \"one\" to 11))\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "minus creates a Map from entries of a Map on the left except those with keys from the right-hand side operand.\nSo, the right-hand side operand can be either a single key or a collection of keys: list, set, and so on."}, {"type": "code", "text": "minus"}, {"type": "code", "text": "Map"}, {"type": "code", "text": "Map"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap - \"one\")\n    println(numbersMap - listOf(\"two\", \"four\"))\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap - \"one\")\n    println(numbersMap - listOf(\"two\", \"four\"))\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap - \"one\")\n    println(numbersMap - listOf(\"two\", \"four\"))\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "For details on using plusAssign (+=) and minusAssign (-=) operators on mutable maps, see Map write operations below."}, {"type": "a", "text": "plusAssign"}, {"type": "code", "text": "plusAssign"}, {"type": "code", "text": "+="}, {"type": "a", "text": "minusAssign"}, {"type": "code", "text": "minusAssign"}, {"type": "code", "text": "-="}, {"type": "a", "text": "Map write operations"}, {"type": "h2", "text": "Map write operations"}, {"type": "p", "text": "Mutable maps offer map-specific write operations.\nThese operations let you change the map content using the key-based access to the values."}, {"type": "a", "text": "Mutable"}, {"type": "p", "text": "There are certain rules that define write operations on maps:"}, {"type": "ul", "text": "\nValues can be updated. In turn, keys never change: once you add an entry, its key is constant.\nFor each key, there is always a single value associated with it. You can add and remove whole entries.\n"}, {"type": "li", "text": "Values can be updated. In turn, keys never change: once you add an entry, its key is constant."}, {"type": "li", "text": "For each key, there is always a single value associated with it. You can add and remove whole entries."}, {"type": "p", "text": "Below are descriptions of the standard library functions for write operations available on mutable maps."}, {"type": "h3", "text": "Adding and updating entries"}, {"type": "p", "text": "To  add a new key-value pair to a mutable map, use put().\nWhen a new entry is put into a LinkedHashMap (the default map implementation), it is added so that it comes last when iterating the map.\nIn sorted maps, the positions of new elements are defined by the order of their keys."}, {"type": "a", "text": "put()"}, {"type": "code", "text": "put()"}, {"type": "code", "text": "LinkedHashMap"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap.put(\"three\", 3)\n    println(numbersMap)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap.put(\"three\", 3)\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap.put(\"three\", 3)\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "To add multiple entries at a time, use putAll(). Its argument can be a Map or a group of Pairs: Iterable, Sequence, or Array."}, {"type": "a", "text": "putAll()"}, {"type": "code", "text": "putAll()"}, {"type": "code", "text": "Map"}, {"type": "code", "text": "Pair"}, {"type": "code", "text": "Iterable"}, {"type": "code", "text": "Sequence"}, {"type": "code", "text": "Array"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap.putAll(setOf(\"four\" to 4, \"five\" to 5))\n    println(numbersMap)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap.putAll(setOf(\"four\" to 4, \"five\" to 5))\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap.putAll(setOf(\"four\" to 4, \"five\" to 5))\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "Both put() and putAll() overwrite the values if the given keys already exist in the map. Thus, you can use them to update values of map entries."}, {"type": "code", "text": "put()"}, {"type": "code", "text": "putAll()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    val previousValue = numbersMap.put(\"one\", 11)\n    println(\"value associated with 'one', before: $previousValue, after: ${numbersMap[\"one\"]}\")\n    println(numbersMap)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    val previousValue = numbersMap.put(\"one\", 11)\n    println(\"value associated with 'one', before: $previousValue, after: ${numbersMap[\"one\"]}\")\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    val previousValue = numbersMap.put(\"one\", 11)\n    println(\"value associated with 'one', before: $previousValue, after: ${numbersMap[\"one\"]}\")\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "You can also add new entries to maps using the shorthand operator form. There are two ways:"}, {"type": "ul", "text": "\nplusAssign (+=) operator.\nthe [] operator alias for put().\n"}, {"type": "li", "text": "plusAssign (+=) operator."}, {"type": "a", "text": "plusAssign"}, {"type": "code", "text": "plusAssign"}, {"type": "code", "text": "+="}, {"type": "li", "text": "the [] operator alias for put()."}, {"type": "code", "text": "[]"}, {"type": "code", "text": "put()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap[\"three\"] = 3     // calls numbersMap.put(\"three\", 3)\n    numbersMap += mapOf(\"four\" to 4, \"five\" to 5)\n    println(numbersMap)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap[\"three\"] = 3     // calls numbersMap.put(\"three\", 3)\n    numbersMap += mapOf(\"four\" to 4, \"five\" to 5)\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap[\"three\"] = 3     // calls numbersMap.put(\"three\", 3)\n    numbersMap += mapOf(\"four\" to 4, \"five\" to 5)\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "When called with the key present in the map, operators overwrite the values of the corresponding entries."}, {"type": "h3", "text": "Removing entries"}, {"type": "p", "text": "To remove an entry from a mutable map, use the remove() function.\nWhen calling remove(), you can pass either a key or a whole key-value-pair.\nIf you specify both the key and value, the element with this key will be removed only if its value matches the second argument."}, {"type": "a", "text": "remove()"}, {"type": "code", "text": "remove()"}, {"type": "code", "text": "remove()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap.remove(\"one\")\n    println(numbersMap)\n    numbersMap.remove(\"three\", 4)            //doesn't remove anything\n    println(numbersMap)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap.remove(\"one\")\n    println(numbersMap)\n    numbersMap.remove(\"three\", 4)            //doesn't remove anything\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap.remove(\"one\")\n    println(numbersMap)\n    numbersMap.remove(\"three\", 4)            //doesn't remove anything\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "You can also remove entries from a mutable map by their keys or values.\nTo do this, call remove() on the map's keys or values providing the key or the value of an entry.\nWhen called on values, remove() removes only the first entry with the given value."}, {"type": "code", "text": "remove()"}, {"type": "code", "text": "remove()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"threeAgain\" to 3)\n    numbersMap.keys.remove(\"one\")\n    println(numbersMap)\n    numbersMap.values.remove(3)\n    println(numbersMap)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"threeAgain\" to 3)\n    numbersMap.keys.remove(\"one\")\n    println(numbersMap)\n    numbersMap.values.remove(3)\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"threeAgain\" to 3)\n    numbersMap.keys.remove(\"one\")\n    println(numbersMap)\n    numbersMap.values.remove(3)\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "p", "text": "The minusAssign (-=) operator is also available for mutable maps."}, {"type": "a", "text": "minusAssign"}, {"type": "code", "text": "minusAssign"}, {"type": "code", "text": "-="}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap -= \"two\"\n    println(numbersMap)\n    numbersMap -= \"five\"             //doesn't remove anything\n    println(numbersMap)\n//sampleEnd\n}\n\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap -= \"two\"\n    println(numbersMap)\n    numbersMap -= \"five\"             //doesn't remove anything\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap -= \"two\"\n    println(numbersMap)\n    numbersMap -= \"five\"             //doesn't remove anything\n    println(numbersMap)\n//sampleEnd\n}\n\n"}]