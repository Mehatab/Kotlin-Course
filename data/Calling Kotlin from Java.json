[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Calling Kotlin from Java"}, {"type": "p", "text": "Kotlin code can be easily called from Java.\nFor example, instances of a Kotlin class can be seamlessly created and operated in Java methods.\nHowever, there are certain differences between Java and Kotlin that require attention when\nintegrating Kotlin code into Java. \nOn this page, we'll describe the ways to tailor the interop of your Kotlin code with its Java clients."}, {"type": "h2", "text": "Properties"}, {"type": "p", "text": "A Kotlin property is compiled to the following Java elements:"}, {"type": "ul", "text": "\nA getter method, with the name calculated by prepending the get prefix;\nA setter method, with the name calculated by prepending the set prefix (only for var properties);\nA private field, with the same name as the property name (only for properties with backing fields).\n"}, {"type": "li", "text": "A getter method, with the name calculated by prepending the get prefix;"}, {"type": "code", "text": "get"}, {"type": "li", "text": "A setter method, with the name calculated by prepending the set prefix (only for var properties);"}, {"type": "code", "text": "set"}, {"type": "code", "text": "var"}, {"type": "li", "text": "A private field, with the same name as the property name (only for properties with backing fields)."}, {"type": "p", "text": "For example, var firstName: String gets compiled to the following Java declarations:"}, {"type": "code", "text": "var firstName: String"}, {"type": "div", "text": "\nprivate String firstName;\n\npublic String getFirstName() {\n    return firstName;\n}\n\npublic void setFirstName(String firstName) {\n    this.firstName = firstName;\n}\n\n"}, {"type": "pre", "text": "private String firstName;\n\npublic String getFirstName() {\n    return firstName;\n}\n\npublic void setFirstName(String firstName) {\n    this.firstName = firstName;\n}\n"}, {"type": "code", "text": "private String firstName;\n\npublic String getFirstName() {\n    return firstName;\n}\n\npublic void setFirstName(String firstName) {\n    this.firstName = firstName;\n}\n"}, {"type": "p", "text": "If the name of the property starts with is, a different name mapping rule is used: the name of the getter will be\nthe same as the property name, and the name of the setter will be obtained by replacing is with set.\nFor example, for a property isOpen, the getter will be called isOpen() and the setter will be called setOpen().\nThis rule applies for properties of any type, not just Boolean."}, {"type": "code", "text": "is"}, {"type": "code", "text": "is"}, {"type": "code", "text": "set"}, {"type": "code", "text": "isOpen"}, {"type": "code", "text": "isOpen()"}, {"type": "code", "text": "setOpen()"}, {"type": "code", "text": "Boolean"}, {"type": "h2", "text": "Package-level functions"}, {"type": "p", "text": "All the functions and properties declared in a file app.kt inside a package org.example, including extension functions,\nare compiled into static methods of a Java class named org.example.AppKt."}, {"type": "code", "text": "app.kt"}, {"type": "code", "text": "org.example"}, {"type": "code", "text": "org.example.AppKt"}, {"type": "div", "text": "\n// app.kt\npackage org.example\n\nclass Util\n\nfun getTime() { /*...*/ }\n\n\n"}, {"type": "pre", "text": "// app.kt\npackage org.example\n\nclass Util\n\nfun getTime() { /*...*/ }\n\n"}, {"type": "code", "text": "// app.kt\npackage org.example\n\nclass Util\n\nfun getTime() { /*...*/ }\n\n"}, {"type": "div", "text": "\n// Java\nnew org.example.Util();\norg.example.AppKt.getTime();\n\n"}, {"type": "pre", "text": "// Java\nnew org.example.Util();\norg.example.AppKt.getTime();\n"}, {"type": "code", "text": "// Java\nnew org.example.Util();\norg.example.AppKt.getTime();\n"}, {"type": "p", "text": "The name of the generated Java class can be changed using the @JvmName annotation:"}, {"type": "code", "text": "@JvmName"}, {"type": "div", "text": "\n@file:JvmName(\"DemoUtils\")\n\npackage org.example\n\nclass Util\n\nfun getTime() { /*...*/ }\n\n\n"}, {"type": "pre", "text": "@file:JvmName(\"DemoUtils\")\n\npackage org.example\n\nclass Util\n\nfun getTime() { /*...*/ }\n\n"}, {"type": "code", "text": "@file:JvmName(\"DemoUtils\")\n\npackage org.example\n\nclass Util\n\nfun getTime() { /*...*/ }\n\n"}, {"type": "div", "text": "\n// Java\nnew org.example.Util();\norg.example.DemoUtils.getTime();\n\n"}, {"type": "pre", "text": "// Java\nnew org.example.Util();\norg.example.DemoUtils.getTime();\n"}, {"type": "code", "text": "// Java\nnew org.example.Util();\norg.example.DemoUtils.getTime();\n"}, {"type": "p", "text": "Having multiple files which have the same generated Java class name (the same package and the same name or the same\n@JvmName annotation) is normally an error.\nHowever, the compiler has the ability to generate a single Java facade class which has the specified name and contains all the declarations from all the files which have that name.\nTo enable the generation of such a facade, use the @JvmMultifileClass annotation in all of the files."}, {"type": "a", "text": "@JvmName"}, {"type": "code", "text": "@JvmName"}, {"type": "a", "text": "@JvmMultifileClass"}, {"type": "code", "text": "@JvmMultifileClass"}, {"type": "div", "text": "\n// oldutils.kt\n@file:JvmName(\"Utils\")\n@file:JvmMultifileClass\n\npackage org.example\n\nfun getTime() { /*...*/ }\n\n"}, {"type": "pre", "text": "// oldutils.kt\n@file:JvmName(\"Utils\")\n@file:JvmMultifileClass\n\npackage org.example\n\nfun getTime() { /*...*/ }\n"}, {"type": "code", "text": "// oldutils.kt\n@file:JvmName(\"Utils\")\n@file:JvmMultifileClass\n\npackage org.example\n\nfun getTime() { /*...*/ }\n"}, {"type": "div", "text": "\n// newutils.kt\n@file:JvmName(\"Utils\")\n@file:JvmMultifileClass\n\npackage org.example\n\nfun getDate() { /*...*/ }\n\n"}, {"type": "pre", "text": "// newutils.kt\n@file:JvmName(\"Utils\")\n@file:JvmMultifileClass\n\npackage org.example\n\nfun getDate() { /*...*/ }\n"}, {"type": "code", "text": "// newutils.kt\n@file:JvmName(\"Utils\")\n@file:JvmMultifileClass\n\npackage org.example\n\nfun getDate() { /*...*/ }\n"}, {"type": "div", "text": "\n// Java\norg.example.Utils.getTime();\norg.example.Utils.getDate();\n\n"}, {"type": "pre", "text": "// Java\norg.example.Utils.getTime();\norg.example.Utils.getDate();\n"}, {"type": "code", "text": "// Java\norg.example.Utils.getTime();\norg.example.Utils.getDate();\n"}, {"type": "h2", "text": "Instance fields"}, {"type": "p", "text": "If you need to expose a Kotlin property as a field in Java, annotate it with the @JvmField annotation.\nThe field will have the same visibility as the underlying property. You can annotate a property with @JvmField\nif it has a backing field, is not private, does not have open, override or const modifiers, and is not a delegated property."}, {"type": "a", "text": "@JvmField"}, {"type": "code", "text": "@JvmField"}, {"type": "code", "text": "@JvmField"}, {"type": "code", "text": "open"}, {"type": "code", "text": "override"}, {"type": "code", "text": "const"}, {"type": "div", "text": "\nclass User(id: String) {\n    @JvmField val ID = id\n}\n\n"}, {"type": "pre", "text": "class User(id: String) {\n    @JvmField val ID = id\n}\n"}, {"type": "code", "text": "class User(id: String) {\n    @JvmField val ID = id\n}\n"}, {"type": "div", "text": "\n// Java\nclass JavaClient {\n    public String getID(User user) {\n        return user.ID;\n    }\n}\n\n"}, {"type": "pre", "text": "// Java\nclass JavaClient {\n    public String getID(User user) {\n        return user.ID;\n    }\n}\n"}, {"type": "code", "text": "// Java\nclass JavaClient {\n    public String getID(User user) {\n        return user.ID;\n    }\n}\n"}, {"type": "p", "text": "Late-Initialized properties are also exposed as fields. \nThe visibility of the field will be the same as the visibility of lateinit property setter."}, {"type": "a", "text": "Late-Initialized"}, {"type": "code", "text": "lateinit"}, {"type": "h2", "text": "Static fields"}, {"type": "p", "text": "Kotlin properties declared in a named object or a companion object will have static backing fields\neither in that named object or in the class containing the companion object."}, {"type": "p", "text": "Usually these fields are private but they can be exposed in one of the following ways:"}, {"type": "ul", "text": "\n@JvmField annotation;\nlateinit modifier;\nconst modifier.\n"}, {"type": "li", "text": "@JvmField annotation;"}, {"type": "a", "text": "@JvmField"}, {"type": "code", "text": "@JvmField"}, {"type": "li", "text": "lateinit modifier;"}, {"type": "code", "text": "lateinit"}, {"type": "li", "text": "const modifier."}, {"type": "code", "text": "const"}, {"type": "p", "text": "Annotating such a property with @JvmField makes it a static field with the same visibility as the property itself."}, {"type": "code", "text": "@JvmField"}, {"type": "div", "text": "\nclass Key(val value: Int) {\n    companion object {\n        @JvmField\n        val COMPARATOR: Comparator<Key> = compareBy<Key> { it.value }\n    }\n}\n\n"}, {"type": "pre", "text": "class Key(val value: Int) {\n    companion object {\n        @JvmField\n        val COMPARATOR: Comparator<Key> = compareBy<Key> { it.value }\n    }\n}\n"}, {"type": "code", "text": "class Key(val value: Int) {\n    companion object {\n        @JvmField\n        val COMPARATOR: Comparator<Key> = compareBy<Key> { it.value }\n    }\n}\n"}, {"type": "div", "text": "\n// Java\nKey.COMPARATOR.compare(key1, key2);\n// public static final field in Key class\n\n"}, {"type": "pre", "text": "// Java\nKey.COMPARATOR.compare(key1, key2);\n// public static final field in Key class\n"}, {"type": "code", "text": "// Java\nKey.COMPARATOR.compare(key1, key2);\n// public static final field in Key class\n"}, {"type": "p", "text": "A late-initialized property in an object or a companion object\nhas a static backing field with the same visibility as the property setter."}, {"type": "a", "text": "late-initialized"}, {"type": "div", "text": "\nobject Singleton {\n    lateinit var provider: Provider\n}\n\n"}, {"type": "pre", "text": "object Singleton {\n    lateinit var provider: Provider\n}\n"}, {"type": "code", "text": "object Singleton {\n    lateinit var provider: Provider\n}\n"}, {"type": "div", "text": "\n// Java\nSingleton.provider = new Provider();\n// public static non-final field in Singleton class\n\n"}, {"type": "pre", "text": "// Java\nSingleton.provider = new Provider();\n// public static non-final field in Singleton class\n"}, {"type": "code", "text": "// Java\nSingleton.provider = new Provider();\n// public static non-final field in Singleton class\n"}, {"type": "p", "text": "Properties declared as const (in classes as well as at the top level) are turned into static fields in Java:"}, {"type": "code", "text": "const"}, {"type": "div", "text": "\n// file example.kt\n\nobject Obj {\n    const val CONST = 1\n}\n\nclass C {\n    companion object {\n        const val VERSION = 9\n    }\n}\n\nconst val MAX = 239\n\n"}, {"type": "pre", "text": "// file example.kt\n\nobject Obj {\n    const val CONST = 1\n}\n\nclass C {\n    companion object {\n        const val VERSION = 9\n    }\n}\n\nconst val MAX = 239\n"}, {"type": "code", "text": "// file example.kt\n\nobject Obj {\n    const val CONST = 1\n}\n\nclass C {\n    companion object {\n        const val VERSION = 9\n    }\n}\n\nconst val MAX = 239\n"}, {"type": "p", "text": "In Java:"}, {"type": "div", "text": "\nint const = Obj.CONST;\nint max = ExampleKt.MAX;\nint version = C.VERSION;\n\n"}, {"type": "pre", "text": "int const = Obj.CONST;\nint max = ExampleKt.MAX;\nint version = C.VERSION;\n"}, {"type": "code", "text": "int const = Obj.CONST;\nint max = ExampleKt.MAX;\nint version = C.VERSION;\n"}, {"type": "h2", "text": "Static methods"}, {"type": "p", "text": "As mentioned above, Kotlin represents package-level functions as static methods.\nKotlin can also generate static methods for functions defined in named objects or companion objects if you annotate those functions as @JvmStatic.\nIf you use this annotation, the compiler will generate both a static method in the enclosing class of the object and an instance method in the object itself.\nFor example:"}, {"type": "a", "text": "@JvmStatic"}, {"type": "code", "text": "@JvmStatic"}, {"type": "div", "text": "\nclass C {\n    companion object {\n        @JvmStatic fun callStatic() {}\n        fun callNonStatic() {}\n    }\n}\n\n"}, {"type": "pre", "text": "class C {\n    companion object {\n        @JvmStatic fun callStatic() {}\n        fun callNonStatic() {}\n    }\n}\n"}, {"type": "code", "text": "class C {\n    companion object {\n        @JvmStatic fun callStatic() {}\n        fun callNonStatic() {}\n    }\n}\n"}, {"type": "p", "text": "Now, callStatic() is static in Java, while callNonStatic() is not:"}, {"type": "code", "text": "callStatic()"}, {"type": "code", "text": "callNonStatic()"}, {"type": "div", "text": "\nC.callStatic(); // works fine\nC.callNonStatic(); // error: not a static method\nC.Companion.callStatic(); // instance method remains\nC.Companion.callNonStatic(); // the only way it works\n\n"}, {"type": "pre", "text": "C.callStatic(); // works fine\nC.callNonStatic(); // error: not a static method\nC.Companion.callStatic(); // instance method remains\nC.Companion.callNonStatic(); // the only way it works\n"}, {"type": "code", "text": "C.callStatic(); // works fine\nC.callNonStatic(); // error: not a static method\nC.Companion.callStatic(); // instance method remains\nC.Companion.callNonStatic(); // the only way it works\n"}, {"type": "p", "text": "Same for named objects:"}, {"type": "div", "text": "\nobject Obj {\n    @JvmStatic fun callStatic() {}\n    fun callNonStatic() {}\n}\n\n"}, {"type": "pre", "text": "object Obj {\n    @JvmStatic fun callStatic() {}\n    fun callNonStatic() {}\n}\n"}, {"type": "code", "text": "object Obj {\n    @JvmStatic fun callStatic() {}\n    fun callNonStatic() {}\n}\n"}, {"type": "p", "text": "In Java:"}, {"type": "div", "text": "\nObj.callStatic(); // works fine\nObj.callNonStatic(); // error\nObj.INSTANCE.callNonStatic(); // works, a call through the singleton instance\nObj.INSTANCE.callStatic(); // works too\n\n"}, {"type": "pre", "text": "Obj.callStatic(); // works fine\nObj.callNonStatic(); // error\nObj.INSTANCE.callNonStatic(); // works, a call through the singleton instance\nObj.INSTANCE.callStatic(); // works too\n"}, {"type": "code", "text": "Obj.callStatic(); // works fine\nObj.callNonStatic(); // error\nObj.INSTANCE.callNonStatic(); // works, a call through the singleton instance\nObj.INSTANCE.callStatic(); // works too\n"}, {"type": "p", "text": "Starting from Kotlin 1.3, @JvmStatic applies to functions defined in companion objects of interfaces as well.\nSuch functions compile to static methods in interfaces. Note that static method in interfaces were introduced in Java 1.8,\nso be sure to use the corresponding targets."}, {"type": "code", "text": "@JvmStatic"}, {"type": "div", "text": "\ninterface ChatBot {\n    companion object {\n        @JvmStatic fun greet(username: String) {\n            println(\"Hello, $username\")\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "interface ChatBot {\n    companion object {\n        @JvmStatic fun greet(username: String) {\n            println(\"Hello, $username\")\n        }\n    }\n}\n"}, {"type": "code", "text": "interface ChatBot {\n    companion object {\n        @JvmStatic fun greet(username: String) {\n            println(\"Hello, $username\")\n        }\n    }\n}\n"}, {"type": "p", "text": "@JvmStatic annotation can also be applied on a property of an object or a companion object\nmaking its getter and setter methods static members in that object or the class containing the companion object."}, {"type": "code", "text": "@JvmStatic"}, {"type": "h2", "text": "Default methods in interfaces"}, {"type": "blockquote", "text": "\nDefault methods are available only for targets JVM 1.8 and above.\n"}, {"type": "p", "text": "Default methods are available only for targets JVM 1.8 and above."}, {"type": "blockquote", "text": "\nThe @JvmDefault annotation is experimental in Kotlin 1.3. Its name and behavior may change, leading to future incompatibility.\n"}, {"type": "p", "text": "The @JvmDefault annotation is experimental in Kotlin 1.3. Its name and behavior may change, leading to future incompatibility."}, {"type": "code", "text": "@JvmDefault"}, {"type": "p", "text": "Starting from JDK 1.8, interfaces in Java can contain default methods.\nYou can declare a non-abstract member of a Kotlin interface as default for the Java classes implementing it.\nTo make a member default, mark it with the @JvmDefault annotation.\nHere is an example of a Kotlin interface with a default method:"}, {"type": "a", "text": "default methods"}, {"type": "a", "text": "@JvmDefault"}, {"type": "code", "text": "@JvmDefault"}, {"type": "div", "text": "\ninterface Robot {\n    @JvmDefault fun move() { println(\"~walking~\") }\n    fun speak(): Unit\n}\n\n"}, {"type": "pre", "text": "interface Robot {\n    @JvmDefault fun move() { println(\"~walking~\") }\n    fun speak(): Unit\n}\n"}, {"type": "code", "text": "interface Robot {\n    @JvmDefault fun move() { println(\"~walking~\") }\n    fun speak(): Unit\n}\n"}, {"type": "p", "text": "The default implementation is available for Java classes implementing the interface."}, {"type": "div", "text": "\n//Java implementation\npublic class C3PO implements Robot {\n    // move() implementation from Robot is available implicitly\n    @Override\n    public void speak() {\n        System.out.println(\"I beg your pardon, sir\");\n    }\n}\n\n"}, {"type": "pre", "text": "//Java implementation\npublic class C3PO implements Robot {\n    // move() implementation from Robot is available implicitly\n    @Override\n    public void speak() {\n        System.out.println(\"I beg your pardon, sir\");\n    }\n}\n"}, {"type": "code", "text": "//Java implementation\npublic class C3PO implements Robot {\n    // move() implementation from Robot is available implicitly\n    @Override\n    public void speak() {\n        System.out.println(\"I beg your pardon, sir\");\n    }\n}\n"}, {"type": "div", "text": "\nC3PO c3po = new C3PO();\nc3po.move(); // default implementation from the Robot interface\nc3po.speak();\n\n"}, {"type": "pre", "text": "C3PO c3po = new C3PO();\nc3po.move(); // default implementation from the Robot interface\nc3po.speak();\n"}, {"type": "code", "text": "C3PO c3po = new C3PO();\nc3po.move(); // default implementation from the Robot interface\nc3po.speak();\n"}, {"type": "p", "text": "Implementations of the interface can override default methods."}, {"type": "div", "text": "\n//Java\npublic class BB8 implements Robot {\n    //own implementation of the default method\n    @Override\n    public void move() {\n        System.out.println(\"~rolling~\");\n    }\n\n    @Override\n    public void speak() {\n        System.out.println(\"Beep-beep\");\n    }\n}\n\n"}, {"type": "pre", "text": "//Java\npublic class BB8 implements Robot {\n    //own implementation of the default method\n    @Override\n    public void move() {\n        System.out.println(\"~rolling~\");\n    }\n\n    @Override\n    public void speak() {\n        System.out.println(\"Beep-beep\");\n    }\n}\n"}, {"type": "code", "text": "//Java\npublic class BB8 implements Robot {\n    //own implementation of the default method\n    @Override\n    public void move() {\n        System.out.println(\"~rolling~\");\n    }\n\n    @Override\n    public void speak() {\n        System.out.println(\"Beep-beep\");\n    }\n}\n"}, {"type": "p", "text": "For the @JvmDefault annotation to take effect, the interface must be compiled with an -Xjvm-default argument.\nDepending on the case of adding the annotation, specify one of the argument values:"}, {"type": "code", "text": "@JvmDefault"}, {"type": "code", "text": "-Xjvm-default"}, {"type": "ul", "text": "\n-Xjvm-default=enabled should be used if you add only new methods with the @JvmDefault annotation.\n This includes adding the entire interface for your API.\n-Xjvm-default=compatibility should be used if you are adding a @JvmDefault to the methods that were available in the API before.\n This mode helps avoid compatibility breaks: all the interface implementations written for the previous versions will be fully compatible with the new version.\n However, the compatibility mode may add some overhead to the resulting bytecode size and affect the performance.\n"}, {"type": "li", "text": "-Xjvm-default=enabled should be used if you add only new methods with the @JvmDefault annotation.\n This includes adding the entire interface for your API."}, {"type": "code", "text": "-Xjvm-default=enabled"}, {"type": "code", "text": "@JvmDefault"}, {"type": "li", "text": "-Xjvm-default=compatibility should be used if you are adding a @JvmDefault to the methods that were available in the API before.\n This mode helps avoid compatibility breaks: all the interface implementations written for the previous versions will be fully compatible with the new version.\n However, the compatibility mode may add some overhead to the resulting bytecode size and affect the performance."}, {"type": "code", "text": "-Xjvm-default=compatibility"}, {"type": "code", "text": "@JvmDefault"}, {"type": "p", "text": "For more details about compatibility issues, see the @JvmDefault reference page."}, {"type": "code", "text": "@JvmDefault"}, {"type": "a", "text": "reference page"}, {"type": "h3", "text": "Using in delegates"}, {"type": "p", "text": "Note that if an interface with @JvmDefault methods is used as a delegate,\nthe default method implementations are called even if the actual delegate type provides its own implementations."}, {"type": "code", "text": "@JvmDefault"}, {"type": "a", "text": "delegate"}, {"type": "div", "text": "\ninterface Producer {\n    @JvmDefault fun produce() {\n        println(\"interface method\")\n    }\n}\n\nclass ProducerImpl: Producer {\n    override fun produce() {\n        println(\"class method\")\n    }\n}\n\nclass DelegatedProducer(val p: Producer): Producer by p {\n}\n\nfun main() {\n    val prod = ProducerImpl()\n    DelegatedProducer(prod).produce() // prints \"interface method\"\n}\n\n"}, {"type": "pre", "text": "interface Producer {\n    @JvmDefault fun produce() {\n        println(\"interface method\")\n    }\n}\n\nclass ProducerImpl: Producer {\n    override fun produce() {\n        println(\"class method\")\n    }\n}\n\nclass DelegatedProducer(val p: Producer): Producer by p {\n}\n\nfun main() {\n    val prod = ProducerImpl()\n    DelegatedProducer(prod).produce() // prints \"interface method\"\n}\n"}, {"type": "code", "text": "interface Producer {\n    @JvmDefault fun produce() {\n        println(\"interface method\")\n    }\n}\n\nclass ProducerImpl: Producer {\n    override fun produce() {\n        println(\"class method\")\n    }\n}\n\nclass DelegatedProducer(val p: Producer): Producer by p {\n}\n\nfun main() {\n    val prod = ProducerImpl()\n    DelegatedProducer(prod).produce() // prints \"interface method\"\n}\n"}, {"type": "p", "text": "For more details about interface delegation in Kotlin, see Delegation."}, {"type": "a", "text": "Delegation"}, {"type": "h2", "text": "Visibility"}, {"type": "p", "text": "The Kotlin visibilities are mapped to Java in the following way:"}, {"type": "ul", "text": "\nprivate members are compiled to private members;\nprivate top-level declarations are compiled to package-local declarations;\nprotected remains protected (note that Java allows accessing protected members from other classes in the same package\nand Kotlin doesn't, so Java classes will have broader access to the code);\ninternal declarations become public in Java. Members of internal classes go through name mangling, to make\nit harder to accidentally use them from Java and to allow overloading for members with the same signature that don't see\neach other according to Kotlin rules;\npublic remains public.\n"}, {"type": "li", "text": "private members are compiled to private members;"}, {"type": "code", "text": "private"}, {"type": "code", "text": "private"}, {"type": "li", "text": "private top-level declarations are compiled to package-local declarations;"}, {"type": "code", "text": "private"}, {"type": "li", "text": "protected remains protected (note that Java allows accessing protected members from other classes in the same package\nand Kotlin doesn't, so Java classes will have broader access to the code);"}, {"type": "code", "text": "protected"}, {"type": "code", "text": "protected"}, {"type": "li", "text": "internal declarations become public in Java. Members of internal classes go through name mangling, to make\nit harder to accidentally use them from Java and to allow overloading for members with the same signature that don't see\neach other according to Kotlin rules;"}, {"type": "code", "text": "internal"}, {"type": "code", "text": "public"}, {"type": "code", "text": "internal"}, {"type": "li", "text": "public remains public."}, {"type": "code", "text": "public"}, {"type": "code", "text": "public"}, {"type": "h2", "text": "KClass"}, {"type": "p", "text": "Sometimes you need to call a Kotlin method with a parameter of type KClass.\nThere is no automatic conversion from Class to KClass, so you have to do it manually by invoking the equivalent of\nthe Class<T>.kotlin extension property:"}, {"type": "code", "text": "KClass"}, {"type": "code", "text": "Class"}, {"type": "code", "text": "KClass"}, {"type": "code", "text": "Class<T>.kotlin"}, {"type": "div", "text": "\nkotlin.jvm.JvmClassMappingKt.getKotlinClass(MainView.class)\n\n"}, {"type": "pre", "text": "kotlin.jvm.JvmClassMappingKt.getKotlinClass(MainView.class)\n"}, {"type": "code", "text": "kotlin.jvm.JvmClassMappingKt.getKotlinClass(MainView.class)\n"}, {"type": "h2", "text": "Handling signature clashes with @JvmName"}, {"type": "code", "text": "@JvmName"}, {"type": "p", "text": "Sometimes we have a named function in Kotlin, for which we need a different JVM name in the byte code.\nThe most prominent example happens due to type erasure:"}, {"type": "em", "text": "type erasure"}, {"type": "div", "text": "\nfun List<String>.filterValid(): List<String>\nfun List<Int>.filterValid(): List<Int>\n\n"}, {"type": "pre", "text": "fun List<String>.filterValid(): List<String>\nfun List<Int>.filterValid(): List<Int>\n"}, {"type": "code", "text": "fun List<String>.filterValid(): List<String>\nfun List<Int>.filterValid(): List<Int>\n"}, {"type": "p", "text": "These two functions can not be defined side-by-side, because their JVM signatures are the same: filterValid(Ljava/util/List;)Ljava/util/List;.\nIf we really want them to have the same name in Kotlin, we can annotate one (or both) of them with @JvmName and specify a different name as an argument:"}, {"type": "code", "text": "filterValid(Ljava/util/List;)Ljava/util/List;"}, {"type": "a", "text": "@JvmName"}, {"type": "code", "text": "@JvmName"}, {"type": "div", "text": "\nfun List<String>.filterValid(): List<String>\n\n@JvmName(\"filterValidInt\")\nfun List<Int>.filterValid(): List<Int>\n\n"}, {"type": "pre", "text": "fun List<String>.filterValid(): List<String>\n\n@JvmName(\"filterValidInt\")\nfun List<Int>.filterValid(): List<Int>\n"}, {"type": "code", "text": "fun List<String>.filterValid(): List<String>\n\n@JvmName(\"filterValidInt\")\nfun List<Int>.filterValid(): List<Int>\n"}, {"type": "p", "text": "From Kotlin they will be accessible by the same name filterValid, but from Java it will be filterValid and filterValidInt."}, {"type": "code", "text": "filterValid"}, {"type": "code", "text": "filterValid"}, {"type": "code", "text": "filterValidInt"}, {"type": "p", "text": "The same trick applies when we need to have a property x alongside with a function getX():"}, {"type": "code", "text": "x"}, {"type": "code", "text": "getX()"}, {"type": "div", "text": "\nval x: Int\n    @JvmName(\"getX_prop\")\n    get() = 15\n\nfun getX() = 10\n\n"}, {"type": "pre", "text": "val x: Int\n    @JvmName(\"getX_prop\")\n    get() = 15\n\nfun getX() = 10\n"}, {"type": "code", "text": "val x: Int\n    @JvmName(\"getX_prop\")\n    get() = 15\n\nfun getX() = 10\n"}, {"type": "p", "text": "To change the names of generated accessor methods for properties without explicitly implemented getters and setters, you can use @get:JvmName and @set:JvmName:"}, {"type": "code", "text": "@get:JvmName"}, {"type": "code", "text": "@set:JvmName"}, {"type": "div", "text": "\n@get:JvmName(\"x\")\n@set:JvmName(\"changeX\")\nvar x: Int = 23\n\n"}, {"type": "pre", "text": "@get:JvmName(\"x\")\n@set:JvmName(\"changeX\")\nvar x: Int = 23\n"}, {"type": "code", "text": "@get:JvmName(\"x\")\n@set:JvmName(\"changeX\")\nvar x: Int = 23\n"}, {"type": "h2", "text": "Overloads generation"}, {"type": "p", "text": "Normally, if you write a Kotlin function with default parameter values, it will be visible in Java only as a full\nsignature, with all parameters present. If you wish to expose multiple overloads to Java callers, you can use the\n@JvmOverloads annotation."}, {"type": "a", "text": "@JvmOverloads"}, {"type": "code", "text": "@JvmOverloads"}, {"type": "p", "text": "The annotation also works for constructors, static methods, and so on. It can't be used on abstract methods, including methods\ndefined in interfaces."}, {"type": "div", "text": "\nclass Circle @JvmOverloads constructor(centerX: Int, centerY: Int, radius: Double = 1.0) {\n    @JvmOverloads fun draw(label: String, lineWidth: Int = 1, color: String = \"red\") { /*...*/ }\n}\n\n"}, {"type": "pre", "text": "class Circle @JvmOverloads constructor(centerX: Int, centerY: Int, radius: Double = 1.0) {\n    @JvmOverloads fun draw(label: String, lineWidth: Int = 1, color: String = \"red\") { /*...*/ }\n}\n"}, {"type": "code", "text": "class Circle @JvmOverloads constructor(centerX: Int, centerY: Int, radius: Double = 1.0) {\n    @JvmOverloads fun draw(label: String, lineWidth: Int = 1, color: String = \"red\") { /*...*/ }\n}\n"}, {"type": "p", "text": "For every parameter with a default value, this will generate one additional overload, which has this parameter and\nall parameters to the right of it in the parameter list removed. In this example, the following will be\ngenerated:"}, {"type": "div", "text": "\n// Constructors:\nCircle(int centerX, int centerY, double radius)\nCircle(int centerX, int centerY)\n\n// Methods\nvoid draw(String label, int lineWidth, String color) { }\nvoid draw(String label, int lineWidth) { }\nvoid draw(String label) { }\n\n"}, {"type": "pre", "text": "// Constructors:\nCircle(int centerX, int centerY, double radius)\nCircle(int centerX, int centerY)\n\n// Methods\nvoid draw(String label, int lineWidth, String color) { }\nvoid draw(String label, int lineWidth) { }\nvoid draw(String label) { }\n"}, {"type": "code", "text": "// Constructors:\nCircle(int centerX, int centerY, double radius)\nCircle(int centerX, int centerY)\n\n// Methods\nvoid draw(String label, int lineWidth, String color) { }\nvoid draw(String label, int lineWidth) { }\nvoid draw(String label) { }\n"}, {"type": "p", "text": "Note that, as described in Secondary Constructors, if a class has default\nvalues for all constructor parameters, a public no-argument constructor will be generated for it. This works even\nif the @JvmOverloads annotation is not specified."}, {"type": "a", "text": "Secondary Constructors"}, {"type": "code", "text": "@JvmOverloads"}, {"type": "h2", "text": "Checked exceptions"}, {"type": "p", "text": "As we mentioned above, Kotlin does not have checked exceptions.\nSo, normally, the Java signatures of Kotlin functions do not declare exceptions thrown.\nThus if we have a function in Kotlin like this:"}, {"type": "div", "text": "\n// example.kt\npackage demo\n\nfun writeToFile() {\n    /*...*/\n    throw IOException()\n}\n\n"}, {"type": "pre", "text": "// example.kt\npackage demo\n\nfun writeToFile() {\n    /*...*/\n    throw IOException()\n}\n"}, {"type": "code", "text": "// example.kt\npackage demo\n\nfun writeToFile() {\n    /*...*/\n    throw IOException()\n}\n"}, {"type": "p", "text": "And we want to call it from Java and catch the exception:"}, {"type": "div", "text": "\n// Java\ntry {\n  demo.Example.writeToFile();\n}\ncatch (IOException e) { // error: writeToFile() does not declare IOException in the throws list\n  // ...\n}\n\n"}, {"type": "pre", "text": "// Java\ntry {\n  demo.Example.writeToFile();\n}\ncatch (IOException e) { // error: writeToFile() does not declare IOException in the throws list\n  // ...\n}\n"}, {"type": "code", "text": "// Java\ntry {\n  demo.Example.writeToFile();\n}\ncatch (IOException e) { // error: writeToFile() does not declare IOException in the throws list\n  // ...\n}\n"}, {"type": "p", "text": "we get an error message from the Java compiler, because writeToFile() does not declare IOException.\nTo work around this problem, use the @Throws annotation in Kotlin:"}, {"type": "code", "text": "writeToFile()"}, {"type": "code", "text": "IOException"}, {"type": "a", "text": "@Throws"}, {"type": "code", "text": "@Throws"}, {"type": "div", "text": "\n@Throws(IOException::class)\nfun writeToFile() {\n    /*...*/\n    throw IOException()\n}\n\n"}, {"type": "pre", "text": "@Throws(IOException::class)\nfun writeToFile() {\n    /*...*/\n    throw IOException()\n}\n"}, {"type": "code", "text": "@Throws(IOException::class)\nfun writeToFile() {\n    /*...*/\n    throw IOException()\n}\n"}, {"type": "h2", "text": "Null-safety"}, {"type": "p", "text": "When calling Kotlin functions from Java, nobody prevents us from passing null as a non-null parameter.\nThat's why Kotlin generates runtime checks for all public functions that expect non-nulls.\nThis way we get a NullPointerException in the Java code immediately."}, {"type": "em", "text": "null"}, {"type": "code", "text": "NullPointerException"}, {"type": "h2", "text": "Variant generics"}, {"type": "p", "text": "When Kotlin classes make use of declaration-site variance, there are two \noptions of how their usages are seen from the Java code. Let's say we have the following class and two functions that use it:"}, {"type": "a", "text": "declaration-site variance"}, {"type": "div", "text": "\nclass Box<out T>(val value: T)\n\ninterface Base\nclass Derived : Base\n\nfun boxDerived(value: Derived): Box<Derived> = Box(value)\nfun unboxBase(box: Box<Base>): Base = box.value\n\n"}, {"type": "pre", "text": "class Box<out T>(val value: T)\n\ninterface Base\nclass Derived : Base\n\nfun boxDerived(value: Derived): Box<Derived> = Box(value)\nfun unboxBase(box: Box<Base>): Base = box.value\n"}, {"type": "code", "text": "class Box<out T>(val value: T)\n\ninterface Base\nclass Derived : Base\n\nfun boxDerived(value: Derived): Box<Derived> = Box(value)\nfun unboxBase(box: Box<Base>): Base = box.value\n"}, {"type": "p", "text": "A naive way of translating these functions into Java would be this:"}, {"type": "div", "text": "\nBox<Derived> boxDerived(Derived value) { ... }\nBase unboxBase(Box<Base> box) { ... }\n\n"}, {"type": "pre", "text": "Box<Derived> boxDerived(Derived value) { ... }\nBase unboxBase(Box<Base> box) { ... }\n"}, {"type": "code", "text": "Box<Derived> boxDerived(Derived value) { ... }\nBase unboxBase(Box<Base> box) { ... }\n"}, {"type": "p", "text": "The problem is that in Kotlin we can say unboxBase(boxDerived(\"s\")), but in Java that would be impossible, because in Java \n  the class Box is invariant in its parameter T, and thus Box<Derived> is not a subtype of Box<Base>. \n  To make it work in Java we'd have to define unboxBase as follows:"}, {"type": "code", "text": "unboxBase(boxDerived(\"s\"))"}, {"type": "code", "text": "Box"}, {"type": "em", "text": "invariant"}, {"type": "code", "text": "T"}, {"type": "code", "text": "Box<Derived>"}, {"type": "code", "text": "Box<Base>"}, {"type": "code", "text": "unboxBase"}, {"type": "div", "text": "\nBase unboxBase(Box<? extends Base> box) { ... }  \n\n"}, {"type": "pre", "text": "Base unboxBase(Box<? extends Base> box) { ... }  \n"}, {"type": "code", "text": "Base unboxBase(Box<? extends Base> box) { ... }  \n"}, {"type": "p", "text": "Here we make use of Java's wildcards types (? extends Base) to emulate declaration-site variance through use-site \nvariance, because it is all Java has."}, {"type": "em", "text": "wildcards types"}, {"type": "code", "text": "? extends Base"}, {"type": "p", "text": "To make Kotlin APIs work in Java we generate Box<Super> as Box<? extends Super> for covariantly defined Box \n(or Foo<? super Bar> for contravariantly defined Foo) when it appears as a parameter. When it's a return value,\nwe don't generate wildcards, because otherwise Java clients will have to deal with them (and it's against the common \nJava coding style). Therefore, the functions from our example are actually translated as follows:"}, {"type": "code", "text": "Box<Super>"}, {"type": "code", "text": "Box<? extends Super>"}, {"type": "code", "text": "Box"}, {"type": "code", "text": "Foo<? super Bar>"}, {"type": "code", "text": "Foo"}, {"type": "em", "text": "as a parameter"}, {"type": "div", "text": "\n// return type - no wildcards\nBox<Derived> boxDerived(Derived value) { ... }\n \n// parameter - wildcards \nBase unboxBase(Box<? extends Base> box) { ... }\n\n"}, {"type": "pre", "text": "// return type - no wildcards\nBox<Derived> boxDerived(Derived value) { ... }\n \n// parameter - wildcards \nBase unboxBase(Box<? extends Base> box) { ... }\n"}, {"type": "code", "text": "// return type - no wildcards\nBox<Derived> boxDerived(Derived value) { ... }\n \n// parameter - wildcards \nBase unboxBase(Box<? extends Base> box) { ... }\n"}, {"type": "blockquote", "text": "\nWhen the argument type is final, there's usually no point in generating the wildcard, so Box<String> is always Box<String>, no matter what position it takes.\n"}, {"type": "p", "text": "When the argument type is final, there's usually no point in generating the wildcard, so Box<String> is always Box<String>, no matter what position it takes."}, {"type": "code", "text": "Box<String>"}, {"type": "code", "text": "Box<String>"}, {"type": "p", "text": "If we need wildcards where they are not generated by default, we can use the @JvmWildcard annotation:"}, {"type": "code", "text": "@JvmWildcard"}, {"type": "div", "text": "\nfun boxDerived(value: Derived): Box<@JvmWildcard Derived> = Box(value)\n// is translated to \n// Box<? extends Derived> boxDerived(Derived value) { ... }\n\n"}, {"type": "pre", "text": "fun boxDerived(value: Derived): Box<@JvmWildcard Derived> = Box(value)\n// is translated to \n// Box<? extends Derived> boxDerived(Derived value) { ... }\n"}, {"type": "code", "text": "fun boxDerived(value: Derived): Box<@JvmWildcard Derived> = Box(value)\n// is translated to \n// Box<? extends Derived> boxDerived(Derived value) { ... }\n"}, {"type": "p", "text": "On the other hand, if we don't need wildcards where they are generated, we can use @JvmSuppressWildcards:"}, {"type": "code", "text": "@JvmSuppressWildcards"}, {"type": "div", "text": "\nfun unboxBase(box: Box<@JvmSuppressWildcards Base>): Base = box.value\n// is translated to \n// Base unboxBase(Box<Base> box) { ... }\n\n"}, {"type": "pre", "text": "fun unboxBase(box: Box<@JvmSuppressWildcards Base>): Base = box.value\n// is translated to \n// Base unboxBase(Box<Base> box) { ... }\n"}, {"type": "code", "text": "fun unboxBase(box: Box<@JvmSuppressWildcards Base>): Base = box.value\n// is translated to \n// Base unboxBase(Box<Base> box) { ... }\n"}, {"type": "blockquote", "text": "\n@JvmSuppressWildcards can be used not only on individual type arguments, but on entire declarations, such as functions or classes, causing all wildcards inside them to be suppressed.\n"}, {"type": "p", "text": "@JvmSuppressWildcards can be used not only on individual type arguments, but on entire declarations, such as functions or classes, causing all wildcards inside them to be suppressed."}, {"type": "code", "text": "@JvmSuppressWildcards"}, {"type": "h3", "text": "Translation of type Nothing"}, {"type": "code", "text": "Nothing"}, {"type": "p", "text": "The type Nothing is special, because it has no natural counterpart in Java. Indeed, every Java reference type, including\njava.lang.Void, accepts null as a value, and Nothing doesn't accept even that. So, this type cannot be accurately\nrepresented in the Java world. This is why Kotlin generates a raw type where an argument of type Nothing is used:"}, {"type": "a", "text": "Nothing"}, {"type": "code", "text": "Nothing"}, {"type": "code", "text": "java.lang.Void"}, {"type": "code", "text": "null"}, {"type": "code", "text": "Nothing"}, {"type": "code", "text": "Nothing"}, {"type": "div", "text": "\nfun emptyList(): List<Nothing> = listOf()\n// is translated to\n// List emptyList() { ... }\n\n"}, {"type": "pre", "text": "fun emptyList(): List<Nothing> = listOf()\n// is translated to\n// List emptyList() { ... }\n"}, {"type": "code", "text": "fun emptyList(): List<Nothing> = listOf()\n// is translated to\n// List emptyList() { ... }\n"}]