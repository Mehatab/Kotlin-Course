[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "p", "text": "Table of contents"}, {"type": "strong", "text": "Table of contents"}, {"type": "ul", "text": "\nShared mutable state and concurrency\n\nThe problem\nVolatiles are of no help\nThread-safe data structures\nThread confinement fine-grained\nThread confinement coarse-grained\nMutual exclusion\nActors\n\n\n"}, {"type": "li", "text": "Shared mutable state and concurrency\n\nThe problem\nVolatiles are of no help\nThread-safe data structures\nThread confinement fine-grained\nThread confinement coarse-grained\nMutual exclusion\nActors\n\n"}, {"type": "a", "text": "Shared mutable state and concurrency"}, {"type": "ul", "text": "\nThe problem\nVolatiles are of no help\nThread-safe data structures\nThread confinement fine-grained\nThread confinement coarse-grained\nMutual exclusion\nActors\n"}, {"type": "li", "text": "The problem"}, {"type": "a", "text": "The problem"}, {"type": "li", "text": "Volatiles are of no help"}, {"type": "a", "text": "Volatiles are of no help"}, {"type": "li", "text": "Thread-safe data structures"}, {"type": "a", "text": "Thread-safe data structures"}, {"type": "li", "text": "Thread confinement fine-grained"}, {"type": "a", "text": "Thread confinement fine-grained"}, {"type": "li", "text": "Thread confinement coarse-grained"}, {"type": "a", "text": "Thread confinement coarse-grained"}, {"type": "li", "text": "Mutual exclusion"}, {"type": "a", "text": "Mutual exclusion"}, {"type": "li", "text": "Actors"}, {"type": "a", "text": "Actors"}, {"type": "h2", "text": "Shared mutable state and concurrency"}, {"type": "p", "text": "Coroutines can be executed concurrently using a multi-threaded dispatcher like the Dispatchers.Default. It presents\nall the usual concurrency problems. The main problem being synchronization of access to shared mutable state. \nSome solutions to this problem in the land of coroutines are similar to the solutions in the multi-threaded world, \nbut others are unique."}, {"type": "a", "text": "Dispatchers.Default"}, {"type": "strong", "text": "shared mutable state"}, {"type": "h3", "text": "The problem"}, {"type": "p", "text": "Let us launch a hundred coroutines all doing the same action thousand times. \nWe'll also measure their completion time for further comparisons:"}, {"type": "div", "text": "\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n"}, {"type": "pre", "text": "suspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n"}, {"type": "code", "text": "suspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n"}, {"type": "p", "text": "We start with a very simple action that increments a shared mutable variable using \nmulti-threaded Dispatchers.Default."}, {"type": "a", "text": "Dispatchers.Default"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlin.system.*    \n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter++\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd    \n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*    \n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter++\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd    \n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*    \n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter++\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd    \n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "What does it print at the end? It is highly unlikely to ever print \"Counter = 100000\", because a hundred coroutines \nincrement the counter concurrently from multiple threads without any synchronization."}, {"type": "code", "text": "counter"}, {"type": "h3", "text": "Volatiles are of no help"}, {"type": "p", "text": "There is common misconception that making a variable volatile solves concurrency problem. Let us try it:"}, {"type": "code", "text": "volatile"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\n@Volatile // in Kotlin `volatile` is an annotation \nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter++\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd    \n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\n@Volatile // in Kotlin `volatile` is an annotation \nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter++\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd    \n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\n@Volatile // in Kotlin `volatile` is an annotation \nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter++\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd    \n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "This code works slower, but we still don't get \"Counter = 100000\" at the end, because volatile variables guarantee\nlinearizable (this is a technical term for \"atomic\") reads and writes to the corresponding variable, but\ndo not provide atomicity of larger actions (increment in our case)."}, {"type": "h3", "text": "Thread-safe data structures"}, {"type": "p", "text": "The general solution that works both for threads and for coroutines is to use a thread-safe (aka synchronized,\nlinearizable, or atomic) data structure that provides all the necessarily synchronization for the corresponding \noperations that needs to be performed on a shared state. \nIn the case of a simple counter we can use AtomicInteger class which has atomic incrementAndGet operations:"}, {"type": "code", "text": "AtomicInteger"}, {"type": "code", "text": "incrementAndGet"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport java.util.concurrent.atomic.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nval counter = AtomicInteger()\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter.incrementAndGet()\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd    \n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport java.util.concurrent.atomic.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nval counter = AtomicInteger()\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter.incrementAndGet()\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd    \n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport java.util.concurrent.atomic.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nval counter = AtomicInteger()\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter.incrementAndGet()\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd    \n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "This is the fastest solution for this particular problem. It works for plain counters, collections, queues and other\nstandard data structures and basic operations on them. However, it does not easily scale to complex\nstate or to complex operations that do not have ready-to-use thread-safe implementations."}, {"type": "h3", "text": "Thread confinement fine-grained"}, {"type": "p", "text": "Thread confinement is an approach to the problem of shared mutable state where all access to the particular shared\nstate is confined to a single thread. It is typically used in UI applications, where all UI state is confined to \nthe single event-dispatch/application thread. It is easy to apply with coroutines by using a\nsingle-threaded context."}, {"type": "em", "text": "Thread confinement"}, {"type": "br", "text": ""}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nval counterContext = newSingleThreadContext(\"CounterContext\")\nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            // confine each increment to a single-threaded context\n            withContext(counterContext) {\n                counter++\n            }\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd      \n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nval counterContext = newSingleThreadContext(\"CounterContext\")\nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            // confine each increment to a single-threaded context\n            withContext(counterContext) {\n                counter++\n            }\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd      \n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nval counterContext = newSingleThreadContext(\"CounterContext\")\nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            // confine each increment to a single-threaded context\n            withContext(counterContext) {\n                counter++\n            }\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd      \n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "This code works very slowly, because it does fine-grained thread-confinement. Each individual increment switches \nfrom multi-threaded Dispatchers.Default context to the single-threaded context using \nwithContext(counterContext) block."}, {"type": "em", "text": "fine-grained"}, {"type": "a", "text": "Dispatchers.Default"}, {"type": "a", "text": "withContext(counterContext)"}, {"type": "h3", "text": "Thread confinement coarse-grained"}, {"type": "p", "text": "In practice, thread confinement is performed in large chunks, e.g. big pieces of state-updating business logic\nare confined to the single thread. The following example does it like that, running each coroutine in \nthe single-threaded context to start with."}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nval counterContext = newSingleThreadContext(\"CounterContext\")\nvar counter = 0\n\nfun main() = runBlocking {\n    // confine everything to a single-threaded context\n    withContext(counterContext) {\n        massiveRun {\n            counter++\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd     \n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nval counterContext = newSingleThreadContext(\"CounterContext\")\nvar counter = 0\n\nfun main() = runBlocking {\n    // confine everything to a single-threaded context\n    withContext(counterContext) {\n        massiveRun {\n            counter++\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd     \n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nval counterContext = newSingleThreadContext(\"CounterContext\")\nvar counter = 0\n\nfun main() = runBlocking {\n    // confine everything to a single-threaded context\n    withContext(counterContext) {\n        massiveRun {\n            counter++\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd     \n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "This now works much faster and produces correct result."}, {"type": "h3", "text": "Mutual exclusion"}, {"type": "p", "text": "Mutual exclusion solution to the problem is to protect all modifications of the shared state with a critical section\nthat is never executed concurrently. In a blocking world you'd typically use synchronized or ReentrantLock for that.\nCoroutine's alternative is called Mutex. It has lock and unlock functions to \ndelimit a critical section. The key difference is that Mutex.lock() is a suspending function. It does not block a thread."}, {"type": "em", "text": "critical section"}, {"type": "code", "text": "synchronized"}, {"type": "code", "text": "ReentrantLock"}, {"type": "a", "text": "Mutex"}, {"type": "a", "text": "lock"}, {"type": "a", "text": "unlock"}, {"type": "code", "text": "Mutex.lock()"}, {"type": "p", "text": "There is also withLock extension function that conveniently represents \nmutex.lock(); try { ... } finally { mutex.unlock() } pattern:"}, {"type": "a", "text": "withLock"}, {"type": "code", "text": "mutex.lock(); try { ... } finally { mutex.unlock() }"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.sync.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nval mutex = Mutex()\nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            // protect each increment with lock\n            mutex.withLock {\n                counter++\n            }\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd    \n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.sync.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nval mutex = Mutex()\nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            // protect each increment with lock\n            mutex.withLock {\n                counter++\n            }\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd    \n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.sync.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n//sampleStart\nval mutex = Mutex()\nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            // protect each increment with lock\n            mutex.withLock {\n                counter++\n            }\n        }\n    }\n    println(\"Counter = $counter\")\n}\n//sampleEnd    \n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The locking in this example is fine-grained, so it pays the price. However, it is a good choice for some situations\nwhere you absolutely must modify some shared state periodically, but there is no natural thread that this state\nis confined to."}, {"type": "h3", "text": "Actors"}, {"type": "p", "text": "An actor is an entity made up of a combination of a coroutine,\nthe state that is confined and encapsulated into this coroutine,\nand a channel to communicate with other coroutines. A simple actor can be written as a function, \nbut an actor with a complex state is better suited for a class."}, {"type": "a", "text": "actor"}, {"type": "p", "text": "There is an actor coroutine builder that conveniently combines actor's mailbox channel into its \nscope to receive messages from and combines the send channel into the resulting job object, so that a \nsingle reference to the actor can be carried around as its handle."}, {"type": "a", "text": "actor"}, {"type": "p", "text": "The first step of using an actor is to define a class of messages that an actor is going to process.\nKotlin's sealed classes are well suited for that purpose.\nWe define CounterMsg sealed class with IncCounter message to increment a counter and GetCounter message\nto get its value. The later needs to send a response. A CompletableDeferred communication\nprimitive, that represents a single value that will be known (communicated) in the future,\nis used here for that purpose."}, {"type": "a", "text": "sealed classes"}, {"type": "code", "text": "CounterMsg"}, {"type": "code", "text": "IncCounter"}, {"type": "code", "text": "GetCounter"}, {"type": "a", "text": "CompletableDeferred"}, {"type": "div", "text": "\n// Message types for counterActor\nsealed class CounterMsg\nobject IncCounter : CounterMsg() // one-way message to increment counter\nclass GetCounter(val response: CompletableDeferred<Int>) : CounterMsg() // a request with reply\n\n"}, {"type": "pre", "text": "// Message types for counterActor\nsealed class CounterMsg\nobject IncCounter : CounterMsg() // one-way message to increment counter\nclass GetCounter(val response: CompletableDeferred<Int>) : CounterMsg() // a request with reply\n"}, {"type": "code", "text": "// Message types for counterActor\nsealed class CounterMsg\nobject IncCounter : CounterMsg() // one-way message to increment counter\nclass GetCounter(val response: CompletableDeferred<Int>) : CounterMsg() // a request with reply\n"}, {"type": "p", "text": "Then we define a function that launches an actor using an actor coroutine builder:"}, {"type": "a", "text": "actor"}, {"type": "div", "text": "\n// This function launches a new counter actor\nfun CoroutineScope.counterActor() = actor<CounterMsg> {\n    var counter = 0 // actor state\n    for (msg in channel) { // iterate over incoming messages\n        when (msg) {\n            is IncCounter -> counter++\n            is GetCounter -> msg.response.complete(counter)\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "// This function launches a new counter actor\nfun CoroutineScope.counterActor() = actor<CounterMsg> {\n    var counter = 0 // actor state\n    for (msg in channel) { // iterate over incoming messages\n        when (msg) {\n            is IncCounter -> counter++\n            is GetCounter -> msg.response.complete(counter)\n        }\n    }\n}\n"}, {"type": "code", "text": "// This function launches a new counter actor\nfun CoroutineScope.counterActor() = actor<CounterMsg> {\n    var counter = 0 // actor state\n    for (msg in channel) { // iterate over incoming messages\n        when (msg) {\n            is IncCounter -> counter++\n            is GetCounter -> msg.response.complete(counter)\n        }\n    }\n}\n"}, {"type": "p", "text": "The main code is straightforward:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n// Message types for counterActor\nsealed class CounterMsg\nobject IncCounter : CounterMsg() // one-way message to increment counter\nclass GetCounter(val response: CompletableDeferred<Int>) : CounterMsg() // a request with reply\n\n// This function launches a new counter actor\nfun CoroutineScope.counterActor() = actor<CounterMsg> {\n    var counter = 0 // actor state\n    for (msg in channel) { // iterate over incoming messages\n        when (msg) {\n            is IncCounter -> counter++\n            is GetCounter -> msg.response.complete(counter)\n        }\n    }\n}\n\n//sampleStart\nfun main() = runBlocking<Unit> {\n    val counter = counterActor() // create the actor\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter.send(IncCounter)\n        }\n    }\n    // send a message to get a counter value from an actor\n    val response = CompletableDeferred<Int>()\n    counter.send(GetCounter(response))\n    println(\"Counter = ${response.await()}\")\n    counter.close() // shutdown the actor\n}\n//sampleEnd    \n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n// Message types for counterActor\nsealed class CounterMsg\nobject IncCounter : CounterMsg() // one-way message to increment counter\nclass GetCounter(val response: CompletableDeferred<Int>) : CounterMsg() // a request with reply\n\n// This function launches a new counter actor\nfun CoroutineScope.counterActor() = actor<CounterMsg> {\n    var counter = 0 // actor state\n    for (msg in channel) { // iterate over incoming messages\n        when (msg) {\n            is IncCounter -> counter++\n            is GetCounter -> msg.response.complete(counter)\n        }\n    }\n}\n\n//sampleStart\nfun main() = runBlocking<Unit> {\n    val counter = counterActor() // create the actor\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter.send(IncCounter)\n        }\n    }\n    // send a message to get a counter value from an actor\n    val response = CompletableDeferred<Int>()\n    counter.send(GetCounter(response))\n    println(\"Counter = ${response.await()}\")\n    counter.close() // shutdown the actor\n}\n//sampleEnd    \n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n// Message types for counterActor\nsealed class CounterMsg\nobject IncCounter : CounterMsg() // one-way message to increment counter\nclass GetCounter(val response: CompletableDeferred<Int>) : CounterMsg() // a request with reply\n\n// This function launches a new counter actor\nfun CoroutineScope.counterActor() = actor<CounterMsg> {\n    var counter = 0 // actor state\n    for (msg in channel) { // iterate over incoming messages\n        when (msg) {\n            is IncCounter -> counter++\n            is GetCounter -> msg.response.complete(counter)\n        }\n    }\n}\n\n//sampleStart\nfun main() = runBlocking<Unit> {\n    val counter = counterActor() // create the actor\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter.send(IncCounter)\n        }\n    }\n    // send a message to get a counter value from an actor\n    val response = CompletableDeferred<Int>()\n    counter.send(GetCounter(response))\n    println(\"Counter = ${response.await()}\")\n    counter.close() // shutdown the actor\n}\n//sampleEnd    \n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It does not matter (for correctness) what context the actor itself is executed in. An actor is\na coroutine and a coroutine is executed sequentially, so confinement of the state to the specific coroutine\nworks as a solution to the problem of shared mutable state. Indeed, actors may modify their own private state, \nbut can only affect each other through messages (avoiding the need for any locks)."}, {"type": "p", "text": "Actor is more efficient than locking under load, because in this case it always has work to do and it does not \nhave to switch to a different context at all."}, {"type": "blockquote", "text": "\nNote that an actor coroutine builder is a dual of produce coroutine builder. An actor is associated \n  with the channel that it receives messages from, while a producer is associated with the channel that it \n  sends elements to.\n"}, {"type": "p", "text": "Note that an actor coroutine builder is a dual of produce coroutine builder. An actor is associated \n  with the channel that it receives messages from, while a producer is associated with the channel that it \n  sends elements to."}, {"type": "a", "text": "actor"}, {"type": "a", "text": "produce"}]