[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Exceptions"}, {"type": "h2", "text": "Exception Classes"}, {"type": "p", "text": "All exception classes in Kotlin are descendants of the class Throwable.\nEvery exception has a message, stack trace and an optional cause."}, {"type": "code", "text": "Throwable"}, {"type": "p", "text": "To throw an exception object, use the throw-expression:"}, {"type": "em", "text": "throw"}, {"type": "div", "text": "\n\nfun main() {\n//sampleStart\n    throw Exception(\"Hi There!\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "\nfun main() {\n//sampleStart\n    throw Exception(\"Hi There!\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "\nfun main() {\n//sampleStart\n    throw Exception(\"Hi There!\")\n//sampleEnd\n}\n"}, {"type": "p", "text": "To catch an exception, use the try-expression:"}, {"type": "em", "text": "try"}, {"type": "div", "text": "\ntry {\n    // some code\n}\ncatch (e: SomeException) {\n    // handler\n}\nfinally {\n    // optional finally block\n}\n\n"}, {"type": "pre", "text": "try {\n    // some code\n}\ncatch (e: SomeException) {\n    // handler\n}\nfinally {\n    // optional finally block\n}\n"}, {"type": "code", "text": "try {\n    // some code\n}\ncatch (e: SomeException) {\n    // handler\n}\nfinally {\n    // optional finally block\n}\n"}, {"type": "p", "text": "There may be zero or more catch blocks. finally block may be omitted.\nHowever at least one catch or finally block should be present."}, {"type": "em", "text": "catch"}, {"type": "em", "text": "finally"}, {"type": "em", "text": "catch"}, {"type": "em", "text": "finally"}, {"type": "h3", "text": "Try is an expression"}, {"type": "p", "text": "try is an expression, i.e. it may have a return value:"}, {"type": "em", "text": "try"}, {"type": "div", "text": "\nval a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }\n\n"}, {"type": "pre", "text": "val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }\n"}, {"type": "code", "text": "val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }\n"}, {"type": "p", "text": "The returned value of a try-expression is either the last expression in the try block or the\nlast expression in the catch block (or blocks).\nContents of the finally block do not affect the result of the expression."}, {"type": "em", "text": "try"}, {"type": "em", "text": "try"}, {"type": "em", "text": "catch"}, {"type": "em", "text": "finally"}, {"type": "h2", "text": "Checked Exceptions"}, {"type": "p", "text": "Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example."}, {"type": "p", "text": "The following is an example interface of the JDK implemented by StringBuilder class:"}, {"type": "code", "text": "StringBuilder"}, {"type": "div", "text": "\nAppendable append(CharSequence csq) throws IOException;\n\n"}, {"type": "pre", "text": "Appendable append(CharSequence csq) throws IOException;\n"}, {"type": "code", "text": "Appendable append(CharSequence csq) throws IOException;\n"}, {"type": "p", "text": "What does this signature say? It says that every time I append a string to something (a StringBuilder, some kind of a log, a console, etc.)\nI have to catch those IOExceptions. Why? Because it might be performing IO (Writer also implements Appendable)\u2026\nSo it results in this kind of code all over the place:"}, {"type": "code", "text": "StringBuilder"}, {"type": "code", "text": "IOExceptions"}, {"type": "code", "text": "Writer"}, {"type": "code", "text": "Appendable"}, {"type": "div", "text": "\ntry {\n    log.append(message)\n}\ncatch (IOException e) {\n    // Must be safe\n}\n\n"}, {"type": "pre", "text": "try {\n    log.append(message)\n}\ncatch (IOException e) {\n    // Must be safe\n}\n"}, {"type": "code", "text": "try {\n    log.append(message)\n}\ncatch (IOException e) {\n    // Must be safe\n}\n"}, {"type": "p", "text": "And this is no good, see Effective Java, 3rd Edition, Item 77: Don't ignore exceptions."}, {"type": "a", "text": "Effective Java, 3rd Edition"}, {"type": "em", "text": "Don't ignore exceptions"}, {"type": "p", "text": "Bruce Eckel says about checked exceptions:"}, {"type": "blockquote", "text": "\nExamination of small programs leads to the conclusion that requiring exception specifications could both enhance developer productivity and enhance code quality, but experience with large software projects suggests a different result \u2013 decreased productivity and little or no increase in code quality.\n"}, {"type": "p", "text": "Examination of small programs leads to the conclusion that requiring exception specifications could both enhance developer productivity and enhance code quality, but experience with large software projects suggests a different result \u2013 decreased productivity and little or no increase in code quality."}, {"type": "p", "text": "Other citations of this sort:"}, {"type": "ul", "text": "\nJava's checked exceptions were a mistake (Rod Waldhoff)\nThe Trouble with Checked Exceptions (Anders Hejlsberg)\n"}, {"type": "li", "text": "Java's checked exceptions were a mistake (Rod Waldhoff)"}, {"type": "a", "text": "Java's checked exceptions were a mistake"}, {"type": "li", "text": "The Trouble with Checked Exceptions (Anders Hejlsberg)"}, {"type": "a", "text": "The Trouble with Checked Exceptions"}, {"type": "p", "text": "If you want to alert callers of possible exceptions when calling Kotlin code from Java, Swift, or Objective-C, you can use the @Throws annotation. Read more about using this annotation for Java as well as for Swift and Objective-C."}, {"type": "code", "text": "@Throws"}, {"type": "a", "text": "for Java"}, {"type": "a", "text": "for Swift and Objective-C"}, {"type": "h2", "text": "The Nothing type"}, {"type": "p", "text": "throw is an expression in Kotlin, so you can use it, for example, as part of an Elvis expression:"}, {"type": "code", "text": "throw"}, {"type": "div", "text": "\nval s = person.name ?: throw IllegalArgumentException(\"Name required\")\n\n"}, {"type": "pre", "text": "val s = person.name ?: throw IllegalArgumentException(\"Name required\")\n"}, {"type": "code", "text": "val s = person.name ?: throw IllegalArgumentException(\"Name required\")\n"}, {"type": "p", "text": "The type of the throw expression is the special type Nothing.\nThe type has no values and is used to mark code locations that can never be reached.\nIn your own code, you can use Nothing to mark a function that never returns:"}, {"type": "code", "text": "throw"}, {"type": "code", "text": "Nothing"}, {"type": "code", "text": "Nothing"}, {"type": "div", "text": "\nfun fail(message: String): Nothing {\n    throw IllegalArgumentException(message)\n}\n\n"}, {"type": "pre", "text": "fun fail(message: String): Nothing {\n    throw IllegalArgumentException(message)\n}\n"}, {"type": "code", "text": "fun fail(message: String): Nothing {\n    throw IllegalArgumentException(message)\n}\n"}, {"type": "p", "text": "When you call this function, the compiler will know that the execution doesn't continue beyond the call:"}, {"type": "div", "text": "\nval s = person.name ?: fail(\"Name required\")\nprintln(s)     // 's' is known to be initialized at this point\n\n"}, {"type": "pre", "text": "val s = person.name ?: fail(\"Name required\")\nprintln(s)     // 's' is known to be initialized at this point\n"}, {"type": "code", "text": "val s = person.name ?: fail(\"Name required\")\nprintln(s)     // 's' is known to be initialized at this point\n"}, {"type": "p", "text": "Another case where you may encounter this type is type inference. The nullable variant of this type,\nNothing?, has exactly one possible value, which is null. If you use null to initialize\na value of an inferred type and there's no other information that can be used to determine a more\nspecific type, the compiler will infer the Nothing? type:"}, {"type": "code", "text": "Nothing?"}, {"type": "code", "text": "null"}, {"type": "code", "text": "null"}, {"type": "code", "text": "Nothing?"}, {"type": "div", "text": "\nval x = null           // 'x' has type `Nothing?`\nval l = listOf(null)   // 'l' has type `List<Nothing?>\n\n"}, {"type": "pre", "text": "val x = null           // 'x' has type `Nothing?`\nval l = listOf(null)   // 'l' has type `List<Nothing?>\n"}, {"type": "code", "text": "val x = null           // 'x' has type `Nothing?`\nval l = listOf(null)   // 'l' has type `List<Nothing?>\n"}, {"type": "h2", "text": "Java Interoperability"}, {"type": "p", "text": "Please see the section on exceptions in the Java Interoperability section for information about Java interoperability."}, {"type": "a", "text": "Java Interoperability section"}]