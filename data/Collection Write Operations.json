[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Collection Write Operations"}, {"type": "p", "text": "Mutable collections support operations for changing the collection contents, for example, adding or removing elements.\nOn this page, we'll describe write operations available for all implementations of MutableCollection.\nFor more specific operations available for List and Map, see List Specific Operations and Map Specific Operations respectively."}, {"type": "a", "text": "Mutable collections"}, {"type": "code", "text": "MutableCollection"}, {"type": "code", "text": "List"}, {"type": "code", "text": "Map"}, {"type": "a", "text": "List Specific Operations"}, {"type": "a", "text": "Map Specific Operations"}, {"type": "h2", "text": "Adding elements"}, {"type": "p", "text": "To add a single element to a list or a set, use the add() function. The specified object is appended to the end of the collection."}, {"type": "a", "text": "add()"}, {"type": "code", "text": "add()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    numbers.add(5)\n    println(numbers)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    numbers.add(5)\n    println(numbers)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    numbers.add(5)\n    println(numbers)\n//sampleEnd\n}\n"}, {"type": "p", "text": "addAll() adds every element of the argument object to a list or a set. The argument can be an Iterable, a Sequence, or an Array.\nThe types of the receiver and the argument may be different, for example, you can add all items from a Set to a List."}, {"type": "a", "text": "addAll()"}, {"type": "code", "text": "addAll()"}, {"type": "code", "text": "Iterable"}, {"type": "code", "text": "Sequence"}, {"type": "code", "text": "Array"}, {"type": "code", "text": "Set"}, {"type": "code", "text": "List"}, {"type": "p", "text": "When called on lists, addAll() adds new elements in the same order as they go in the argument.\nYou can also call addAll() specifying an element position as the first argument.\nThe first element of the argument collection will be inserted at this position.\nOther elements of the argument collection will follow it, shifting the receiver elements to the end."}, {"type": "code", "text": "addAll()"}, {"type": "code", "text": "addAll()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 5, 6)\n    numbers.addAll(arrayOf(7, 8))\n    println(numbers)\n    numbers.addAll(2, setOf(3, 4))\n    println(numbers)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 5, 6)\n    numbers.addAll(arrayOf(7, 8))\n    println(numbers)\n    numbers.addAll(2, setOf(3, 4))\n    println(numbers)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 5, 6)\n    numbers.addAll(arrayOf(7, 8))\n    println(numbers)\n    numbers.addAll(2, setOf(3, 4))\n    println(numbers)\n//sampleEnd\n}\n"}, {"type": "p", "text": "You can also add elements using the in-place version of the plus operator - plusAssign (+=)\n When applied to a mutable collection, += appends the second operand (an element or another collection) to the end of the collection."}, {"type": "a", "text": "plus operator"}, {"type": "code", "text": "plus"}, {"type": "a", "text": "plusAssign"}, {"type": "code", "text": "plusAssign"}, {"type": "code", "text": "+="}, {"type": "code", "text": "+="}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\")\n    numbers += \"three\"\n    println(numbers)\n    numbers += listOf(\"four\", \"five\")    \n    println(numbers)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\")\n    numbers += \"three\"\n    println(numbers)\n    numbers += listOf(\"four\", \"five\")    \n    println(numbers)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\")\n    numbers += \"three\"\n    println(numbers)\n    numbers += listOf(\"four\", \"five\")    \n    println(numbers)\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Removing elements"}, {"type": "p", "text": "To remove an element from a mutable collection, use the remove() function.\nremove() accepts the element value and removes one occurrence of this value."}, {"type": "a", "text": "remove()"}, {"type": "code", "text": "remove()"}, {"type": "code", "text": "remove()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4, 3)\n    numbers.remove(3)                    // removes the first `3`\n    println(numbers)\n    numbers.remove(5)                    // removes nothing\n    println(numbers)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4, 3)\n    numbers.remove(3)                    // removes the first `3`\n    println(numbers)\n    numbers.remove(5)                    // removes nothing\n    println(numbers)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4, 3)\n    numbers.remove(3)                    // removes the first `3`\n    println(numbers)\n    numbers.remove(5)                    // removes nothing\n    println(numbers)\n//sampleEnd\n}\n"}, {"type": "p", "text": "For removing multiple elements at once, there are the following functions :"}, {"type": "ul", "text": "\nremoveAll() removes all elements that are present in the argument collection.\n Alternatively, you can call it with a predicate as an argument; in this case the function removes all elements for which the predicate yields true.\nretainAll() is the opposite of removeAll(): it removes all elements except the ones from the argument collection.\n When used with a predicate, it leaves only elements that match it.\nclear() removes all elements from a list and leaves it empty.\n"}, {"type": "li", "text": "removeAll() removes all elements that are present in the argument collection.\n Alternatively, you can call it with a predicate as an argument; in this case the function removes all elements for which the predicate yields true."}, {"type": "a", "text": "removeAll()"}, {"type": "code", "text": "removeAll()"}, {"type": "code", "text": "true"}, {"type": "li", "text": "retainAll() is the opposite of removeAll(): it removes all elements except the ones from the argument collection.\n When used with a predicate, it leaves only elements that match it."}, {"type": "a", "text": "retainAll()"}, {"type": "code", "text": "retainAll()"}, {"type": "code", "text": "removeAll()"}, {"type": "li", "text": "clear() removes all elements from a list and leaves it empty."}, {"type": "a", "text": "clear()"}, {"type": "code", "text": "clear()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    println(numbers)\n    numbers.retainAll { it >= 3 }\n    println(numbers)\n    numbers.clear()\n    println(numbers)\n\n    val numbersSet = mutableSetOf(\"one\", \"two\", \"three\", \"four\")\n    numbersSet.removeAll(setOf(\"one\", \"two\"))\n    println(numbersSet)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    println(numbers)\n    numbers.retainAll { it >= 3 }\n    println(numbers)\n    numbers.clear()\n    println(numbers)\n\n    val numbersSet = mutableSetOf(\"one\", \"two\", \"three\", \"four\")\n    numbersSet.removeAll(setOf(\"one\", \"two\"))\n    println(numbersSet)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    println(numbers)\n    numbers.retainAll { it >= 3 }\n    println(numbers)\n    numbers.clear()\n    println(numbers)\n\n    val numbersSet = mutableSetOf(\"one\", \"two\", \"three\", \"four\")\n    numbersSet.removeAll(setOf(\"one\", \"two\"))\n    println(numbersSet)\n//sampleEnd\n}\n"}, {"type": "p", "text": "Another way to remove elements from a collection is with the minusAssign (-=) operator \u2013 the in-place version of minus. \nThe second argument can be a single instance of the element type or another collection.\nWith a single element on the right-hand side, -= removes the first occurrence of it.\nIn turn, if it's a collection, all occurrences of its elements are removed.\nFor example, if a list contains duplicate elements, they are removed at once.\nThe second operand can contain elements that are not present in the collection. Such elements don't affect the operation execution."}, {"type": "a", "text": "minusAssign"}, {"type": "code", "text": "minusAssign"}, {"type": "code", "text": "-="}, {"type": "a", "text": "minus"}, {"type": "code", "text": "minus"}, {"type": "code", "text": "-="}, {"type": "em", "text": "first"}, {"type": "em", "text": "all"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"three\", \"four\")\n    numbers -= \"three\"\n    println(numbers)\n    numbers -= listOf(\"four\", \"five\")    \n    //numbers -= listOf(\"four\")    // does the same as above\n    println(numbers)    \n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"three\", \"four\")\n    numbers -= \"three\"\n    println(numbers)\n    numbers -= listOf(\"four\", \"five\")    \n    //numbers -= listOf(\"four\")    // does the same as above\n    println(numbers)    \n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"three\", \"four\")\n    numbers -= \"three\"\n    println(numbers)\n    numbers -= listOf(\"four\", \"five\")    \n    //numbers -= listOf(\"four\")    // does the same as above\n    println(numbers)    \n//sampleEnd\n}\n"}, {"type": "h2", "text": "Updating elements"}, {"type": "p", "text": "Lists and maps also provide operations for updating elements.\nThey are described in List Specific Operations and Map Specific Operations.\nFor sets, updating doesn't make sense since it's actually removing an element and adding another one."}, {"type": "a", "text": "List Specific Operations"}, {"type": "a", "text": "Map Specific Operations"}]