[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Calling JavaScript from Kotlin"}, {"type": "p", "text": "Kotlin was designed for easy interoperation with Java platform. It sees Java classes as Kotlin classes, and\nJava sees Kotlin classes as Java classes. However, JavaScript is a dynamically-typed language, which means\nit does not check types in compile-time. You can freely talk to JavaScript from Kotlin via \ndynamic types, but if you want the full power of Kotlin\ntype system, you can create Kotlin headers for JavaScript libraries."}, {"type": "a", "text": "dynamic"}, {"type": "h2", "text": "Inline JavaScript"}, {"type": "p", "text": "You can inline some JavaScript code into your Kotlin code using the js(\"\u2026\") function.\nFor example:"}, {"type": "a", "text": "js(\"\u2026\")"}, {"type": "div", "text": "\nfun jsTypeOf(o: Any): String {\n    return js(\"typeof o\")\n}\n\n"}, {"type": "pre", "text": "fun jsTypeOf(o: Any): String {\n    return js(\"typeof o\")\n}\n"}, {"type": "code", "text": "fun jsTypeOf(o: Any): String {\n    return js(\"typeof o\")\n}\n"}, {"type": "p", "text": "The parameter of js is required to be a string constant. So, the following code is incorrect:"}, {"type": "code", "text": "js"}, {"type": "div", "text": "\nfun jsTypeOf(o: Any): String {\n    return js(getTypeof() + \" o\") // error reported here\n}\nfun getTypeof() = \"typeof\"\n\n"}, {"type": "pre", "text": "fun jsTypeOf(o: Any): String {\n    return js(getTypeof() + \" o\") // error reported here\n}\nfun getTypeof() = \"typeof\"\n"}, {"type": "code", "text": "fun jsTypeOf(o: Any): String {\n    return js(getTypeof() + \" o\") // error reported here\n}\nfun getTypeof() = \"typeof\"\n"}, {"type": "h2", "text": "external modifier"}, {"type": "code", "text": "external"}, {"type": "p", "text": "To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with external modifier.\nWhen the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or\nproperty is provided by the developer, and therefore does not try to generate any JavaScript code from the declaration.\nThis means that you should omit bodies of external declarations. For example:"}, {"type": "code", "text": "external"}, {"type": "code", "text": "external"}, {"type": "div", "text": "\nexternal fun alert(message: Any?): Unit\n\nexternal class Node {\n    val firstChild: Node\n\n    fun append(child: Node): Node\n\n    fun removeChild(child: Node): Node\n\n    // etc\n}\n\nexternal val window: Window\n\n"}, {"type": "pre", "text": "external fun alert(message: Any?): Unit\n\nexternal class Node {\n    val firstChild: Node\n\n    fun append(child: Node): Node\n\n    fun removeChild(child: Node): Node\n\n    // etc\n}\n\nexternal val window: Window\n"}, {"type": "code", "text": "external fun alert(message: Any?): Unit\n\nexternal class Node {\n    val firstChild: Node\n\n    fun append(child: Node): Node\n\n    fun removeChild(child: Node): Node\n\n    // etc\n}\n\nexternal val window: Window\n"}, {"type": "p", "text": "Note that external modifier is inherited by nested declarations, i.e. in Node class we do not put external\nbefore member functions and properties."}, {"type": "code", "text": "external"}, {"type": "code", "text": "Node"}, {"type": "code", "text": "external"}, {"type": "p", "text": "The external modifier is only allowed on package-level declarations. You can't declare an external member of a non-external class."}, {"type": "code", "text": "external"}, {"type": "code", "text": "external"}, {"type": "code", "text": "external"}, {"type": "h3", "text": "Declaring (static) members of a class"}, {"type": "p", "text": "In JavaScript you can define members either on a prototype or a class itself. I.e.:"}, {"type": "div", "text": "\nfunction MyClass() { ... }\nMyClass.sharedMember = function() { /* implementation */ };\nMyClass.prototype.ownMember = function() { /* implementation */ };\n\n"}, {"type": "pre", "text": "function MyClass() { ... }\nMyClass.sharedMember = function() { /* implementation */ };\nMyClass.prototype.ownMember = function() { /* implementation */ };\n"}, {"type": "code", "text": "function MyClass() { ... }\nMyClass.sharedMember = function() { /* implementation */ };\nMyClass.prototype.ownMember = function() { /* implementation */ };\n"}, {"type": "p", "text": "There's no such syntax in Kotlin. However, in Kotlin we have companion objects. Kotlin treats companion objects\nof external class in a special way: instead of expecting an object, it assumes members of companion objects\nto be members of the class itself. To describe MyClass from the example above, you can write:"}, {"type": "code", "text": "companion"}, {"type": "code", "text": "external"}, {"type": "code", "text": "MyClass"}, {"type": "div", "text": "\nexternal class MyClass {\n    companion object {\n        fun sharedMember()\n    }\n\n    fun ownMember()\n}\n\n"}, {"type": "pre", "text": "external class MyClass {\n    companion object {\n        fun sharedMember()\n    }\n\n    fun ownMember()\n}\n"}, {"type": "code", "text": "external class MyClass {\n    companion object {\n        fun sharedMember()\n    }\n\n    fun ownMember()\n}\n"}, {"type": "h3", "text": "Declaring optional parameters"}, {"type": "p", "text": "An external function can have optional parameters.\nHow the JavaScript implementation actually computes default values for these parameters, is unknown to Kotlin,\nthus it's impossible to use the usual syntax to declare such parameters in Kotlin.\nYou should use the following syntax:"}, {"type": "div", "text": "\nexternal fun myFunWithOptionalArgs(x: Int,\n    y: String = definedExternally,\n    z: Long = definedExternally)\n\n"}, {"type": "pre", "text": "external fun myFunWithOptionalArgs(x: Int,\n    y: String = definedExternally,\n    z: Long = definedExternally)\n"}, {"type": "code", "text": "external fun myFunWithOptionalArgs(x: Int,\n    y: String = definedExternally,\n    z: Long = definedExternally)\n"}, {"type": "p", "text": "This means you can call myFunWithOptionalArgs with one required argument and two optional arguments (their\ndefault values are calculated by some JavaScript code)."}, {"type": "code", "text": "myFunWithOptionalArgs"}, {"type": "h3", "text": "Extending JavaScript classes"}, {"type": "p", "text": "You can easily extend JavaScript classes as they were Kotlin classes. Just define an external class and\nextend it by non-external class. For example:"}, {"type": "code", "text": "external"}, {"type": "code", "text": "external"}, {"type": "div", "text": "\nexternal open class HTMLElement : Element() {\n    /* members */\n}\n\nclass CustomElement : HTMLElement() {\n    fun foo() {\n        alert(\"bar\")\n    }\n}\n\n"}, {"type": "pre", "text": "external open class HTMLElement : Element() {\n    /* members */\n}\n\nclass CustomElement : HTMLElement() {\n    fun foo() {\n        alert(\"bar\")\n    }\n}\n"}, {"type": "code", "text": "external open class HTMLElement : Element() {\n    /* members */\n}\n\nclass CustomElement : HTMLElement() {\n    fun foo() {\n        alert(\"bar\")\n    }\n}\n"}, {"type": "p", "text": "There are some limitations:"}, {"type": "ol", "text": "\nWhen a function of external base class is overloaded by signature, you can't override it in a derived class.\nYou can't override a function with default arguments.\n"}, {"type": "li", "text": "When a function of external base class is overloaded by signature, you can't override it in a derived class."}, {"type": "li", "text": "You can't override a function with default arguments."}, {"type": "p", "text": "Note that you can't extend a non-external class by external classes."}, {"type": "h3", "text": "external interfaces"}, {"type": "code", "text": "external"}, {"type": "p", "text": "JavaScript does not have the concept of interfaces. When a function expects its parameter to support foo\nand bar methods, you just pass objects that actually have these methods. You can use interfaces to express this\nfor statically-typed Kotlin, for example:"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "bar"}, {"type": "div", "text": "\nexternal interface HasFooAndBar {\n    fun foo()\n\n    fun bar()\n}\n\nexternal fun myFunction(p: HasFooAndBar)\n\n"}, {"type": "pre", "text": "external interface HasFooAndBar {\n    fun foo()\n\n    fun bar()\n}\n\nexternal fun myFunction(p: HasFooAndBar)\n"}, {"type": "code", "text": "external interface HasFooAndBar {\n    fun foo()\n\n    fun bar()\n}\n\nexternal fun myFunction(p: HasFooAndBar)\n"}, {"type": "p", "text": "Another use case for external interfaces is to describe settings objects. For example:"}, {"type": "div", "text": "\nexternal interface JQueryAjaxSettings {\n    var async: Boolean\n\n    var cache: Boolean\n\n    var complete: (JQueryXHR, String) -> Unit\n\n    // etc\n}\n\nfun JQueryAjaxSettings(): JQueryAjaxSettings = js(\"{}\")\n\nexternal class JQuery {\n    companion object {\n        fun get(settings: JQueryAjaxSettings): JQueryXHR\n    }\n}\n\nfun sendQuery() {\n    JQuery.get(JQueryAjaxSettings().apply {\n        complete = { (xhr, data) ->\n            window.alert(\"Request complete\")\n        }\n    })\n}\n\n"}, {"type": "pre", "text": "external interface JQueryAjaxSettings {\n    var async: Boolean\n\n    var cache: Boolean\n\n    var complete: (JQueryXHR, String) -> Unit\n\n    // etc\n}\n\nfun JQueryAjaxSettings(): JQueryAjaxSettings = js(\"{}\")\n\nexternal class JQuery {\n    companion object {\n        fun get(settings: JQueryAjaxSettings): JQueryXHR\n    }\n}\n\nfun sendQuery() {\n    JQuery.get(JQueryAjaxSettings().apply {\n        complete = { (xhr, data) ->\n            window.alert(\"Request complete\")\n        }\n    })\n}\n"}, {"type": "code", "text": "external interface JQueryAjaxSettings {\n    var async: Boolean\n\n    var cache: Boolean\n\n    var complete: (JQueryXHR, String) -> Unit\n\n    // etc\n}\n\nfun JQueryAjaxSettings(): JQueryAjaxSettings = js(\"{}\")\n\nexternal class JQuery {\n    companion object {\n        fun get(settings: JQueryAjaxSettings): JQueryXHR\n    }\n}\n\nfun sendQuery() {\n    JQuery.get(JQueryAjaxSettings().apply {\n        complete = { (xhr, data) ->\n            window.alert(\"Request complete\")\n        }\n    })\n}\n"}, {"type": "p", "text": "External interfaces have some restrictions:"}, {"type": "ol", "text": "\nThey can't be used on the right hand side of is checks.\nas cast to external interface always succeeds (and produces a warning in compile-time).\nThey can't be passed as reified type arguments.\nThey can't be used in class literal expressions (i.e. I::class).\n"}, {"type": "li", "text": "They can't be used on the right hand side of is checks."}, {"type": "code", "text": "is"}, {"type": "li", "text": "as cast to external interface always succeeds (and produces a warning in compile-time)."}, {"type": "code", "text": "as"}, {"type": "li", "text": "They can't be passed as reified type arguments."}, {"type": "li", "text": "They can't be used in class literal expressions (i.e. I::class)."}, {"type": "code", "text": "I::class"}]