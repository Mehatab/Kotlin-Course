[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Inline Functions"}, {"type": "p", "text": "Using higher-order functions imposes certain runtime penalties: each function is an object, and it captures a closure,\ni.e. those variables that are accessed in the body of the function.\nMemory allocations (both for function objects and classes) and virtual calls introduce runtime overhead."}, {"type": "a", "text": "higher-order functions"}, {"type": "p", "text": "But it appears that in many cases this kind of overhead can be eliminated by inlining the lambda expressions.\nThe functions shown below are good examples of this situation. I.e., the lock() function could be easily inlined at call-sites.\nConsider the following case:"}, {"type": "code", "text": "lock()"}, {"type": "div", "text": "\nlock(l) { foo() }\n\n"}, {"type": "pre", "text": "lock(l) { foo() }\n"}, {"type": "code", "text": "lock(l) { foo() }\n"}, {"type": "p", "text": "Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code:"}, {"type": "div", "text": "\nl.lock()\ntry {\n    foo()\n}\nfinally {\n    l.unlock()\n}\n\n"}, {"type": "pre", "text": "l.lock()\ntry {\n    foo()\n}\nfinally {\n    l.unlock()\n}\n"}, {"type": "code", "text": "l.lock()\ntry {\n    foo()\n}\nfinally {\n    l.unlock()\n}\n"}, {"type": "p", "text": "Isn't it what we wanted from the very beginning?"}, {"type": "p", "text": "To make the compiler do this, we need to mark the lock() function with the inline modifier:"}, {"type": "code", "text": "lock()"}, {"type": "code", "text": "inline"}, {"type": "div", "text": "\ninline fun <T> lock(lock: Lock, body: () -> T): T { ... }\n\n"}, {"type": "pre", "text": "inline fun <T> lock(lock: Lock, body: () -> T): T { ... }\n"}, {"type": "code", "text": "inline fun <T> lock(lock: Lock, body: () -> T): T { ... }\n"}, {"type": "p", "text": "The inline modifier affects both the function itself and the lambdas passed to it: all of those will be inlined\ninto the call site."}, {"type": "code", "text": "inline"}, {"type": "p", "text": "Inlining may cause the generated code to grow; however, if we do it in a reasonable way (i.e. avoiding inlining large functions), it will pay off in performance, especially at \"megamorphic\" call-sites inside loops."}, {"type": "h2", "text": "noinline"}, {"type": "p", "text": "In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function\nparameters with the noinline modifier:"}, {"type": "code", "text": "noinline"}, {"type": "div", "text": "\ninline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) { ... }\n\n"}, {"type": "pre", "text": "inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) { ... }\n"}, {"type": "code", "text": "inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) { ... }\n"}, {"type": "p", "text": "Inlinable lambdas can only be called inside the inline functions or passed as inlinable arguments,\nbut noinline ones can be manipulated in any way we like: stored in fields, passed around etc."}, {"type": "code", "text": "noinline"}, {"type": "p", "text": "Note that if an inline function has no inlinable function parameters and no\nreified type parameters, the compiler will issue a warning, since inlining such functions is\n very unlikely to be beneficial (you can suppress the warning if you are sure the inlining is needed using the annotation @Suppress(\"NOTHING_TO_INLINE\"))."}, {"type": "a", "text": "reified type parameters"}, {"type": "code", "text": "@Suppress(\"NOTHING_TO_INLINE\")"}, {"type": "h2", "text": "Non-local returns"}, {"type": "p", "text": "In Kotlin, we can only use a normal, unqualified return to exit a named function or an anonymous function.\nThis means that to exit a lambda, we have to use a label, and a bare return is forbidden\ninside a lambda, because a lambda cannot make the enclosing function return:"}, {"type": "code", "text": "return"}, {"type": "a", "text": "label"}, {"type": "code", "text": "return"}, {"type": "div", "text": "\nfun ordinaryFunction(block: () -> Unit) {\n    println(\"hi!\")\n}\n//sampleStart\nfun foo() {\n    ordinaryFunction {\n        return // ERROR: cannot make `foo` return here\n    }\n}\n//sampleEnd\nfun main() {\n    foo()\n}\n\n"}, {"type": "pre", "text": "fun ordinaryFunction(block: () -> Unit) {\n    println(\"hi!\")\n}\n//sampleStart\nfun foo() {\n    ordinaryFunction {\n        return // ERROR: cannot make `foo` return here\n    }\n}\n//sampleEnd\nfun main() {\n    foo()\n}\n"}, {"type": "code", "text": "fun ordinaryFunction(block: () -> Unit) {\n    println(\"hi!\")\n}\n//sampleStart\nfun foo() {\n    ordinaryFunction {\n        return // ERROR: cannot make `foo` return here\n    }\n}\n//sampleEnd\nfun main() {\n    foo()\n}\n"}, {"type": "p", "text": "But if the function the lambda is passed to is inlined, the return can be inlined as well, so it is allowed:"}, {"type": "div", "text": "\ninline fun inlined(block: () -> Unit) {\n    println(\"hi!\")\n}\n//sampleStart\nfun foo() {\n    inlined {\n        return // OK: the lambda is inlined\n    }\n}\n//sampleEnd\nfun main() {\n    foo()\n}\n\n"}, {"type": "p", "text": "inline fun inlined(block: () -> Unit) {\n    println(\"hi!\")\n}"}, {"type": "pre", "text": "//sampleStart\nfun foo() {\n    inlined {\n        return // OK: the lambda is inlined\n    }\n}\n//sampleEnd\nfun main() {\n    foo()\n}\n"}, {"type": "code", "text": "//sampleStart\nfun foo() {\n    inlined {\n        return // OK: the lambda is inlined\n    }\n}\n//sampleEnd\nfun main() {\n    foo()\n}\n"}, {"type": "p", "text": "Such returns (located in a lambda, but exiting the enclosing function) are called non-local returns. We are used to\nthis sort of construct in loops, which inline functions often enclose:"}, {"type": "em", "text": "non-local"}, {"type": "div", "text": "\nfun hasZeros(ints: List<Int>): Boolean {\n    ints.forEach {\n        if (it == 0) return true // returns from hasZeros\n    }\n    return false\n}\n\n"}, {"type": "pre", "text": "fun hasZeros(ints: List<Int>): Boolean {\n    ints.forEach {\n        if (it == 0) return true // returns from hasZeros\n    }\n    return false\n}\n"}, {"type": "code", "text": "fun hasZeros(ints: List<Int>): Boolean {\n    ints.forEach {\n        if (it == 0) return true // returns from hasZeros\n    }\n    return false\n}\n"}, {"type": "p", "text": "Note that some inline functions may call the lambdas passed to them as parameters not directly from the function body,\nbut from another execution context, such as a local object or a nested function. In such cases, non-local control flow\nis also not allowed in the lambdas. To indicate that, the lambda parameter needs to be marked with\nthe crossinline modifier:"}, {"type": "code", "text": "crossinline"}, {"type": "div", "text": "\ninline fun f(crossinline body: () -> Unit) {\n    val f = object: Runnable {\n        override fun run() = body()\n    }\n    // ...\n}\n\n"}, {"type": "pre", "text": "inline fun f(crossinline body: () -> Unit) {\n    val f = object: Runnable {\n        override fun run() = body()\n    }\n    // ...\n}\n"}, {"type": "code", "text": "inline fun f(crossinline body: () -> Unit) {\n    val f = object: Runnable {\n        override fun run() = body()\n    }\n    // ...\n}\n"}, {"type": "blockquote", "text": "\nbreak and continue are not yet available in inlined lambdas, but we are planning to support them too.\n"}, {"type": "p", "text": "break and continue are not yet available in inlined lambdas, but we are planning to support them too."}, {"type": "code", "text": "break"}, {"type": "code", "text": "continue"}, {"type": "h2", "text": "Reified type parameters"}, {"type": "p", "text": "Sometimes we need to access a type passed to us as a parameter:"}, {"type": "div", "text": "\nfun <T> TreeNode.findParentOfType(clazz: Class<T>): T? {\n    var p = parent\n    while (p != null && !clazz.isInstance(p)) {\n        p = p.parent\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return p as T?\n}\n\n"}, {"type": "pre", "text": "fun <T> TreeNode.findParentOfType(clazz: Class<T>): T? {\n    var p = parent\n    while (p != null && !clazz.isInstance(p)) {\n        p = p.parent\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return p as T?\n}\n"}, {"type": "code", "text": "fun <T> TreeNode.findParentOfType(clazz: Class<T>): T? {\n    var p = parent\n    while (p != null && !clazz.isInstance(p)) {\n        p = p.parent\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return p as T?\n}\n"}, {"type": "p", "text": "Here, we walk up a tree and use reflection to check if a node has a certain type.\nIt\u2019s all fine, but the call site is not very pretty:"}, {"type": "div", "text": "\ntreeNode.findParentOfType(MyTreeNode::class.java)\n\n"}, {"type": "pre", "text": "treeNode.findParentOfType(MyTreeNode::class.java)\n"}, {"type": "code", "text": "treeNode.findParentOfType(MyTreeNode::class.java)\n"}, {"type": "p", "text": "What we actually want is simply pass a type to this function, i.e. call it like this:"}, {"type": "div", "text": "\ntreeNode.findParentOfType<MyTreeNode>()\n\n"}, {"type": "pre", "text": "treeNode.findParentOfType<MyTreeNode>()\n"}, {"type": "code", "text": "treeNode.findParentOfType<MyTreeNode>()\n"}, {"type": "p", "text": "To enable this, inline functions support reified type parameters, so we can write something like this:"}, {"type": "em", "text": "reified type parameters"}, {"type": "div", "text": "\ninline fun <reified T> TreeNode.findParentOfType(): T? {\n    var p = parent\n    while (p != null && p !is T) {\n        p = p.parent\n    }\n    return p as T?\n}\n\n"}, {"type": "pre", "text": "inline fun <reified T> TreeNode.findParentOfType(): T? {\n    var p = parent\n    while (p != null && p !is T) {\n        p = p.parent\n    }\n    return p as T?\n}\n"}, {"type": "code", "text": "inline fun <reified T> TreeNode.findParentOfType(): T? {\n    var p = parent\n    while (p != null && p !is T) {\n        p = p.parent\n    }\n    return p as T?\n}\n"}, {"type": "p", "text": "We qualified the type parameter with the reified modifier, now it\u2019s accessible inside the function,\nalmost as if it were a normal class. Since the function is inlined, no reflection is needed, normal operators like !is\nand as are working now. Also, we can call it as mentioned above: myTree.findParentOfType<MyTreeNodeType>()."}, {"type": "code", "text": "reified"}, {"type": "code", "text": "!is"}, {"type": "code", "text": "as"}, {"type": "code", "text": "myTree.findParentOfType<MyTreeNodeType>()"}, {"type": "p", "text": "Though reflection may not be needed in many cases, we can still use it with a reified type parameter:"}, {"type": "div", "text": "\ninline fun <reified T> membersOf() = T::class.members\n\nfun main(s: Array<String>) {\n    println(membersOf<StringBuilder>().joinToString(\"\\n\"))\n}\n\n"}, {"type": "pre", "text": "inline fun <reified T> membersOf() = T::class.members\n\nfun main(s: Array<String>) {\n    println(membersOf<StringBuilder>().joinToString(\"\\n\"))\n}\n"}, {"type": "code", "text": "inline fun <reified T> membersOf() = T::class.members\n\nfun main(s: Array<String>) {\n    println(membersOf<StringBuilder>().joinToString(\"\\n\"))\n}\n"}, {"type": "p", "text": "Normal functions (not marked as inline) cannot have reified parameters.\nA type that does not have a run-time representation (e.g. a non-reified type parameter or a fictitious type like Nothing)\ncannot be used as an argument for a reified type parameter."}, {"type": "code", "text": "Nothing"}, {"type": "p", "text": "For a low-level description, see the spec document."}, {"type": "a", "text": "spec document"}, {"type": "h2", "text": "Inline properties (since 1.1)"}, {"type": "p", "text": "The inline modifier can be used on accessors of properties that don't have a backing field.\nYou can annotate individual property accessors:"}, {"type": "code", "text": "inline"}, {"type": "div", "text": "\nval foo: Foo\n    inline get() = Foo()\n\nvar bar: Bar\n    get() = ...\n    inline set(v) { ... }\n\n"}, {"type": "pre", "text": "val foo: Foo\n    inline get() = Foo()\n\nvar bar: Bar\n    get() = ...\n    inline set(v) { ... }\n"}, {"type": "code", "text": "val foo: Foo\n    inline get() = Foo()\n\nvar bar: Bar\n    get() = ...\n    inline set(v) { ... }\n"}, {"type": "p", "text": "You can also annotate an entire property, which marks both of its accessors as inline:"}, {"type": "div", "text": "\ninline var bar: Bar\n    get() = ...\n    set(v) { ... }\n\n"}, {"type": "pre", "text": "inline var bar: Bar\n    get() = ...\n    set(v) { ... }\n"}, {"type": "code", "text": "inline var bar: Bar\n    get() = ...\n    set(v) { ... }\n"}, {"type": "p", "text": "At the call site, inline accessors are inlined as regular inline functions."}, {"type": "h2", "text": "Restrictions for public API inline functions"}, {"type": "p", "text": "When an inline function is public or protected and is not a part of a private or internal declaration, it is considered a module's public API. It can be called in other modules and is inlined at such call sites as well."}, {"type": "code", "text": "public"}, {"type": "code", "text": "protected"}, {"type": "code", "text": "private"}, {"type": "code", "text": "internal"}, {"type": "a", "text": "module"}, {"type": "p", "text": "This imposes certain risks of binary incompatibility caused by changes in the module that declares an inline function in case the calling module is not re-compiled after the change."}, {"type": "p", "text": "To eliminate the risk of such incompatibility being introduced by a change in non-public API of a module, the public API inline functions are not allowed to use non-public-API declarations, i.e. private and internal declarations and their parts, in their bodies."}, {"type": "strong", "text": "non"}, {"type": "code", "text": "private"}, {"type": "code", "text": "internal"}, {"type": "p", "text": "An internal declaration can be annotated with @PublishedApi, which allows its use in public API inline functions. When an internal inline function is marked as @PublishedApi, its body is checked too, as if it were public."}, {"type": "code", "text": "internal"}, {"type": "code", "text": "@PublishedApi"}, {"type": "code", "text": "internal"}, {"type": "code", "text": "@PublishedApi"}]