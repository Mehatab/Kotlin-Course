[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Control Flow: if, when, for, while"}, {"type": "h2", "text": "If Expression"}, {"type": "p", "text": "In Kotlin, if is an expression, i.e. it returns a value.\nTherefore there is no ternary operator (condition ? then : else), because ordinary if works fine in this role."}, {"type": "em", "text": "if"}, {"type": "em", "text": "if"}, {"type": "div", "text": "\n// Traditional usage \nvar max = a \nif (a < b) max = b\n\n// With else \nvar max: Int\nif (a > b) {\n    max = a\n} else {\n    max = b\n}\n \n// As expression \nval max = if (a > b) a else b\n\n"}, {"type": "pre", "text": "// Traditional usage \nvar max = a \nif (a < b) max = b\n\n// With else \nvar max: Int\nif (a > b) {\n    max = a\n} else {\n    max = b\n}\n \n// As expression \nval max = if (a > b) a else b\n"}, {"type": "code", "text": "// Traditional usage \nvar max = a \nif (a < b) max = b\n\n// With else \nvar max: Int\nif (a > b) {\n    max = a\n} else {\n    max = b\n}\n \n// As expression \nval max = if (a > b) a else b\n"}, {"type": "p", "text": "if branches can be blocks, and the last expression is the value of a block:"}, {"type": "em", "text": "if"}, {"type": "div", "text": "\nval max = if (a > b) {\n    print(\"Choose a\")\n    a\n} else {\n    print(\"Choose b\")\n    b\n}\n\n"}, {"type": "pre", "text": "val max = if (a > b) {\n    print(\"Choose a\")\n    a\n} else {\n    print(\"Choose b\")\n    b\n}\n"}, {"type": "code", "text": "val max = if (a > b) {\n    print(\"Choose a\")\n    a\n} else {\n    print(\"Choose b\")\n    b\n}\n"}, {"type": "p", "text": "If you're using if as an expression rather than a statement (for example, returning its value or\nassigning it to a variable), the expression is required to have an else branch."}, {"type": "em", "text": "if"}, {"type": "code", "text": "else"}, {"type": "p", "text": "See the grammar for if."}, {"type": "a", "text": "grammar for if"}, {"type": "em", "text": "if"}, {"type": "h2", "text": "When Expression"}, {"type": "p", "text": "when replaces the switch operator of C-like languages. In the simplest form it looks like this"}, {"type": "em", "text": "when"}, {"type": "div", "text": "\nwhen (x) {\n    1 -> print(\"x == 1\")\n    2 -> print(\"x == 2\")\n    else -> { // Note the block\n        print(\"x is neither 1 nor 2\")\n    }\n}\n\n"}, {"type": "pre", "text": "when (x) {\n    1 -> print(\"x == 1\")\n    2 -> print(\"x == 2\")\n    else -> { // Note the block\n        print(\"x is neither 1 nor 2\")\n    }\n}\n"}, {"type": "code", "text": "when (x) {\n    1 -> print(\"x == 1\")\n    2 -> print(\"x == 2\")\n    else -> { // Note the block\n        print(\"x is neither 1 nor 2\")\n    }\n}\n"}, {"type": "p", "text": "when matches its argument against all branches sequentially until some branch condition is satisfied.\nwhen can be used either as an expression or as a statement. If it is used as an expression, the value\nof the satisfied branch becomes the value of the overall expression. If it is used as a statement, the values of\nindividual branches are ignored. (Just like with if, each branch can be a block, and its value\nis the value of the last expression in the block.)"}, {"type": "em", "text": "when"}, {"type": "em", "text": "when"}, {"type": "em", "text": "if"}, {"type": "p", "text": "The else branch is evaluated if none of the other branch conditions are satisfied.\nIf when is used as an expression, the else branch is mandatory,\nunless the compiler can prove that all possible cases are covered with branch conditions (as, for example, with enum class entries and sealed class subtypes)."}, {"type": "em", "text": "else"}, {"type": "em", "text": "when"}, {"type": "em", "text": "else"}, {"type": "a", "text": "enum class"}, {"type": "em", "text": "enum"}, {"type": "a", "text": "sealed class"}, {"type": "em", "text": "sealed"}, {"type": "p", "text": "If many cases should be handled in the same way, the branch conditions may be combined with a comma:"}, {"type": "div", "text": "\nwhen (x) {\n    0, 1 -> print(\"x == 0 or x == 1\")\n    else -> print(\"otherwise\")\n}\n\n"}, {"type": "pre", "text": "when (x) {\n    0, 1 -> print(\"x == 0 or x == 1\")\n    else -> print(\"otherwise\")\n}\n"}, {"type": "code", "text": "when (x) {\n    0, 1 -> print(\"x == 0 or x == 1\")\n    else -> print(\"otherwise\")\n}\n"}, {"type": "p", "text": "We can use arbitrary expressions (not only constants) as branch conditions"}, {"type": "div", "text": "\nwhen (x) {\n    parseInt(s) -> print(\"s encodes x\")\n    else -> print(\"s does not encode x\")\n}\n\n"}, {"type": "pre", "text": "when (x) {\n    parseInt(s) -> print(\"s encodes x\")\n    else -> print(\"s does not encode x\")\n}\n"}, {"type": "code", "text": "when (x) {\n    parseInt(s) -> print(\"s encodes x\")\n    else -> print(\"s does not encode x\")\n}\n"}, {"type": "p", "text": "We can also check a value for being in or !in a range or a collection:"}, {"type": "em", "text": "in"}, {"type": "em", "text": "!in"}, {"type": "a", "text": "range"}, {"type": "div", "text": "\nwhen (x) {\n    in 1..10 -> print(\"x is in the range\")\n    in validNumbers -> print(\"x is valid\")\n    !in 10..20 -> print(\"x is outside the range\")\n    else -> print(\"none of the above\")\n}\n\n"}, {"type": "pre", "text": "when (x) {\n    in 1..10 -> print(\"x is in the range\")\n    in validNumbers -> print(\"x is valid\")\n    !in 10..20 -> print(\"x is outside the range\")\n    else -> print(\"none of the above\")\n}\n"}, {"type": "code", "text": "when (x) {\n    in 1..10 -> print(\"x is in the range\")\n    in validNumbers -> print(\"x is valid\")\n    !in 10..20 -> print(\"x is outside the range\")\n    else -> print(\"none of the above\")\n}\n"}, {"type": "p", "text": "Another possibility is to check that a value is or !is of a particular type. Note that,\ndue to smart casts, you can access the methods and properties of the type without\nany extra checks."}, {"type": "em", "text": "is"}, {"type": "em", "text": "!is"}, {"type": "a", "text": "smart casts"}, {"type": "div", "text": "\nfun hasPrefix(x: Any) = when(x) {\n    is String -> x.startsWith(\"prefix\")\n    else -> false\n}\n\n"}, {"type": "pre", "text": "fun hasPrefix(x: Any) = when(x) {\n    is String -> x.startsWith(\"prefix\")\n    else -> false\n}\n"}, {"type": "code", "text": "fun hasPrefix(x: Any) = when(x) {\n    is String -> x.startsWith(\"prefix\")\n    else -> false\n}\n"}, {"type": "p", "text": "when can also be used as a replacement for an if-else if chain.\nIf no argument is supplied, the branch conditions are simply boolean expressions, and a branch is executed when its condition is true:"}, {"type": "em", "text": "when"}, {"type": "em", "text": "if"}, {"type": "em", "text": "else"}, {"type": "em", "text": "if"}, {"type": "div", "text": "\nwhen {\n    x.isOdd() -> print(\"x is odd\")\n    y.isEven() -> print(\"y is even\")\n    else -> print(\"x+y is even.\")\n}\n\n"}, {"type": "pre", "text": "when {\n    x.isOdd() -> print(\"x is odd\")\n    y.isEven() -> print(\"y is even\")\n    else -> print(\"x+y is even.\")\n}\n"}, {"type": "code", "text": "when {\n    x.isOdd() -> print(\"x is odd\")\n    y.isEven() -> print(\"y is even\")\n    else -> print(\"x+y is even.\")\n}\n"}, {"type": "p", "text": "Since Kotlin 1.3, it is possible to capture when subject in a variable using following syntax:"}, {"type": "em", "text": "when"}, {"type": "div", "text": "\nfun Request.getBody() =\n        when (val response = executeRequest()) {\n            is Success -> response.body\n            is HttpError -> throw HttpException(response.status)\n        }\n\n"}, {"type": "pre", "text": "fun Request.getBody() =\n        when (val response = executeRequest()) {\n            is Success -> response.body\n            is HttpError -> throw HttpException(response.status)\n        }\n"}, {"type": "code", "text": "fun Request.getBody() =\n        when (val response = executeRequest()) {\n            is Success -> response.body\n            is HttpError -> throw HttpException(response.status)\n        }\n"}, {"type": "p", "text": "Scope of variable, introduced in when subject, is restricted to when body."}, {"type": "em", "text": "when"}, {"type": "em", "text": "when"}, {"type": "p", "text": "See the grammar for when."}, {"type": "a", "text": "grammar for when"}, {"type": "em", "text": "when"}, {"type": "h2", "text": "For Loops"}, {"type": "p", "text": "for loop iterates through anything that provides an iterator. This is equivalent\nto the foreach loop in languages like C#. The syntax is as follows:"}, {"type": "em", "text": "for"}, {"type": "code", "text": "foreach"}, {"type": "div", "text": "\nfor (item in collection) print(item)\n\n"}, {"type": "pre", "text": "for (item in collection) print(item)\n"}, {"type": "code", "text": "for (item in collection) print(item)\n"}, {"type": "p", "text": "The body can be a block."}, {"type": "div", "text": "\nfor (item: Int in ints) {\n    // ...\n}\n\n"}, {"type": "pre", "text": "for (item: Int in ints) {\n    // ...\n}\n"}, {"type": "code", "text": "for (item: Int in ints) {\n    // ...\n}\n"}, {"type": "p", "text": "As mentioned before, for iterates through anything that provides an iterator, i.e."}, {"type": "em", "text": "for"}, {"type": "ul", "text": "\nhas a member- or extension-function iterator(), whose return type\n    \nhas a member- or extension-function next(), and\nhas a member- or extension-function hasNext() that returns Boolean.\n\n\n"}, {"type": "li", "text": "has a member- or extension-function iterator(), whose return type\n    \nhas a member- or extension-function next(), and\nhas a member- or extension-function hasNext() that returns Boolean.\n\n"}, {"type": "code", "text": "iterator()"}, {"type": "ul", "text": "\nhas a member- or extension-function next(), and\nhas a member- or extension-function hasNext() that returns Boolean.\n"}, {"type": "li", "text": "has a member- or extension-function next(), and"}, {"type": "code", "text": "next()"}, {"type": "li", "text": "has a member- or extension-function hasNext() that returns Boolean."}, {"type": "code", "text": "hasNext()"}, {"type": "code", "text": "Boolean"}, {"type": "p", "text": "All of these three functions need to be marked as operator."}, {"type": "code", "text": "operator"}, {"type": "p", "text": "To iterate over a range of numbers, use a range expression:"}, {"type": "a", "text": "range expression"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    for (i in 1..3) {\n        println(i)\n    }\n    for (i in 6 downTo 0 step 2) {\n        println(i)\n    }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    for (i in 1..3) {\n        println(i)\n    }\n    for (i in 6 downTo 0 step 2) {\n        println(i)\n    }\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    for (i in 1..3) {\n        println(i)\n    }\n    for (i in 6 downTo 0 step 2) {\n        println(i)\n    }\n//sampleEnd\n}\n"}, {"type": "p", "text": "A for loop over a range or an array is compiled to an index-based loop that does not create an iterator object."}, {"type": "code", "text": "for"}, {"type": "p", "text": "If you want to iterate through an array or a list with an index, you can do it this way:"}, {"type": "div", "text": "\nfun main() {\nval array = arrayOf(\"a\", \"b\", \"c\")\n//sampleStart\n    for (i in array.indices) {\n        println(array[i])\n    }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\nval array = arrayOf(\"a\", \"b\", \"c\")\n//sampleStart\n    for (i in array.indices) {\n        println(array[i])\n    }\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\nval array = arrayOf(\"a\", \"b\", \"c\")\n//sampleStart\n    for (i in array.indices) {\n        println(array[i])\n    }\n//sampleEnd\n}\n"}, {"type": "p", "text": "Alternatively, you can use the withIndex library function:"}, {"type": "code", "text": "withIndex"}, {"type": "div", "text": "\nfun main() {\n    val array = arrayOf(\"a\", \"b\", \"c\")\n//sampleStart\n    for ((index, value) in array.withIndex()) {\n        println(\"the element at $index is $value\")\n    }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n    val array = arrayOf(\"a\", \"b\", \"c\")\n//sampleStart\n    for ((index, value) in array.withIndex()) {\n        println(\"the element at $index is $value\")\n    }\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n    val array = arrayOf(\"a\", \"b\", \"c\")\n//sampleStart\n    for ((index, value) in array.withIndex()) {\n        println(\"the element at $index is $value\")\n    }\n//sampleEnd\n}\n"}, {"type": "p", "text": "See the grammar for for."}, {"type": "a", "text": "grammar for for"}, {"type": "em", "text": "for"}, {"type": "h2", "text": "While Loops"}, {"type": "p", "text": "while and do..while work as usual"}, {"type": "em", "text": "while"}, {"type": "em", "text": "do"}, {"type": "em", "text": "while"}, {"type": "div", "text": "\nwhile (x > 0) {\n    x--\n}\n\ndo {\n    val y = retrieveData()\n} while (y != null) // y is visible here!\n\n"}, {"type": "pre", "text": "while (x > 0) {\n    x--\n}\n\ndo {\n    val y = retrieveData()\n} while (y != null) // y is visible here!\n"}, {"type": "code", "text": "while (x > 0) {\n    x--\n}\n\ndo {\n    val y = retrieveData()\n} while (y != null) // y is visible here!\n"}, {"type": "p", "text": "See the grammar for while."}, {"type": "a", "text": "grammar for while"}, {"type": "em", "text": "while"}, {"type": "h2", "text": "Break and continue in loops"}, {"type": "p", "text": "Kotlin supports traditional break and continue operators in loops. See Returns and jumps."}, {"type": "em", "text": "break"}, {"type": "em", "text": "continue"}, {"type": "a", "text": "Returns and jumps"}]