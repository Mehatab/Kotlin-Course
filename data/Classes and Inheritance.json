[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Classes and Inheritance"}, {"type": "h2", "text": "Classes"}, {"type": "p", "text": "Classes in Kotlin are declared using the keyword class:"}, {"type": "em", "text": "class"}, {"type": "div", "text": "\nclass Invoice { /*...*/ }\n\n"}, {"type": "pre", "text": "class Invoice { /*...*/ }\n"}, {"type": "code", "text": "class Invoice { /*...*/ }\n"}, {"type": "p", "text": "The class declaration consists of the class name, the class header (specifying its type parameters, the primary\nconstructor etc.) and the class body, surrounded by curly braces. Both the header and the body are optional;\nif the class has no body, curly braces can be omitted."}, {"type": "div", "text": "\nclass Empty\n\n"}, {"type": "pre", "text": "class Empty\n"}, {"type": "code", "text": "class Empty\n"}, {"type": "h3", "text": "Constructors"}, {"type": "p", "text": "A class in Kotlin can have a primary constructor and one or more secondary constructors. The primary\nconstructor is part of the class header: it goes after the class name (and optional type parameters)."}, {"type": "strong", "text": "primary constructor"}, {"type": "strong", "text": "secondary constructors"}, {"type": "div", "text": "\nclass Person constructor(firstName: String) { /*...*/ }\n\n"}, {"type": "pre", "text": "class Person constructor(firstName: String) { /*...*/ }\n"}, {"type": "code", "text": "class Person constructor(firstName: String) { /*...*/ }\n"}, {"type": "p", "text": "If the primary constructor does not have any annotations or visibility modifiers, the constructor\nkeyword can be omitted:"}, {"type": "em", "text": "constructor"}, {"type": "div", "text": "\nclass Person(firstName: String) { /*...*/ }\n\n"}, {"type": "pre", "text": "class Person(firstName: String) { /*...*/ }\n"}, {"type": "code", "text": "class Person(firstName: String) { /*...*/ }\n"}, {"type": "p", "text": "The primary constructor cannot contain any code. Initialization code can be placed\nin initializer blocks, which are prefixed with the init keyword."}, {"type": "strong", "text": "initializer blocks"}, {"type": "em", "text": "init"}, {"type": "p", "text": "During an instance initialization, the initializer blocks are executed in the same order as they appear \nin the class body, interleaved with the property initializers:"}, {"type": "div", "text": "\n//sampleStart\nclass InitOrderDemo(name: String) {\n    val firstProperty = \"First property: $name\".also(::println)\n    \n    init {\n        println(\"First initializer block that prints ${name}\")\n    }\n    \n    val secondProperty = \"Second property: ${name.length}\".also(::println)\n    \n    init {\n        println(\"Second initializer block that prints ${name.length}\")\n    }\n}\n//sampleEnd\n\nfun main() {\n    InitOrderDemo(\"hello\")\n}\n\n"}, {"type": "pre", "text": "//sampleStart\nclass InitOrderDemo(name: String) {\n    val firstProperty = \"First property: $name\".also(::println)\n    \n    init {\n        println(\"First initializer block that prints ${name}\")\n    }\n    \n    val secondProperty = \"Second property: ${name.length}\".also(::println)\n    \n    init {\n        println(\"Second initializer block that prints ${name.length}\")\n    }\n}\n//sampleEnd\n\nfun main() {\n    InitOrderDemo(\"hello\")\n}\n"}, {"type": "code", "text": "//sampleStart\nclass InitOrderDemo(name: String) {\n    val firstProperty = \"First property: $name\".also(::println)\n    \n    init {\n        println(\"First initializer block that prints ${name}\")\n    }\n    \n    val secondProperty = \"Second property: ${name.length}\".also(::println)\n    \n    init {\n        println(\"Second initializer block that prints ${name.length}\")\n    }\n}\n//sampleEnd\n\nfun main() {\n    InitOrderDemo(\"hello\")\n}\n"}, {"type": "p", "text": "Note that parameters of the primary constructor can be used in the initializer blocks. They can also be used in\nproperty initializers declared in the class body:"}, {"type": "div", "text": "\nclass Customer(name: String) {\n    val customerKey = name.toUpperCase()\n}\n\n"}, {"type": "pre", "text": "class Customer(name: String) {\n    val customerKey = name.toUpperCase()\n}\n"}, {"type": "code", "text": "class Customer(name: String) {\n    val customerKey = name.toUpperCase()\n}\n"}, {"type": "p", "text": "In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:"}, {"type": "div", "text": "\nclass Person(val firstName: String, val lastName: String, var age: Int) { /*...*/ }\n\n"}, {"type": "pre", "text": "class Person(val firstName: String, val lastName: String, var age: Int) { /*...*/ }\n"}, {"type": "code", "text": "class Person(val firstName: String, val lastName: String, var age: Int) { /*...*/ }\n"}, {"type": "p", "text": "Much the same way as regular properties, the properties declared in the primary constructor can be\nmutable (var) or read-only (val)."}, {"type": "em", "text": "var"}, {"type": "em", "text": "val"}, {"type": "p", "text": "If the constructor has annotations or visibility modifiers, the constructor keyword is required, and\nthe modifiers go before it:"}, {"type": "em", "text": "constructor"}, {"type": "div", "text": "\nclass Customer public @Inject constructor(name: String) { /*...*/ }\n\n"}, {"type": "pre", "text": "class Customer public @Inject constructor(name: String) { /*...*/ }\n"}, {"type": "code", "text": "class Customer public @Inject constructor(name: String) { /*...*/ }\n"}, {"type": "p", "text": "For more details, see Visibility Modifiers."}, {"type": "a", "text": "Visibility Modifiers"}, {"type": "h4", "text": "Secondary constructors"}, {"type": "p", "text": "The class can also declare secondary constructors, which are prefixed with constructor:"}, {"type": "strong", "text": "secondary constructors"}, {"type": "em", "text": "constructor"}, {"type": "div", "text": "\nclass Person {\n    var children: MutableList<Person> = mutableListOf<>()\n    constructor(parent: Person) {\n        parent.children.add(this)\n    }\n}\n\n"}, {"type": "pre", "text": "class Person {\n    var children: MutableList<Person> = mutableListOf<>()\n    constructor(parent: Person) {\n        parent.children.add(this)\n    }\n}\n"}, {"type": "code", "text": "class Person {\n    var children: MutableList<Person> = mutableListOf<>()\n    constructor(parent: Person) {\n        parent.children.add(this)\n    }\n}\n"}, {"type": "p", "text": "If the class has a primary constructor, each secondary constructor needs to delegate to the primary constructor, either\ndirectly or indirectly through another secondary constructor(s). Delegation to another constructor of the same class\nis done using the this keyword:"}, {"type": "em", "text": "this"}, {"type": "div", "text": "\nclass Person(val name: String) {\n    var children: MutableList<Person> = mutableListOf<>()\n    constructor(name: String, parent: Person) : this(name) {\n        parent.children.add(this)\n    }\n}\n\n"}, {"type": "pre", "text": "class Person(val name: String) {\n    var children: MutableList<Person> = mutableListOf<>()\n    constructor(name: String, parent: Person) : this(name) {\n        parent.children.add(this)\n    }\n}\n"}, {"type": "code", "text": "class Person(val name: String) {\n    var children: MutableList<Person> = mutableListOf<>()\n    constructor(name: String, parent: Person) : this(name) {\n        parent.children.add(this)\n    }\n}\n"}, {"type": "p", "text": "Note that code in initializer blocks effectively becomes part of the primary constructor. Delegation to the primary\nconstructor happens as the first statement of a secondary constructor, so the code in all initializer blocks and property initializers is executed\nbefore the secondary constructor body. Even if the class has no primary constructor, the delegation still happens\nimplicitly, and the initializer blocks are still executed:"}, {"type": "div", "text": "\n//sampleStart\nclass Constructors {\n    init {\n        println(\"Init block\")\n    }\n\n    constructor(i: Int) {\n        println(\"Constructor\")\n    }\n}\n//sampleEnd\n\nfun main() {\n    Constructors(1)\n}\n\n"}, {"type": "pre", "text": "//sampleStart\nclass Constructors {\n    init {\n        println(\"Init block\")\n    }\n\n    constructor(i: Int) {\n        println(\"Constructor\")\n    }\n}\n//sampleEnd\n\nfun main() {\n    Constructors(1)\n}\n"}, {"type": "code", "text": "//sampleStart\nclass Constructors {\n    init {\n        println(\"Init block\")\n    }\n\n    constructor(i: Int) {\n        println(\"Constructor\")\n    }\n}\n//sampleEnd\n\nfun main() {\n    Constructors(1)\n}\n"}, {"type": "p", "text": "If a non-abstract class does not declare any constructors (primary or secondary), it will have a generated primary\nconstructor with no arguments. The visibility of the constructor will be public. If you do not want your class\nto have a public constructor, you need to declare an empty primary constructor with non-default visibility:"}, {"type": "div", "text": "\nclass DontCreateMe private constructor () { /*...*/ }\n\n"}, {"type": "pre", "text": "class DontCreateMe private constructor () { /*...*/ }\n"}, {"type": "code", "text": "class DontCreateMe private constructor () { /*...*/ }\n"}, {"type": "blockquote", "text": "\nNOTE: On the JVM, if all of the parameters of the primary constructor have default values, the compiler will\ngenerate an additional parameterless constructor which will use the default values. This makes it easier to use\nKotlin with libraries such as Jackson or JPA that create class instances through parameterless constructors.\n"}, {"type": "p", "text": "NOTE: On the JVM, if all of the parameters of the primary constructor have default values, the compiler will\ngenerate an additional parameterless constructor which will use the default values. This makes it easier to use\nKotlin with libraries such as Jackson or JPA that create class instances through parameterless constructors."}, {"type": "strong", "text": "NOTE"}, {"type": "blockquote", "text": "\n\nclass Customer(val customerName: String = \"\")\n\n\n"}, {"type": "div", "text": "\nclass Customer(val customerName: String = \"\")\n\n"}, {"type": "pre", "text": "class Customer(val customerName: String = \"\")\n"}, {"type": "code", "text": "class Customer(val customerName: String = \"\")\n"}, {"type": "h3", "text": "Creating instances of classes"}, {"type": "p", "text": "To create an instance of a class, we call the constructor as if it were a regular function:"}, {"type": "div", "text": "\nval invoice = Invoice()\n\nval customer = Customer(\"Joe Smith\")\n\n"}, {"type": "pre", "text": "val invoice = Invoice()\n\nval customer = Customer(\"Joe Smith\")\n"}, {"type": "code", "text": "val invoice = Invoice()\n\nval customer = Customer(\"Joe Smith\")\n"}, {"type": "p", "text": "Note that Kotlin does not have a new keyword."}, {"type": "em", "text": "new"}, {"type": "p", "text": "Creating instances of nested, inner and anonymous inner classes is described in Nested classes."}, {"type": "a", "text": "Nested classes"}, {"type": "h3", "text": "Class members"}, {"type": "p", "text": "Classes can contain:"}, {"type": "ul", "text": "\nConstructors and initializer blocks\nFunctions\nProperties\nNested and Inner Classes\nObject Declarations\n"}, {"type": "li", "text": "Constructors and initializer blocks"}, {"type": "a", "text": "Constructors and initializer blocks"}, {"type": "li", "text": "Functions"}, {"type": "a", "text": "Functions"}, {"type": "li", "text": "Properties"}, {"type": "a", "text": "Properties"}, {"type": "li", "text": "Nested and Inner Classes"}, {"type": "a", "text": "Nested and Inner Classes"}, {"type": "li", "text": "Object Declarations"}, {"type": "a", "text": "Object Declarations"}, {"type": "h2", "text": "Inheritance"}, {"type": "p", "text": "All classes in Kotlin have a common superclass Any, that is the default superclass for a class with no supertypes declared:"}, {"type": "code", "text": "Any"}, {"type": "div", "text": "\nclass Example // Implicitly inherits from Any\n\n"}, {"type": "pre", "text": "class Example // Implicitly inherits from Any\n"}, {"type": "code", "text": "class Example // Implicitly inherits from Any\n"}, {"type": "p", "text": "Any has three methods: equals(), hashCode() and toString(). Thus, they are defined for all Kotlin classes."}, {"type": "code", "text": "Any"}, {"type": "code", "text": "equals()"}, {"type": "code", "text": "hashCode()"}, {"type": "code", "text": "toString()"}, {"type": "p", "text": "By default, Kotlin classes are final: they can\u2019t be inherited.\nTo make a class inheritable, mark it with the open keyword."}, {"type": "code", "text": "open"}, {"type": "div", "text": "\nopen class Base //Class is open for inheritance\n\n\n"}, {"type": "pre", "text": "open class Base //Class is open for inheritance\n\n"}, {"type": "code", "text": "open class Base //Class is open for inheritance\n\n"}, {"type": "p", "text": "To declare an explicit supertype, place the type after a colon in the class header:"}, {"type": "div", "text": "\nopen class Base(p: Int)\n\nclass Derived(p: Int) : Base(p)\n\n"}, {"type": "pre", "text": "open class Base(p: Int)\n\nclass Derived(p: Int) : Base(p)\n"}, {"type": "code", "text": "open class Base(p: Int)\n\nclass Derived(p: Int) : Base(p)\n"}, {"type": "p", "text": "If the derived class has a primary constructor, the base class can (and must) be initialized right there,\nusing the parameters of the primary constructor."}, {"type": "p", "text": "If the derived class has no primary constructor, then each secondary constructor has to initialize the base type\nusing the super keyword, or to delegate to another constructor which does that.\nNote that in this case different secondary constructors can call different constructors of the base type:"}, {"type": "em", "text": "super"}, {"type": "div", "text": "\nclass MyView : View {\n    constructor(ctx: Context) : super(ctx)\n\n    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)\n}\n\n"}, {"type": "pre", "text": "class MyView : View {\n    constructor(ctx: Context) : super(ctx)\n\n    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)\n}\n"}, {"type": "code", "text": "class MyView : View {\n    constructor(ctx: Context) : super(ctx)\n\n    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)\n}\n"}, {"type": "h3", "text": "Overriding methods"}, {"type": "p", "text": "As we mentioned before, we stick to making things explicit in Kotlin. So, Kotlin requires explicit\nmodifiers for overridable members (we call them open) and for overrides:"}, {"type": "em", "text": "open"}, {"type": "div", "text": "\nopen class Shape {\n    open fun draw() { /*...*/ }\n    fun fill() { /*...*/ }\n}\n\nclass Circle() : Shape() {\n    override fun draw() { /*...*/ }\n}\n\n"}, {"type": "pre", "text": "open class Shape {\n    open fun draw() { /*...*/ }\n    fun fill() { /*...*/ }\n}\n\nclass Circle() : Shape() {\n    override fun draw() { /*...*/ }\n}\n"}, {"type": "code", "text": "open class Shape {\n    open fun draw() { /*...*/ }\n    fun fill() { /*...*/ }\n}\n\nclass Circle() : Shape() {\n    override fun draw() { /*...*/ }\n}\n"}, {"type": "p", "text": "The override modifier is required for Circle.draw(). If it were missing, the compiler would complain.\nIf there is no open modifier on a function, like Shape.fill(), declaring a method with the same signature in a subclass is illegal,\neither with override or without it. The open modifier has no effect when added on members of a final class (i.e.. a class with no open modifier)."}, {"type": "em", "text": "override"}, {"type": "code", "text": "Circle.draw()"}, {"type": "em", "text": "open"}, {"type": "code", "text": "Shape.fill()"}, {"type": "em", "text": "override"}, {"type": "em", "text": "open"}, {"type": "em", "text": "open"}, {"type": "p", "text": "A member marked override is itself open, i.e. it may be overridden in subclasses. If you want to prohibit re-overriding, use final:"}, {"type": "em", "text": "override"}, {"type": "em", "text": "final"}, {"type": "div", "text": "\nopen class Rectangle() : Shape() {\n    final override fun draw() { /*...*/ }\n}\n\n"}, {"type": "pre", "text": "open class Rectangle() : Shape() {\n    final override fun draw() { /*...*/ }\n}\n"}, {"type": "code", "text": "open class Rectangle() : Shape() {\n    final override fun draw() { /*...*/ }\n}\n"}, {"type": "h3", "text": "Overriding properties"}, {"type": "p", "text": "Overriding properties works in a similar way to overriding methods; properties declared on a superclass \nthat are then redeclared on a derived class must be prefaced with override, and they must have a compatible type.\nEach declared property can be overridden by a property with an initializer or by a property with a get method."}, {"type": "em", "text": "override"}, {"type": "code", "text": "get"}, {"type": "div", "text": "\nopen class Shape {\n    open val vertexCount: Int = 0\n}\n\nclass Rectangle : Shape() {\n    override val vertexCount = 4\n}\n\n"}, {"type": "pre", "text": "open class Shape {\n    open val vertexCount: Int = 0\n}\n\nclass Rectangle : Shape() {\n    override val vertexCount = 4\n}\n"}, {"type": "code", "text": "open class Shape {\n    open val vertexCount: Int = 0\n}\n\nclass Rectangle : Shape() {\n    override val vertexCount = 4\n}\n"}, {"type": "p", "text": "You can also override a val property with a var property, but not vice versa.\nThis is allowed because a val property essentially declares a get method,\nand overriding it as a var additionally declares a set method in the derived class."}, {"type": "code", "text": "val"}, {"type": "code", "text": "var"}, {"type": "code", "text": "val"}, {"type": "code", "text": "get"}, {"type": "code", "text": "var"}, {"type": "code", "text": "set"}, {"type": "p", "text": "Note that you can use the override keyword as part of the property declaration in a primary constructor."}, {"type": "em", "text": "override"}, {"type": "div", "text": "\ninterface Shape {\n    val vertexCount: Int\n}\n\nclass Rectangle(override val vertexCount: Int = 4) : Shape // Always has 4 vertices\n\nclass Polygon : Shape {\n    override var vertexCount: Int = 0  // Can be set to any number later\n}\n\n"}, {"type": "pre", "text": "interface Shape {\n    val vertexCount: Int\n}\n\nclass Rectangle(override val vertexCount: Int = 4) : Shape // Always has 4 vertices\n\nclass Polygon : Shape {\n    override var vertexCount: Int = 0  // Can be set to any number later\n}\n"}, {"type": "code", "text": "interface Shape {\n    val vertexCount: Int\n}\n\nclass Rectangle(override val vertexCount: Int = 4) : Shape // Always has 4 vertices\n\nclass Polygon : Shape {\n    override var vertexCount: Int = 0  // Can be set to any number later\n}\n"}, {"type": "h3", "text": "Derived class initialization order"}, {"type": "p", "text": "During construction of a new instance of a derived class, the base class initialization is done as the first step (preceded only by evaluation of the arguments for the base class constructor) and thus happens before the initialization logic of the derived class is run."}, {"type": "div", "text": "\n//sampleStart\nopen class Base(val name: String) {\n\n    init { println(\"Initializing Base\") }\n\n    open val size: Int = \n        name.length.also { println(\"Initializing size in Base: $it\") }\n}\n\nclass Derived(\n    name: String,\n    val lastName: String\n) : Base(name.capitalize().also { println(\"Argument for Base: $it\") }) {\n\n    init { println(\"Initializing Derived\") }\n\n    override val size: Int =\n        (super.size + lastName.length).also { println(\"Initializing size in Derived: $it\") }\n}\n//sampleEnd\n\nfun main() {\n    println(\"Constructing Derived(\\\"hello\\\", \\\"world\\\")\")\n    val d = Derived(\"hello\", \"world\")\n}\n\n"}, {"type": "pre", "text": "//sampleStart\nopen class Base(val name: String) {\n\n    init { println(\"Initializing Base\") }\n\n    open val size: Int = \n        name.length.also { println(\"Initializing size in Base: $it\") }\n}\n\nclass Derived(\n    name: String,\n    val lastName: String\n) : Base(name.capitalize().also { println(\"Argument for Base: $it\") }) {\n\n    init { println(\"Initializing Derived\") }\n\n    override val size: Int =\n        (super.size + lastName.length).also { println(\"Initializing size in Derived: $it\") }\n}\n//sampleEnd\n\nfun main() {\n    println(\"Constructing Derived(\\\"hello\\\", \\\"world\\\")\")\n    val d = Derived(\"hello\", \"world\")\n}\n"}, {"type": "code", "text": "//sampleStart\nopen class Base(val name: String) {\n\n    init { println(\"Initializing Base\") }\n\n    open val size: Int = \n        name.length.also { println(\"Initializing size in Base: $it\") }\n}\n\nclass Derived(\n    name: String,\n    val lastName: String\n) : Base(name.capitalize().also { println(\"Argument for Base: $it\") }) {\n\n    init { println(\"Initializing Derived\") }\n\n    override val size: Int =\n        (super.size + lastName.length).also { println(\"Initializing size in Derived: $it\") }\n}\n//sampleEnd\n\nfun main() {\n    println(\"Constructing Derived(\\\"hello\\\", \\\"world\\\")\")\n    val d = Derived(\"hello\", \"world\")\n}\n"}, {"type": "p", "text": "It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden open member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using open members in the constructors, property initializers, and init blocks."}, {"type": "em", "text": "open"}, {"type": "em", "text": "open"}, {"type": "em", "text": "init"}, {"type": "h3", "text": "Calling the superclass implementation"}, {"type": "p", "text": "Code in a derived class can call its superclass functions and property accessors implementations using the super keyword:"}, {"type": "em", "text": "super"}, {"type": "div", "text": "\nopen class Rectangle {\n    open fun draw() { println(\"Drawing a rectangle\") }\n    val borderColor: String get() = \"black\"\n}\n\nclass FilledRectangle : Rectangle() {\n    override fun draw() {\n        super.draw()\n        println(\"Filling the rectangle\")\n    }\n\n    val fillColor: String get() = super.borderColor\n}\n\n"}, {"type": "pre", "text": "open class Rectangle {\n    open fun draw() { println(\"Drawing a rectangle\") }\n    val borderColor: String get() = \"black\"\n}\n\nclass FilledRectangle : Rectangle() {\n    override fun draw() {\n        super.draw()\n        println(\"Filling the rectangle\")\n    }\n\n    val fillColor: String get() = super.borderColor\n}\n"}, {"type": "code", "text": "open class Rectangle {\n    open fun draw() { println(\"Drawing a rectangle\") }\n    val borderColor: String get() = \"black\"\n}\n\nclass FilledRectangle : Rectangle() {\n    override fun draw() {\n        super.draw()\n        println(\"Filling the rectangle\")\n    }\n\n    val fillColor: String get() = super.borderColor\n}\n"}, {"type": "p", "text": "Inside an inner class, accessing the superclass of the outer class is done with the super keyword qualified with the outer class name: super@Outer:"}, {"type": "em", "text": "super"}, {"type": "code", "text": "super@Outer"}, {"type": "div", "text": "\nclass FilledRectangle: Rectangle() {\n    fun draw() { /* ... */ }\n    val borderColor: String get() = \"black\"\n    \n    inner class Filler {\n        fun fill() { /* ... */ }\n        fun drawAndFill() {\n            super@FilledRectangle.draw() // Calls Rectangle's implementation of draw()\n            fill()\n            println(\"Drawn a filled rectangle with color ${super@FilledRectangle.borderColor}\") // Uses Rectangle's implementation of borderColor's get()\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "class FilledRectangle: Rectangle() {\n    fun draw() { /* ... */ }\n    val borderColor: String get() = \"black\"\n    \n    inner class Filler {\n        fun fill() { /* ... */ }\n        fun drawAndFill() {\n            super@FilledRectangle.draw() // Calls Rectangle's implementation of draw()\n            fill()\n            println(\"Drawn a filled rectangle with color ${super@FilledRectangle.borderColor}\") // Uses Rectangle's implementation of borderColor's get()\n        }\n    }\n}\n"}, {"type": "code", "text": "class FilledRectangle: Rectangle() {\n    fun draw() { /* ... */ }\n    val borderColor: String get() = \"black\"\n    \n    inner class Filler {\n        fun fill() { /* ... */ }\n        fun drawAndFill() {\n            super@FilledRectangle.draw() // Calls Rectangle's implementation of draw()\n            fill()\n            println(\"Drawn a filled rectangle with color ${super@FilledRectangle.borderColor}\") // Uses Rectangle's implementation of borderColor's get()\n        }\n    }\n}\n"}, {"type": "h3", "text": "Overriding rules"}, {"type": "p", "text": "In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits multiple implementations of the same member from its immediate superclasses,\nit must override this member and provide its own implementation (perhaps, using one of the inherited ones).\nTo denote the supertype from which the inherited implementation is taken, we use super qualified by the supertype name in angle brackets, e.g. super<Base>:"}, {"type": "em", "text": "super"}, {"type": "code", "text": "super<Base>"}, {"type": "div", "text": "\nopen class Rectangle {\n    open fun draw() { /* ... */ }\n}\n\ninterface Polygon {\n    fun draw() { /* ... */ } // interface members are 'open' by default\n}\n\nclass Square() : Rectangle(), Polygon {\n    // The compiler requires draw() to be overridden:\n    override fun draw() {\n        super<Rectangle>.draw() // call to Rectangle.draw()\n        super<Polygon>.draw() // call to Polygon.draw()\n    }\n}\n\n"}, {"type": "pre", "text": "open class Rectangle {\n    open fun draw() { /* ... */ }\n}\n\ninterface Polygon {\n    fun draw() { /* ... */ } // interface members are 'open' by default\n}\n\nclass Square() : Rectangle(), Polygon {\n    // The compiler requires draw() to be overridden:\n    override fun draw() {\n        super<Rectangle>.draw() // call to Rectangle.draw()\n        super<Polygon>.draw() // call to Polygon.draw()\n    }\n}\n"}, {"type": "code", "text": "open class Rectangle {\n    open fun draw() { /* ... */ }\n}\n\ninterface Polygon {\n    fun draw() { /* ... */ } // interface members are 'open' by default\n}\n\nclass Square() : Rectangle(), Polygon {\n    // The compiler requires draw() to be overridden:\n    override fun draw() {\n        super<Rectangle>.draw() // call to Rectangle.draw()\n        super<Polygon>.draw() // call to Polygon.draw()\n    }\n}\n"}, {"type": "p", "text": "It's fine to inherit from both Rectangle and Polygon,\nbut both of them have their implementations of draw(), so we have to override draw() in Square\nand provide its own implementation that eliminates the ambiguity."}, {"type": "code", "text": "Rectangle"}, {"type": "code", "text": "Polygon"}, {"type": "code", "text": "draw()"}, {"type": "code", "text": "draw()"}, {"type": "code", "text": "Square"}, {"type": "h2", "text": "Abstract classes"}, {"type": "p", "text": "A class and some of its members may be declared abstract.\nAn abstract member does not have an implementation in its class.\nNote that we do not need to annotate an abstract class or function with open \u2013 it goes without saying."}, {"type": "em", "text": "abstract"}, {"type": "p", "text": "We can override a non-abstract open member with an abstract one"}, {"type": "div", "text": "\nopen class Polygon {\n    open fun draw() {}\n}\n\nabstract class Rectangle : Polygon() {\n    abstract override fun draw()\n}\n\n"}, {"type": "pre", "text": "open class Polygon {\n    open fun draw() {}\n}\n\nabstract class Rectangle : Polygon() {\n    abstract override fun draw()\n}\n"}, {"type": "code", "text": "open class Polygon {\n    open fun draw() {}\n}\n\nabstract class Rectangle : Polygon() {\n    abstract override fun draw()\n}\n"}, {"type": "h2", "text": "Companion objects"}, {"type": "p", "text": "If you need to write a function that can be called without having a class instance but needs access to the internals\nof a class (for example, a factory method), you can write it as a member of an object declaration\ninside that class."}, {"type": "a", "text": "object declaration"}, {"type": "p", "text": "Even more specifically, if you declare a companion object inside your class,\nyou can access its members using only the class name as a qualifier."}, {"type": "a", "text": "companion object"}]