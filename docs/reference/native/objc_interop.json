[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Kotlin/Native interoperability with Swift/Objective-C"}, {"type": "em", "text": "Kotlin/Native"}, {"type": "p", "text": "This document covers some details of Kotlin/Native interoperability with\nSwift/Objective-C."}, {"type": "h2", "text": "Usage"}, {"type": "p", "text": "Kotlin/Native provides bidirectional interoperability with Objective-C.\nObjective-C frameworks and libraries can be used in Kotlin code if\nproperly imported to the build (system frameworks are imported by default).\nSee e.g. \"Using cinterop\" in\nGradle plugin documentation.\nA Swift library can be used in Kotlin code if its API is exported to Objective-C\nwith @objc. Pure Swift modules are not yet supported."}, {"type": "a", "text": "Gradle plugin documentation"}, {"type": "code", "text": "@objc"}, {"type": "p", "text": "Kotlin modules can be used in Swift/Objective-C code if compiled into a\nframework (see \"Targets and output kinds\" section in Gradle plugin documentation).\nSee calculator sample for an example."}, {"type": "a", "text": "Gradle plugin documentation"}, {"type": "a", "text": "calculator sample"}, {"type": "h2", "text": "Mappings"}, {"type": "p", "text": "The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa."}, {"type": "table", "text": "\n\n\nKotlin\nSwift\nObjective-C\nNotes\n\n\n\n\nclass\nclass\n@interface\nnote\n\n\ninterface\nprotocol\n@protocol\n\u00a0\n\n\nconstructor/create\nInitializer\nInitializer\nnote\n\n\nProperty\nProperty\nProperty\nnote note\n\n\nMethod\nMethod\nMethod\nnote note\n\n\n@Throws\nthrows\nerror:(NSError**)error\nnote\n\n\nExtension\nExtension\nCategory member\nnote\n\n\ncompanion member <-\nClass method or property\nClass method or property\n\u00a0\n\n\nnull\nnil\nnil\n\u00a0\n\n\nSingleton\nSingleton()\n[Singleton singleton]\nnote\n\n\nPrimitive type\nPrimitive type / NSNumber\n\u00a0\nnote\n\n\nUnit return type\nVoid\nvoid\n\u00a0\n\n\nString\nString\nNSString\n\u00a0\n\n\nString\nNSMutableString\nNSMutableString\nnote\n\n\nList\nArray\nNSArray\n\u00a0\n\n\nMutableList\nNSMutableArray\nNSMutableArray\n\u00a0\n\n\nSet\nSet\nNSSet\n\u00a0\n\n\nMutableSet\nNSMutableSet\nNSMutableSet\nnote\n\n\nMap\nDictionary\nNSDictionary\n\u00a0\n\n\nMutableMap\nNSMutableDictionary\nNSMutableDictionary\nnote\n\n\nFunction type\nFunction type\nBlock pointer type\nnote\n\n\nSuspend functions\nUnsupported\nUnsupported\nnote\n\n\nInline classes\nUnsupported\nUnsupported\nnote\n\n\n"}, {"type": "thead", "text": "\n\nKotlin\nSwift\nObjective-C\nNotes\n\n"}, {"type": "tr", "text": "\nKotlin\nSwift\nObjective-C\nNotes\n"}, {"type": "th", "text": "Kotlin"}, {"type": "th", "text": "Swift"}, {"type": "th", "text": "Objective-C"}, {"type": "th", "text": "Notes"}, {"type": "tbody", "text": "\n\nclass\nclass\n@interface\nnote\n\n\ninterface\nprotocol\n@protocol\n\u00a0\n\n\nconstructor/create\nInitializer\nInitializer\nnote\n\n\nProperty\nProperty\nProperty\nnote note\n\n\nMethod\nMethod\nMethod\nnote note\n\n\n@Throws\nthrows\nerror:(NSError**)error\nnote\n\n\nExtension\nExtension\nCategory member\nnote\n\n\ncompanion member <-\nClass method or property\nClass method or property\n\u00a0\n\n\nnull\nnil\nnil\n\u00a0\n\n\nSingleton\nSingleton()\n[Singleton singleton]\nnote\n\n\nPrimitive type\nPrimitive type / NSNumber\n\u00a0\nnote\n\n\nUnit return type\nVoid\nvoid\n\u00a0\n\n\nString\nString\nNSString\n\u00a0\n\n\nString\nNSMutableString\nNSMutableString\nnote\n\n\nList\nArray\nNSArray\n\u00a0\n\n\nMutableList\nNSMutableArray\nNSMutableArray\n\u00a0\n\n\nSet\nSet\nNSSet\n\u00a0\n\n\nMutableSet\nNSMutableSet\nNSMutableSet\nnote\n\n\nMap\nDictionary\nNSDictionary\n\u00a0\n\n\nMutableMap\nNSMutableDictionary\nNSMutableDictionary\nnote\n\n\nFunction type\nFunction type\nBlock pointer type\nnote\n\n\nSuspend functions\nUnsupported\nUnsupported\nnote\n\n\nInline classes\nUnsupported\nUnsupported\nnote\n\n"}, {"type": "tr", "text": "\nclass\nclass\n@interface\nnote\n"}, {"type": "td", "text": "class"}, {"type": "code", "text": "class"}, {"type": "td", "text": "class"}, {"type": "code", "text": "class"}, {"type": "td", "text": "@interface"}, {"type": "code", "text": "@interface"}, {"type": "td", "text": "note"}, {"type": "a", "text": "note"}, {"type": "tr", "text": "\ninterface\nprotocol\n@protocol\n\u00a0\n"}, {"type": "td", "text": "interface"}, {"type": "code", "text": "interface"}, {"type": "td", "text": "protocol"}, {"type": "code", "text": "protocol"}, {"type": "td", "text": "@protocol"}, {"type": "code", "text": "@protocol"}, {"type": "td", "text": "\u00a0"}, {"type": "tr", "text": "\nconstructor/create\nInitializer\nInitializer\nnote\n"}, {"type": "td", "text": "constructor/create"}, {"type": "code", "text": "constructor"}, {"type": "code", "text": "create"}, {"type": "td", "text": "Initializer"}, {"type": "td", "text": "Initializer"}, {"type": "td", "text": "note"}, {"type": "a", "text": "note"}, {"type": "tr", "text": "\nProperty\nProperty\nProperty\nnote note\n"}, {"type": "td", "text": "Property"}, {"type": "td", "text": "Property"}, {"type": "td", "text": "Property"}, {"type": "td", "text": "note note"}, {"type": "a", "text": "note"}, {"type": "a", "text": "note"}, {"type": "tr", "text": "\nMethod\nMethod\nMethod\nnote note\n"}, {"type": "td", "text": "Method"}, {"type": "td", "text": "Method"}, {"type": "td", "text": "Method"}, {"type": "td", "text": "note note"}, {"type": "a", "text": "note"}, {"type": "a", "text": "note"}, {"type": "tr", "text": "\n@Throws\nthrows\nerror:(NSError**)error\nnote\n"}, {"type": "td", "text": "@Throws"}, {"type": "code", "text": "@Throws"}, {"type": "td", "text": "throws"}, {"type": "code", "text": "throws"}, {"type": "td", "text": "error:(NSError**)error"}, {"type": "code", "text": "error:(NSError**)error"}, {"type": "td", "text": "note"}, {"type": "a", "text": "note"}, {"type": "tr", "text": "\nExtension\nExtension\nCategory member\nnote\n"}, {"type": "td", "text": "Extension"}, {"type": "td", "text": "Extension"}, {"type": "td", "text": "Category member"}, {"type": "td", "text": "note"}, {"type": "a", "text": "note"}, {"type": "tr", "text": "\ncompanion member <-\nClass method or property\nClass method or property\n\u00a0\n"}, {"type": "td", "text": "companion member <-"}, {"type": "code", "text": "companion"}, {"type": "td", "text": "Class method or property"}, {"type": "td", "text": "Class method or property"}, {"type": "td", "text": "\u00a0"}, {"type": "tr", "text": "\nnull\nnil\nnil\n\u00a0\n"}, {"type": "td", "text": "null"}, {"type": "code", "text": "null"}, {"type": "td", "text": "nil"}, {"type": "code", "text": "nil"}, {"type": "td", "text": "nil"}, {"type": "code", "text": "nil"}, {"type": "td", "text": "\u00a0"}, {"type": "tr", "text": "\nSingleton\nSingleton()\n[Singleton singleton]\nnote\n"}, {"type": "td", "text": "Singleton"}, {"type": "code", "text": "Singleton"}, {"type": "td", "text": "Singleton()"}, {"type": "code", "text": "Singleton()"}, {"type": "td", "text": "[Singleton singleton]"}, {"type": "code", "text": "[Singleton singleton]"}, {"type": "td", "text": "note"}, {"type": "a", "text": "note"}, {"type": "tr", "text": "\nPrimitive type\nPrimitive type / NSNumber\n\u00a0\nnote\n"}, {"type": "td", "text": "Primitive type"}, {"type": "td", "text": "Primitive type / NSNumber"}, {"type": "code", "text": "NSNumber"}, {"type": "td", "text": "\u00a0"}, {"type": "td", "text": "note"}, {"type": "a", "text": "note"}, {"type": "tr", "text": "\nUnit return type\nVoid\nvoid\n\u00a0\n"}, {"type": "td", "text": "Unit return type"}, {"type": "code", "text": "Unit"}, {"type": "td", "text": "Void"}, {"type": "code", "text": "Void"}, {"type": "td", "text": "void"}, {"type": "code", "text": "void"}, {"type": "td", "text": "\u00a0"}, {"type": "tr", "text": "\nString\nString\nNSString\n\u00a0\n"}, {"type": "td", "text": "String"}, {"type": "code", "text": "String"}, {"type": "td", "text": "String"}, {"type": "code", "text": "String"}, {"type": "td", "text": "NSString"}, {"type": "code", "text": "NSString"}, {"type": "td", "text": "\u00a0"}, {"type": "tr", "text": "\nString\nNSMutableString\nNSMutableString\nnote\n"}, {"type": "td", "text": "String"}, {"type": "code", "text": "String"}, {"type": "td", "text": "NSMutableString"}, {"type": "code", "text": "NSMutableString"}, {"type": "td", "text": "NSMutableString"}, {"type": "code", "text": "NSMutableString"}, {"type": "td", "text": "note"}, {"type": "a", "text": "note"}, {"type": "tr", "text": "\nList\nArray\nNSArray\n\u00a0\n"}, {"type": "td", "text": "List"}, {"type": "code", "text": "List"}, {"type": "td", "text": "Array"}, {"type": "code", "text": "Array"}, {"type": "td", "text": "NSArray"}, {"type": "code", "text": "NSArray"}, {"type": "td", "text": "\u00a0"}, {"type": "tr", "text": "\nMutableList\nNSMutableArray\nNSMutableArray\n\u00a0\n"}, {"type": "td", "text": "MutableList"}, {"type": "code", "text": "MutableList"}, {"type": "td", "text": "NSMutableArray"}, {"type": "code", "text": "NSMutableArray"}, {"type": "td", "text": "NSMutableArray"}, {"type": "code", "text": "NSMutableArray"}, {"type": "td", "text": "\u00a0"}, {"type": "tr", "text": "\nSet\nSet\nNSSet\n\u00a0\n"}, {"type": "td", "text": "Set"}, {"type": "code", "text": "Set"}, {"type": "td", "text": "Set"}, {"type": "code", "text": "Set"}, {"type": "td", "text": "NSSet"}, {"type": "code", "text": "NSSet"}, {"type": "td", "text": "\u00a0"}, {"type": "tr", "text": "\nMutableSet\nNSMutableSet\nNSMutableSet\nnote\n"}, {"type": "td", "text": "MutableSet"}, {"type": "code", "text": "MutableSet"}, {"type": "td", "text": "NSMutableSet"}, {"type": "code", "text": "NSMutableSet"}, {"type": "td", "text": "NSMutableSet"}, {"type": "code", "text": "NSMutableSet"}, {"type": "td", "text": "note"}, {"type": "a", "text": "note"}, {"type": "tr", "text": "\nMap\nDictionary\nNSDictionary\n\u00a0\n"}, {"type": "td", "text": "Map"}, {"type": "code", "text": "Map"}, {"type": "td", "text": "Dictionary"}, {"type": "code", "text": "Dictionary"}, {"type": "td", "text": "NSDictionary"}, {"type": "code", "text": "NSDictionary"}, {"type": "td", "text": "\u00a0"}, {"type": "tr", "text": "\nMutableMap\nNSMutableDictionary\nNSMutableDictionary\nnote\n"}, {"type": "td", "text": "MutableMap"}, {"type": "code", "text": "MutableMap"}, {"type": "td", "text": "NSMutableDictionary"}, {"type": "code", "text": "NSMutableDictionary"}, {"type": "td", "text": "NSMutableDictionary"}, {"type": "code", "text": "NSMutableDictionary"}, {"type": "td", "text": "note"}, {"type": "a", "text": "note"}, {"type": "tr", "text": "\nFunction type\nFunction type\nBlock pointer type\nnote\n"}, {"type": "td", "text": "Function type"}, {"type": "td", "text": "Function type"}, {"type": "td", "text": "Block pointer type"}, {"type": "td", "text": "note"}, {"type": "a", "text": "note"}, {"type": "tr", "text": "\nSuspend functions\nUnsupported\nUnsupported\nnote\n"}, {"type": "td", "text": "Suspend functions"}, {"type": "td", "text": "Unsupported"}, {"type": "td", "text": "Unsupported"}, {"type": "td", "text": "note"}, {"type": "a", "text": "note"}, {"type": "tr", "text": "\nInline classes\nUnsupported\nUnsupported\nnote\n"}, {"type": "td", "text": "Inline classes"}, {"type": "td", "text": "Unsupported"}, {"type": "td", "text": "Unsupported"}, {"type": "td", "text": "note"}, {"type": "a", "text": "note"}, {"type": "h3", "text": "Name translation"}, {"type": "p", "text": "Objective-C classes are imported into Kotlin with their original names.\nProtocols are imported as interfaces with Protocol name suffix,\ni.e. @protocol Foo -> interface FooProtocol.\nThese classes and interfaces are placed into a package specified in build configuration\n(platform.* packages for preconfigured system frameworks)."}, {"type": "code", "text": "Protocol"}, {"type": "code", "text": "@protocol Foo"}, {"type": "code", "text": "interface FooProtocol"}, {"type": "a", "text": "specified in build configuration"}, {"type": "code", "text": "platform.*"}, {"type": "p", "text": "The names of Kotlin classes and interfaces are prefixed when imported to Objective-C.\nThe prefix is derived from the framework name."}, {"type": "h3", "text": "Initializers"}, {"type": "p", "text": "Swift/Objective-C initializers are imported to Kotlin as constructors and factory methods\nnamed create. The latter happens with initializers declared in the Objective-C category or\nas a Swift extension, because Kotlin has no concept of extension constructors."}, {"type": "code", "text": "create"}, {"type": "p", "text": "Kotlin constructors are imported as initializers to Swift/Objective-C."}, {"type": "h3", "text": "Setters"}, {"type": "p", "text": "Writeable Objective-C properties overriding read-only properties of the superclass are represented as setFoo() method for the property foo. Same goes for a protocol's read-only properties that are implemented as mutable."}, {"type": "code", "text": "setFoo()"}, {"type": "code", "text": "foo"}, {"type": "h3", "text": "Top-level functions and properties"}, {"type": "p", "text": "Top-level Kotlin functions and properties are accessible as members of special classes.\nEach Kotlin file is translated into such a class. E.g."}, {"type": "div", "text": "\n// MyLibraryUtils.kt\npackage my.library\n\nfun foo() {}\n\n"}, {"type": "pre", "text": "// MyLibraryUtils.kt\npackage my.library\n\nfun foo() {}\n"}, {"type": "code", "text": "// MyLibraryUtils.kt\npackage my.library\n\nfun foo() {}\n"}, {"type": "p", "text": "can be called from Swift like"}, {"type": "div", "text": "\nMyLibraryUtilsKt.foo()\n\n"}, {"type": "pre", "text": "MyLibraryUtilsKt.foo()\n"}, {"type": "code", "text": "MyLibraryUtilsKt.foo()\n"}, {"type": "h3", "text": "Method names translation"}, {"type": "p", "text": "Generally Swift argument labels and Objective-C selector pieces are mapped to Kotlin\nparameter names. Anyway these two concepts have different semantics, so sometimes\nSwift/Objective-C methods can be imported with a clashing Kotlin signature. In this case\nthe clashing methods can be called from Kotlin using named arguments, e.g.:"}, {"type": "div", "text": "\n[player moveTo:LEFT byMeters:17]\n[player moveTo:UP byInches:42]\n\n"}, {"type": "pre", "text": "[player moveTo:LEFT byMeters:17]\n[player moveTo:UP byInches:42]\n"}, {"type": "code", "text": "[player moveTo:LEFT byMeters:17]\n[player moveTo:UP byInches:42]\n"}, {"type": "p", "text": "in Kotlin it would be:"}, {"type": "div", "text": "\nplayer.moveTo(LEFT, byMeters = 17)\nplayer.moveTo(UP, byInches = 42)\n\n"}, {"type": "pre", "text": "player.moveTo(LEFT, byMeters = 17)\nplayer.moveTo(UP, byInches = 42)\n"}, {"type": "code", "text": "player.moveTo(LEFT, byMeters = 17)\nplayer.moveTo(UP, byInches = 42)\n"}, {"type": "h3", "text": "Errors and exceptions"}, {"type": "p", "text": "Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked.\nSwift has only checked errors. So if Swift or Objective-C code calls a Kotlin method\nwhich throws an exception to be handled, then the Kotlin method should be marked\nwith a @Throws annotation. In this case all Kotlin exceptions\n(except for instances of Error, RuntimeException and subclasses) are translated into\na Swift error/NSError."}, {"type": "code", "text": "@Throws"}, {"type": "code", "text": "Error"}, {"type": "code", "text": "RuntimeException"}, {"type": "code", "text": "NSError"}, {"type": "p", "text": "Note that the opposite reversed translation is not implemented yet:\nSwift/Objective-C error-throwing methods aren't imported to Kotlin as\nexception-throwing."}, {"type": "h3", "text": "Category members"}, {"type": "p", "text": "Members of Objective-C categories and Swift extensions are imported to Kotlin\nas extensions. That's why these declarations can't be overridden in Kotlin.\nAnd the extension initializers aren't available as Kotlin constructors."}, {"type": "h3", "text": "Kotlin singletons"}, {"type": "p", "text": "Kotlin singleton (made with an object declaration, including companion object)\nis imported to Swift/Objective-C as a class with a single instance.\nThe instance is available through the factory method, i.e. as\n[MySingleton mySingleton] in Objective-C and MySingleton() in Swift."}, {"type": "code", "text": "object"}, {"type": "code", "text": "companion object"}, {"type": "code", "text": "[MySingleton mySingleton]"}, {"type": "code", "text": "MySingleton()"}, {"type": "h3", "text": "NSNumber"}, {"type": "p", "text": "Kotlin primitive type boxes are mapped to special Swift/Objective-C classes.\nFor example, kotlin.Int box is represented as KotlinInt class instance in Swift\n(or ${prefix}Int instance in Objective-C, where prefix is the framework names prefix).\nThese classes are derived from NSNumber, so the instances are proper NSNumbers\nsupporting all corresponding operations."}, {"type": "code", "text": "kotlin.Int"}, {"type": "code", "text": "KotlinInt"}, {"type": "code", "text": "${prefix}Int"}, {"type": "code", "text": "prefix"}, {"type": "code", "text": "NSNumber"}, {"type": "code", "text": "NSNumber"}, {"type": "p", "text": "NSNumber type is not automatically translated to Kotlin primitive types\nwhen used as a Swift/Objective-C parameter type or return value.\nThe reason is that NSNumber type doesn't provide enough information\nabout a wrapped primitive value type, i.e. NSNumber is statically not known\nto be a e.g. Byte, Boolean, or Double. So Kotlin primitive values\nshould be cast to/from NSNumber manually (see below)."}, {"type": "code", "text": "NSNumber"}, {"type": "code", "text": "NSNumber"}, {"type": "code", "text": "NSNumber"}, {"type": "code", "text": "Byte"}, {"type": "code", "text": "Boolean"}, {"type": "code", "text": "Double"}, {"type": "code", "text": "NSNumber"}, {"type": "a", "text": "below"}, {"type": "h3", "text": "NSMutableString"}, {"type": "p", "text": "NSMutableString Objective-C class is not available from Kotlin.\nAll instances of NSMutableString are copied when passed to Kotlin."}, {"type": "code", "text": "NSMutableString"}, {"type": "code", "text": "NSMutableString"}, {"type": "h3", "text": "Collections"}, {"type": "p", "text": "Kotlin collections are converted to Swift/Objective-C collections as described\nin the table above. Swift/Objective-C collections are mapped to Kotlin in the same way,\nexcept for NSMutableSet and NSMutableDictionary. NSMutableSet isn't converted to\na Kotlin MutableSet. To pass an object for Kotlin MutableSet,\nyou can create this kind of Kotlin collection explicitly by either creating it \nin Kotlin with e.g. mutableSetOf(), or using the KotlinMutableSet class in Swift \n(or ${prefix}MutableSet in Objective-C, where prefix is the framework names prefix).\nThe same holds for MutableMap."}, {"type": "code", "text": "NSMutableSet"}, {"type": "code", "text": "NSMutableDictionary"}, {"type": "code", "text": "NSMutableSet"}, {"type": "code", "text": "MutableSet"}, {"type": "code", "text": "MutableSet"}, {"type": "code", "text": "mutableSetOf()"}, {"type": "code", "text": "KotlinMutableSet"}, {"type": "code", "text": "${prefix}MutableSet"}, {"type": "code", "text": "prefix"}, {"type": "code", "text": "MutableMap"}, {"type": "h3", "text": "Function types"}, {"type": "p", "text": "Kotlin function-typed objects (e.g. lambdas) are converted to \nSwift functions / Objective-C blocks. However there is a difference in how\ntypes of parameters and return values are mapped when translating a function\nand a function type. In the latter case primitive types are mapped to their\nboxed representation. Kotlin Unit return value is represented\nas a corresponding Unit singleton in Swift/Objective-C. The value of this singleton\ncan be retrieved in the same way as it is for any other Kotlin object\n(see singletons in the table above).\nTo sum the things up:"}, {"type": "code", "text": "Unit"}, {"type": "code", "text": "Unit"}, {"type": "code", "text": "object"}, {"type": "div", "text": "\nfun foo(block: (Int) -> Unit) { ... }\n\n"}, {"type": "pre", "text": "fun foo(block: (Int) -> Unit) { ... }\n"}, {"type": "code", "text": "fun foo(block: (Int) -> Unit) { ... }\n"}, {"type": "p", "text": "would be represented in Swift as"}, {"type": "div", "text": "\nfunc foo(block: (KotlinInt) -> KotlinUnit)\n\n"}, {"type": "pre", "text": "func foo(block: (KotlinInt) -> KotlinUnit)\n"}, {"type": "code", "text": "func foo(block: (KotlinInt) -> KotlinUnit)\n"}, {"type": "p", "text": "and can be called like"}, {"type": "div", "text": "\nfoo {\n    bar($0 as! Int32)\n    return KotlinUnit()\n}\n\n"}, {"type": "pre", "text": "foo {\n    bar($0 as! Int32)\n    return KotlinUnit()\n}\n"}, {"type": "code", "text": "foo {\n    bar($0 as! Int32)\n    return KotlinUnit()\n}\n"}, {"type": "h3", "text": "Generics"}, {"type": "p", "text": "Objective-C supports \"lightweight generics\" defined on classes, with a relatively limited feature set. Swift can import \ngenerics defined on classes to help provide additional type information to the compiler."}, {"type": "p", "text": "Generic feature support for Objc and Swift differ from Kotlin, so the translation will inevitably lose some information,\nbut the features supported retain meaningful information."}, {"type": "h3", "text": "To Use"}, {"type": "p", "text": "Generics are currently not enabled by default. To have the framework header written with generics, add an experimental\nflag to the compiler config:"}, {"type": "div", "text": "\nbinaries.framework {\n     freeCompilerArgs += \"-Xobjc-generics\"\n}\n\n"}, {"type": "pre", "text": "binaries.framework {\n     freeCompilerArgs += \"-Xobjc-generics\"\n}\n"}, {"type": "code", "text": "binaries.framework {\n     freeCompilerArgs += \"-Xobjc-generics\"\n}\n"}, {"type": "h4", "text": "Limitations"}, {"type": "p", "text": "Objective-C generics do not support all features of either Kotlin or Swift, so there will be some information lost\nin the translation."}, {"type": "p", "text": "Generics can only be defined on classes, not on interfaces (protocols in Objc and Swift) or functions."}, {"type": "h4", "text": "Nullability"}, {"type": "p", "text": "Kotlin and Swift both define nullability as part of the type specification, while Objc defines nullability on methods\nand properties of a type. As such, the following:"}, {"type": "div", "text": "\nclass Sample<T>(){\n  fun myVal():T\n}\n\n"}, {"type": "pre", "text": "class Sample<T>(){\n  fun myVal():T\n}\n"}, {"type": "code", "text": "class Sample<T>(){\n  fun myVal():T\n}\n"}, {"type": "p", "text": "will (logically) look like this:"}, {"type": "div", "text": "\nclass Sample<T>(){\n  fun myVal():T?\n}\n\n"}, {"type": "pre", "text": "class Sample<T>(){\n  fun myVal():T?\n}\n"}, {"type": "code", "text": "class Sample<T>(){\n  fun myVal():T?\n}\n"}, {"type": "p", "text": "In order to support a potentially nullable type, the Objc header needs to define myVal with a nullable return value."}, {"type": "code", "text": "myVal"}, {"type": "p", "text": "To mitigate this, when defining your generic classes, if the generic type should never be null, provide a non-null \ntype constraint:"}, {"type": "em", "text": "never"}, {"type": "div", "text": "\nclass Sample<T:Any>(){\n  fun myVal():T\n}\n\n"}, {"type": "pre", "text": "class Sample<T:Any>(){\n  fun myVal():T\n}\n"}, {"type": "code", "text": "class Sample<T:Any>(){\n  fun myVal():T\n}\n"}, {"type": "p", "text": "That will force the Objc header to mark myVal as non-null."}, {"type": "code", "text": "myVal"}, {"type": "h4", "text": "Variance"}, {"type": "p", "text": "Objective-C allows generics to be declared covariant or contravariant. Swift has no support for variance. Generic classes coming\nfrom Objective-C can be force-cast as needed."}, {"type": "div", "text": "\ndata class SomeData(val num:Int = 42):BaseData()\nclass GenVarOut<out T:Any>(val arg:T)\n\n"}, {"type": "pre", "text": "data class SomeData(val num:Int = 42):BaseData()\nclass GenVarOut<out T:Any>(val arg:T)\n"}, {"type": "code", "text": "data class SomeData(val num:Int = 42):BaseData()\nclass GenVarOut<out T:Any>(val arg:T)\n"}, {"type": "div", "text": "\nlet variOut = GenVarOut<SomeData>(arg: sd)\nlet variOutAny : GenVarOut<BaseData> = variOut as! GenVarOut<BaseData>\n\n"}, {"type": "pre", "text": "let variOut = GenVarOut<SomeData>(arg: sd)\nlet variOutAny : GenVarOut<BaseData> = variOut as! GenVarOut<BaseData>\n"}, {"type": "code", "text": "let variOut = GenVarOut<SomeData>(arg: sd)\nlet variOutAny : GenVarOut<BaseData> = variOut as! GenVarOut<BaseData>\n"}, {"type": "h4", "text": "Constraints"}, {"type": "p", "text": "In Kotlin you can provide upper bounds for a generic type. Objective-C also supports this, but that support is unavailable \nin more complex cases, and is currently not supported in the Kotlin - Objective-C interop. The exception here being a non-null\nupper bound will make Objective-C methods/properties non-null."}, {"type": "h2", "text": "Casting between mapped types"}, {"type": "p", "text": "When writing Kotlin code, an object may need to be converted from a Kotlin type\nto the equivalent Swift/Objective-C type (or vice versa). In this case a plain old\nKotlin cast can be used, e.g."}, {"type": "div", "text": "\nval nsArray = listOf(1, 2, 3) as NSArray\nval string = nsString as String\nval nsNumber = 42 as NSNumber\n\n"}, {"type": "pre", "text": "val nsArray = listOf(1, 2, 3) as NSArray\nval string = nsString as String\nval nsNumber = 42 as NSNumber\n"}, {"type": "code", "text": "val nsArray = listOf(1, 2, 3) as NSArray\nval string = nsString as String\nval nsNumber = 42 as NSNumber\n"}, {"type": "h2", "text": "Subclassing"}, {"type": "h3", "text": "Subclassing Kotlin classes and interfaces from Swift/Objective-C"}, {"type": "p", "text": "Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes\nand protocols."}, {"type": "h3", "text": "Subclassing Swift/Objective-C classes and protocols from Kotlin"}, {"type": "p", "text": "Swift/Objective-C classes and protocols can be subclassed with a Kotlin final class.\nNon-final Kotlin classes inheriting Swift/Objective-C types aren't supported yet, so it is\nnot possible to declare a complex class hierarchy inheriting Swift/Objective-C types."}, {"type": "code", "text": "final"}, {"type": "code", "text": "final"}, {"type": "p", "text": "Normal methods can be overridden using the override Kotlin keyword. In this case\nthe overriding method must have the same parameter names as the overridden one."}, {"type": "code", "text": "override"}, {"type": "p", "text": "Sometimes it is required to override initializers, e.g. when subclassing UIViewController. \nInitializers imported as Kotlin constructors can be overridden by Kotlin constructors\nmarked with the @OverrideInit annotation:"}, {"type": "code", "text": "UIViewController"}, {"type": "code", "text": "@OverrideInit"}, {"type": "div", "text": "\nclass ViewController : UIViewController {\n    @OverrideInit constructor(coder: NSCoder) : super(coder)\n\n    ...\n}\n\n"}, {"type": "pre", "text": "class ViewController : UIViewController {\n    @OverrideInit constructor(coder: NSCoder) : super(coder)\n\n    ...\n}\n"}, {"type": "code", "text": "class ViewController : UIViewController {\n    @OverrideInit constructor(coder: NSCoder) : super(coder)\n\n    ...\n}\n"}, {"type": "p", "text": "The overriding constructor must have the same parameter names and types as the overridden one."}, {"type": "p", "text": "To override different methods with clashing Kotlin signatures, you can add a\n@Suppress(\"CONFLICTING_OVERLOADS\") annotation to the class."}, {"type": "code", "text": "@Suppress(\"CONFLICTING_OVERLOADS\")"}, {"type": "p", "text": "By default the Kotlin/Native compiler doesn't allow calling a non-designated\nObjective-C initializer as a super(...) constructor. This behaviour can be\ninconvenient if the designated initializers aren't marked properly in the Objective-C\nlibrary. Adding a disableDesignatedInitializerChecks = true to the .def file for\nthis library would disable these compiler checks."}, {"type": "code", "text": "super(...)"}, {"type": "code", "text": "disableDesignatedInitializerChecks = true"}, {"type": "code", "text": ".def"}, {"type": "h2", "text": "C features"}, {"type": "p", "text": "See INTEROP.md for an example case where the library uses some plain C features\n(e.g. unsafe pointers, structs etc.)."}, {"type": "a", "text": "INTEROP.md"}, {"type": "h2", "text": "Unsupported"}, {"type": "p", "text": "Some features of Kotlin programming language are not yet mapped into respective features of Objective-C or Swift.\nCurrently, following features are not properly exposed in generated framework headers:"}, {"type": "ul", "text": "\nsuspend functions\ninline classes (arguments are mapped as either underlying primitive type or id)\ncustom classes implementing standard Kotlin collection interfaces (List, Map, Set) and other special classes\nKotlin subclasses of Objective-C classes\n"}, {"type": "li", "text": "suspend functions"}, {"type": "li", "text": "inline classes (arguments are mapped as either underlying primitive type or id)"}, {"type": "code", "text": "id"}, {"type": "li", "text": "custom classes implementing standard Kotlin collection interfaces (List, Map, Set) and other special classes"}, {"type": "code", "text": "List"}, {"type": "code", "text": "Map"}, {"type": "code", "text": "Set"}, {"type": "li", "text": "Kotlin subclasses of Objective-C classes"}]