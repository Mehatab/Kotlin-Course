[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h2", "text": "Concurrency in Kotlin/Native"}, {"type": "p", "text": "Kotlin/Native runtime doesn't encourage a classical thread-oriented concurrency\n model with mutually exclusive code blocks and conditional variables, as this model is\n known to be error-prone and unreliable. Instead, we suggest a collection of\n alternative approaches, allowing you to use hardware concurrency and implement blocking IO.\n Those approaches are as follows, and they will be elaborated on in further sections:"}, {"type": "ul", "text": "\nWorkers with message passing\nObject subgraph ownership transfer\nObject subgraph freezing\nObject subgraph detachment\nRaw shared memory using C globals\nCoroutines for blocking operations (not covered in this document)\n"}, {"type": "li", "text": "Workers with message passing"}, {"type": "li", "text": "Object subgraph ownership transfer"}, {"type": "li", "text": "Object subgraph freezing"}, {"type": "li", "text": "Object subgraph detachment"}, {"type": "li", "text": "Raw shared memory using C globals"}, {"type": "li", "text": "Coroutines for blocking operations (not covered in this document)"}, {"type": "h3", "text": "Workers"}, {"type": "p", "text": "Instead of threads Kotlin/Native runtime offers the concept of workers: concurrently executed\n control flow streams with an associated request queue. Workers are very similar to the actors\n in the Actor Model. A worker can exchange Kotlin objects with another worker, so that at any moment\n each mutable object is owned by a single worker, but ownership can be transferred.\n See section Object transfer and freezing."}, {"type": "a", "text": "Object transfer and freezing"}, {"type": "p", "text": "Once a worker is started with the Worker.start function call, it can be addressed with its own unique integer\n worker id. Other workers, or non-worker concurrency primitives, such as OS threads, can send a message\n to the worker with the execute call."}, {"type": "code", "text": "Worker.start"}, {"type": "code", "text": "execute"}, {"type": "div", "text": "\nval future = execute(TransferMode.SAFE, { SomeDataForWorker() }) {\n   // data returned by the second function argument comes to the\n   // worker routine as 'input' parameter.\n   input ->\n   // Here we create an instance to be returned when someone consumes result future.\n   WorkerResult(input.stringParam + \" result\")\n}\n\nfuture.consume {\n  // Here we see result returned from routine above. Note that future object or\n  // id could be transferred to another worker, so we don't have to consume future\n  // in same execution context it was obtained.\n  result -> println(\"result is $result\")\n}\n\n"}, {"type": "pre", "text": "val future = execute(TransferMode.SAFE, { SomeDataForWorker() }) {\n   // data returned by the second function argument comes to the\n   // worker routine as 'input' parameter.\n   input ->\n   // Here we create an instance to be returned when someone consumes result future.\n   WorkerResult(input.stringParam + \" result\")\n}\n\nfuture.consume {\n  // Here we see result returned from routine above. Note that future object or\n  // id could be transferred to another worker, so we don't have to consume future\n  // in same execution context it was obtained.\n  result -> println(\"result is $result\")\n}\n"}, {"type": "code", "text": "val future = execute(TransferMode.SAFE, { SomeDataForWorker() }) {\n   // data returned by the second function argument comes to the\n   // worker routine as 'input' parameter.\n   input ->\n   // Here we create an instance to be returned when someone consumes result future.\n   WorkerResult(input.stringParam + \" result\")\n}\n\nfuture.consume {\n  // Here we see result returned from routine above. Note that future object or\n  // id could be transferred to another worker, so we don't have to consume future\n  // in same execution context it was obtained.\n  result -> println(\"result is $result\")\n}\n"}, {"type": "p", "text": "The call to execute uses a function passed as its second parameter to produce an object subgraph\n (i.e. set of mutually referring objects) which is then passed as a whole to that worker, it is then no longer\n available to the thread that initiated the request. This property is checked if the first parameter\n is TransferMode.SAFE by graph traversal and is just assumed to be true, if it is TransferMode.UNSAFE.\n The last parameter to execute is a special Kotlin lambda, which is not allowed to capture any state,\n and is actually invoked in the target worker's context. Once processed, the result is transferred to whatever consumes\n it in the future, and it is attached to the object graph of that worker/thread."}, {"type": "code", "text": "execute"}, {"type": "code", "text": "TransferMode.SAFE"}, {"type": "code", "text": "TransferMode.UNSAFE"}, {"type": "code", "text": "execute"}, {"type": "p", "text": "If an object is transferred in UNSAFE mode and is still accessible from multiple concurrent executors,\n program will likely crash unexpectedly, so consider that last resort in optimizing, not a general purpose\n mechanism."}, {"type": "code", "text": "UNSAFE"}, {"type": "p", "text": "For a more complete example please refer to the workers example\n in the Kotlin/Native repository."}, {"type": "a", "text": "workers example"}, {"type": "p", "text": ""}, {"type": "a", "text": ""}, {"type": "h3", "text": "Object transfer and freezing"}, {"type": "p", "text": "An important invariant that Kotlin/Native runtime maintains is that the object is either owned by a single\n  thread/worker, or it is immutable (shared XOR mutable). This ensures that the same data has a single mutator, and so there is no need for locking to exist. To achieve such an invariant, we use the concept of not externally referred object subgraphs.\n  This is a subgraph which has no external references from outside of the subgraph, which could be checked\n  algorithmically with O(N) complexity (in ARC systems), where N is the number of elements in such a subgraph.\n  Such subgraphs are usually produced as a result of a lambda expression, for example some builder, and may not\n  contain objects, referred to externally."}, {"type": "em", "text": "shared XOR mutable"}, {"type": "p", "text": "Freezing is a runtime operation making a given object subgraph immutable, by modifying the object header\n  so that future mutation attempts throw an InvalidMutabilityException. It is deep, so\n  if an object has a pointer to other objects - transitive closure of such objects will be frozen.\n  Freezing is a one way transformation, frozen objects cannot be unfrozen. Frozen objects have a nice\n  property that due to their immutability, they can be freely shared between multiple workers/threads\n  without breaking the \"mutable XOR shared\" invariant."}, {"type": "code", "text": "InvalidMutabilityException"}, {"type": "p", "text": "If an object is frozen it can be checked with an extension property isFrozen, and if it is, object sharing\n is allowed. Currently, Kotlin/Native runtime only freezes the enum objects after creation, although additional\n autofreezing of certain provably immutable objects could be implemented in the future."}, {"type": "code", "text": "isFrozen"}, {"type": "p", "text": ""}, {"type": "a", "text": ""}, {"type": "h3", "text": "Object subgraph detachment"}, {"type": "p", "text": "An object subgraph without external references can be disconnected using DetachedObjectGraph<T> to\n  a COpaquePointer value, which could be stored in void* data, so the disconnected object subgraphs\n  can be stored in a C data structure, and later attached back with DetachedObjectGraph<T>.attach() in an arbitrary thread\n  or a worker. Combining it with raw memory sharing it allows side channel object transfer between\n  concurrent threads, if the worker mechanisms are insufficient for a particular task."}, {"type": "code", "text": "DetachedObjectGraph<T>"}, {"type": "code", "text": "COpaquePointer"}, {"type": "code", "text": "void*"}, {"type": "code", "text": "DetachedObjectGraph<T>.attach()"}, {"type": "a", "text": "raw memory sharing"}, {"type": "p", "text": ""}, {"type": "a", "text": ""}, {"type": "h3", "text": "Raw shared memory"}, {"type": "p", "text": "Considering the strong ties between Kotlin/Native and C via interoperability, in conjunction with the other mechanisms\n mentioned above it is possible to build popular data structures, like concurrent hashmap or shared cache with\n Kotlin/Native. It is possible to rely upon shared C data, and store in it references to detached object subgraphs.\n Consider the following .def file:"}, {"type": "div", "text": "\npackage = global\n\n---\ntypedef struct {\n  int version;\n  void* kotlinObject;\n} SharedData;\n\nSharedData sharedData;\n\n"}, {"type": "pre", "text": "package = global\n\n---\ntypedef struct {\n  int version;\n  void* kotlinObject;\n} SharedData;\n\nSharedData sharedData;\n"}, {"type": "code", "text": "package = global\n\n---\ntypedef struct {\n  int version;\n  void* kotlinObject;\n} SharedData;\n\nSharedData sharedData;\n"}, {"type": "p", "text": "After running the cinterop tool it can share Kotlin data in a versionized global structure,\nand interact with it from Kotlin transparently via autogenerated Kotlin like this:"}, {"type": "div", "text": "\nclass SharedData(rawPtr: NativePtr) : CStructVar(rawPtr) {\n    var version: Int\n    var kotlinObject: COpaquePointer?\n}\n\n"}, {"type": "pre", "text": "class SharedData(rawPtr: NativePtr) : CStructVar(rawPtr) {\n    var version: Int\n    var kotlinObject: COpaquePointer?\n}\n"}, {"type": "code", "text": "class SharedData(rawPtr: NativePtr) : CStructVar(rawPtr) {\n    var version: Int\n    var kotlinObject: COpaquePointer?\n}\n"}, {"type": "p", "text": "So in combination with the top level variable declared above, it can allow looking at the same memory from different\nthreads and building traditional concurrent structures with platform-specific synchronization primitives."}, {"type": "p", "text": ""}, {"type": "a", "text": ""}, {"type": "h3", "text": "Global variables and singletons"}, {"type": "p", "text": "Frequently, global variables are a source of unintended concurrency issues, so Kotlin/Native implements\nthe following mechanisms to prevent the unintended sharing of state via global objects:"}, {"type": "em", "text": "Kotlin/Native"}, {"type": "ul", "text": "\nglobal variables, unless specially marked, can be only accessed from the main thread (that is, the thread\n   Kotlin/Native runtime was first initialized), if other thread access such a global, IncorrectDereferenceException is thrown\nfor global variables marked with the @kotlin.native.ThreadLocal annotation each threads keeps thread-local copy,\n   so changes are not visible between threads\nfor global variables marked with the @kotlin.native.SharedImmutable annotation value is shared, but frozen\n   before publishing, so each threads sees the same value\nsingleton objects unless marked with @kotlin.native.ThreadLocal are frozen and shared, lazy values allowed,\n   unless cyclic frozen structures were attempted to be created\nenums are always frozen\n"}, {"type": "li", "text": "global variables, unless specially marked, can be only accessed from the main thread (that is, the thread\n   Kotlin/Native runtime was first initialized), if other thread access such a global, IncorrectDereferenceException is thrown"}, {"type": "em", "text": "Kotlin/Native"}, {"type": "code", "text": "IncorrectDereferenceException"}, {"type": "li", "text": "for global variables marked with the @kotlin.native.ThreadLocal annotation each threads keeps thread-local copy,\n   so changes are not visible between threads"}, {"type": "code", "text": "@kotlin.native.ThreadLocal"}, {"type": "li", "text": "for global variables marked with the @kotlin.native.SharedImmutable annotation value is shared, but frozen\n   before publishing, so each threads sees the same value"}, {"type": "code", "text": "@kotlin.native.SharedImmutable"}, {"type": "li", "text": "singleton objects unless marked with @kotlin.native.ThreadLocal are frozen and shared, lazy values allowed,\n   unless cyclic frozen structures were attempted to be created"}, {"type": "code", "text": "@kotlin.native.ThreadLocal"}, {"type": "li", "text": "enums are always frozen"}, {"type": "p", "text": "Combined, these mechanisms allow natural race-free programming with code reuse across platforms in MPP projects."}]