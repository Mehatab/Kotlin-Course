[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Delegation"}, {"type": "h2", "text": "Property Delegation"}, {"type": "p", "text": "Delegated properties are described on a separate page: Delegated Properties."}, {"type": "a", "text": "Delegated Properties"}, {"type": "h2", "text": "Implementation by Delegation"}, {"type": "p", "text": "The Delegation pattern has proven to be a good alternative to implementation inheritance,\nand Kotlin supports it natively requiring zero boilerplate code.\nA class Derived can implement an interface Base by delegating all of its public members to a specified object:"}, {"type": "a", "text": "Delegation pattern"}, {"type": "code", "text": "Derived"}, {"type": "code", "text": "Base"}, {"type": "div", "text": "\ninterface Base {\n    fun print()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override fun print() { print(x) }\n}\n\nclass Derived(b: Base) : Base by b\n\nfun main() {\n    val b = BaseImpl(10)\n    Derived(b).print()\n}\n\n"}, {"type": "pre", "text": "interface Base {\n    fun print()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override fun print() { print(x) }\n}\n\nclass Derived(b: Base) : Base by b\n\nfun main() {\n    val b = BaseImpl(10)\n    Derived(b).print()\n}\n"}, {"type": "code", "text": "interface Base {\n    fun print()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override fun print() { print(x) }\n}\n\nclass Derived(b: Base) : Base by b\n\nfun main() {\n    val b = BaseImpl(10)\n    Derived(b).print()\n}\n"}, {"type": "p", "text": "The by-clause in the supertype list for Derived indicates that b will be stored internally in objects \nof Derived and the compiler will generate all the methods of Base that forward to b."}, {"type": "em", "text": "by"}, {"type": "code", "text": "Derived"}, {"type": "code", "text": "b"}, {"type": "code", "text": "Derived"}, {"type": "code", "text": "Base"}, {"type": "code", "text": "b"}, {"type": "h3", "text": "Overriding a member of an interface implemented by delegation"}, {"type": "p", "text": "Overrides work as you might expect: the compiler will use your override \nimplementations instead of those in the delegate object. If we were to add override fun printMessage() { print(\"abc\") } to \nDerived, the program would print \"abc\" instead of \"10\" when printMessage is called:"}, {"type": "a", "text": "Overrides"}, {"type": "code", "text": "override"}, {"type": "code", "text": "override fun printMessage() { print(\"abc\") }"}, {"type": "code", "text": "Derived"}, {"type": "code", "text": "printMessage"}, {"type": "div", "text": "\ninterface Base {\n    fun printMessage()\n    fun printMessageLine()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override fun printMessage() { print(x) }\n    override fun printMessageLine() { println(x) }\n}\n\nclass Derived(b: Base) : Base by b {\n    override fun printMessage() { print(\"abc\") }\n}\n\nfun main() {\n    val b = BaseImpl(10)\n    Derived(b).printMessage()\n    Derived(b).printMessageLine()\n}\n\n"}, {"type": "pre", "text": "interface Base {\n    fun printMessage()\n    fun printMessageLine()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override fun printMessage() { print(x) }\n    override fun printMessageLine() { println(x) }\n}\n\nclass Derived(b: Base) : Base by b {\n    override fun printMessage() { print(\"abc\") }\n}\n\nfun main() {\n    val b = BaseImpl(10)\n    Derived(b).printMessage()\n    Derived(b).printMessageLine()\n}\n"}, {"type": "code", "text": "interface Base {\n    fun printMessage()\n    fun printMessageLine()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override fun printMessage() { print(x) }\n    override fun printMessageLine() { println(x) }\n}\n\nclass Derived(b: Base) : Base by b {\n    override fun printMessage() { print(\"abc\") }\n}\n\nfun main() {\n    val b = BaseImpl(10)\n    Derived(b).printMessage()\n    Derived(b).printMessageLine()\n}\n"}, {"type": "p", "text": "Note, however, that members overridden in this way do not get called from the members of the \ndelegate object, which can only access its own implementations of the interface members:"}, {"type": "div", "text": "\ninterface Base {\n    val message: String\n    fun print()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override val message = \"BaseImpl: x = $x\"\n    override fun print() { println(message) }\n}\n\nclass Derived(b: Base) : Base by b {\n    // This property is not accessed from b's implementation of `print`\n    override val message = \"Message of Derived\"\n}\n\nfun main() {\n    val b = BaseImpl(10)\n    val derived = Derived(b)\n    derived.print()\n    println(derived.message)\n}\n\n"}, {"type": "pre", "text": "interface Base {\n    val message: String\n    fun print()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override val message = \"BaseImpl: x = $x\"\n    override fun print() { println(message) }\n}\n\nclass Derived(b: Base) : Base by b {\n    // This property is not accessed from b's implementation of `print`\n    override val message = \"Message of Derived\"\n}\n\nfun main() {\n    val b = BaseImpl(10)\n    val derived = Derived(b)\n    derived.print()\n    println(derived.message)\n}\n"}, {"type": "code", "text": "interface Base {\n    val message: String\n    fun print()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override val message = \"BaseImpl: x = $x\"\n    override fun print() { println(message) }\n}\n\nclass Derived(b: Base) : Base by b {\n    // This property is not accessed from b's implementation of `print`\n    override val message = \"Message of Derived\"\n}\n\nfun main() {\n    val b = BaseImpl(10)\n    val derived = Derived(b)\n    derived.print()\n    println(derived.message)\n}\n"}, {"type": "blockquote", "text": "\nOn the JVM: when an interface with default methods is used for delegation (including Kotlin interfaces with  @JvmDefault),\nthe default implementations are called even if the actual delegate type provides its own implementations.\nFor details, see Calling Kotlin from Java.\n"}, {"type": "p", "text": "On the JVM: when an interface with default methods is used for delegation (including Kotlin interfaces with  @JvmDefault),\nthe default implementations are called even if the actual delegate type provides its own implementations.\nFor details, see Calling Kotlin from Java."}, {"type": "strong", "text": "On the JVM"}, {"type": "code", "text": "default"}, {"type": "code", "text": "@JvmDefault"}, {"type": "a", "text": "Calling Kotlin from Java"}]