[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "p", "text": "Table of contents"}, {"type": "strong", "text": "Table of contents"}, {"type": "ul", "text": "\nCoroutine Basics\n\nYour first coroutine\nBridging blocking and non-blocking worlds\nWaiting for a job\nStructured concurrency\nScope builder\nExtract function refactoring\nCoroutines ARE light-weight\nGlobal coroutines are like daemon threads\n\n\n"}, {"type": "li", "text": "Coroutine Basics\n\nYour first coroutine\nBridging blocking and non-blocking worlds\nWaiting for a job\nStructured concurrency\nScope builder\nExtract function refactoring\nCoroutines ARE light-weight\nGlobal coroutines are like daemon threads\n\n"}, {"type": "a", "text": "Coroutine Basics"}, {"type": "ul", "text": "\nYour first coroutine\nBridging blocking and non-blocking worlds\nWaiting for a job\nStructured concurrency\nScope builder\nExtract function refactoring\nCoroutines ARE light-weight\nGlobal coroutines are like daemon threads\n"}, {"type": "li", "text": "Your first coroutine"}, {"type": "a", "text": "Your first coroutine"}, {"type": "li", "text": "Bridging blocking and non-blocking worlds"}, {"type": "a", "text": "Bridging blocking and non-blocking worlds"}, {"type": "li", "text": "Waiting for a job"}, {"type": "a", "text": "Waiting for a job"}, {"type": "li", "text": "Structured concurrency"}, {"type": "a", "text": "Structured concurrency"}, {"type": "li", "text": "Scope builder"}, {"type": "a", "text": "Scope builder"}, {"type": "li", "text": "Extract function refactoring"}, {"type": "a", "text": "Extract function refactoring"}, {"type": "li", "text": "Coroutines ARE light-weight"}, {"type": "a", "text": "Coroutines ARE light-weight"}, {"type": "li", "text": "Global coroutines are like daemon threads"}, {"type": "a", "text": "Global coroutines are like daemon threads"}, {"type": "h2", "text": "Coroutine Basics"}, {"type": "p", "text": "This section covers basic coroutine concepts."}, {"type": "h3", "text": "Your first coroutine"}, {"type": "p", "text": "Run the following code:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { // launch a new coroutine in background and continue\n        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)\n        println(\"World!\") // print after delay\n    }\n    println(\"Hello,\") // main thread continues while coroutine is delayed\n    Thread.sleep(2000L) // block main thread for 2 seconds to keep JVM alive\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { // launch a new coroutine in background and continue\n        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)\n        println(\"World!\") // print after delay\n    }\n    println(\"Hello,\") // main thread continues while coroutine is delayed\n    Thread.sleep(2000L) // block main thread for 2 seconds to keep JVM alive\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { // launch a new coroutine in background and continue\n        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)\n        println(\"World!\") // print after delay\n    }\n    println(\"Hello,\") // main thread continues while coroutine is delayed\n    Thread.sleep(2000L) // block main thread for 2 seconds to keep JVM alive\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "You will see the following result:"}, {"type": "pre", "text": "Hello,\nWorld!\n"}, {"type": "code", "text": "Hello,\nWorld!\n"}, {"type": "p", "text": "Essentially, coroutines are light-weight threads.\nThey are launched with launch coroutine builder in a context of some CoroutineScope.\nHere we are launching a new coroutine in the GlobalScope, meaning that the lifetime of the new\ncoroutine is limited only by the lifetime of the whole application."}, {"type": "a", "text": "launch"}, {"type": "em", "text": "coroutine builder"}, {"type": "a", "text": "CoroutineScope"}, {"type": "a", "text": "GlobalScope"}, {"type": "p", "text": "You can achieve the same result replacing\nGlobalScope.launch { ... } with thread { ... } and delay(...) with Thread.sleep(...). \nTry it (don't forget to import kotlin.concurrent.thread)."}, {"type": "code", "text": "GlobalScope.launch { ... }"}, {"type": "code", "text": "thread { ... }"}, {"type": "code", "text": "delay(...)"}, {"type": "code", "text": "Thread.sleep(...)"}, {"type": "code", "text": "kotlin.concurrent.thread"}, {"type": "p", "text": "If you start by replacing GlobalScope.launch by thread, the compiler produces the following error:"}, {"type": "code", "text": "GlobalScope.launch"}, {"type": "code", "text": "thread"}, {"type": "pre", "text": "Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function\n"}, {"type": "code", "text": "Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function\n"}, {"type": "p", "text": "That is because delay is a special suspending function that does not block a thread, but suspends\ncoroutine and it can be only used from a coroutine."}, {"type": "a", "text": "delay"}, {"type": "em", "text": "suspending function"}, {"type": "em", "text": "suspends"}, {"type": "h3", "text": "Bridging blocking and non-blocking worlds"}, {"type": "p", "text": "The first example mixes non-blocking delay(...) and blocking Thread.sleep(...) in the same code. \nIt is easy to lose track of which one is blocking and which one is not. \nLet's be explicit about blocking using runBlocking coroutine builder:"}, {"type": "em", "text": "non-blocking"}, {"type": "code", "text": "delay(...)"}, {"type": "em", "text": "blocking"}, {"type": "code", "text": "Thread.sleep(...)"}, {"type": "a", "text": "runBlocking"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() { \n    GlobalScope.launch { // launch a new coroutine in background and continue\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\") // main thread continues here immediately\n    runBlocking {     // but this expression blocks the main thread\n        delay(2000L)  // ... while we delay for 2 seconds to keep JVM alive\n    } \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() { \n    GlobalScope.launch { // launch a new coroutine in background and continue\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\") // main thread continues here immediately\n    runBlocking {     // but this expression blocks the main thread\n        delay(2000L)  // ... while we delay for 2 seconds to keep JVM alive\n    } \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() { \n    GlobalScope.launch { // launch a new coroutine in background and continue\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\") // main thread continues here immediately\n    runBlocking {     // but this expression blocks the main thread\n        delay(2000L)  // ... while we delay for 2 seconds to keep JVM alive\n    } \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The result is the same, but this code uses only non-blocking delay. \nThe main thread invoking runBlocking blocks until the coroutine inside runBlocking completes."}, {"type": "a", "text": "delay"}, {"type": "code", "text": "runBlocking"}, {"type": "em", "text": "blocks"}, {"type": "code", "text": "runBlocking"}, {"type": "p", "text": "This example can be also rewritten in a more idiomatic way, using runBlocking to wrap \nthe execution of the main function:"}, {"type": "code", "text": "runBlocking"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> { // start main coroutine\n    GlobalScope.launch { // launch a new coroutine in background and continue\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\") // main coroutine continues here immediately\n    delay(2000L)      // delaying for 2 seconds to keep JVM alive\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> { // start main coroutine\n    GlobalScope.launch { // launch a new coroutine in background and continue\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\") // main coroutine continues here immediately\n    delay(2000L)      // delaying for 2 seconds to keep JVM alive\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> { // start main coroutine\n    GlobalScope.launch { // launch a new coroutine in background and continue\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\") // main coroutine continues here immediately\n    delay(2000L)      // delaying for 2 seconds to keep JVM alive\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Here runBlocking<Unit> { ... } works as an adaptor that is used to start the top-level main coroutine. \nWe explicitly specify its Unit return type, because a well-formed main function in Kotlin has to return Unit."}, {"type": "code", "text": "runBlocking<Unit> { ... }"}, {"type": "code", "text": "Unit"}, {"type": "code", "text": "main"}, {"type": "code", "text": "Unit"}, {"type": "p", "text": "This is also a way to write unit tests for suspending functions:"}, {"type": "div", "text": "\nclass MyTest {\n    @Test\n    fun testMySuspendingFunction() = runBlocking<Unit> {\n        // here we can use suspending functions using any assertion style that we like\n    }\n}\n\n"}, {"type": "pre", "text": "class MyTest {\n    @Test\n    fun testMySuspendingFunction() = runBlocking<Unit> {\n        // here we can use suspending functions using any assertion style that we like\n    }\n}\n"}, {"type": "code", "text": "class MyTest {\n    @Test\n    fun testMySuspendingFunction() = runBlocking<Unit> {\n        // here we can use suspending functions using any assertion style that we like\n    }\n}\n"}, {"type": "h3", "text": "Waiting for a job"}, {"type": "p", "text": "Delaying for a time while another coroutine is working is not a good approach. Let's explicitly \nwait (in a non-blocking way) until the background Job that we have launched is complete:"}, {"type": "a", "text": "Job"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = GlobalScope.launch { // launch a new coroutine and keep a reference to its Job\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    job.join() // wait until child coroutine completes\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = GlobalScope.launch { // launch a new coroutine and keep a reference to its Job\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    job.join() // wait until child coroutine completes\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = GlobalScope.launch { // launch a new coroutine and keep a reference to its Job\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    job.join() // wait until child coroutine completes\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Now the result is still the same, but the code of the main coroutine is not tied to the duration of\nthe background job in any way. Much better."}, {"type": "h3", "text": "Structured concurrency"}, {"type": "p", "text": "There is still something to be desired for practical usage of coroutines. \nWhen we use GlobalScope.launch, we create a top-level coroutine. Even though it is light-weight, it still \nconsumes some memory resources while it runs. If we forget to keep a reference to the newly launched \ncoroutine it still runs. What if the code in the coroutine hangs (for example, we erroneously\ndelay for too long), what if we launched too many coroutines and ran out of memory? \nHaving to manually keep references to all the launched coroutines and join them is error-prone."}, {"type": "code", "text": "GlobalScope.launch"}, {"type": "a", "text": "join"}, {"type": "p", "text": "There is a better solution. We can use structured concurrency in our code. \nInstead of launching coroutines in the GlobalScope, just like we usually do with threads (threads are always global), \nwe can launch coroutines in the specific scope of the operation we are performing."}, {"type": "a", "text": "GlobalScope"}, {"type": "p", "text": "In our example, we have main function that is turned into a coroutine using runBlocking coroutine builder.\nEvery coroutine builder, including runBlocking, adds an instance of CoroutineScope to the scope of its code block. \nWe can launch coroutines in this scope without having to join them explicitly, because\nan outer coroutine (runBlocking in our example) does not complete until all the coroutines launched\nin its scope complete. Thus, we can make our example simpler:"}, {"type": "code", "text": "main"}, {"type": "a", "text": "runBlocking"}, {"type": "code", "text": "runBlocking"}, {"type": "a", "text": "CoroutineScope"}, {"type": "code", "text": "join"}, {"type": "code", "text": "runBlocking"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking { // this: CoroutineScope\n    launch { // launch a new coroutine in the scope of runBlocking\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking { // this: CoroutineScope\n    launch { // launch a new coroutine in the scope of runBlocking\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking { // this: CoroutineScope\n    launch { // launch a new coroutine in the scope of runBlocking\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "h3", "text": "Scope builder"}, {"type": "p", "text": "In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using\ncoroutineScope builder. It creates a coroutine scope and does not complete until all launched children\ncomplete."}, {"type": "a", "text": "coroutineScope"}, {"type": "p", "text": "runBlocking and coroutineScope may look similar because they both wait for its body and all its children to complete.\nThe main difference between these two is that the runBlocking method blocks the current thread for waiting,\nwhile coroutineScope just suspends, releasing the underlying thread for other usages.\nBecause of that difference, runBlocking is a regular function and coroutineScope is a suspending function."}, {"type": "a", "text": "runBlocking"}, {"type": "a", "text": "coroutineScope"}, {"type": "a", "text": "runBlocking"}, {"type": "em", "text": "blocks"}, {"type": "a", "text": "coroutineScope"}, {"type": "a", "text": "runBlocking"}, {"type": "a", "text": "coroutineScope"}, {"type": "p", "text": "It can be demonstrated by the following example:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking { // this: CoroutineScope\n    launch { \n        delay(200L)\n        println(\"Task from runBlocking\")\n    }\n    \n    coroutineScope { // Creates a coroutine scope\n        launch {\n            delay(500L) \n            println(\"Task from nested launch\")\n        }\n    \n        delay(100L)\n        println(\"Task from coroutine scope\") // This line will be printed before the nested launch\n    }\n    \n    println(\"Coroutine scope is over\") // This line is not printed until the nested launch completes\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking { // this: CoroutineScope\n    launch { \n        delay(200L)\n        println(\"Task from runBlocking\")\n    }\n    \n    coroutineScope { // Creates a coroutine scope\n        launch {\n            delay(500L) \n            println(\"Task from nested launch\")\n        }\n    \n        delay(100L)\n        println(\"Task from coroutine scope\") // This line will be printed before the nested launch\n    }\n    \n    println(\"Coroutine scope is over\") // This line is not printed until the nested launch completes\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking { // this: CoroutineScope\n    launch { \n        delay(200L)\n        println(\"Task from runBlocking\")\n    }\n    \n    coroutineScope { // Creates a coroutine scope\n        launch {\n            delay(500L) \n            println(\"Task from nested launch\")\n        }\n    \n        delay(100L)\n        println(\"Task from coroutine scope\") // This line will be printed before the nested launch\n    }\n    \n    println(\"Coroutine scope is over\") // This line is not printed until the nested launch completes\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Note that right after \"Task from coroutine scope\" message, while waiting for nested launch,\n \"Task from runBlocking\" is executed and printed, though coroutineScope is not completed yet."}, {"type": "h3", "text": "Extract function refactoring"}, {"type": "p", "text": "Let's extract the block of code inside launch { ... } into a separate function. When you \nperform \"Extract function\" refactoring on this code you get a new function with suspend modifier.\nThat is your first suspending function. Suspending functions can be used inside coroutines\njust like regular functions, but their additional feature is that they can, in turn, \nuse other suspending functions, like delay in this example, to suspend execution of a coroutine."}, {"type": "code", "text": "launch { ... }"}, {"type": "code", "text": "suspend"}, {"type": "em", "text": "suspending function"}, {"type": "code", "text": "delay"}, {"type": "em", "text": "suspend"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    launch { doWorld() }\n    println(\"Hello,\")\n}\n\n// this is your first suspending function\nsuspend fun doWorld() {\n    delay(1000L)\n    println(\"World!\")\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    launch { doWorld() }\n    println(\"Hello,\")\n}\n\n// this is your first suspending function\nsuspend fun doWorld() {\n    delay(1000L)\n    println(\"World!\")\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    launch { doWorld() }\n    println(\"Hello,\")\n}\n\n// this is your first suspending function\nsuspend fun doWorld() {\n    delay(1000L)\n    println(\"World!\")\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "But what if the extracted function contains a coroutine builder which is invoked on the current scope?\nIn this case suspend modifier on the extracted function is not enough. Making doWorld an extension\nmethod on CoroutineScope is one of the solutions, but it may not always be applicable as it does not make API clearer.\nThe idiomatic solution is to have either an explicit CoroutineScope as a field in a class containing the target function\nor an implicit one when the outer class implements CoroutineScope.\nAs a last resort, CoroutineScope(coroutineContext) can be used, but such approach is structurally unsafe \nbecause you no longer have control on the scope of execution of this method. Only private APIs can use this builder."}, {"type": "code", "text": "suspend"}, {"type": "code", "text": "doWorld"}, {"type": "code", "text": "CoroutineScope"}, {"type": "code", "text": "CoroutineScope"}, {"type": "code", "text": "CoroutineScope"}, {"type": "a", "text": "CoroutineScope(coroutineContext)"}, {"type": "h3", "text": "Coroutines ARE light-weight"}, {"type": "p", "text": "Run the following code:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    repeat(100_000) { // launch a lot of coroutines\n        launch {\n            delay(1000L)\n            print(\".\")\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    repeat(100_000) { // launch a lot of coroutines\n        launch {\n            delay(1000L)\n            print(\".\")\n        }\n    }\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    repeat(100_000) { // launch a lot of coroutines\n        launch {\n            delay(1000L)\n            print(\".\")\n        }\n    }\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It launches 100K coroutines and, after a second, each coroutine prints a dot. \nNow, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)"}, {"type": "h3", "text": "Global coroutines are like daemon threads"}, {"type": "p", "text": "The following code launches a long-running coroutine in GlobalScope that prints \"I'm sleeping\" twice a second and then \nreturns from the main function after some delay:"}, {"type": "a", "text": "GlobalScope"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    GlobalScope.launch {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n    delay(1300L) // just quit after delay\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    GlobalScope.launch {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n    delay(1300L) // just quit after delay\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    GlobalScope.launch {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n    delay(1300L) // just quit after delay\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "You can run and see that it prints three lines and terminates:"}, {"type": "pre", "text": "I'm sleeping 0 ...\nI'm sleeping 1 ...\nI'm sleeping 2 ...\n"}, {"type": "code", "text": "I'm sleeping 0 ...\nI'm sleeping 1 ...\nI'm sleeping 2 ...\n"}, {"type": "p", "text": "Active coroutines that were launched in GlobalScope do not keep the process alive. They are like daemon threads."}, {"type": "a", "text": "GlobalScope"}]