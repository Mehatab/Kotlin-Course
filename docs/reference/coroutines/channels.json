[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "p", "text": "Table of contents"}, {"type": "strong", "text": "Table of contents"}, {"type": "ul", "text": "\nChannels\n\nChannel basics\nClosing and iteration over channels\nBuilding channel producers\nPipelines\nPrime numbers with pipeline\nFan-out\nFan-in\nBuffered channels\nChannels are fair\nTicker channels\n\n\n"}, {"type": "li", "text": "Channels\n\nChannel basics\nClosing and iteration over channels\nBuilding channel producers\nPipelines\nPrime numbers with pipeline\nFan-out\nFan-in\nBuffered channels\nChannels are fair\nTicker channels\n\n"}, {"type": "a", "text": "Channels"}, {"type": "ul", "text": "\nChannel basics\nClosing and iteration over channels\nBuilding channel producers\nPipelines\nPrime numbers with pipeline\nFan-out\nFan-in\nBuffered channels\nChannels are fair\nTicker channels\n"}, {"type": "li", "text": "Channel basics"}, {"type": "a", "text": "Channel basics"}, {"type": "li", "text": "Closing and iteration over channels"}, {"type": "a", "text": "Closing and iteration over channels"}, {"type": "li", "text": "Building channel producers"}, {"type": "a", "text": "Building channel producers"}, {"type": "li", "text": "Pipelines"}, {"type": "a", "text": "Pipelines"}, {"type": "li", "text": "Prime numbers with pipeline"}, {"type": "a", "text": "Prime numbers with pipeline"}, {"type": "li", "text": "Fan-out"}, {"type": "a", "text": "Fan-out"}, {"type": "li", "text": "Fan-in"}, {"type": "a", "text": "Fan-in"}, {"type": "li", "text": "Buffered channels"}, {"type": "a", "text": "Buffered channels"}, {"type": "li", "text": "Channels are fair"}, {"type": "a", "text": "Channels are fair"}, {"type": "li", "text": "Ticker channels"}, {"type": "a", "text": "Ticker channels"}, {"type": "h2", "text": "Channels"}, {"type": "p", "text": "Deferred values provide a convenient way to transfer a single value between coroutines.\nChannels provide a way to transfer a stream of values."}, {"type": "h3", "text": "Channel basics"}, {"type": "p", "text": "A Channel is conceptually very similar to BlockingQueue. One key difference is that\ninstead of a blocking put operation it has a suspending send, and instead of \na blocking take operation it has a suspending receive."}, {"type": "a", "text": "Channel"}, {"type": "code", "text": "BlockingQueue"}, {"type": "code", "text": "put"}, {"type": "a", "text": "send"}, {"type": "code", "text": "take"}, {"type": "a", "text": "receive"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    val channel = Channel<Int>()\n    launch {\n        // this might be heavy CPU-consuming computation or async logic, we'll just send five squares\n        for (x in 1..5) channel.send(x * x)\n    }\n    // here we print five received integers:\n    repeat(5) { println(channel.receive()) }\n    println(\"Done!\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    val channel = Channel<Int>()\n    launch {\n        // this might be heavy CPU-consuming computation or async logic, we'll just send five squares\n        for (x in 1..5) channel.send(x * x)\n    }\n    // here we print five received integers:\n    repeat(5) { println(channel.receive()) }\n    println(\"Done!\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    val channel = Channel<Int>()\n    launch {\n        // this might be heavy CPU-consuming computation or async logic, we'll just send five squares\n        for (x in 1..5) channel.send(x * x)\n    }\n    // here we print five received integers:\n    repeat(5) { println(channel.receive()) }\n    println(\"Done!\")\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code is:"}, {"type": "pre", "text": "1\n4\n9\n16\n25\nDone!\n"}, {"type": "code", "text": "1\n4\n9\n16\n25\nDone!\n"}, {"type": "h3", "text": "Closing and iteration over channels"}, {"type": "p", "text": "Unlike a queue, a channel can be closed to indicate that no more elements are coming. \nOn the receiver side it is convenient to use a regular for loop to receive elements \nfrom the channel."}, {"type": "code", "text": "for"}, {"type": "p", "text": "Conceptually, a close is like sending a special close token to the channel. \nThe iteration stops as soon as this close token is received, so there is a guarantee \nthat all previously sent elements before the close are received:"}, {"type": "a", "text": "close"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    val channel = Channel<Int>()\n    launch {\n        for (x in 1..5) channel.send(x * x)\n        channel.close() // we're done sending\n    }\n    // here we print received values using `for` loop (until the channel is closed)\n    for (y in channel) println(y)\n    println(\"Done!\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    val channel = Channel<Int>()\n    launch {\n        for (x in 1..5) channel.send(x * x)\n        channel.close() // we're done sending\n    }\n    // here we print received values using `for` loop (until the channel is closed)\n    for (y in channel) println(y)\n    println(\"Done!\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    val channel = Channel<Int>()\n    launch {\n        for (x in 1..5) channel.send(x * x)\n        channel.close() // we're done sending\n    }\n    // here we print received values using `for` loop (until the channel is closed)\n    for (y in channel) println(y)\n    println(\"Done!\")\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "h3", "text": "Building channel producers"}, {"type": "p", "text": "The pattern where a coroutine is producing a sequence of elements is quite common. \nThis is a part of producer-consumer pattern that is often found in concurrent code. \nYou could abstract such a producer into a function that takes channel as its parameter, but this goes contrary\nto common sense that results must be returned from functions."}, {"type": "em", "text": "producer-consumer"}, {"type": "p", "text": "There is a convenient coroutine builder named produce that makes it easy to do it right on producer side,\nand an extension function consumeEach, that replaces a for loop on the consumer side:"}, {"type": "a", "text": "produce"}, {"type": "a", "text": "consumeEach"}, {"type": "code", "text": "for"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun CoroutineScope.produceSquares(): ReceiveChannel<Int> = produce {\n    for (x in 1..5) send(x * x)\n}\n\nfun main() = runBlocking {\n//sampleStart\n    val squares = produceSquares()\n    squares.consumeEach { println(it) }\n    println(\"Done!\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun CoroutineScope.produceSquares(): ReceiveChannel<Int> = produce {\n    for (x in 1..5) send(x * x)\n}\n\nfun main() = runBlocking {\n//sampleStart\n    val squares = produceSquares()\n    squares.consumeEach { println(it) }\n    println(\"Done!\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun CoroutineScope.produceSquares(): ReceiveChannel<Int> = produce {\n    for (x in 1..5) send(x * x)\n}\n\nfun main() = runBlocking {\n//sampleStart\n    val squares = produceSquares()\n    squares.consumeEach { println(it) }\n    println(\"Done!\")\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "h3", "text": "Pipelines"}, {"type": "p", "text": "A pipeline is a pattern where one coroutine is producing, possibly infinite, stream of values:"}, {"type": "div", "text": "\nfun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1\n    while (true) send(x++) // infinite stream of integers starting from 1\n}\n\n"}, {"type": "pre", "text": "fun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1\n    while (true) send(x++) // infinite stream of integers starting from 1\n}\n"}, {"type": "code", "text": "fun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1\n    while (true) send(x++) // infinite stream of integers starting from 1\n}\n"}, {"type": "p", "text": "And another coroutine or coroutines are consuming that stream, doing some processing, and producing some other results.\nIn the example below, the numbers are just squared:"}, {"type": "div", "text": "\nfun CoroutineScope.square(numbers: ReceiveChannel<Int>): ReceiveChannel<Int> = produce {\n    for (x in numbers) send(x * x)\n}\n\n"}, {"type": "pre", "text": "fun CoroutineScope.square(numbers: ReceiveChannel<Int>): ReceiveChannel<Int> = produce {\n    for (x in numbers) send(x * x)\n}\n"}, {"type": "code", "text": "fun CoroutineScope.square(numbers: ReceiveChannel<Int>): ReceiveChannel<Int> = produce {\n    for (x in numbers) send(x * x)\n}\n"}, {"type": "p", "text": "The main code starts and connects the whole pipeline:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    val numbers = produceNumbers() // produces integers from 1 and on\n    val squares = square(numbers) // squares integers\n    repeat(5) {\n        println(squares.receive()) // print first five\n    }\n    println(\"Done!\") // we are done\n    coroutineContext.cancelChildren() // cancel children coroutines\n//sampleEnd\n}\n\nfun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1\n    while (true) send(x++) // infinite stream of integers starting from 1\n}\n\nfun CoroutineScope.square(numbers: ReceiveChannel<Int>): ReceiveChannel<Int> = produce {\n    for (x in numbers) send(x * x)\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    val numbers = produceNumbers() // produces integers from 1 and on\n    val squares = square(numbers) // squares integers\n    repeat(5) {\n        println(squares.receive()) // print first five\n    }\n    println(\"Done!\") // we are done\n    coroutineContext.cancelChildren() // cancel children coroutines\n//sampleEnd\n}\n\nfun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1\n    while (true) send(x++) // infinite stream of integers starting from 1\n}\n\nfun CoroutineScope.square(numbers: ReceiveChannel<Int>): ReceiveChannel<Int> = produce {\n    for (x in numbers) send(x * x)\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    val numbers = produceNumbers() // produces integers from 1 and on\n    val squares = square(numbers) // squares integers\n    repeat(5) {\n        println(squares.receive()) // print first five\n    }\n    println(\"Done!\") // we are done\n    coroutineContext.cancelChildren() // cancel children coroutines\n//sampleEnd\n}\n\nfun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1\n    while (true) send(x++) // infinite stream of integers starting from 1\n}\n\nfun CoroutineScope.square(numbers: ReceiveChannel<Int>): ReceiveChannel<Int> = produce {\n    for (x in numbers) send(x * x)\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "blockquote", "text": "\nAll functions that create coroutines are defined as extensions on CoroutineScope,\nso that we can rely on structured concurrency to make\nsure that we don't have lingering global coroutines in our application.\n"}, {"type": "p", "text": "All functions that create coroutines are defined as extensions on CoroutineScope,\nso that we can rely on structured concurrency to make\nsure that we don't have lingering global coroutines in our application."}, {"type": "a", "text": "CoroutineScope"}, {"type": "a", "text": "structured concurrency"}, {"type": "h3", "text": "Prime numbers with pipeline"}, {"type": "p", "text": "Let's take pipelines to the extreme with an example that generates prime numbers using a pipeline \nof coroutines. We start with an infinite sequence of numbers."}, {"type": "div", "text": "\nfun CoroutineScope.numbersFrom(start: Int) = produce<Int> {\n    var x = start\n    while (true) send(x++) // infinite stream of integers from start\n}\n\n"}, {"type": "pre", "text": "fun CoroutineScope.numbersFrom(start: Int) = produce<Int> {\n    var x = start\n    while (true) send(x++) // infinite stream of integers from start\n}\n"}, {"type": "code", "text": "fun CoroutineScope.numbersFrom(start: Int) = produce<Int> {\n    var x = start\n    while (true) send(x++) // infinite stream of integers from start\n}\n"}, {"type": "p", "text": "The following pipeline stage filters an incoming stream of numbers, removing all the numbers \nthat are divisible by the given prime number:"}, {"type": "div", "text": "\nfun CoroutineScope.filter(numbers: ReceiveChannel<Int>, prime: Int) = produce<Int> {\n    for (x in numbers) if (x % prime != 0) send(x)\n}\n\n"}, {"type": "pre", "text": "fun CoroutineScope.filter(numbers: ReceiveChannel<Int>, prime: Int) = produce<Int> {\n    for (x in numbers) if (x % prime != 0) send(x)\n}\n"}, {"type": "code", "text": "fun CoroutineScope.filter(numbers: ReceiveChannel<Int>, prime: Int) = produce<Int> {\n    for (x in numbers) if (x % prime != 0) send(x)\n}\n"}, {"type": "p", "text": "Now we build our pipeline by starting a stream of numbers from 2, taking a prime number from the current channel, \nand launching new pipeline stage for each prime number found:"}, {"type": "pre", "text": "numbersFrom(2) -> filter(2) -> filter(3) -> filter(5) -> filter(7) ... \n"}, {"type": "code", "text": "numbersFrom(2) -> filter(2) -> filter(3) -> filter(5) -> filter(7) ... \n"}, {"type": "p", "text": "The following example prints the first ten prime numbers, \nrunning the whole pipeline in the context of the main thread. Since all the coroutines are launched in\nthe scope of the main runBlocking coroutine \nwe don't have to keep an explicit list of all the coroutines we have started. \nWe use cancelChildren \nextension function to cancel all the children coroutines after we have printed\nthe first ten prime numbers."}, {"type": "a", "text": "runBlocking"}, {"type": "a", "text": "cancelChildren"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    var cur = numbersFrom(2)\n    repeat(10) {\n        val prime = cur.receive()\n        println(prime)\n        cur = filter(cur, prime)\n    }\n    coroutineContext.cancelChildren() // cancel all children to let main finish\n//sampleEnd    \n}\n\nfun CoroutineScope.numbersFrom(start: Int) = produce<Int> {\n    var x = start\n    while (true) send(x++) // infinite stream of integers from start\n}\n\nfun CoroutineScope.filter(numbers: ReceiveChannel<Int>, prime: Int) = produce<Int> {\n    for (x in numbers) if (x % prime != 0) send(x)\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    var cur = numbersFrom(2)\n    repeat(10) {\n        val prime = cur.receive()\n        println(prime)\n        cur = filter(cur, prime)\n    }\n    coroutineContext.cancelChildren() // cancel all children to let main finish\n//sampleEnd    \n}\n\nfun CoroutineScope.numbersFrom(start: Int) = produce<Int> {\n    var x = start\n    while (true) send(x++) // infinite stream of integers from start\n}\n\nfun CoroutineScope.filter(numbers: ReceiveChannel<Int>, prime: Int) = produce<Int> {\n    for (x in numbers) if (x % prime != 0) send(x)\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    var cur = numbersFrom(2)\n    repeat(10) {\n        val prime = cur.receive()\n        println(prime)\n        cur = filter(cur, prime)\n    }\n    coroutineContext.cancelChildren() // cancel all children to let main finish\n//sampleEnd    \n}\n\nfun CoroutineScope.numbersFrom(start: Int) = produce<Int> {\n    var x = start\n    while (true) send(x++) // infinite stream of integers from start\n}\n\nfun CoroutineScope.filter(numbers: ReceiveChannel<Int>, prime: Int) = produce<Int> {\n    for (x in numbers) if (x % prime != 0) send(x)\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code is:"}, {"type": "pre", "text": "2\n3\n5\n7\n11\n13\n17\n19\n23\n29\n"}, {"type": "code", "text": "2\n3\n5\n7\n11\n13\n17\n19\n23\n29\n"}, {"type": "p", "text": "Note that you can build the same pipeline using \niterator \ncoroutine builder from the standard library. \nReplace produce with iterator, send with yield, receive with next, \nReceiveChannel with Iterator, and get rid of the coroutine scope. You will not need runBlocking either.\nHowever, the benefit of a pipeline that uses channels as shown above is that it can actually use \nmultiple CPU cores if you run it in Dispatchers.Default context."}, {"type": "a", "text": "iterator"}, {"type": "code", "text": "iterator"}, {"type": "code", "text": "produce"}, {"type": "code", "text": "iterator"}, {"type": "code", "text": "send"}, {"type": "code", "text": "yield"}, {"type": "code", "text": "receive"}, {"type": "code", "text": "next"}, {"type": "code", "text": "ReceiveChannel"}, {"type": "code", "text": "Iterator"}, {"type": "code", "text": "runBlocking"}, {"type": "a", "text": "Dispatchers.Default"}, {"type": "p", "text": "Anyway, this is an extremely impractical way to find prime numbers. In practice, pipelines do involve some\nother suspending invocations (like asynchronous calls to remote services) and these pipelines cannot be\nbuilt using sequence/iterator, because they do not allow arbitrary suspension, unlike\nproduce, which is fully asynchronous."}, {"type": "code", "text": "sequence"}, {"type": "code", "text": "iterator"}, {"type": "code", "text": "produce"}, {"type": "h3", "text": "Fan-out"}, {"type": "p", "text": "Multiple coroutines may receive from the same channel, distributing work between themselves.\nLet us start with a producer coroutine that is periodically producing integers \n(ten numbers per second):"}, {"type": "div", "text": "\nfun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1 // start from 1\n    while (true) {\n        send(x++) // produce next\n        delay(100) // wait 0.1s\n    }\n}\n\n"}, {"type": "pre", "text": "fun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1 // start from 1\n    while (true) {\n        send(x++) // produce next\n        delay(100) // wait 0.1s\n    }\n}\n"}, {"type": "code", "text": "fun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1 // start from 1\n    while (true) {\n        send(x++) // produce next\n        delay(100) // wait 0.1s\n    }\n}\n"}, {"type": "p", "text": "Then we can have several processor coroutines. In this example, they just print their id and\nreceived number:"}, {"type": "div", "text": "\nfun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel<Int>) = launch {\n    for (msg in channel) {\n        println(\"Processor #$id received $msg\")\n    }    \n}\n\n"}, {"type": "pre", "text": "fun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel<Int>) = launch {\n    for (msg in channel) {\n        println(\"Processor #$id received $msg\")\n    }    \n}\n"}, {"type": "code", "text": "fun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel<Int>) = launch {\n    for (msg in channel) {\n        println(\"Processor #$id received $msg\")\n    }    \n}\n"}, {"type": "p", "text": "Now let us launch five processors and let them work for almost a second. See what happens:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val producer = produceNumbers()\n    repeat(5) { launchProcessor(it, producer) }\n    delay(950)\n    producer.cancel() // cancel producer coroutine and thus kill them all\n//sampleEnd\n}\n\nfun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1 // start from 1\n    while (true) {\n        send(x++) // produce next\n        delay(100) // wait 0.1s\n    }\n}\n\nfun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel<Int>) = launch {\n    for (msg in channel) {\n        println(\"Processor #$id received $msg\")\n    }    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val producer = produceNumbers()\n    repeat(5) { launchProcessor(it, producer) }\n    delay(950)\n    producer.cancel() // cancel producer coroutine and thus kill them all\n//sampleEnd\n}\n\nfun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1 // start from 1\n    while (true) {\n        send(x++) // produce next\n        delay(100) // wait 0.1s\n    }\n}\n\nfun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel<Int>) = launch {\n    for (msg in channel) {\n        println(\"Processor #$id received $msg\")\n    }    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val producer = produceNumbers()\n    repeat(5) { launchProcessor(it, producer) }\n    delay(950)\n    producer.cancel() // cancel producer coroutine and thus kill them all\n//sampleEnd\n}\n\nfun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1 // start from 1\n    while (true) {\n        send(x++) // produce next\n        delay(100) // wait 0.1s\n    }\n}\n\nfun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel<Int>) = launch {\n    for (msg in channel) {\n        println(\"Processor #$id received $msg\")\n    }    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output will be similar to the the following one, albeit the processor ids that receive\neach specific integer may be different:"}, {"type": "pre", "text": "Processor #2 received 1\nProcessor #4 received 2\nProcessor #0 received 3\nProcessor #1 received 4\nProcessor #3 received 5\nProcessor #2 received 6\nProcessor #4 received 7\nProcessor #0 received 8\nProcessor #1 received 9\nProcessor #3 received 10\n"}, {"type": "code", "text": "Processor #2 received 1\nProcessor #4 received 2\nProcessor #0 received 3\nProcessor #1 received 4\nProcessor #3 received 5\nProcessor #2 received 6\nProcessor #4 received 7\nProcessor #0 received 8\nProcessor #1 received 9\nProcessor #3 received 10\n"}, {"type": "p", "text": "Note that cancelling a producer coroutine closes its channel, thus eventually terminating iteration\nover the channel that processor coroutines are doing."}, {"type": "p", "text": "Also, pay attention to how we explicitly iterate over channel with for loop to perform fan-out in launchProcessor code. \nUnlike consumeEach, this for loop pattern is perfectly safe to use from multiple coroutines. If one of the processor \ncoroutines fails, then others would still be processing the channel, while a processor that is written via consumeEach \nalways consumes (cancels) the underlying channel on its normal or abnormal completion."}, {"type": "code", "text": "for"}, {"type": "code", "text": "launchProcessor"}, {"type": "code", "text": "consumeEach"}, {"type": "code", "text": "for"}, {"type": "code", "text": "consumeEach"}, {"type": "h3", "text": "Fan-in"}, {"type": "p", "text": "Multiple coroutines may send to the same channel.\nFor example, let us have a channel of strings, and a suspending function that \nrepeatedly sends a specified string to this channel with a specified delay:"}, {"type": "div", "text": "\nsuspend fun sendString(channel: SendChannel<String>, s: String, time: Long) {\n    while (true) {\n        delay(time)\n        channel.send(s)\n    }\n}\n\n"}, {"type": "pre", "text": "suspend fun sendString(channel: SendChannel<String>, s: String, time: Long) {\n    while (true) {\n        delay(time)\n        channel.send(s)\n    }\n}\n"}, {"type": "code", "text": "suspend fun sendString(channel: SendChannel<String>, s: String, time: Long) {\n    while (true) {\n        delay(time)\n        channel.send(s)\n    }\n}\n"}, {"type": "p", "text": "Now, let us see what happens if we launch a couple of coroutines sending strings \n(in this example we launch them in the context of the main thread as main coroutine's children):"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    val channel = Channel<String>()\n    launch { sendString(channel, \"foo\", 200L) }\n    launch { sendString(channel, \"BAR!\", 500L) }\n    repeat(6) { // receive first six\n        println(channel.receive())\n    }\n    coroutineContext.cancelChildren() // cancel all children to let main finish\n//sampleEnd\n}\n\nsuspend fun sendString(channel: SendChannel<String>, s: String, time: Long) {\n    while (true) {\n        delay(time)\n        channel.send(s)\n    }\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    val channel = Channel<String>()\n    launch { sendString(channel, \"foo\", 200L) }\n    launch { sendString(channel, \"BAR!\", 500L) }\n    repeat(6) { // receive first six\n        println(channel.receive())\n    }\n    coroutineContext.cancelChildren() // cancel all children to let main finish\n//sampleEnd\n}\n\nsuspend fun sendString(channel: SendChannel<String>, s: String, time: Long) {\n    while (true) {\n        delay(time)\n        channel.send(s)\n    }\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n//sampleStart\n    val channel = Channel<String>()\n    launch { sendString(channel, \"foo\", 200L) }\n    launch { sendString(channel, \"BAR!\", 500L) }\n    repeat(6) { // receive first six\n        println(channel.receive())\n    }\n    coroutineContext.cancelChildren() // cancel all children to let main finish\n//sampleEnd\n}\n\nsuspend fun sendString(channel: SendChannel<String>, s: String, time: Long) {\n    while (true) {\n        delay(time)\n        channel.send(s)\n    }\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output is:"}, {"type": "pre", "text": "foo\nfoo\nBAR!\nfoo\nfoo\nBAR!\n"}, {"type": "code", "text": "foo\nfoo\nBAR!\nfoo\nfoo\nBAR!\n"}, {"type": "h3", "text": "Buffered channels"}, {"type": "p", "text": "The channels shown so far had no buffer. Unbuffered channels transfer elements when sender and receiver \nmeet each other (aka rendezvous). If send is invoked first, then it is suspended until receive is invoked, \nif receive is invoked first, it is suspended until send is invoked."}, {"type": "p", "text": "Both Channel() factory function and produce builder take an optional capacity parameter to\nspecify buffer size. Buffer allows senders to send multiple elements before suspending, \nsimilar to the BlockingQueue with a specified capacity, which blocks when buffer is full."}, {"type": "a", "text": "Channel()"}, {"type": "a", "text": "produce"}, {"type": "code", "text": "capacity"}, {"type": "em", "text": "buffer size"}, {"type": "code", "text": "BlockingQueue"}, {"type": "p", "text": "Take a look at the behavior of the following code:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val channel = Channel<Int>(4) // create buffered channel\n    val sender = launch { // launch sender coroutine\n        repeat(10) {\n            println(\"Sending $it\") // print before sending each element\n            channel.send(it) // will suspend when buffer is full\n        }\n    }\n    // don't receive anything... just wait....\n    delay(1000)\n    sender.cancel() // cancel sender coroutine\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val channel = Channel<Int>(4) // create buffered channel\n    val sender = launch { // launch sender coroutine\n        repeat(10) {\n            println(\"Sending $it\") // print before sending each element\n            channel.send(it) // will suspend when buffer is full\n        }\n    }\n    // don't receive anything... just wait....\n    delay(1000)\n    sender.cancel() // cancel sender coroutine\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val channel = Channel<Int>(4) // create buffered channel\n    val sender = launch { // launch sender coroutine\n        repeat(10) {\n            println(\"Sending $it\") // print before sending each element\n            channel.send(it) // will suspend when buffer is full\n        }\n    }\n    // don't receive anything... just wait....\n    delay(1000)\n    sender.cancel() // cancel sender coroutine\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It prints \"sending\" five times using a buffered channel with capacity of four:"}, {"type": "em", "text": "five"}, {"type": "em", "text": "four"}, {"type": "pre", "text": "Sending 0\nSending 1\nSending 2\nSending 3\nSending 4\n"}, {"type": "code", "text": "Sending 0\nSending 1\nSending 2\nSending 3\nSending 4\n"}, {"type": "p", "text": "The first four elements are added to the buffer and the sender suspends when trying to send the fifth one."}, {"type": "h3", "text": "Channels are fair"}, {"type": "p", "text": "Send and receive operations to channels are fair with respect to the order of their invocation from \nmultiple coroutines. They are served in first-in first-out order, e.g. the first coroutine to invoke receive \ngets the element. In the following example two coroutines \"ping\" and \"pong\" are \nreceiving the \"ball\" object from the shared \"table\" channel."}, {"type": "em", "text": "fair"}, {"type": "code", "text": "receive"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\n//sampleStart\ndata class Ball(var hits: Int)\n\nfun main() = runBlocking {\n    val table = Channel<Ball>() // a shared table\n    launch { player(\"ping\", table) }\n    launch { player(\"pong\", table) }\n    table.send(Ball(0)) // serve the ball\n    delay(1000) // delay 1 second\n    coroutineContext.cancelChildren() // game over, cancel them\n}\n\nsuspend fun player(name: String, table: Channel<Ball>) {\n    for (ball in table) { // receive the ball in a loop\n        ball.hits++\n        println(\"$name $ball\")\n        delay(300) // wait a bit\n        table.send(ball) // send the ball back\n    }\n}\n//sampleEnd\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\n//sampleStart\ndata class Ball(var hits: Int)\n\nfun main() = runBlocking {\n    val table = Channel<Ball>() // a shared table\n    launch { player(\"ping\", table) }\n    launch { player(\"pong\", table) }\n    table.send(Ball(0)) // serve the ball\n    delay(1000) // delay 1 second\n    coroutineContext.cancelChildren() // game over, cancel them\n}\n\nsuspend fun player(name: String, table: Channel<Ball>) {\n    for (ball in table) { // receive the ball in a loop\n        ball.hits++\n        println(\"$name $ball\")\n        delay(300) // wait a bit\n        table.send(ball) // send the ball back\n    }\n}\n//sampleEnd\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\n//sampleStart\ndata class Ball(var hits: Int)\n\nfun main() = runBlocking {\n    val table = Channel<Ball>() // a shared table\n    launch { player(\"ping\", table) }\n    launch { player(\"pong\", table) }\n    table.send(Ball(0)) // serve the ball\n    delay(1000) // delay 1 second\n    coroutineContext.cancelChildren() // game over, cancel them\n}\n\nsuspend fun player(name: String, table: Channel<Ball>) {\n    for (ball in table) { // receive the ball in a loop\n        ball.hits++\n        println(\"$name $ball\")\n        delay(300) // wait a bit\n        table.send(ball) // send the ball back\n    }\n}\n//sampleEnd\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The \"ping\" coroutine is started first, so it is the first one to receive the ball. Even though \"ping\"\ncoroutine immediately starts receiving the ball again after sending it back to the table, the ball gets\nreceived by the \"pong\" coroutine, because it was already waiting for it:"}, {"type": "pre", "text": "ping Ball(hits=1)\npong Ball(hits=2)\nping Ball(hits=3)\npong Ball(hits=4)\n"}, {"type": "code", "text": "ping Ball(hits=1)\npong Ball(hits=2)\nping Ball(hits=3)\npong Ball(hits=4)\n"}, {"type": "p", "text": "Note that sometimes channels may produce executions that look unfair due to the nature of the executor\nthat is being used. See this issue for details."}, {"type": "a", "text": "this issue"}, {"type": "h3", "text": "Ticker channels"}, {"type": "p", "text": "Ticker channel is a special rendezvous channel that produces Unit every time given delay passes since last consumption from this channel.\nThough it may seem to be useless standalone, it is a useful building block to create complex time-based produce \npipelines and operators that do windowing and other time-dependent processing.\nTicker channel can be used in select to perform \"on tick\" action."}, {"type": "code", "text": "Unit"}, {"type": "a", "text": "produce"}, {"type": "a", "text": "select"}, {"type": "p", "text": "To create such channel use a factory method ticker. \nTo indicate that no further elements are needed use ReceiveChannel.cancel method on it."}, {"type": "a", "text": "ticker"}, {"type": "a", "text": "ReceiveChannel.cancel"}, {"type": "p", "text": "Now let's see how it works in practice:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking<Unit> {\n    val tickerChannel = ticker(delayMillis = 100, initialDelayMillis = 0) // create ticker channel\n    var nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }\n    println(\"Initial element is available immediately: $nextElement\") // no initial delay\n\n    nextElement = withTimeoutOrNull(50) { tickerChannel.receive() } // all subsequent elements have 100ms delay\n    println(\"Next element is not ready in 50 ms: $nextElement\")\n\n    nextElement = withTimeoutOrNull(60) { tickerChannel.receive() }\n    println(\"Next element is ready in 100 ms: $nextElement\")\n\n    // Emulate large consumption delays\n    println(\"Consumer pauses for 150ms\")\n    delay(150)\n    // Next element is available immediately\n    nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }\n    println(\"Next element is available immediately after large consumer delay: $nextElement\")\n    // Note that the pause between `receive` calls is taken into account and next element arrives faster\n    nextElement = withTimeoutOrNull(60) { tickerChannel.receive() } \n    println(\"Next element is ready in 50ms after consumer pause in 150ms: $nextElement\")\n\n    tickerChannel.cancel() // indicate that no more elements are needed\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking<Unit> {\n    val tickerChannel = ticker(delayMillis = 100, initialDelayMillis = 0) // create ticker channel\n    var nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }\n    println(\"Initial element is available immediately: $nextElement\") // no initial delay\n\n    nextElement = withTimeoutOrNull(50) { tickerChannel.receive() } // all subsequent elements have 100ms delay\n    println(\"Next element is not ready in 50 ms: $nextElement\")\n\n    nextElement = withTimeoutOrNull(60) { tickerChannel.receive() }\n    println(\"Next element is ready in 100 ms: $nextElement\")\n\n    // Emulate large consumption delays\n    println(\"Consumer pauses for 150ms\")\n    delay(150)\n    // Next element is available immediately\n    nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }\n    println(\"Next element is available immediately after large consumer delay: $nextElement\")\n    // Note that the pause between `receive` calls is taken into account and next element arrives faster\n    nextElement = withTimeoutOrNull(60) { tickerChannel.receive() } \n    println(\"Next element is ready in 50ms after consumer pause in 150ms: $nextElement\")\n\n    tickerChannel.cancel() // indicate that no more elements are needed\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking<Unit> {\n    val tickerChannel = ticker(delayMillis = 100, initialDelayMillis = 0) // create ticker channel\n    var nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }\n    println(\"Initial element is available immediately: $nextElement\") // no initial delay\n\n    nextElement = withTimeoutOrNull(50) { tickerChannel.receive() } // all subsequent elements have 100ms delay\n    println(\"Next element is not ready in 50 ms: $nextElement\")\n\n    nextElement = withTimeoutOrNull(60) { tickerChannel.receive() }\n    println(\"Next element is ready in 100 ms: $nextElement\")\n\n    // Emulate large consumption delays\n    println(\"Consumer pauses for 150ms\")\n    delay(150)\n    // Next element is available immediately\n    nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }\n    println(\"Next element is available immediately after large consumer delay: $nextElement\")\n    // Note that the pause between `receive` calls is taken into account and next element arrives faster\n    nextElement = withTimeoutOrNull(60) { tickerChannel.receive() } \n    println(\"Next element is ready in 50ms after consumer pause in 150ms: $nextElement\")\n\n    tickerChannel.cancel() // indicate that no more elements are needed\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It prints following lines:"}, {"type": "pre", "text": "Initial element is available immediately: kotlin.Unit\nNext element is not ready in 50 ms: null\nNext element is ready in 100 ms: kotlin.Unit\nConsumer pauses for 150ms\nNext element is available immediately after large consumer delay: kotlin.Unit\nNext element is ready in 50ms after consumer pause in 150ms: kotlin.Unit\n"}, {"type": "code", "text": "Initial element is available immediately: kotlin.Unit\nNext element is not ready in 50 ms: null\nNext element is ready in 100 ms: kotlin.Unit\nConsumer pauses for 150ms\nNext element is available immediately after large consumer delay: kotlin.Unit\nNext element is ready in 50ms after consumer pause in 150ms: kotlin.Unit\n"}, {"type": "p", "text": "Note that ticker is aware of possible consumer pauses and, by default, adjusts next produced element \ndelay if a pause occurs, trying to maintain a fixed rate of produced elements."}, {"type": "a", "text": "ticker"}, {"type": "p", "text": "Optionally, a mode parameter equal to TickerMode.FIXED_DELAY can be specified to maintain a fixed\ndelay between elements."}, {"type": "code", "text": "mode"}, {"type": "a", "text": "TickerMode.FIXED_DELAY"}]