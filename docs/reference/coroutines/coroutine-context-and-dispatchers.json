[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "p", "text": "Table of contents"}, {"type": "strong", "text": "Table of contents"}, {"type": "ul", "text": "\nCoroutine Context and Dispatchers\n\nDispatchers and threads\nUnconfined vs confined dispatcher\nDebugging coroutines and threads\nJumping between threads\nJob in the context\nChildren of a coroutine\nParental responsibilities\nNaming coroutines for debugging\nCombining context elements\nCoroutine scope\nThread-local data\n\n\n"}, {"type": "li", "text": "Coroutine Context and Dispatchers\n\nDispatchers and threads\nUnconfined vs confined dispatcher\nDebugging coroutines and threads\nJumping between threads\nJob in the context\nChildren of a coroutine\nParental responsibilities\nNaming coroutines for debugging\nCombining context elements\nCoroutine scope\nThread-local data\n\n"}, {"type": "a", "text": "Coroutine Context and Dispatchers"}, {"type": "ul", "text": "\nDispatchers and threads\nUnconfined vs confined dispatcher\nDebugging coroutines and threads\nJumping between threads\nJob in the context\nChildren of a coroutine\nParental responsibilities\nNaming coroutines for debugging\nCombining context elements\nCoroutine scope\nThread-local data\n"}, {"type": "li", "text": "Dispatchers and threads"}, {"type": "a", "text": "Dispatchers and threads"}, {"type": "li", "text": "Unconfined vs confined dispatcher"}, {"type": "a", "text": "Unconfined vs confined dispatcher"}, {"type": "li", "text": "Debugging coroutines and threads"}, {"type": "a", "text": "Debugging coroutines and threads"}, {"type": "li", "text": "Jumping between threads"}, {"type": "a", "text": "Jumping between threads"}, {"type": "li", "text": "Job in the context"}, {"type": "a", "text": "Job in the context"}, {"type": "li", "text": "Children of a coroutine"}, {"type": "a", "text": "Children of a coroutine"}, {"type": "li", "text": "Parental responsibilities"}, {"type": "a", "text": "Parental responsibilities"}, {"type": "li", "text": "Naming coroutines for debugging"}, {"type": "a", "text": "Naming coroutines for debugging"}, {"type": "li", "text": "Combining context elements"}, {"type": "a", "text": "Combining context elements"}, {"type": "li", "text": "Coroutine scope"}, {"type": "a", "text": "Coroutine scope"}, {"type": "li", "text": "Thread-local data"}, {"type": "a", "text": "Thread-local data"}, {"type": "h2", "text": "Coroutine Context and Dispatchers"}, {"type": "p", "text": "Coroutines always execute in some context represented by a value of the \nCoroutineContext \ntype, defined in the Kotlin standard library."}, {"type": "a", "text": "CoroutineContext"}, {"type": "p", "text": "The coroutine context is a set of various elements. The main elements are the Job of the coroutine, \nwhich we've seen before, and its dispatcher, which is covered in this section."}, {"type": "a", "text": "Job"}, {"type": "h3", "text": "Dispatchers and threads"}, {"type": "p", "text": "The coroutine context includes a coroutine dispatcher (see CoroutineDispatcher) that determines what thread or threads \nthe corresponding coroutine uses for its execution. The coroutine dispatcher can confine coroutine execution \nto a specific thread, dispatch it to a thread pool, or let it run unconfined."}, {"type": "em", "text": "coroutine dispatcher"}, {"type": "a", "text": "CoroutineDispatcher"}, {"type": "p", "text": "All coroutine builders like launch and async accept an optional \nCoroutineContext \nparameter that can be used to explicitly specify the dispatcher for the new coroutine and other context elements."}, {"type": "a", "text": "launch"}, {"type": "a", "text": "async"}, {"type": "a", "text": "CoroutineContext"}, {"type": "p", "text": "Try the following example:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    launch { // context of the parent, main runBlocking coroutine\n        println(\"main runBlocking      : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread\n        println(\"Unconfined            : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Default) { // will get dispatched to DefaultDispatcher \n        println(\"Default               : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(newSingleThreadContext(\"MyOwnThread\")) { // will get its own new thread\n        println(\"newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}\")\n    }\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    launch { // context of the parent, main runBlocking coroutine\n        println(\"main runBlocking      : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread\n        println(\"Unconfined            : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Default) { // will get dispatched to DefaultDispatcher \n        println(\"Default               : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(newSingleThreadContext(\"MyOwnThread\")) { // will get its own new thread\n        println(\"newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}\")\n    }\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    launch { // context of the parent, main runBlocking coroutine\n        println(\"main runBlocking      : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread\n        println(\"Unconfined            : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Default) { // will get dispatched to DefaultDispatcher \n        println(\"Default               : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(newSingleThreadContext(\"MyOwnThread\")) { // will get its own new thread\n        println(\"newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}\")\n    }\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It produces the following output (maybe in different order):"}, {"type": "pre", "text": "Unconfined            : I'm working in thread main\nDefault               : I'm working in thread DefaultDispatcher-worker-1\nnewSingleThreadContext: I'm working in thread MyOwnThread\nmain runBlocking      : I'm working in thread main\n"}, {"type": "code", "text": "Unconfined            : I'm working in thread main\nDefault               : I'm working in thread DefaultDispatcher-worker-1\nnewSingleThreadContext: I'm working in thread MyOwnThread\nmain runBlocking      : I'm working in thread main\n"}, {"type": "p", "text": "When launch { ... } is used without parameters, it inherits the context (and thus dispatcher)\nfrom the CoroutineScope it is being launched from. In this case, it inherits the\ncontext of the main runBlocking coroutine which runs in the main thread."}, {"type": "code", "text": "launch { ... }"}, {"type": "a", "text": "CoroutineScope"}, {"type": "code", "text": "runBlocking"}, {"type": "code", "text": "main"}, {"type": "p", "text": "Dispatchers.Unconfined is a special dispatcher that also appears to run in the main thread, but it is,\nin fact, a different mechanism that is explained later."}, {"type": "a", "text": "Dispatchers.Unconfined"}, {"type": "code", "text": "main"}, {"type": "p", "text": "The default dispatcher that is used when coroutines are launched in GlobalScope\nis represented by Dispatchers.Default and uses a shared background pool of threads,\nso launch(Dispatchers.Default) { ... } uses the same dispatcher as GlobalScope.launch { ... }."}, {"type": "a", "text": "GlobalScope"}, {"type": "a", "text": "Dispatchers.Default"}, {"type": "code", "text": "launch(Dispatchers.Default) { ... }"}, {"type": "code", "text": "GlobalScope.launch { ... }"}, {"type": "p", "text": "newSingleThreadContext creates a thread for the coroutine to run. \nA dedicated thread is a very expensive resource. \nIn a real application it must be either released, when no longer needed, using the close \nfunction, or stored in a top-level variable and reused throughout the application."}, {"type": "a", "text": "newSingleThreadContext"}, {"type": "a", "text": "close"}, {"type": "h3", "text": "Unconfined vs confined dispatcher"}, {"type": "p", "text": "The Dispatchers.Unconfined coroutine dispatcher starts a coroutine in the caller thread, but only until the\nfirst suspension point. After suspension it resumes the coroutine in the thread that is fully determined by the\nsuspending function that was invoked. The unconfined dispatcher is appropriate for coroutines which neither\nconsume CPU time nor update any shared data (like UI) confined to a specific thread."}, {"type": "a", "text": "Dispatchers.Unconfined"}, {"type": "p", "text": "On the other side, the dispatcher is inherited from the outer CoroutineScope by default. \nThe default dispatcher for the runBlocking coroutine, in particular,\nis confined to the invoker thread, so inheriting it has the effect of confining execution to\nthis thread with predictable FIFO scheduling."}, {"type": "a", "text": "CoroutineScope"}, {"type": "a", "text": "runBlocking"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread\n        println(\"Unconfined      : I'm working in thread ${Thread.currentThread().name}\")\n        delay(500)\n        println(\"Unconfined      : After delay in thread ${Thread.currentThread().name}\")\n    }\n    launch { // context of the parent, main runBlocking coroutine\n        println(\"main runBlocking: I'm working in thread ${Thread.currentThread().name}\")\n        delay(1000)\n        println(\"main runBlocking: After delay in thread ${Thread.currentThread().name}\")\n    }\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread\n        println(\"Unconfined      : I'm working in thread ${Thread.currentThread().name}\")\n        delay(500)\n        println(\"Unconfined      : After delay in thread ${Thread.currentThread().name}\")\n    }\n    launch { // context of the parent, main runBlocking coroutine\n        println(\"main runBlocking: I'm working in thread ${Thread.currentThread().name}\")\n        delay(1000)\n        println(\"main runBlocking: After delay in thread ${Thread.currentThread().name}\")\n    }\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread\n        println(\"Unconfined      : I'm working in thread ${Thread.currentThread().name}\")\n        delay(500)\n        println(\"Unconfined      : After delay in thread ${Thread.currentThread().name}\")\n    }\n    launch { // context of the parent, main runBlocking coroutine\n        println(\"main runBlocking: I'm working in thread ${Thread.currentThread().name}\")\n        delay(1000)\n        println(\"main runBlocking: After delay in thread ${Thread.currentThread().name}\")\n    }\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "Produces the output:"}, {"type": "pre", "text": "Unconfined      : I'm working in thread main\nmain runBlocking: I'm working in thread main\nUnconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor\nmain runBlocking: After delay in thread main\n"}, {"type": "code", "text": "Unconfined      : I'm working in thread main\nmain runBlocking: I'm working in thread main\nUnconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor\nmain runBlocking: After delay in thread main\n"}, {"type": "p", "text": "So, the coroutine with the context inherited from runBlocking {...} continues to execute\nin the main thread, while the unconfined one resumes in the default executor thread that the delay\nfunction is using."}, {"type": "code", "text": "runBlocking {...}"}, {"type": "code", "text": "main"}, {"type": "a", "text": "delay"}, {"type": "blockquote", "text": "\nThe unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where\ndispatching of a coroutine for its execution later is not needed or produces undesirable side-effects,\nbecause some operation in a coroutine must be performed right away. \nThe unconfined dispatcher should not be used in general code.\n"}, {"type": "p", "text": "The unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where\ndispatching of a coroutine for its execution later is not needed or produces undesirable side-effects,\nbecause some operation in a coroutine must be performed right away. \nThe unconfined dispatcher should not be used in general code."}, {"type": "h3", "text": "Debugging coroutines and threads"}, {"type": "p", "text": "Coroutines can suspend on one thread and resume on another thread. \nEven with a single-threaded dispatcher it might be hard to\nfigure out what the coroutine was doing, where, and when. The common approach to debugging applications with \nthreads is to print the thread name in the log file on each log statement. This feature is universally supported\nby logging frameworks. When using coroutines, the thread name alone does not give much of a context, so \nkotlinx.coroutines includes debugging facilities to make it easier."}, {"type": "code", "text": "kotlinx.coroutines"}, {"type": "p", "text": "Run the following code with -Dkotlinx.coroutines.debug JVM option:"}, {"type": "code", "text": "-Dkotlinx.coroutines.debug"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val a = async {\n        log(\"I'm computing a piece of the answer\")\n        6\n    }\n    val b = async {\n        log(\"I'm computing another piece of the answer\")\n        7\n    }\n    log(\"The answer is ${a.await() * b.await()}\")\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val a = async {\n        log(\"I'm computing a piece of the answer\")\n        6\n    }\n    val b = async {\n        log(\"I'm computing another piece of the answer\")\n        7\n    }\n    log(\"The answer is ${a.await() * b.await()}\")\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val a = async {\n        log(\"I'm computing a piece of the answer\")\n        6\n    }\n    val b = async {\n        log(\"I'm computing another piece of the answer\")\n        7\n    }\n    log(\"The answer is ${a.await() * b.await()}\")\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "There are three coroutines. The main coroutine (#1) inside runBlocking \nand two coroutines computing the deferred values a (#2) and b (#3).\nThey are all executing in the context of runBlocking and are confined to the main thread.\nThe output of this code is:"}, {"type": "code", "text": "runBlocking"}, {"type": "code", "text": "a"}, {"type": "code", "text": "b"}, {"type": "code", "text": "runBlocking"}, {"type": "pre", "text": "[main @coroutine#2] I'm computing a piece of the answer\n[main @coroutine#3] I'm computing another piece of the answer\n[main @coroutine#1] The answer is 42\n"}, {"type": "code", "text": "[main @coroutine#2] I'm computing a piece of the answer\n[main @coroutine#3] I'm computing another piece of the answer\n[main @coroutine#1] The answer is 42\n"}, {"type": "p", "text": "The log function prints the name of the thread in square brackets, and you can see that it is the main\nthread with the identifier of the currently executing coroutine appended to it. This identifier \nis consecutively assigned to all created coroutines when the debugging mode is on."}, {"type": "code", "text": "log"}, {"type": "code", "text": "main"}, {"type": "blockquote", "text": "\nDebugging mode is also turned on when JVM is run with -ea option.\nYou can read more about debugging facilities in the documentation of the DEBUG_PROPERTY_NAME property.\n"}, {"type": "p", "text": "Debugging mode is also turned on when JVM is run with -ea option.\nYou can read more about debugging facilities in the documentation of the DEBUG_PROPERTY_NAME property."}, {"type": "code", "text": "-ea"}, {"type": "a", "text": "DEBUG_PROPERTY_NAME"}, {"type": "h3", "text": "Jumping between threads"}, {"type": "p", "text": "Run the following code with the -Dkotlinx.coroutines.debug JVM option (see debug):"}, {"type": "code", "text": "-Dkotlinx.coroutines.debug"}, {"type": "a", "text": "debug"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() {\n//sampleStart\n    newSingleThreadContext(\"Ctx1\").use { ctx1 ->\n        newSingleThreadContext(\"Ctx2\").use { ctx2 ->\n            runBlocking(ctx1) {\n                log(\"Started in ctx1\")\n                withContext(ctx2) {\n                    log(\"Working in ctx2\")\n                }\n                log(\"Back to ctx1\")\n            }\n        }\n    }\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() {\n//sampleStart\n    newSingleThreadContext(\"Ctx1\").use { ctx1 ->\n        newSingleThreadContext(\"Ctx2\").use { ctx2 ->\n            runBlocking(ctx1) {\n                log(\"Started in ctx1\")\n                withContext(ctx2) {\n                    log(\"Working in ctx2\")\n                }\n                log(\"Back to ctx1\")\n            }\n        }\n    }\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() {\n//sampleStart\n    newSingleThreadContext(\"Ctx1\").use { ctx1 ->\n        newSingleThreadContext(\"Ctx2\").use { ctx2 ->\n            runBlocking(ctx1) {\n                log(\"Started in ctx1\")\n                withContext(ctx2) {\n                    log(\"Working in ctx2\")\n                }\n                log(\"Back to ctx1\")\n            }\n        }\n    }\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "It demonstrates several new techniques. One is using runBlocking with an explicitly specified context, and\nthe other one is using the withContext function to change the context of a coroutine while still staying in the\nsame coroutine, as you can see in the output below:"}, {"type": "a", "text": "runBlocking"}, {"type": "a", "text": "withContext"}, {"type": "pre", "text": "[Ctx1 @coroutine#1] Started in ctx1\n[Ctx2 @coroutine#1] Working in ctx2\n[Ctx1 @coroutine#1] Back to ctx1\n"}, {"type": "code", "text": "[Ctx1 @coroutine#1] Started in ctx1\n[Ctx2 @coroutine#1] Working in ctx2\n[Ctx1 @coroutine#1] Back to ctx1\n"}, {"type": "p", "text": "Note that this example also uses the use function from the Kotlin standard library to release threads\ncreated with newSingleThreadContext when they are no longer needed."}, {"type": "code", "text": "use"}, {"type": "a", "text": "newSingleThreadContext"}, {"type": "h3", "text": "Job in the context"}, {"type": "p", "text": "The coroutine's Job is part of its context, and can be retrieved from it \nusing the coroutineContext[Job] expression:"}, {"type": "a", "text": "Job"}, {"type": "code", "text": "coroutineContext[Job]"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    println(\"My job is ${coroutineContext[Job]}\")\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    println(\"My job is ${coroutineContext[Job]}\")\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    println(\"My job is ${coroutineContext[Job]}\")\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "In the debug mode, it outputs something like this:"}, {"type": "a", "text": "debug mode"}, {"type": "pre", "text": "My job is \"coroutine#1\":BlockingCoroutine{Active}@6d311334\n"}, {"type": "code", "text": "My job is \"coroutine#1\":BlockingCoroutine{Active}@6d311334\n"}, {"type": "p", "text": "Note that isActive in CoroutineScope is just a convenient shortcut for\ncoroutineContext[Job]?.isActive == true."}, {"type": "a", "text": "isActive"}, {"type": "a", "text": "CoroutineScope"}, {"type": "code", "text": "coroutineContext[Job]?.isActive == true"}, {"type": "h3", "text": "Children of a coroutine"}, {"type": "p", "text": "When a coroutine is launched in the CoroutineScope of another coroutine,\nit inherits its context via CoroutineScope.coroutineContext and \nthe Job of the new coroutine becomes\na child of the parent coroutine's job. When the parent coroutine is cancelled, all its children\nare recursively cancelled, too."}, {"type": "a", "text": "CoroutineScope"}, {"type": "a", "text": "CoroutineScope.coroutineContext"}, {"type": "a", "text": "Job"}, {"type": "em", "text": "child"}, {"type": "p", "text": "However, when GlobalScope is used to launch a coroutine, there is no parent for the job of the new coroutine.\nIt is therefore not tied to the scope it was launched from and operates independently."}, {"type": "a", "text": "GlobalScope"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    // launch a coroutine to process some kind of incoming request\n    val request = launch {\n        // it spawns two other jobs, one with GlobalScope\n        GlobalScope.launch {\n            println(\"job1: I run in GlobalScope and execute independently!\")\n            delay(1000)\n            println(\"job1: I am not affected by cancellation of the request\")\n        }\n        // and the other inherits the parent context\n        launch {\n            delay(100)\n            println(\"job2: I am a child of the request coroutine\")\n            delay(1000)\n            println(\"job2: I will not execute this line if my parent request is cancelled\")\n        }\n    }\n    delay(500)\n    request.cancel() // cancel processing of the request\n    delay(1000) // delay a second to see what happens\n    println(\"main: Who has survived request cancellation?\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    // launch a coroutine to process some kind of incoming request\n    val request = launch {\n        // it spawns two other jobs, one with GlobalScope\n        GlobalScope.launch {\n            println(\"job1: I run in GlobalScope and execute independently!\")\n            delay(1000)\n            println(\"job1: I am not affected by cancellation of the request\")\n        }\n        // and the other inherits the parent context\n        launch {\n            delay(100)\n            println(\"job2: I am a child of the request coroutine\")\n            delay(1000)\n            println(\"job2: I will not execute this line if my parent request is cancelled\")\n        }\n    }\n    delay(500)\n    request.cancel() // cancel processing of the request\n    delay(1000) // delay a second to see what happens\n    println(\"main: Who has survived request cancellation?\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    // launch a coroutine to process some kind of incoming request\n    val request = launch {\n        // it spawns two other jobs, one with GlobalScope\n        GlobalScope.launch {\n            println(\"job1: I run in GlobalScope and execute independently!\")\n            delay(1000)\n            println(\"job1: I am not affected by cancellation of the request\")\n        }\n        // and the other inherits the parent context\n        launch {\n            delay(100)\n            println(\"job2: I am a child of the request coroutine\")\n            delay(1000)\n            println(\"job2: I will not execute this line if my parent request is cancelled\")\n        }\n    }\n    delay(500)\n    request.cancel() // cancel processing of the request\n    delay(1000) // delay a second to see what happens\n    println(\"main: Who has survived request cancellation?\")\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code is:"}, {"type": "pre", "text": "job1: I run in GlobalScope and execute independently!\njob2: I am a child of the request coroutine\njob1: I am not affected by cancellation of the request\nmain: Who has survived request cancellation?\n"}, {"type": "code", "text": "job1: I run in GlobalScope and execute independently!\njob2: I am a child of the request coroutine\njob1: I am not affected by cancellation of the request\nmain: Who has survived request cancellation?\n"}, {"type": "h3", "text": "Parental responsibilities"}, {"type": "p", "text": "A parent coroutine always waits for completion of all its children. A parent does not have to explicitly track\nall the children it launches, and it does not have to use Job.join to wait for them at the end:"}, {"type": "a", "text": "Job.join"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    // launch a coroutine to process some kind of incoming request\n    val request = launch {\n        repeat(3) { i -> // launch a few children jobs\n            launch  {\n                delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms\n                println(\"Coroutine $i is done\")\n            }\n        }\n        println(\"request: I'm done and I don't explicitly join my children that are still active\")\n    }\n    request.join() // wait for completion of the request, including all its children\n    println(\"Now processing of the request is complete\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    // launch a coroutine to process some kind of incoming request\n    val request = launch {\n        repeat(3) { i -> // launch a few children jobs\n            launch  {\n                delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms\n                println(\"Coroutine $i is done\")\n            }\n        }\n        println(\"request: I'm done and I don't explicitly join my children that are still active\")\n    }\n    request.join() // wait for completion of the request, including all its children\n    println(\"Now processing of the request is complete\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    // launch a coroutine to process some kind of incoming request\n    val request = launch {\n        repeat(3) { i -> // launch a few children jobs\n            launch  {\n                delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms\n                println(\"Coroutine $i is done\")\n            }\n        }\n        println(\"request: I'm done and I don't explicitly join my children that are still active\")\n    }\n    request.join() // wait for completion of the request, including all its children\n    println(\"Now processing of the request is complete\")\n//sampleEnd\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The result is going to be:"}, {"type": "pre", "text": "request: I'm done and I don't explicitly join my children that are still active\nCoroutine 0 is done\nCoroutine 1 is done\nCoroutine 2 is done\nNow processing of the request is complete\n"}, {"type": "code", "text": "request: I'm done and I don't explicitly join my children that are still active\nCoroutine 0 is done\nCoroutine 1 is done\nCoroutine 2 is done\nNow processing of the request is complete\n"}, {"type": "h3", "text": "Naming coroutines for debugging"}, {"type": "p", "text": "Automatically assigned ids are good when coroutines log often and you just need to correlate log records\ncoming from the same coroutine. However, when a coroutine is tied to the processing of a specific request\nor doing some specific background task, it is better to name it explicitly for debugging purposes.\nThe CoroutineName context element serves the same purpose as the thread name. It is included in the thread name that\nis executing this coroutine when the debugging mode is turned on."}, {"type": "a", "text": "CoroutineName"}, {"type": "a", "text": "debugging mode"}, {"type": "p", "text": "The following example demonstrates this concept:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() = runBlocking(CoroutineName(\"main\")) {\n//sampleStart\n    log(\"Started main coroutine\")\n    // run two background value computations\n    val v1 = async(CoroutineName(\"v1coroutine\")) {\n        delay(500)\n        log(\"Computing v1\")\n        252\n    }\n    val v2 = async(CoroutineName(\"v2coroutine\")) {\n        delay(1000)\n        log(\"Computing v2\")\n        6\n    }\n    log(\"The answer for v1 / v2 = ${v1.await() / v2.await()}\")\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() = runBlocking(CoroutineName(\"main\")) {\n//sampleStart\n    log(\"Started main coroutine\")\n    // run two background value computations\n    val v1 = async(CoroutineName(\"v1coroutine\")) {\n        delay(500)\n        log(\"Computing v1\")\n        252\n    }\n    val v2 = async(CoroutineName(\"v2coroutine\")) {\n        delay(1000)\n        log(\"Computing v2\")\n        6\n    }\n    log(\"The answer for v1 / v2 = ${v1.await() / v2.await()}\")\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() = runBlocking(CoroutineName(\"main\")) {\n//sampleStart\n    log(\"Started main coroutine\")\n    // run two background value computations\n    val v1 = async(CoroutineName(\"v1coroutine\")) {\n        delay(500)\n        log(\"Computing v1\")\n        252\n    }\n    val v2 = async(CoroutineName(\"v2coroutine\")) {\n        delay(1000)\n        log(\"Computing v2\")\n        6\n    }\n    log(\"The answer for v1 / v2 = ${v1.await() / v2.await()}\")\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output it produces with -Dkotlinx.coroutines.debug JVM option is similar to:"}, {"type": "code", "text": "-Dkotlinx.coroutines.debug"}, {"type": "pre", "text": "[main @main#1] Started main coroutine\n[main @v1coroutine#2] Computing v1\n[main @v2coroutine#3] Computing v2\n[main @main#1] The answer for v1 / v2 = 42\n"}, {"type": "code", "text": "[main @main#1] Started main coroutine\n[main @v1coroutine#2] Computing v1\n[main @v2coroutine#3] Computing v2\n[main @main#1] The answer for v1 / v2 = 42\n"}, {"type": "h3", "text": "Combining context elements"}, {"type": "p", "text": "Sometimes we need to define multiple elements for a coroutine context. We can use the + operator for that.\nFor example, we can launch a coroutine with an explicitly specified dispatcher and an explicitly specified \nname at the same time:"}, {"type": "code", "text": "+"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    launch(Dispatchers.Default + CoroutineName(\"test\")) {\n        println(\"I'm working in thread ${Thread.currentThread().name}\")\n    }\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    launch(Dispatchers.Default + CoroutineName(\"test\")) {\n        println(\"I'm working in thread ${Thread.currentThread().name}\")\n    }\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    launch(Dispatchers.Default + CoroutineName(\"test\")) {\n        println(\"I'm working in thread ${Thread.currentThread().name}\")\n    }\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code with the -Dkotlinx.coroutines.debug JVM option is:"}, {"type": "code", "text": "-Dkotlinx.coroutines.debug"}, {"type": "pre", "text": "I'm working in thread DefaultDispatcher-worker-1 @test#2\n"}, {"type": "code", "text": "I'm working in thread DefaultDispatcher-worker-1 @test#2\n"}, {"type": "h3", "text": "Coroutine scope"}, {"type": "p", "text": "Let us put our knowledge about contexts, children and jobs together. Assume that our application has\nan object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application\nand launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch \nand update data, do animations, etc. All of these coroutines must be cancelled when the activity is destroyed\nto avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie the lifecycles of the activity \nand its coroutines, but kotlinx.coroutines provides an abstraction encapsulating that: CoroutineScope.\nYou should be already familiar with the coroutine scope as all coroutine builders are declared as extensions on it."}, {"type": "code", "text": "kotlinx.coroutines"}, {"type": "a", "text": "CoroutineScope"}, {"type": "p", "text": "We manage the lifecycles of our coroutines by creating an instance of CoroutineScope tied to \nthe lifecycle of our activity. A CoroutineScope instance can be created by the CoroutineScope() or MainScope()\nfactory functions. The former creates a general-purpose scope, while the latter creates a scope for UI applications and uses\nDispatchers.Main as the default dispatcher:"}, {"type": "a", "text": "CoroutineScope"}, {"type": "code", "text": "CoroutineScope"}, {"type": "a", "text": "CoroutineScope()"}, {"type": "a", "text": "MainScope()"}, {"type": "a", "text": "Dispatchers.Main"}, {"type": "div", "text": "\nclass Activity {\n    private val mainScope = MainScope()\n    \n    fun destroy() {\n        mainScope.cancel()\n    }\n    // to be continued ...\n\n"}, {"type": "pre", "text": "class Activity {\n    private val mainScope = MainScope()\n    \n    fun destroy() {\n        mainScope.cancel()\n    }\n    // to be continued ...\n"}, {"type": "code", "text": "class Activity {\n    private val mainScope = MainScope()\n    \n    fun destroy() {\n        mainScope.cancel()\n    }\n    // to be continued ...\n"}, {"type": "p", "text": "Now, we can launch coroutines in the scope of this Activity using the defined scope.\nFor the demo, we launch ten coroutines that delay for a different time:"}, {"type": "code", "text": "Activity"}, {"type": "code", "text": "scope"}, {"type": "div", "text": "\n    // class Activity continues\n    fun doSomething() {\n        // launch ten coroutines for a demo, each working for a different time\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc\n                println(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // class Activity ends\n\n"}, {"type": "pre", "text": "    // class Activity continues\n    fun doSomething() {\n        // launch ten coroutines for a demo, each working for a different time\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc\n                println(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // class Activity ends\n"}, {"type": "code", "text": "    // class Activity continues\n    fun doSomething() {\n        // launch ten coroutines for a demo, each working for a different time\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc\n                println(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // class Activity ends\n"}, {"type": "p", "text": "In our main function we create the activity, call our test doSomething function, and destroy the activity after 500ms.\nThis cancels all the coroutines that were launched from doSomething. We can see that because after the destruction \nof the activity no more messages are printed, even if we wait a little longer."}, {"type": "code", "text": "doSomething"}, {"type": "code", "text": "doSomething"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nclass Activity {\n    private val mainScope = CoroutineScope(Dispatchers.Default) // use Default for test purposes\n    \n    fun destroy() {\n        mainScope.cancel()\n    }\n\n    fun doSomething() {\n        // launch ten coroutines for a demo, each working for a different time\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc\n                println(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // class Activity ends\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val activity = Activity()\n    activity.doSomething() // run test function\n    println(\"Launched coroutines\")\n    delay(500L) // delay for half a second\n    println(\"Destroying activity!\")\n    activity.destroy() // cancels all coroutines\n    delay(1000) // visually confirm that they don't work\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nclass Activity {\n    private val mainScope = CoroutineScope(Dispatchers.Default) // use Default for test purposes\n    \n    fun destroy() {\n        mainScope.cancel()\n    }\n\n    fun doSomething() {\n        // launch ten coroutines for a demo, each working for a different time\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc\n                println(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // class Activity ends\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val activity = Activity()\n    activity.doSomething() // run test function\n    println(\"Launched coroutines\")\n    delay(500L) // delay for half a second\n    println(\"Destroying activity!\")\n    activity.destroy() // cancels all coroutines\n    delay(1000) // visually confirm that they don't work\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nclass Activity {\n    private val mainScope = CoroutineScope(Dispatchers.Default) // use Default for test purposes\n    \n    fun destroy() {\n        mainScope.cancel()\n    }\n\n    fun doSomething() {\n        // launch ten coroutines for a demo, each working for a different time\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc\n                println(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // class Activity ends\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val activity = Activity()\n    activity.doSomething() // run test function\n    println(\"Launched coroutines\")\n    delay(500L) // delay for half a second\n    println(\"Destroying activity!\")\n    activity.destroy() // cancels all coroutines\n    delay(1000) // visually confirm that they don't work\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this example is:"}, {"type": "pre", "text": "Launched coroutines\nCoroutine 0 is done\nCoroutine 1 is done\nDestroying activity!\n"}, {"type": "code", "text": "Launched coroutines\nCoroutine 0 is done\nCoroutine 1 is done\nDestroying activity!\n"}, {"type": "p", "text": "As you can see, only the first two coroutines print a message and the others are cancelled \nby a single invocation of job.cancel() in Activity.destroy()."}, {"type": "code", "text": "job.cancel()"}, {"type": "code", "text": "Activity.destroy()"}, {"type": "blockquote", "text": "\nNote, that Android has first-party support for coroutine scope in all entities with the lifecycle.\nSee the corresponding documentation.\n"}, {"type": "p", "text": "Note, that Android has first-party support for coroutine scope in all entities with the lifecycle.\nSee the corresponding documentation."}, {"type": "a", "text": "the corresponding documentation"}, {"type": "h3", "text": "Thread-local data"}, {"type": "p", "text": "Sometimes it is convenient to have an ability to pass some thread-local data to or between coroutines. \nHowever, since they are not bound to any particular thread, this will likely lead to boilerplate if done manually."}, {"type": "p", "text": "For ThreadLocal, \nthe asContextElement extension function is here for the rescue. It creates an additional context element \nwhich keeps the value of the given ThreadLocal and restores it every time the coroutine switches its context."}, {"type": "a", "text": "ThreadLocal"}, {"type": "code", "text": "ThreadLocal"}, {"type": "a", "text": "asContextElement"}, {"type": "code", "text": "ThreadLocal"}, {"type": "p", "text": "It is easy to demonstrate it in action:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nval threadLocal = ThreadLocal<String?>() // declare thread-local variable\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    threadLocal.set(\"main\")\n    println(\"Pre-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n    val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = \"launch\")) {\n        println(\"Launch start, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n        yield()\n        println(\"After yield, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n    }\n    job.join()\n    println(\"Post-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nval threadLocal = ThreadLocal<String?>() // declare thread-local variable\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    threadLocal.set(\"main\")\n    println(\"Pre-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n    val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = \"launch\")) {\n        println(\"Launch start, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n        yield()\n        println(\"After yield, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n    }\n    job.join()\n    println(\"Post-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nval threadLocal = ThreadLocal<String?>() // declare thread-local variable\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    threadLocal.set(\"main\")\n    println(\"Pre-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n    val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = \"launch\")) {\n        println(\"Launch start, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n        yield()\n        println(\"After yield, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n    }\n    job.join()\n    println(\"Post-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "In this example we launch a new coroutine in a background thread pool using Dispatchers.Default, so\nit works on a different thread from the thread pool, but it still has the value of the thread local variable\nthat we specified using threadLocal.asContextElement(value = \"launch\"),\nno matter on what thread the coroutine is executed.\nThus, the output (with debug) is:"}, {"type": "a", "text": "Dispatchers.Default"}, {"type": "code", "text": "threadLocal.asContextElement(value = \"launch\")"}, {"type": "a", "text": "debug"}, {"type": "pre", "text": "Pre-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'\nLaunch start, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: 'launch'\nAfter yield, current thread: Thread[DefaultDispatcher-worker-2 @coroutine#2,5,main], thread local value: 'launch'\nPost-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'\n"}, {"type": "code", "text": "Pre-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'\nLaunch start, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: 'launch'\nAfter yield, current thread: Thread[DefaultDispatcher-worker-2 @coroutine#2,5,main], thread local value: 'launch'\nPost-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'\n"}, {"type": "p", "text": "It's easy to forget to set the corresponding context element. The thread-local variable accessed from the coroutine may\nthen have an unexpected value, if the thread running the coroutine is different.\nTo avoid such situations, it is recommended to use the ensurePresent method\nand fail-fast on improper usages."}, {"type": "a", "text": "ensurePresent"}, {"type": "p", "text": "ThreadLocal has first-class support and can be used with any primitive kotlinx.coroutines provides.\nIt has one key limitation, though: when a thread-local is mutated, a new value is not propagated to the coroutine caller \n(because a context element cannot track all ThreadLocal object accesses), and the updated value is lost on the next suspension.\nUse withContext to update the value of the thread-local in a coroutine, see asContextElement for more details."}, {"type": "code", "text": "ThreadLocal"}, {"type": "code", "text": "kotlinx.coroutines"}, {"type": "code", "text": "ThreadLocal"}, {"type": "a", "text": "withContext"}, {"type": "a", "text": "asContextElement"}, {"type": "p", "text": "Alternatively, a value can be stored in a mutable box like class Counter(var i: Int), which is, in turn, \nstored in a thread-local variable. However, in this case you are fully responsible to synchronize \npotentially concurrent modifications to the variable in this mutable box."}, {"type": "code", "text": "class Counter(var i: Int)"}, {"type": "p", "text": "For advanced usage, for example for integration with logging MDC, transactional contexts or any other libraries\nwhich internally use thread-locals for passing data, see documentation of the ThreadContextElement interface \nthat should be implemented."}, {"type": "a", "text": "ThreadContextElement"}]