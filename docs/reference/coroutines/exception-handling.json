[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "p", "text": "Table of contents"}, {"type": "strong", "text": "Table of contents"}, {"type": "ul", "text": "\nException Handling\n\nException propagation\nCoroutineExceptionHandler\nCancellation and exceptions\nExceptions aggregation\nSupervision\n\nSupervision job\nSupervision scope\nExceptions in supervised coroutines\n\n\n\n\n"}, {"type": "li", "text": "Exception Handling\n\nException propagation\nCoroutineExceptionHandler\nCancellation and exceptions\nExceptions aggregation\nSupervision\n\nSupervision job\nSupervision scope\nExceptions in supervised coroutines\n\n\n\n"}, {"type": "a", "text": "Exception Handling"}, {"type": "ul", "text": "\nException propagation\nCoroutineExceptionHandler\nCancellation and exceptions\nExceptions aggregation\nSupervision\n\nSupervision job\nSupervision scope\nExceptions in supervised coroutines\n\n\n"}, {"type": "li", "text": "Exception propagation"}, {"type": "a", "text": "Exception propagation"}, {"type": "li", "text": "CoroutineExceptionHandler"}, {"type": "a", "text": "CoroutineExceptionHandler"}, {"type": "li", "text": "Cancellation and exceptions"}, {"type": "a", "text": "Cancellation and exceptions"}, {"type": "li", "text": "Exceptions aggregation"}, {"type": "a", "text": "Exceptions aggregation"}, {"type": "li", "text": "Supervision\n\nSupervision job\nSupervision scope\nExceptions in supervised coroutines\n\n"}, {"type": "a", "text": "Supervision"}, {"type": "ul", "text": "\nSupervision job\nSupervision scope\nExceptions in supervised coroutines\n"}, {"type": "li", "text": "Supervision job"}, {"type": "a", "text": "Supervision job"}, {"type": "li", "text": "Supervision scope"}, {"type": "a", "text": "Supervision scope"}, {"type": "li", "text": "Exceptions in supervised coroutines"}, {"type": "a", "text": "Exceptions in supervised coroutines"}, {"type": "h2", "text": "Exception Handling"}, {"type": "p", "text": "This section covers exception handling and cancellation on exceptions.\nWe already know that cancelled coroutine throws CancellationException in suspension points and that it\nis ignored by the coroutines' machinery. Here we look at what happens if an exception is thrown during cancellation or multiple children of the same\ncoroutine throw an exception."}, {"type": "a", "text": "CancellationException"}, {"type": "h3", "text": "Exception propagation"}, {"type": "p", "text": "Coroutine builders come in two flavors: propagating exceptions automatically (launch and actor) or\nexposing them to users (async and produce).\nWhen these builders are used to create a root coroutine, that is not a child of another coroutine,\nthe former builder treat exceptions as uncaught exceptions, similar to Java's Thread.uncaughtExceptionHandler,\nwhile the latter are relying on the user to consume the final\nexception, for example via await or receive \n(produce and receive are covered later in Channels section)."}, {"type": "a", "text": "launch"}, {"type": "a", "text": "actor"}, {"type": "a", "text": "async"}, {"type": "a", "text": "produce"}, {"type": "em", "text": "root"}, {"type": "em", "text": "child"}, {"type": "strong", "text": "uncaught"}, {"type": "code", "text": "Thread.uncaughtExceptionHandler"}, {"type": "a", "text": "await"}, {"type": "a", "text": "receive"}, {"type": "a", "text": "produce"}, {"type": "a", "text": "receive"}, {"type": "a", "text": "Channels"}, {"type": "p", "text": "It can be demonstrated by a simple example that creates root coroutines using the GlobalScope:"}, {"type": "a", "text": "GlobalScope"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val job = GlobalScope.launch { // root coroutine with launch\n        println(\"Throwing exception from launch\")\n        throw IndexOutOfBoundsException() // Will be printed to the console by Thread.defaultUncaughtExceptionHandler\n    }\n    job.join()\n    println(\"Joined failed job\")\n    val deferred = GlobalScope.async { // root coroutine with async\n        println(\"Throwing exception from async\")\n        throw ArithmeticException() // Nothing is printed, relying on user to call await\n    }\n    try {\n        deferred.await()\n        println(\"Unreached\")\n    } catch (e: ArithmeticException) {\n        println(\"Caught ArithmeticException\")\n    }\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val job = GlobalScope.launch { // root coroutine with launch\n        println(\"Throwing exception from launch\")\n        throw IndexOutOfBoundsException() // Will be printed to the console by Thread.defaultUncaughtExceptionHandler\n    }\n    job.join()\n    println(\"Joined failed job\")\n    val deferred = GlobalScope.async { // root coroutine with async\n        println(\"Throwing exception from async\")\n        throw ArithmeticException() // Nothing is printed, relying on user to call await\n    }\n    try {\n        deferred.await()\n        println(\"Unreached\")\n    } catch (e: ArithmeticException) {\n        println(\"Caught ArithmeticException\")\n    }\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val job = GlobalScope.launch { // root coroutine with launch\n        println(\"Throwing exception from launch\")\n        throw IndexOutOfBoundsException() // Will be printed to the console by Thread.defaultUncaughtExceptionHandler\n    }\n    job.join()\n    println(\"Joined failed job\")\n    val deferred = GlobalScope.async { // root coroutine with async\n        println(\"Throwing exception from async\")\n        throw ArithmeticException() // Nothing is printed, relying on user to call await\n    }\n    try {\n        deferred.await()\n        println(\"Unreached\")\n    } catch (e: ArithmeticException) {\n        println(\"Caught ArithmeticException\")\n    }\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code is (with debug):"}, {"type": "a", "text": "debug"}, {"type": "pre", "text": "Throwing exception from launch\nException in thread \"DefaultDispatcher-worker-2 @coroutine#2\" java.lang.IndexOutOfBoundsException\nJoined failed job\nThrowing exception from async\nCaught ArithmeticException\n"}, {"type": "code", "text": "Throwing exception from launch\nException in thread \"DefaultDispatcher-worker-2 @coroutine#2\" java.lang.IndexOutOfBoundsException\nJoined failed job\nThrowing exception from async\nCaught ArithmeticException\n"}, {"type": "h3", "text": "CoroutineExceptionHandler"}, {"type": "p", "text": "It is possible to customize the default behavior of printing uncaught exceptions to the console.\nCoroutineExceptionHandler context element on a root coroutine can be used as generic catch block for\nthis root coroutine and all its children where custom exception handling may take place.\nIt is similar to Thread.uncaughtExceptionHandler.\nYou cannot recover from the exception in the CoroutineExceptionHandler. The coroutine had already completed\nwith the corresponding exception when the handler is called. Normally, the handler is used to\nlog the exception, show some kind of error message, terminate, and/or restart the application."}, {"type": "strong", "text": "uncaught"}, {"type": "a", "text": "CoroutineExceptionHandler"}, {"type": "em", "text": "root"}, {"type": "code", "text": "catch"}, {"type": "a", "text": "Thread.uncaughtExceptionHandler"}, {"type": "code", "text": "Thread.uncaughtExceptionHandler"}, {"type": "code", "text": "CoroutineExceptionHandler"}, {"type": "p", "text": "On JVM it is possible to redefine global exception handler for all coroutines by registering CoroutineExceptionHandler via\nServiceLoader.\nGlobal exception handler is similar to \nThread.defaultUncaughtExceptionHandler \nwhich is used when no more specific handlers are registered.\nOn Android, uncaughtExceptionPreHandler is installed as a global coroutine exception handler."}, {"type": "a", "text": "CoroutineExceptionHandler"}, {"type": "a", "text": "ServiceLoader"}, {"type": "code", "text": "ServiceLoader"}, {"type": "a", "text": "Thread.defaultUncaughtExceptionHandler"}, {"type": "code", "text": "Thread.defaultUncaughtExceptionHandler"}, {"type": "code", "text": "uncaughtExceptionPreHandler"}, {"type": "p", "text": "CoroutineExceptionHandler is invoked only on uncaught exceptions \u2014 exceptions that were not handled in any other way.\nIn particular, all children coroutines (coroutines created in the context of another Job) delegate handling of\ntheir exceptions to their parent coroutine, which also delegates to the parent, and so on until the root,\nso the CoroutineExceptionHandler installed in their context is never used. \nIn addition to that, async builder always catches all exceptions and represents them in the resulting Deferred object, \nso its CoroutineExceptionHandler has no effect either."}, {"type": "code", "text": "CoroutineExceptionHandler"}, {"type": "strong", "text": "uncaught"}, {"type": "em", "text": "children"}, {"type": "a", "text": "Job"}, {"type": "code", "text": "CoroutineExceptionHandler"}, {"type": "a", "text": "async"}, {"type": "a", "text": "Deferred"}, {"type": "code", "text": "CoroutineExceptionHandler"}, {"type": "blockquote", "text": "\nCoroutines running in supervision scope do not propagate exceptions to their parent and are\nexcluded from this rule. A further Supervision section of this document gives more details.\n"}, {"type": "p", "text": "Coroutines running in supervision scope do not propagate exceptions to their parent and are\nexcluded from this rule. A further Supervision section of this document gives more details."}, {"type": "a", "text": "Supervision"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val handler = CoroutineExceptionHandler { _, exception -> \n        println(\"CoroutineExceptionHandler got $exception\") \n    }\n    val job = GlobalScope.launch(handler) { // root coroutine, running in GlobalScope\n        throw AssertionError()\n    }\n    val deferred = GlobalScope.async(handler) { // also root, but async instead of launch\n        throw ArithmeticException() // Nothing will be printed, relying on user to call deferred.await()\n    }\n    joinAll(job, deferred)\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val handler = CoroutineExceptionHandler { _, exception -> \n        println(\"CoroutineExceptionHandler got $exception\") \n    }\n    val job = GlobalScope.launch(handler) { // root coroutine, running in GlobalScope\n        throw AssertionError()\n    }\n    val deferred = GlobalScope.async(handler) { // also root, but async instead of launch\n        throw ArithmeticException() // Nothing will be printed, relying on user to call deferred.await()\n    }\n    joinAll(job, deferred)\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val handler = CoroutineExceptionHandler { _, exception -> \n        println(\"CoroutineExceptionHandler got $exception\") \n    }\n    val job = GlobalScope.launch(handler) { // root coroutine, running in GlobalScope\n        throw AssertionError()\n    }\n    val deferred = GlobalScope.async(handler) { // also root, but async instead of launch\n        throw ArithmeticException() // Nothing will be printed, relying on user to call deferred.await()\n    }\n    joinAll(job, deferred)\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code is:"}, {"type": "pre", "text": "CoroutineExceptionHandler got java.lang.AssertionError\n"}, {"type": "code", "text": "CoroutineExceptionHandler got java.lang.AssertionError\n"}, {"type": "h3", "text": "Cancellation and exceptions"}, {"type": "p", "text": "Cancellation is closely related to exceptions. Coroutines internally use CancellationException for cancellation, these\nexceptions are ignored by all handlers, so they should be used only as the source of additional debug information, which can\nbe obtained by catch block.\nWhen a coroutine is cancelled using Job.cancel, it terminates, but it does not cancel its parent."}, {"type": "code", "text": "CancellationException"}, {"type": "code", "text": "catch"}, {"type": "a", "text": "Job.cancel"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        val child = launch {\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                println(\"Child is cancelled\")\n            }\n        }\n        yield()\n        println(\"Cancelling child\")\n        child.cancel()\n        child.join()\n        yield()\n        println(\"Parent is not cancelled\")\n    }\n    job.join()\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        val child = launch {\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                println(\"Child is cancelled\")\n            }\n        }\n        yield()\n        println(\"Cancelling child\")\n        child.cancel()\n        child.join()\n        yield()\n        println(\"Parent is not cancelled\")\n    }\n    job.join()\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        val child = launch {\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                println(\"Child is cancelled\")\n            }\n        }\n        yield()\n        println(\"Cancelling child\")\n        child.cancel()\n        child.join()\n        yield()\n        println(\"Parent is not cancelled\")\n    }\n    job.join()\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code is:"}, {"type": "pre", "text": "Cancelling child\nChild is cancelled\nParent is not cancelled\n"}, {"type": "code", "text": "Cancelling child\nChild is cancelled\nParent is not cancelled\n"}, {"type": "p", "text": "If a coroutine encounters an exception other than CancellationException, it cancels its parent with that exception. \nThis behaviour cannot be overridden and is used to provide stable coroutines hierarchies for\nstructured concurrency.\nCoroutineExceptionHandler implementation is not used for child coroutines."}, {"type": "code", "text": "CancellationException"}, {"type": "a", "text": "structured concurrency"}, {"type": "a", "text": "CoroutineExceptionHandler"}, {"type": "blockquote", "text": "\nIn these examples CoroutineExceptionHandler is always installed to a coroutine\nthat is created in GlobalScope. It does not make sense to install an exception handler to a coroutine that\nis launched in the scope of the main runBlocking, since the main coroutine is going to be always cancelled\nwhen its child completes with exception despite the installed handler.\n"}, {"type": "p", "text": "In these examples CoroutineExceptionHandler is always installed to a coroutine\nthat is created in GlobalScope. It does not make sense to install an exception handler to a coroutine that\nis launched in the scope of the main runBlocking, since the main coroutine is going to be always cancelled\nwhen its child completes with exception despite the installed handler."}, {"type": "a", "text": "CoroutineExceptionHandler"}, {"type": "a", "text": "GlobalScope"}, {"type": "a", "text": "runBlocking"}, {"type": "p", "text": "The original exception is handled by the parent only when all its children terminate,\nwhich is demonstrated by the following example."}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val handler = CoroutineExceptionHandler { _, exception -> \n        println(\"CoroutineExceptionHandler got $exception\") \n    }\n    val job = GlobalScope.launch(handler) {\n        launch { // the first child\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                withContext(NonCancellable) {\n                    println(\"Children are cancelled, but exception is not handled until all children terminate\")\n                    delay(100)\n                    println(\"The first child finished its non cancellable block\")\n                }\n            }\n        }\n        launch { // the second child\n            delay(10)\n            println(\"Second child throws an exception\")\n            throw ArithmeticException()\n        }\n    }\n    job.join()\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val handler = CoroutineExceptionHandler { _, exception -> \n        println(\"CoroutineExceptionHandler got $exception\") \n    }\n    val job = GlobalScope.launch(handler) {\n        launch { // the first child\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                withContext(NonCancellable) {\n                    println(\"Children are cancelled, but exception is not handled until all children terminate\")\n                    delay(100)\n                    println(\"The first child finished its non cancellable block\")\n                }\n            }\n        }\n        launch { // the second child\n            delay(10)\n            println(\"Second child throws an exception\")\n            throw ArithmeticException()\n        }\n    }\n    job.join()\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val handler = CoroutineExceptionHandler { _, exception -> \n        println(\"CoroutineExceptionHandler got $exception\") \n    }\n    val job = GlobalScope.launch(handler) {\n        launch { // the first child\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                withContext(NonCancellable) {\n                    println(\"Children are cancelled, but exception is not handled until all children terminate\")\n                    delay(100)\n                    println(\"The first child finished its non cancellable block\")\n                }\n            }\n        }\n        launch { // the second child\n            delay(10)\n            println(\"Second child throws an exception\")\n            throw ArithmeticException()\n        }\n    }\n    job.join()\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code is:"}, {"type": "pre", "text": "Second child throws an exception\nChildren are cancelled, but exception is not handled until all children terminate\nThe first child finished its non cancellable block\nCoroutineExceptionHandler got java.lang.ArithmeticException\n"}, {"type": "code", "text": "Second child throws an exception\nChildren are cancelled, but exception is not handled until all children terminate\nThe first child finished its non cancellable block\nCoroutineExceptionHandler got java.lang.ArithmeticException\n"}, {"type": "h3", "text": "Exceptions aggregation"}, {"type": "p", "text": "When multiple children of a coroutine fail with an exception the\ngeneral rule is \"the first exception wins\", so the first exception gets handled.\nAll additional exceptions that happen after the first one are attached to the first exception as suppressed ones."}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport java.io.*\n\nfun main() = runBlocking {\n    val handler = CoroutineExceptionHandler { _, exception ->\n        println(\"CoroutineExceptionHandler got $exception with suppressed ${exception.suppressed.contentToString()}\")\n    }\n    val job = GlobalScope.launch(handler) {\n        launch {\n            try {\n                delay(Long.MAX_VALUE) // it gets cancelled when another sibling fails with IOException\n            } finally {\n                throw ArithmeticException() // the second exception\n            }\n        }\n        launch {\n            delay(100)\n            throw IOException() // the first exception\n        }\n        delay(Long.MAX_VALUE)\n    }\n    job.join()  \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport java.io.*\n\nfun main() = runBlocking {\n    val handler = CoroutineExceptionHandler { _, exception ->\n        println(\"CoroutineExceptionHandler got $exception with suppressed ${exception.suppressed.contentToString()}\")\n    }\n    val job = GlobalScope.launch(handler) {\n        launch {\n            try {\n                delay(Long.MAX_VALUE) // it gets cancelled when another sibling fails with IOException\n            } finally {\n                throw ArithmeticException() // the second exception\n            }\n        }\n        launch {\n            delay(100)\n            throw IOException() // the first exception\n        }\n        delay(Long.MAX_VALUE)\n    }\n    job.join()  \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport java.io.*\n\nfun main() = runBlocking {\n    val handler = CoroutineExceptionHandler { _, exception ->\n        println(\"CoroutineExceptionHandler got $exception with suppressed ${exception.suppressed.contentToString()}\")\n    }\n    val job = GlobalScope.launch(handler) {\n        launch {\n            try {\n                delay(Long.MAX_VALUE) // it gets cancelled when another sibling fails with IOException\n            } finally {\n                throw ArithmeticException() // the second exception\n            }\n        }\n        launch {\n            delay(100)\n            throw IOException() // the first exception\n        }\n        delay(Long.MAX_VALUE)\n    }\n    job.join()  \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "blockquote", "text": "\nNote: This above code will work properly only on JDK7+ that supports suppressed exceptions\n"}, {"type": "p", "text": "Note: This above code will work properly only on JDK7+ that supports suppressed exceptions"}, {"type": "code", "text": "suppressed"}, {"type": "p", "text": "The output of this code is:"}, {"type": "pre", "text": "CoroutineExceptionHandler got java.io.IOException with suppressed [java.lang.ArithmeticException]\n"}, {"type": "code", "text": "CoroutineExceptionHandler got java.io.IOException with suppressed [java.lang.ArithmeticException]\n"}, {"type": "blockquote", "text": "\nNote, this mechanism currently works only on Java version 1.7+. \nLimitation on JS and Native is temporary and will be fixed in the future.\n"}, {"type": "p", "text": "Note, this mechanism currently works only on Java version 1.7+. \nLimitation on JS and Native is temporary and will be fixed in the future."}, {"type": "p", "text": "Cancellation exceptions are transparent and are unwrapped by default:"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\nimport java.io.*\n\nfun main() = runBlocking {\n//sampleStart\n    val handler = CoroutineExceptionHandler { _, exception ->\n        println(\"CoroutineExceptionHandler got $exception\")\n    }\n    val job = GlobalScope.launch(handler) {\n        val inner = launch { // all this stack of coroutines will get cancelled\n            launch {\n                launch {\n                    throw IOException() // the original exception\n                }\n            }\n        }\n        try {\n            inner.join()\n        } catch (e: CancellationException) {\n            println(\"Rethrowing CancellationException with original cause\")\n            throw e // cancellation exception is rethrown, yet the original IOException gets to the handler  \n        }\n    }\n    job.join()\n//sampleEnd    \n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\nimport java.io.*\n\nfun main() = runBlocking {\n//sampleStart\n    val handler = CoroutineExceptionHandler { _, exception ->\n        println(\"CoroutineExceptionHandler got $exception\")\n    }\n    val job = GlobalScope.launch(handler) {\n        val inner = launch { // all this stack of coroutines will get cancelled\n            launch {\n                launch {\n                    throw IOException() // the original exception\n                }\n            }\n        }\n        try {\n            inner.join()\n        } catch (e: CancellationException) {\n            println(\"Rethrowing CancellationException with original cause\")\n            throw e // cancellation exception is rethrown, yet the original IOException gets to the handler  \n        }\n    }\n    job.join()\n//sampleEnd    \n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\nimport java.io.*\n\nfun main() = runBlocking {\n//sampleStart\n    val handler = CoroutineExceptionHandler { _, exception ->\n        println(\"CoroutineExceptionHandler got $exception\")\n    }\n    val job = GlobalScope.launch(handler) {\n        val inner = launch { // all this stack of coroutines will get cancelled\n            launch {\n                launch {\n                    throw IOException() // the original exception\n                }\n            }\n        }\n        try {\n            inner.join()\n        } catch (e: CancellationException) {\n            println(\"Rethrowing CancellationException with original cause\")\n            throw e // cancellation exception is rethrown, yet the original IOException gets to the handler  \n        }\n    }\n    job.join()\n//sampleEnd    \n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code is:"}, {"type": "pre", "text": "Rethrowing CancellationException with original cause\nCoroutineExceptionHandler got java.io.IOException\n"}, {"type": "code", "text": "Rethrowing CancellationException with original cause\nCoroutineExceptionHandler got java.io.IOException\n"}, {"type": "h3", "text": "Supervision"}, {"type": "p", "text": "As we have studied before, cancellation is a bidirectional relationship propagating through the whole\nhierarchy of coroutines. Let us take a look at the case when unidirectional cancellation is required."}, {"type": "p", "text": "A good example of such a requirement is a UI component with the job defined in its scope. If any of the UI's child tasks\nhave failed, it is not always necessary to cancel (effectively kill) the whole UI component,\nbut if UI component is destroyed (and its job is cancelled), then it is necessary to fail all child jobs as their results are no longer needed."}, {"type": "p", "text": "Another example is a server process that spawns several children jobs and needs to supervise\ntheir execution, tracking their failures and restarting just those children jobs that had failed."}, {"type": "em", "text": "supervise"}, {"type": "h4", "text": "Supervision job"}, {"type": "p", "text": "For these purposes SupervisorJob can be used. \nIt is similar to a regular Job with the only exception that cancellation is propagated\nonly downwards. It is easy to demonstrate with an example:"}, {"type": "a", "text": "SupervisorJob"}, {"type": "a", "text": "Job"}, {"type": "div", "text": "\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val supervisor = SupervisorJob()\n    with(CoroutineScope(coroutineContext + supervisor)) {\n        // launch the first child -- its exception is ignored for this example (don't do this in practice!)\n        val firstChild = launch(CoroutineExceptionHandler { _, _ ->  }) {\n            println(\"First child is failing\")\n            throw AssertionError(\"First child is cancelled\")\n        }\n        // launch the second child\n        val secondChild = launch {\n            firstChild.join()\n            // Cancellation of the first child is not propagated to the second child\n            println(\"First child is cancelled: ${firstChild.isCancelled}, but second one is still active\")\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                // But cancellation of the supervisor is propagated\n                println(\"Second child is cancelled because supervisor is cancelled\")\n            }\n        }\n        // wait until the first child fails & completes\n        firstChild.join()\n        println(\"Cancelling supervisor\")\n        supervisor.cancel()\n        secondChild.join()\n    }\n}\n\n"}, {"type": "pre", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val supervisor = SupervisorJob()\n    with(CoroutineScope(coroutineContext + supervisor)) {\n        // launch the first child -- its exception is ignored for this example (don't do this in practice!)\n        val firstChild = launch(CoroutineExceptionHandler { _, _ ->  }) {\n            println(\"First child is failing\")\n            throw AssertionError(\"First child is cancelled\")\n        }\n        // launch the second child\n        val secondChild = launch {\n            firstChild.join()\n            // Cancellation of the first child is not propagated to the second child\n            println(\"First child is cancelled: ${firstChild.isCancelled}, but second one is still active\")\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                // But cancellation of the supervisor is propagated\n                println(\"Second child is cancelled because supervisor is cancelled\")\n            }\n        }\n        // wait until the first child fails & completes\n        firstChild.join()\n        println(\"Cancelling supervisor\")\n        supervisor.cancel()\n        secondChild.join()\n    }\n}\n"}, {"type": "code", "text": "import kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val supervisor = SupervisorJob()\n    with(CoroutineScope(coroutineContext + supervisor)) {\n        // launch the first child -- its exception is ignored for this example (don't do this in practice!)\n        val firstChild = launch(CoroutineExceptionHandler { _, _ ->  }) {\n            println(\"First child is failing\")\n            throw AssertionError(\"First child is cancelled\")\n        }\n        // launch the second child\n        val secondChild = launch {\n            firstChild.join()\n            // Cancellation of the first child is not propagated to the second child\n            println(\"First child is cancelled: ${firstChild.isCancelled}, but second one is still active\")\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                // But cancellation of the supervisor is propagated\n                println(\"Second child is cancelled because supervisor is cancelled\")\n            }\n        }\n        // wait until the first child fails & completes\n        firstChild.join()\n        println(\"Cancelling supervisor\")\n        supervisor.cancel()\n        secondChild.join()\n    }\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code is:"}, {"type": "pre", "text": "First child is failing\nFirst child is cancelled: true, but second one is still active\nCancelling supervisor\nSecond child is cancelled because supervisor is cancelled\n"}, {"type": "code", "text": "First child is failing\nFirst child is cancelled: true, but second one is still active\nCancelling supervisor\nSecond child is cancelled because supervisor is cancelled\n"}, {"type": "h4", "text": "Supervision scope"}, {"type": "p", "text": "For scoped concurrency supervisorScope can be used instead of coroutineScope for the same purpose. It propagates cancellation\nin one direction only and cancels all children only if it has failed itself. It also waits for all children before completion\njust like coroutineScope does."}, {"type": "em", "text": "scoped"}, {"type": "a", "text": "supervisorScope"}, {"type": "a", "text": "coroutineScope"}, {"type": "a", "text": "coroutineScope"}, {"type": "div", "text": "\nimport kotlin.coroutines.*\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    try {\n        supervisorScope {\n            val child = launch {\n                try {\n                    println(\"Child is sleeping\")\n                    delay(Long.MAX_VALUE)\n                } finally {\n                    println(\"Child is cancelled\")\n                }\n            }\n            // Give our child a chance to execute and print using yield \n            yield()\n            println(\"Throwing exception from scope\")\n            throw AssertionError()\n        }\n    } catch(e: AssertionError) {\n        println(\"Caught assertion error\")\n    }\n}\n\n"}, {"type": "pre", "text": "import kotlin.coroutines.*\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    try {\n        supervisorScope {\n            val child = launch {\n                try {\n                    println(\"Child is sleeping\")\n                    delay(Long.MAX_VALUE)\n                } finally {\n                    println(\"Child is cancelled\")\n                }\n            }\n            // Give our child a chance to execute and print using yield \n            yield()\n            println(\"Throwing exception from scope\")\n            throw AssertionError()\n        }\n    } catch(e: AssertionError) {\n        println(\"Caught assertion error\")\n    }\n}\n"}, {"type": "code", "text": "import kotlin.coroutines.*\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    try {\n        supervisorScope {\n            val child = launch {\n                try {\n                    println(\"Child is sleeping\")\n                    delay(Long.MAX_VALUE)\n                } finally {\n                    println(\"Child is cancelled\")\n                }\n            }\n            // Give our child a chance to execute and print using yield \n            yield()\n            println(\"Throwing exception from scope\")\n            throw AssertionError()\n        }\n    } catch(e: AssertionError) {\n        println(\"Caught assertion error\")\n    }\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code is:"}, {"type": "pre", "text": "Child is sleeping\nThrowing exception from scope\nChild is cancelled\nCaught assertion error\n"}, {"type": "code", "text": "Child is sleeping\nThrowing exception from scope\nChild is cancelled\nCaught assertion error\n"}, {"type": "h4", "text": "Exceptions in supervised coroutines"}, {"type": "p", "text": "Another crucial difference between regular and supervisor jobs is exception handling.\nEvery child should handle its exceptions by itself via exception handling mechanism.\nThis difference comes from the fact that child's failure is not propagated to the parent.\nIt means that coroutines launched directly inside supervisorScope do use the CoroutineExceptionHandler\nthat is installed in their scope in the same way as root coroutines do\n(see CoroutineExceptionHandler section for details)."}, {"type": "a", "text": "supervisorScope"}, {"type": "em", "text": "do"}, {"type": "a", "text": "CoroutineExceptionHandler"}, {"type": "a", "text": "CoroutineExceptionHandler"}, {"type": "div", "text": "\nimport kotlin.coroutines.*\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val handler = CoroutineExceptionHandler { _, exception -> \n        println(\"CoroutineExceptionHandler got $exception\") \n    }\n    supervisorScope {\n        val child = launch(handler) {\n            println(\"Child throws an exception\")\n            throw AssertionError()\n        }\n        println(\"Scope is completing\")\n    }\n    println(\"Scope is completed\")\n}\n\n"}, {"type": "pre", "text": "import kotlin.coroutines.*\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val handler = CoroutineExceptionHandler { _, exception -> \n        println(\"CoroutineExceptionHandler got $exception\") \n    }\n    supervisorScope {\n        val child = launch(handler) {\n            println(\"Child throws an exception\")\n            throw AssertionError()\n        }\n        println(\"Scope is completing\")\n    }\n    println(\"Scope is completed\")\n}\n"}, {"type": "code", "text": "import kotlin.coroutines.*\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val handler = CoroutineExceptionHandler { _, exception -> \n        println(\"CoroutineExceptionHandler got $exception\") \n    }\n    supervisorScope {\n        val child = launch(handler) {\n            println(\"Child throws an exception\")\n            throw AssertionError()\n        }\n        println(\"Scope is completing\")\n    }\n    println(\"Scope is completed\")\n}\n"}, {"type": "blockquote", "text": "\nYou can get full code here.\n"}, {"type": "p", "text": "You can get full code here."}, {"type": "a", "text": "here"}, {"type": "p", "text": "The output of this code is:"}, {"type": "pre", "text": "Scope is completing\nChild throws an exception\nCoroutineExceptionHandler got java.lang.AssertionError\nScope is completed\n"}, {"type": "code", "text": "Scope is completing\nChild throws an exception\nCoroutineExceptionHandler got java.lang.AssertionError\nScope is completed\n"}]