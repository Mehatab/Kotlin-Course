[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Type Checks and Casts: 'is' and 'as'"}, {"type": "h2", "text": "is and !is Operators"}, {"type": "code", "text": "is"}, {"type": "code", "text": "!is"}, {"type": "p", "text": "We can check whether an object conforms to a given type at runtime by using the is operator or its negated form !is:"}, {"type": "code", "text": "is"}, {"type": "code", "text": "!is"}, {"type": "div", "text": "\nif (obj is String) {\n    print(obj.length)\n}\n\nif (obj !is String) { // same as !(obj is String)\n    print(\"Not a String\")\n}\nelse {\n    print(obj.length)\n}\n\n"}, {"type": "pre", "text": "if (obj is String) {\n    print(obj.length)\n}\n\nif (obj !is String) { // same as !(obj is String)\n    print(\"Not a String\")\n}\nelse {\n    print(obj.length)\n}\n"}, {"type": "code", "text": "if (obj is String) {\n    print(obj.length)\n}\n\nif (obj !is String) { // same as !(obj is String)\n    print(\"Not a String\")\n}\nelse {\n    print(obj.length)\n}\n"}, {"type": "h2", "text": "Smart Casts"}, {"type": "p", "text": "In many cases, one does not need to use explicit cast operators in Kotlin, because the compiler tracks the\nis-checks and explicit casts for immutable values and inserts (safe) casts automatically when needed:"}, {"type": "code", "text": "is"}, {"type": "a", "text": "explicit casts"}, {"type": "div", "text": "\nfun demo(x: Any) {\n    if (x is String) {\n        print(x.length) // x is automatically cast to String\n    }\n}\n\n"}, {"type": "pre", "text": "fun demo(x: Any) {\n    if (x is String) {\n        print(x.length) // x is automatically cast to String\n    }\n}\n"}, {"type": "code", "text": "fun demo(x: Any) {\n    if (x is String) {\n        print(x.length) // x is automatically cast to String\n    }\n}\n"}, {"type": "p", "text": "The compiler is smart enough to know a cast to be safe if a negative check leads to a return:"}, {"type": "div", "text": "\nif (x !is String) return\n\nprint(x.length) // x is automatically cast to String\n\n"}, {"type": "pre", "text": "if (x !is String) return\n\nprint(x.length) // x is automatically cast to String\n"}, {"type": "code", "text": "if (x !is String) return\n\nprint(x.length) // x is automatically cast to String\n"}, {"type": "p", "text": "or in the right-hand side of && and ||:"}, {"type": "code", "text": "&&"}, {"type": "code", "text": "||"}, {"type": "div", "text": "\n// x is automatically cast to string on the right-hand side of `||`\nif (x !is String || x.length == 0) return\n\n// x is automatically cast to string on the right-hand side of `&&`\nif (x is String && x.length > 0) {\n    print(x.length) // x is automatically cast to String\n}\n\n"}, {"type": "pre", "text": "// x is automatically cast to string on the right-hand side of `||`\nif (x !is String || x.length == 0) return\n\n// x is automatically cast to string on the right-hand side of `&&`\nif (x is String && x.length > 0) {\n    print(x.length) // x is automatically cast to String\n}\n"}, {"type": "code", "text": "// x is automatically cast to string on the right-hand side of `||`\nif (x !is String || x.length == 0) return\n\n// x is automatically cast to string on the right-hand side of `&&`\nif (x is String && x.length > 0) {\n    print(x.length) // x is automatically cast to String\n}\n"}, {"type": "p", "text": "Such smart casts work for when-expressions\nand while-loops as well:"}, {"type": "em", "text": "smart casts"}, {"type": "a", "text": "when-expressions"}, {"type": "em", "text": "when"}, {"type": "a", "text": "while-loops"}, {"type": "em", "text": "while"}, {"type": "div", "text": "\nwhen (x) {\n    is Int -> print(x + 1)\n    is String -> print(x.length + 1)\n    is IntArray -> print(x.sum())\n}\n\n"}, {"type": "pre", "text": "when (x) {\n    is Int -> print(x + 1)\n    is String -> print(x.length + 1)\n    is IntArray -> print(x.sum())\n}\n"}, {"type": "code", "text": "when (x) {\n    is Int -> print(x + 1)\n    is String -> print(x.length + 1)\n    is IntArray -> print(x.sum())\n}\n"}, {"type": "p", "text": "Note that smart casts do not work when the compiler cannot guarantee that the variable cannot change between the check and the usage.\nMore specifically, smart casts are applicable according to the following rules:"}, {"type": "ul", "text": "\nval local variables - always except for local delegated properties;\nval properties - if the property is private or internal or the check is performed in the same module where the property is declared. Smart casts aren't applicable to open properties or properties that have custom getters;\nvar local variables - if the variable is not modified between the check and the usage, is not captured in a lambda that modifies it, and is not a local delegated property;\nvar properties - never (because the variable can be modified at any time by other code).\n"}, {"type": "li", "text": "val local variables - always except for local delegated properties;"}, {"type": "em", "text": "val"}, {"type": "a", "text": "local delegated properties"}, {"type": "li", "text": "val properties - if the property is private or internal or the check is performed in the same module where the property is declared. Smart casts aren't applicable to open properties or properties that have custom getters;"}, {"type": "em", "text": "val"}, {"type": "a", "text": "module"}, {"type": "li", "text": "var local variables - if the variable is not modified between the check and the usage, is not captured in a lambda that modifies it, and is not a local delegated property;"}, {"type": "em", "text": "var"}, {"type": "li", "text": "var properties - never (because the variable can be modified at any time by other code)."}, {"type": "em", "text": "var"}, {"type": "h2", "text": "\"Unsafe\" cast operator"}, {"type": "p", "text": "Usually, the cast operator throws an exception if the cast is not possible. Thus, we call it unsafe.\nThe unsafe cast in Kotlin is done by the infix operator as (see operator precedence):"}, {"type": "em", "text": "unsafe"}, {"type": "em", "text": "as"}, {"type": "a", "text": "operator precedence"}, {"type": "div", "text": "\nval x: String = y as String\n\n"}, {"type": "pre", "text": "val x: String = y as String\n"}, {"type": "code", "text": "val x: String = y as String\n"}, {"type": "p", "text": "Note that null cannot be cast to String as this type is not nullable,\ni.e. if y is null, the code above throws an exception. \nTo make such code correct for null values, use the nullable type on the right hand side of the cast:"}, {"type": "em", "text": "null"}, {"type": "code", "text": "String"}, {"type": "a", "text": "nullable"}, {"type": "code", "text": "y"}, {"type": "div", "text": "\nval x: String? = y as String?\n\n"}, {"type": "pre", "text": "val x: String? = y as String?\n"}, {"type": "code", "text": "val x: String? = y as String?\n"}, {"type": "h2", "text": "\"Safe\" (nullable) cast operator"}, {"type": "p", "text": "To avoid an exception being thrown, one can use a safe cast operator as? that returns null on failure:"}, {"type": "em", "text": "safe"}, {"type": "em", "text": "as?"}, {"type": "em", "text": "null"}, {"type": "div", "text": "\nval x: String? = y as? String\n\n"}, {"type": "pre", "text": "val x: String? = y as? String\n"}, {"type": "code", "text": "val x: String? = y as? String\n"}, {"type": "p", "text": "Note that despite the fact that the right-hand side of as? is a non-null type String the result of the cast is nullable."}, {"type": "em", "text": "as?"}, {"type": "code", "text": "String"}, {"type": "h2", "text": "Type erasure and generic type checks"}, {"type": "p", "text": "Kotlin ensures type safety of operations involving generics at compile time,\nwhile, at runtime, instances of generic types hold no information about their actual type arguments. For example, \nList<Foo> is erased to just List<*>. In general, there is no way to check whether an instance belongs to a generic \ntype with certain type arguments at runtime."}, {"type": "a", "text": "generics"}, {"type": "code", "text": "List<Foo>"}, {"type": "code", "text": "List<*>"}, {"type": "p", "text": "Given that, the compiler prohibits is-checks that cannot be performed at runtime due to type erasure, such as \nints is List<Int> or list is T (type parameter). You can, however, check an instance against a star-projected type:"}, {"type": "em", "text": "is"}, {"type": "code", "text": "ints is List<Int>"}, {"type": "code", "text": "list is T"}, {"type": "a", "text": "star-projected type"}, {"type": "div", "text": "\nif (something is List<*>) {\n    something.forEach { println(it) } // The items are typed as `Any?`\n}\n\n"}, {"type": "pre", "text": "if (something is List<*>) {\n    something.forEach { println(it) } // The items are typed as `Any?`\n}\n"}, {"type": "code", "text": "if (something is List<*>) {\n    something.forEach { println(it) } // The items are typed as `Any?`\n}\n"}, {"type": "p", "text": "Similarly, when you already have the type arguments of an instance checked statically (at compile time),\nyou can make an is-check or a cast that involves the non-generic part of the type. Note that \nangle brackets are omitted in this case:"}, {"type": "em", "text": "is"}, {"type": "div", "text": "\nfun handleStrings(list: List<String>) {\n    if (list is ArrayList) {\n        // `list` is smart-cast to `ArrayList<String>`\n    }\n}\n\n"}, {"type": "pre", "text": "fun handleStrings(list: List<String>) {\n    if (list is ArrayList) {\n        // `list` is smart-cast to `ArrayList<String>`\n    }\n}\n"}, {"type": "code", "text": "fun handleStrings(list: List<String>) {\n    if (list is ArrayList) {\n        // `list` is smart-cast to `ArrayList<String>`\n    }\n}\n"}, {"type": "p", "text": "The same syntax with omitted type arguments can be used for casts that do not take type arguments into account: list as ArrayList."}, {"type": "code", "text": "list as ArrayList"}, {"type": "p", "text": "Inline functions with reified type parameters have their actual type arguments\n inlined at each call site, which enables arg is T checks for the type parameters, but if arg is an instance of a \ngeneric type itself, its type arguments are still erased. Example:"}, {"type": "a", "text": "reified type parameters"}, {"type": "code", "text": "arg is T"}, {"type": "code", "text": "arg"}, {"type": "em", "text": "its"}, {"type": "div", "text": "\n//sampleStart\ninline fun <reified A, reified B> Pair<*, *>.asPairOf(): Pair<A, B>? {\n    if (first !is A || second !is B) return null\n    return first as A to second as B\n}\n\nval somePair: Pair<Any?, Any?> = \"items\" to listOf(1, 2, 3)\n\nval stringToSomething = somePair.asPairOf<String, Any>()\nval stringToInt = somePair.asPairOf<String, Int>()\nval stringToList = somePair.asPairOf<String, List<*>>()\nval stringToStringList = somePair.asPairOf<String, List<String>>() // Breaks type safety!\n//sampleEnd\n\nfun main() {\n    println(\"stringToSomething = \" + stringToSomething)\n    println(\"stringToInt = \" + stringToInt)\n    println(\"stringToList = \" + stringToList)\n    println(\"stringToStringList = \" + stringToStringList)\n}\n\n"}, {"type": "pre", "text": "//sampleStart\ninline fun <reified A, reified B> Pair<*, *>.asPairOf(): Pair<A, B>? {\n    if (first !is A || second !is B) return null\n    return first as A to second as B\n}\n\nval somePair: Pair<Any?, Any?> = \"items\" to listOf(1, 2, 3)\n\nval stringToSomething = somePair.asPairOf<String, Any>()\nval stringToInt = somePair.asPairOf<String, Int>()\nval stringToList = somePair.asPairOf<String, List<*>>()\nval stringToStringList = somePair.asPairOf<String, List<String>>() // Breaks type safety!\n//sampleEnd\n\nfun main() {\n    println(\"stringToSomething = \" + stringToSomething)\n    println(\"stringToInt = \" + stringToInt)\n    println(\"stringToList = \" + stringToList)\n    println(\"stringToStringList = \" + stringToStringList)\n}\n"}, {"type": "code", "text": "//sampleStart\ninline fun <reified A, reified B> Pair<*, *>.asPairOf(): Pair<A, B>? {\n    if (first !is A || second !is B) return null\n    return first as A to second as B\n}\n\nval somePair: Pair<Any?, Any?> = \"items\" to listOf(1, 2, 3)\n\nval stringToSomething = somePair.asPairOf<String, Any>()\nval stringToInt = somePair.asPairOf<String, Int>()\nval stringToList = somePair.asPairOf<String, List<*>>()\nval stringToStringList = somePair.asPairOf<String, List<String>>() // Breaks type safety!\n//sampleEnd\n\nfun main() {\n    println(\"stringToSomething = \" + stringToSomething)\n    println(\"stringToInt = \" + stringToInt)\n    println(\"stringToList = \" + stringToList)\n    println(\"stringToStringList = \" + stringToStringList)\n}\n"}, {"type": "h2", "text": "Unchecked casts"}, {"type": "p", "text": "As said above, type erasure makes checking actual type arguments of a generic type instance impossible at runtime, and \ngeneric types in the code might be connected to each other not closely enough for the compiler to ensure \ntype safety."}, {"type": "p", "text": "Even so, sometimes we have high-level program logic that implies type safety instead. For example:"}, {"type": "div", "text": "\nfun readDictionary(file: File): Map<String, *> = file.inputStream().use { \n    TODO(\"Read a mapping of strings to arbitrary elements.\")\n}\n\n// We saved a map with `Int`s into that file\nval intsFile = File(\"ints.dictionary\")\n\n// Warning: Unchecked cast: `Map<String, *>` to `Map<String, Int>`\nval intsDictionary: Map<String, Int> = readDictionary(intsFile) as Map<String, Int>\n\n"}, {"type": "pre", "text": "fun readDictionary(file: File): Map<String, *> = file.inputStream().use { \n    TODO(\"Read a mapping of strings to arbitrary elements.\")\n}\n\n// We saved a map with `Int`s into that file\nval intsFile = File(\"ints.dictionary\")\n\n// Warning: Unchecked cast: `Map<String, *>` to `Map<String, Int>`\nval intsDictionary: Map<String, Int> = readDictionary(intsFile) as Map<String, Int>\n"}, {"type": "code", "text": "fun readDictionary(file: File): Map<String, *> = file.inputStream().use { \n    TODO(\"Read a mapping of strings to arbitrary elements.\")\n}\n\n// We saved a map with `Int`s into that file\nval intsFile = File(\"ints.dictionary\")\n\n// Warning: Unchecked cast: `Map<String, *>` to `Map<String, Int>`\nval intsDictionary: Map<String, Int> = readDictionary(intsFile) as Map<String, Int>\n"}, {"type": "p", "text": "The compiler produces a warning for the cast in the last line. The cast cannot be fully checked at runtime and provides \nno guarantee that the values in the map are Int."}, {"type": "code", "text": "Int"}, {"type": "p", "text": "To avoid unchecked casts, you can redesign the program structure: in the example above, there could be interfaces\n DictionaryReader<T> and DictionaryWriter<T> with type-safe implementations for different types. \n You can introduce reasonable abstractions to move unchecked casts from calling code to the implementation details.\n Proper use of generic variance can also help."}, {"type": "code", "text": "DictionaryReader<T>"}, {"type": "code", "text": "DictionaryWriter<T>"}, {"type": "a", "text": "generic variance"}, {"type": "p", "text": "For generic functions, using reified type parameters makes the casts \nsuch as arg as T checked, unless arg's type has its own type arguments that are erased."}, {"type": "a", "text": "reified type parameters"}, {"type": "code", "text": "arg as T"}, {"type": "code", "text": "arg"}, {"type": "em", "text": "its own"}, {"type": "p", "text": "An unchecked cast warning can be suppressed by annotating the statement or the \ndeclaration where it occurs with @Suppress(\"UNCHECKED_CAST\"):"}, {"type": "a", "text": "annotating"}, {"type": "code", "text": "@Suppress(\"UNCHECKED_CAST\")"}, {"type": "div", "text": "\ninline fun <reified T> List<*>.asListOfType(): List<T>? =\n    if (all { it is T })\n        @Suppress(\"UNCHECKED_CAST\")\n        this as List<T> else\n        null\n\n"}, {"type": "pre", "text": "inline fun <reified T> List<*>.asListOfType(): List<T>? =\n    if (all { it is T })\n        @Suppress(\"UNCHECKED_CAST\")\n        this as List<T> else\n        null\n"}, {"type": "code", "text": "inline fun <reified T> List<*>.asListOfType(): List<T>? =\n    if (all { it is T })\n        @Suppress(\"UNCHECKED_CAST\")\n        this as List<T> else\n        null\n"}, {"type": "p", "text": "On the JVM, the array types (Array<Foo>) retain the information about the erased type of \ntheir elements, and the type casts to an array type are partially checked: the \nnullability and actual type arguments of the elements type are still erased. For example, \nthe cast foo as Array<List<String>?> will succeed if foo is an array holding any List<*>, nullable or not."}, {"type": "a", "text": "array types"}, {"type": "code", "text": "Array<Foo>"}, {"type": "code", "text": "foo as Array<List<String>?>"}, {"type": "code", "text": "foo"}, {"type": "code", "text": "List<*>"}]