[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Kotlin Collections Overview"}, {"type": "p", "text": "The Kotlin Standard Library provides a comprehensive set of tools for managing collections \u2013 groups of a variable number of items (possibly zero) that share significance to the problem being solved and are operated upon commonly."}, {"type": "em", "text": "collections"}, {"type": "p", "text": "Collections are a common concept for most programming languages, so if you're familiar with, for example, Java or Python collections, you can skip this introduction and proceed to the detailed sections."}, {"type": "p", "text": "A collection usually contains a number of objects (this number may also be zero) of the same type. Objects in a collection are called elements or items. For example, all the students in a department form a collection that can be used to calculate their average age. \nThe  following collection types are relevant for Kotlin:"}, {"type": "em", "text": "elements"}, {"type": "em", "text": "items"}, {"type": "ul", "text": "\nList is an ordered collection with access to elements by indices \u2013 integer numbers that reflect their position. Elements can occur more than once in a list. An example of a list is a sentence: it's a group of words, their order is important, and they can repeat.\nSet is a collection of unique elements. It reflects the mathematical abstraction of set: a group of objects without repetitions. Generally, the order of set elements has no significance. For example, an alphabet is a set of letters.\nMap (or dictionary) is a set of key-value pairs. Keys are unique, and each of them maps to exactly one value. The values can be duplicates. Maps are useful for storing logical connections between objects, for example, an employee's ID and their position.\n"}, {"type": "li", "text": "List is an ordered collection with access to elements by indices \u2013 integer numbers that reflect their position. Elements can occur more than once in a list. An example of a list is a sentence: it's a group of words, their order is important, and they can repeat."}, {"type": "em", "text": "List"}, {"type": "li", "text": "Set is a collection of unique elements. It reflects the mathematical abstraction of set: a group of objects without repetitions. Generally, the order of set elements has no significance. For example, an alphabet is a set of letters."}, {"type": "em", "text": "Set"}, {"type": "li", "text": "Map (or dictionary) is a set of key-value pairs. Keys are unique, and each of them maps to exactly one value. The values can be duplicates. Maps are useful for storing logical connections between objects, for example, an employee's ID and their position."}, {"type": "em", "text": "Map"}, {"type": "em", "text": "dictionary"}, {"type": "p", "text": "Kotlin lets you manipulate collections independently of the exact type of objects stored in them. In other words, you add a String to a list of Strings the same way as you would do with Ints or a user-defined class.\nSo, the Kotlin Standard Library offers generic interfaces, classes, and functions for creating, populating, and managing collections of any type."}, {"type": "code", "text": "String"}, {"type": "code", "text": "String"}, {"type": "code", "text": "Int"}, {"type": "p", "text": "The collection interfaces and related functions are located in the kotlin.collections package. Let's get an overview of its contents."}, {"type": "h2", "text": "Collection types"}, {"type": "p", "text": "The Kotlin Standard Library provides implementations for basic collection types: sets, lists, and maps.\nA pair of interfaces represent each collection type:"}, {"type": "ul", "text": "\nA read-only interface that provides operations for accessing collection elements.\nA mutable interface that extends the corresponding read-only interface with write operations: adding, removing, and updating its elements.\n"}, {"type": "li", "text": "A read-only interface that provides operations for accessing collection elements."}, {"type": "em", "text": "read-only"}, {"type": "li", "text": "A mutable interface that extends the corresponding read-only interface with write operations: adding, removing, and updating its elements."}, {"type": "em", "text": "mutable"}, {"type": "p", "text": "Note that altering a mutable collection doesn't require it to be a var: write operations modify the same mutable collection object, so the reference doesn't change.\nAlthough, if you try to reassign a val collection, you'll get a compilation error."}, {"type": "a", "text": "var"}, {"type": "code", "text": "var"}, {"type": "code", "text": "val"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n    numbers.add(\"five\")   // this is OK    \n    //numbers = mutableListOf(\"six\", \"seven\")      // compilation error\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n    numbers.add(\"five\")   // this is OK    \n    //numbers = mutableListOf(\"six\", \"seven\")      // compilation error\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n    numbers.add(\"five\")   // this is OK    \n    //numbers = mutableListOf(\"six\", \"seven\")      // compilation error\n//sampleEnd\n}\n"}, {"type": "p", "text": "The read-only collection types are covariant.\nThis means that, if a Rectangle class inherits from Shape, you can use a List<Rectangle> anywhere the List<Shape> is required.\nIn other words, the collection types have the same subtyping relationship as the element types. Maps are covariant on the value type, but not on the key type."}, {"type": "a", "text": "covariant"}, {"type": "code", "text": "Rectangle"}, {"type": "code", "text": "Shape"}, {"type": "code", "text": "List<Rectangle>"}, {"type": "code", "text": "List<Shape>"}, {"type": "p", "text": "In turn, mutable collections aren't covariant; otherwise, this would lead to runtime failures. If MutableList<Rectangle> was a subtype of MutableList<Shape>, you could insert other Shape inheritors (for example, Circle) into it, thus violating its Rectangle type argument."}, {"type": "code", "text": "MutableList<Rectangle>"}, {"type": "code", "text": "MutableList<Shape>"}, {"type": "code", "text": "Shape"}, {"type": "code", "text": "Circle"}, {"type": "code", "text": "Rectangle"}, {"type": "p", "text": "Below is a diagram of the Kotlin collection interfaces:"}, {"type": "p", "text": ""}, {"type": "img", "text": ""}, {"type": "p", "text": "Let's walk through the interfaces and their implementations."}, {"type": "h3", "text": "Collection"}, {"type": "p", "text": "Collection<T> is the root of the collection hierarchy. This interface represents the common behavior of a read-only collection: retrieving size, checking item membership, and so on.\nCollection inherits from the Iterable<T> interface that defines the operations for iterating elements. You can use Collection as a parameter of a function that applies to different collection types. For more specific cases, use the Collection's inheritors: List and Set."}, {"type": "a", "text": "Collection<T>"}, {"type": "code", "text": "Collection<T>"}, {"type": "code", "text": "Collection"}, {"type": "code", "text": "Iterable<T>"}, {"type": "code", "text": "Collection"}, {"type": "code", "text": "Collection"}, {"type": "a", "text": "List"}, {"type": "code", "text": "List"}, {"type": "a", "text": "Set"}, {"type": "code", "text": "Set"}, {"type": "div", "text": "\nfun printAll(strings: Collection<String>) {\n        for(s in strings) print(\"$s \")\n        println()\n    }\n    \nfun main() {\n    val stringList = listOf(\"one\", \"two\", \"one\")\n    printAll(stringList)\n    \n    val stringSet = setOf(\"one\", \"two\", \"three\")\n    printAll(stringSet)\n}\n\n"}, {"type": "pre", "text": "fun printAll(strings: Collection<String>) {\n        for(s in strings) print(\"$s \")\n        println()\n    }\n    \nfun main() {\n    val stringList = listOf(\"one\", \"two\", \"one\")\n    printAll(stringList)\n    \n    val stringSet = setOf(\"one\", \"two\", \"three\")\n    printAll(stringSet)\n}\n"}, {"type": "code", "text": "fun printAll(strings: Collection<String>) {\n        for(s in strings) print(\"$s \")\n        println()\n    }\n    \nfun main() {\n    val stringList = listOf(\"one\", \"two\", \"one\")\n    printAll(stringList)\n    \n    val stringSet = setOf(\"one\", \"two\", \"three\")\n    printAll(stringSet)\n}\n"}, {"type": "p", "text": "MutableCollection is a Collection with write operations, such as add and remove."}, {"type": "a", "text": "MutableCollection"}, {"type": "code", "text": "MutableCollection"}, {"type": "code", "text": "Collection"}, {"type": "code", "text": "add"}, {"type": "code", "text": "remove"}, {"type": "div", "text": "\nfun List<String>.getShortWordsTo(shortWords: MutableList<String>, maxLength: Int) {\n    this.filterTo(shortWords) { it.length <= maxLength }\n    // throwing away the articles\n    val articles = setOf(\"a\", \"A\", \"an\", \"An\", \"the\", \"The\")\n    shortWords -= articles\n}\n\nfun main() {\n    val words = \"A long time ago in a galaxy far far away\".split(\" \")\n    val shortWords = mutableListOf<String>()\n    words.getShortWordsTo(shortWords, 3)\n    println(shortWords)\n}\n\n\n"}, {"type": "pre", "text": "fun List<String>.getShortWordsTo(shortWords: MutableList<String>, maxLength: Int) {\n    this.filterTo(shortWords) { it.length <= maxLength }\n    // throwing away the articles\n    val articles = setOf(\"a\", \"A\", \"an\", \"An\", \"the\", \"The\")\n    shortWords -= articles\n}\n\nfun main() {\n    val words = \"A long time ago in a galaxy far far away\".split(\" \")\n    val shortWords = mutableListOf<String>()\n    words.getShortWordsTo(shortWords, 3)\n    println(shortWords)\n}\n\n"}, {"type": "code", "text": "fun List<String>.getShortWordsTo(shortWords: MutableList<String>, maxLength: Int) {\n    this.filterTo(shortWords) { it.length <= maxLength }\n    // throwing away the articles\n    val articles = setOf(\"a\", \"A\", \"an\", \"An\", \"the\", \"The\")\n    shortWords -= articles\n}\n\nfun main() {\n    val words = \"A long time ago in a galaxy far far away\".split(\" \")\n    val shortWords = mutableListOf<String>()\n    words.getShortWordsTo(shortWords, 3)\n    println(shortWords)\n}\n\n"}, {"type": "h3", "text": "List"}, {"type": "p", "text": "List<T> stores elements in a specified order and provides indexed access to them. Indices start from zero \u2013 the index of the first element \u2013 and go to lastIndex which is the (list.size - 1)."}, {"type": "a", "text": "List<T>"}, {"type": "code", "text": "List<T>"}, {"type": "code", "text": "lastIndex"}, {"type": "code", "text": "(list.size - 1)"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(\"Number of elements: ${numbers.size}\")\n    println(\"Third element: ${numbers.get(2)}\")\n    println(\"Fourth element: ${numbers[3]}\")\n    println(\"Index of element \\\"two\\\" ${numbers.indexOf(\"two\")}\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(\"Number of elements: ${numbers.size}\")\n    println(\"Third element: ${numbers.get(2)}\")\n    println(\"Fourth element: ${numbers[3]}\")\n    println(\"Index of element \\\"two\\\" ${numbers.indexOf(\"two\")}\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(\"Number of elements: ${numbers.size}\")\n    println(\"Third element: ${numbers.get(2)}\")\n    println(\"Fourth element: ${numbers[3]}\")\n    println(\"Index of element \\\"two\\\" ${numbers.indexOf(\"two\")}\")\n//sampleEnd\n}\n"}, {"type": "p", "text": "List elements (including nulls) can duplicate: a list can contain any number of equal objects or occurrences of a single object.\nTwo lists are considered equal if they have the same sizes and structurally equal elements at the same positions."}, {"type": "a", "text": "structurally equal"}, {"type": "div", "text": "\ndata class Person(var name: String, var age: Int)\n\nfun main() {\n//sampleStart\n    val bob = Person(\"Bob\", 31)\n    val people = listOf<Person>(Person(\"Adam\", 20), bob, bob)\n    val people2 = listOf<Person>(Person(\"Adam\", 20), Person(\"Bob\", 31), bob)\n    println(people == people2)\n    bob.age = 32\n    println(people == people2)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "data class Person(var name: String, var age: Int)\n\nfun main() {\n//sampleStart\n    val bob = Person(\"Bob\", 31)\n    val people = listOf<Person>(Person(\"Adam\", 20), bob, bob)\n    val people2 = listOf<Person>(Person(\"Adam\", 20), Person(\"Bob\", 31), bob)\n    println(people == people2)\n    bob.age = 32\n    println(people == people2)\n//sampleEnd\n}\n"}, {"type": "code", "text": "data class Person(var name: String, var age: Int)\n\nfun main() {\n//sampleStart\n    val bob = Person(\"Bob\", 31)\n    val people = listOf<Person>(Person(\"Adam\", 20), bob, bob)\n    val people2 = listOf<Person>(Person(\"Adam\", 20), Person(\"Bob\", 31), bob)\n    println(people == people2)\n    bob.age = 32\n    println(people == people2)\n//sampleEnd\n}\n"}, {"type": "p", "text": "MutableList is a List with list-specific write operations, for example, to add or remove an element at a specific position."}, {"type": "a", "text": "MutableList"}, {"type": "code", "text": "MutableList"}, {"type": "code", "text": "List"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    numbers.add(5)\n    numbers.removeAt(1)\n    numbers[0] = 0\n    numbers.shuffle()\n    println(numbers)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    numbers.add(5)\n    numbers.removeAt(1)\n    numbers[0] = 0\n    numbers.shuffle()\n    println(numbers)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    numbers.add(5)\n    numbers.removeAt(1)\n    numbers[0] = 0\n    numbers.shuffle()\n    println(numbers)\n//sampleEnd\n}\n"}, {"type": "p", "text": "As you see, in some aspects lists are very similar to arrays.\nHowever, there is one important difference:  an array's size is defined upon initialization and is never changed; in turn, a list doesn't have a predefined size; a list's size can be changed as a result of write operations: adding, updating, or removing elements."}, {"type": "p", "text": "In Kotlin, the default implementation of List is ArrayList which you can think of as a resizable array."}, {"type": "code", "text": "List"}, {"type": "a", "text": "ArrayList"}, {"type": "code", "text": "ArrayList"}, {"type": "h3", "text": "Set"}, {"type": "p", "text": "Set<T> stores unique elements; their order is generally undefined. null elements are unique as well: a Set can contain only one null.  Two sets are equal if they have the same size, and for each element of a set there is an equal element in the other set."}, {"type": "a", "text": "Set<T>"}, {"type": "code", "text": "Set<T>"}, {"type": "code", "text": "null"}, {"type": "code", "text": "Set"}, {"type": "code", "text": "null"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3, 4)\n    println(\"Number of elements: ${numbers.size}\")\n    if (numbers.contains(1)) println(\"1 is in the set\")\n\n    val numbersBackwards = setOf(4, 3, 2, 1)\n    println(\"The sets are equal: ${numbers == numbersBackwards}\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3, 4)\n    println(\"Number of elements: ${numbers.size}\")\n    if (numbers.contains(1)) println(\"1 is in the set\")\n\n    val numbersBackwards = setOf(4, 3, 2, 1)\n    println(\"The sets are equal: ${numbers == numbersBackwards}\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3, 4)\n    println(\"Number of elements: ${numbers.size}\")\n    if (numbers.contains(1)) println(\"1 is in the set\")\n\n    val numbersBackwards = setOf(4, 3, 2, 1)\n    println(\"The sets are equal: ${numbers == numbersBackwards}\")\n//sampleEnd\n}\n"}, {"type": "p", "text": "MutableSet is a Set with write operations from MutableCollection."}, {"type": "a", "text": "MutableSet"}, {"type": "code", "text": "MutableSet"}, {"type": "code", "text": "Set"}, {"type": "code", "text": "MutableCollection"}, {"type": "p", "text": "The default implementation of Set \u2013 LinkedHashSet \u2013 preserves the order of elements insertion.\nHence, the functions that rely on the order, such as first() or last(), return predictable results on such sets."}, {"type": "code", "text": "Set"}, {"type": "a", "text": "LinkedHashSet"}, {"type": "code", "text": "LinkedHashSet"}, {"type": "code", "text": "first()"}, {"type": "code", "text": "last()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3, 4)  // LinkedHashSet is the default implementation\n    val numbersBackwards = setOf(4, 3, 2, 1)\n    \n    println(numbers.first() == numbersBackwards.first())\n    println(numbers.first() == numbersBackwards.last())\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3, 4)  // LinkedHashSet is the default implementation\n    val numbersBackwards = setOf(4, 3, 2, 1)\n    \n    println(numbers.first() == numbersBackwards.first())\n    println(numbers.first() == numbersBackwards.last())\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3, 4)  // LinkedHashSet is the default implementation\n    val numbersBackwards = setOf(4, 3, 2, 1)\n    \n    println(numbers.first() == numbersBackwards.first())\n    println(numbers.first() == numbersBackwards.last())\n//sampleEnd\n}\n"}, {"type": "p", "text": "An alternative implementation \u2013 HashSet \u2013 says nothing about the elements order, so calling such functions on it returns unpredictable results. However, HashSet requires less memory to store the same number of elements."}, {"type": "a", "text": "HashSet"}, {"type": "code", "text": "HashSet"}, {"type": "code", "text": "HashSet"}, {"type": "h3", "text": "Map"}, {"type": "p", "text": "Map<K, V> is not an inheritor of the Collection interface; however, it's a Kotlin collection type as well.\nA Map stores key-value pairs (or entries); keys are unique, but different keys can be paired with equal values. The Map interface provides specific functions, such as access to value by key, searching keys and values, and so on."}, {"type": "a", "text": "Map<K, V>"}, {"type": "code", "text": "Map<K, V>"}, {"type": "code", "text": "Collection"}, {"type": "code", "text": "Map"}, {"type": "em", "text": "key-value"}, {"type": "em", "text": "entries"}, {"type": "code", "text": "Map"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)\n    \n    println(\"All keys: ${numbersMap.keys}\")\n    println(\"All values: ${numbersMap.values}\")\n    if (\"key2\" in numbersMap) println(\"Value by key \\\"key2\\\": ${numbersMap[\"key2\"]}\")    \n    if (1 in numbersMap.values) println(\"The value 1 is in the map\")\n    if (numbersMap.containsValue(1)) println(\"The value 1 is in the map\") // same as previous\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)\n    \n    println(\"All keys: ${numbersMap.keys}\")\n    println(\"All values: ${numbersMap.values}\")\n    if (\"key2\" in numbersMap) println(\"Value by key \\\"key2\\\": ${numbersMap[\"key2\"]}\")    \n    if (1 in numbersMap.values) println(\"The value 1 is in the map\")\n    if (numbersMap.containsValue(1)) println(\"The value 1 is in the map\") // same as previous\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)\n    \n    println(\"All keys: ${numbersMap.keys}\")\n    println(\"All values: ${numbersMap.values}\")\n    if (\"key2\" in numbersMap) println(\"Value by key \\\"key2\\\": ${numbersMap[\"key2\"]}\")    \n    if (1 in numbersMap.values) println(\"The value 1 is in the map\")\n    if (numbersMap.containsValue(1)) println(\"The value 1 is in the map\") // same as previous\n//sampleEnd\n}\n"}, {"type": "p", "text": "Two maps containing the equal pairs are equal regardless of the pair order."}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)    \n    val anotherMap = mapOf(\"key2\" to 2, \"key1\" to 1, \"key4\" to 1, \"key3\" to 3)\n    \n    println(\"The maps are equal: ${numbersMap == anotherMap}\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)    \n    val anotherMap = mapOf(\"key2\" to 2, \"key1\" to 1, \"key4\" to 1, \"key3\" to 3)\n    \n    println(\"The maps are equal: ${numbersMap == anotherMap}\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)    \n    val anotherMap = mapOf(\"key2\" to 2, \"key1\" to 1, \"key4\" to 1, \"key3\" to 3)\n    \n    println(\"The maps are equal: ${numbersMap == anotherMap}\")\n//sampleEnd\n}\n"}, {"type": "p", "text": "MutableMap is a Map with map write operations, for example, you can add a new key-value pair or update the value associated with the given key."}, {"type": "a", "text": "MutableMap"}, {"type": "code", "text": "MutableMap"}, {"type": "code", "text": "Map"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap.put(\"three\", 3)\n    numbersMap[\"one\"] = 11\n\n    println(numbersMap)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap.put(\"three\", 3)\n    numbersMap[\"one\"] = 11\n\n    println(numbersMap)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap.put(\"three\", 3)\n    numbersMap[\"one\"] = 11\n\n    println(numbersMap)\n//sampleEnd\n}\n"}, {"type": "p", "text": "The default implementation of Map \u2013 LinkedHashMap \u2013 preserves the order of elements insertion when iterating the map.\nIn turn, an alternative implementation \u2013 HashMap \u2013 says nothing about the elements order."}, {"type": "code", "text": "Map"}, {"type": "a", "text": "LinkedHashMap"}, {"type": "code", "text": "LinkedHashMap"}, {"type": "a", "text": "HashMap"}, {"type": "code", "text": "HashMap"}]