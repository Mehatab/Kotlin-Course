[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Basic Types"}, {"type": "p", "text": "In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable.\nSome of the types can have a special internal representation - for example, numbers, characters and booleans can be\nrepresented as primitive values at runtime - but to the user they look like ordinary classes. \nIn this section we describe the basic types used in Kotlin: numbers, characters, booleans, arrays, and strings."}, {"type": "h2", "text": "Numbers"}, {"type": "p", "text": "Kotlin provides a set of built-in types that represent numbers.\nFor integer numbers, there are four types with different sizes and, hence, value ranges."}, {"type": "br", "text": ""}, {"type": "table", "text": "\n\n\nType\nSize (bits)\nMin value\nMax value\n\n\n\n\nByte\n8\n-128\n127\n\n\nShort\n16\n-32768\n32767\n\n\nInt\n32\n-2,147,483,648 (-231)\n2,147,483,647 (231 - 1)\n\n\nLong\n64\n-9,223,372,036,854,775,808 (-263)\n9,223,372,036,854,775,807 (263 - 1)\n\n\n"}, {"type": "thead", "text": "\n\nType\nSize (bits)\nMin value\nMax value\n\n"}, {"type": "tr", "text": "\nType\nSize (bits)\nMin value\nMax value\n"}, {"type": "th", "text": "Type"}, {"type": "th", "text": "Size (bits)"}, {"type": "th", "text": "Min value"}, {"type": "th", "text": "Max value"}, {"type": "tbody", "text": "\n\nByte\n8\n-128\n127\n\n\nShort\n16\n-32768\n32767\n\n\nInt\n32\n-2,147,483,648 (-231)\n2,147,483,647 (231 - 1)\n\n\nLong\n64\n-9,223,372,036,854,775,808 (-263)\n9,223,372,036,854,775,807 (263 - 1)\n\n"}, {"type": "tr", "text": "\nByte\n8\n-128\n127\n"}, {"type": "td", "text": "Byte"}, {"type": "td", "text": "8"}, {"type": "td", "text": "-128"}, {"type": "td", "text": "127"}, {"type": "tr", "text": "\nShort\n16\n-32768\n32767\n"}, {"type": "td", "text": "Short"}, {"type": "td", "text": "16"}, {"type": "td", "text": "-32768"}, {"type": "td", "text": "32767"}, {"type": "tr", "text": "\nInt\n32\n-2,147,483,648 (-231)\n2,147,483,647 (231 - 1)\n"}, {"type": "td", "text": "Int"}, {"type": "td", "text": "32"}, {"type": "td", "text": "-2,147,483,648 (-231)"}, {"type": "sup", "text": "31"}, {"type": "td", "text": "2,147,483,647 (231 - 1)"}, {"type": "sup", "text": "31"}, {"type": "tr", "text": "\nLong\n64\n-9,223,372,036,854,775,808 (-263)\n9,223,372,036,854,775,807 (263 - 1)\n"}, {"type": "td", "text": "Long"}, {"type": "td", "text": "64"}, {"type": "td", "text": "-9,223,372,036,854,775,808 (-263)"}, {"type": "sup", "text": "63"}, {"type": "td", "text": "9,223,372,036,854,775,807 (263 - 1)"}, {"type": "sup", "text": "63"}, {"type": "p", "text": "All variables initialized with integer values not exceeding the maximum value of Int\nhave the inferred type Int. If the initial value exceeds this value, then the type is Long.\nTo specify the Long value explicitly, append the suffix L to the value."}, {"type": "code", "text": "Int"}, {"type": "code", "text": "Int"}, {"type": "code", "text": "Long"}, {"type": "code", "text": "Long"}, {"type": "code", "text": "L"}, {"type": "div", "text": "\nval one = 1 // Int\nval threeBillion = 3000000000 // Long\nval oneLong = 1L // Long\nval oneByte: Byte = 1\n\n"}, {"type": "pre", "text": "val one = 1 // Int\nval threeBillion = 3000000000 // Long\nval oneLong = 1L // Long\nval oneByte: Byte = 1\n"}, {"type": "code", "text": "val one = 1 // Int\nval threeBillion = 3000000000 // Long\nval oneLong = 1L // Long\nval oneByte: Byte = 1\n"}, {"type": "p", "text": "For floating-point numbers, Kotlin provides types Float and Double.\nAccording to the IEEE 754 standard,\nfloating point types differ by their decimal place, that is, how many decimal digits they can store.\nFloat reflects the IEEE 754 single precision, while Double provides double precision."}, {"type": "code", "text": "Float"}, {"type": "code", "text": "Double"}, {"type": "a", "text": "IEEE 754 standard"}, {"type": "em", "text": "decimal place"}, {"type": "code", "text": "Float"}, {"type": "em", "text": "single precision"}, {"type": "code", "text": "Double"}, {"type": "em", "text": "double precision"}, {"type": "table", "text": "\n\n\nType\nSize (bits)\nSignificant bits\nExponent bits\nDecimal digits\n\n\n\n\nFloat\n32\n24\n8\n6-7\n\n\nDouble\n64\n53\n11\n15-16\n\n\n"}, {"type": "thead", "text": "\n\nType\nSize (bits)\nSignificant bits\nExponent bits\nDecimal digits\n\n"}, {"type": "tr", "text": "\nType\nSize (bits)\nSignificant bits\nExponent bits\nDecimal digits\n"}, {"type": "th", "text": "Type"}, {"type": "th", "text": "Size (bits)"}, {"type": "th", "text": "Significant bits"}, {"type": "th", "text": "Exponent bits"}, {"type": "th", "text": "Decimal digits"}, {"type": "tbody", "text": "\n\nFloat\n32\n24\n8\n6-7\n\n\nDouble\n64\n53\n11\n15-16\n\n"}, {"type": "tr", "text": "\nFloat\n32\n24\n8\n6-7\n"}, {"type": "td", "text": "Float"}, {"type": "td", "text": "32"}, {"type": "td", "text": "24"}, {"type": "td", "text": "8"}, {"type": "td", "text": "6-7"}, {"type": "tr", "text": "\nDouble\n64\n53\n11\n15-16\n"}, {"type": "td", "text": "Double"}, {"type": "td", "text": "64"}, {"type": "td", "text": "53"}, {"type": "td", "text": "11"}, {"type": "td", "text": "15-16"}, {"type": "p", "text": "For variables initialized with fractional numbers, the compiler infers the Double type.\nTo explicitly specify the Float type for a value, add the suffix f or F.\nIf such a value contains more than 6-7 decimal digits, it will be rounded."}, {"type": "code", "text": "Double"}, {"type": "code", "text": "Float"}, {"type": "code", "text": "f"}, {"type": "code", "text": "F"}, {"type": "div", "text": "\nval pi = 3.14 // Double\nval e = 2.7182818284 // Double\nval eFloat = 2.7182818284f // Float, actual value is 2.7182817\n\n"}, {"type": "pre", "text": "val pi = 3.14 // Double\nval e = 2.7182818284 // Double\nval eFloat = 2.7182818284f // Float, actual value is 2.7182817\n"}, {"type": "code", "text": "val pi = 3.14 // Double\nval e = 2.7182818284 // Double\nval eFloat = 2.7182818284f // Float, actual value is 2.7182817\n"}, {"type": "p", "text": "Note that unlike some other languages, there are no implicit widening conversions for numbers in Kotlin.\nFor example, a function with a Double parameter can be called only on Double values, but not Float, \nInt, or other numeric values."}, {"type": "code", "text": "Double"}, {"type": "code", "text": "Double"}, {"type": "code", "text": "Float"}, {"type": "code", "text": "Int"}, {"type": "div", "text": "\nfun main() {\n    fun printDouble(d: Double) { print(d) }\n\n    val i = 1    \n    val d = 1.1\n    val f = 1.1f \n\n    printDouble(d)\n//    printDouble(i) // Error: Type mismatch\n//    printDouble(f) // Error: Type mismatch\n}\n\n"}, {"type": "pre", "text": "fun main() {\n    fun printDouble(d: Double) { print(d) }\n\n    val i = 1    \n    val d = 1.1\n    val f = 1.1f \n\n    printDouble(d)\n//    printDouble(i) // Error: Type mismatch\n//    printDouble(f) // Error: Type mismatch\n}\n"}, {"type": "code", "text": "fun main() {\n    fun printDouble(d: Double) { print(d) }\n\n    val i = 1    \n    val d = 1.1\n    val f = 1.1f \n\n    printDouble(d)\n//    printDouble(i) // Error: Type mismatch\n//    printDouble(f) // Error: Type mismatch\n}\n"}, {"type": "p", "text": "To convert numeric values to different types, use Explicit conversions."}, {"type": "a", "text": "Explicit conversions"}, {"type": "h3", "text": "Literal constants"}, {"type": "p", "text": "There are the following kinds of literal constants for integral values:"}, {"type": "ul", "text": "\nDecimals: 123\n\nLongs are tagged by a capital L: 123L\n\n\nHexadecimals: 0x0F\nBinaries: 0b00001011\n"}, {"type": "li", "text": "Decimals: 123\n\nLongs are tagged by a capital L: 123L\n\n"}, {"type": "code", "text": "123"}, {"type": "ul", "text": "\nLongs are tagged by a capital L: 123L\n"}, {"type": "li", "text": "Longs are tagged by a capital L: 123L"}, {"type": "code", "text": "L"}, {"type": "code", "text": "123L"}, {"type": "li", "text": "Hexadecimals: 0x0F"}, {"type": "code", "text": "0x0F"}, {"type": "li", "text": "Binaries: 0b00001011"}, {"type": "code", "text": "0b00001011"}, {"type": "p", "text": "NOTE: Octal literals are not supported."}, {"type": "p", "text": "Kotlin also supports a conventional notation for floating-point numbers:"}, {"type": "ul", "text": "\nDoubles by default: 123.5, 123.5e10\nFloats are tagged by f or F: 123.5f\n"}, {"type": "li", "text": "Doubles by default: 123.5, 123.5e10"}, {"type": "code", "text": "123.5"}, {"type": "code", "text": "123.5e10"}, {"type": "li", "text": "Floats are tagged by f or F: 123.5f"}, {"type": "code", "text": "f"}, {"type": "code", "text": "F"}, {"type": "code", "text": "123.5f"}, {"type": "h3", "text": "Underscores in numeric literals (since 1.1)"}, {"type": "p", "text": "You can use underscores to make number constants more readable:"}, {"type": "div", "text": "\nval oneMillion = 1_000_000\nval creditCardNumber = 1234_5678_9012_3456L\nval socialSecurityNumber = 999_99_9999L\nval hexBytes = 0xFF_EC_DE_5E\nval bytes = 0b11010010_01101001_10010100_10010010\n\n"}, {"type": "pre", "text": "val oneMillion = 1_000_000\nval creditCardNumber = 1234_5678_9012_3456L\nval socialSecurityNumber = 999_99_9999L\nval hexBytes = 0xFF_EC_DE_5E\nval bytes = 0b11010010_01101001_10010100_10010010\n"}, {"type": "code", "text": "val oneMillion = 1_000_000\nval creditCardNumber = 1234_5678_9012_3456L\nval socialSecurityNumber = 999_99_9999L\nval hexBytes = 0xFF_EC_DE_5E\nval bytes = 0b11010010_01101001_10010100_10010010\n"}, {"type": "h3", "text": "Representation"}, {"type": "p", "text": "On the Java platform, numbers are physically stored as JVM primitive types, unless we need a nullable number reference (e.g. Int?) or generics are involved. \nIn the latter cases numbers are boxed."}, {"type": "code", "text": "Int?"}, {"type": "p", "text": "Note that boxing of numbers does not necessarily preserve identity:"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val a: Int = 10000\n    println(a === a) // Prints 'true'\n    val boxedA: Int? = a\n    val anotherBoxedA: Int? = a\n    println(boxedA === anotherBoxedA) // !!!Prints 'false'!!!\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val a: Int = 10000\n    println(a === a) // Prints 'true'\n    val boxedA: Int? = a\n    val anotherBoxedA: Int? = a\n    println(boxedA === anotherBoxedA) // !!!Prints 'false'!!!\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val a: Int = 10000\n    println(a === a) // Prints 'true'\n    val boxedA: Int? = a\n    val anotherBoxedA: Int? = a\n    println(boxedA === anotherBoxedA) // !!!Prints 'false'!!!\n//sampleEnd\n}\n"}, {"type": "p", "text": "On the other hand, it preserves equality:"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val a: Int = 10000\n    println(a == a) // Prints 'true'\n    val boxedA: Int? = a\n    val anotherBoxedA: Int? = a\n    println(boxedA == anotherBoxedA) // Prints 'true'\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val a: Int = 10000\n    println(a == a) // Prints 'true'\n    val boxedA: Int? = a\n    val anotherBoxedA: Int? = a\n    println(boxedA == anotherBoxedA) // Prints 'true'\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val a: Int = 10000\n    println(a == a) // Prints 'true'\n    val boxedA: Int? = a\n    val anotherBoxedA: Int? = a\n    println(boxedA == anotherBoxedA) // Prints 'true'\n//sampleEnd\n}\n"}, {"type": "h3", "text": "Explicit conversions"}, {"type": "p", "text": "Due to different representations, smaller types are not subtypes of bigger ones.\nIf they were, we would have troubles of the following sort:"}, {"type": "div", "text": "\n// Hypothetical code, does not actually compile:\nval a: Int? = 1 // A boxed Int (java.lang.Integer)\nval b: Long? = a // implicit conversion yields a boxed Long (java.lang.Long)\nprint(b == a) // Surprise! This prints \"false\" as Long's equals() checks whether the other is Long as well\n\n"}, {"type": "pre", "text": "// Hypothetical code, does not actually compile:\nval a: Int? = 1 // A boxed Int (java.lang.Integer)\nval b: Long? = a // implicit conversion yields a boxed Long (java.lang.Long)\nprint(b == a) // Surprise! This prints \"false\" as Long's equals() checks whether the other is Long as well\n"}, {"type": "code", "text": "// Hypothetical code, does not actually compile:\nval a: Int? = 1 // A boxed Int (java.lang.Integer)\nval b: Long? = a // implicit conversion yields a boxed Long (java.lang.Long)\nprint(b == a) // Surprise! This prints \"false\" as Long's equals() checks whether the other is Long as well\n"}, {"type": "p", "text": "So equality would have been lost silently all over the place, not to mention identity."}, {"type": "p", "text": "As a consequence, smaller types are NOT implicitly converted to bigger types.\nThis means that we cannot assign a value of type Byte to an Int variable without an explicit conversion"}, {"type": "code", "text": "Byte"}, {"type": "code", "text": "Int"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val b: Byte = 1 // OK, literals are checked statically\n    val i: Int = b // ERROR\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val b: Byte = 1 // OK, literals are checked statically\n    val i: Int = b // ERROR\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val b: Byte = 1 // OK, literals are checked statically\n    val i: Int = b // ERROR\n//sampleEnd\n}\n"}, {"type": "p", "text": "We can use explicit conversions to widen numbers"}, {"type": "div", "text": "\nfun main() {\n    val b: Byte = 1\n//sampleStart\n    val i: Int = b.toInt() // OK: explicitly widened\n    print(i)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n    val b: Byte = 1\n//sampleStart\n    val i: Int = b.toInt() // OK: explicitly widened\n    print(i)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n    val b: Byte = 1\n//sampleStart\n    val i: Int = b.toInt() // OK: explicitly widened\n    print(i)\n//sampleEnd\n}\n"}, {"type": "p", "text": "Every number type supports the following conversions:"}, {"type": "ul", "text": "\ntoByte(): Byte\ntoShort(): Short\ntoInt(): Int\ntoLong(): Long\ntoFloat(): Float\ntoDouble(): Double\ntoChar(): Char\n"}, {"type": "li", "text": "toByte(): Byte"}, {"type": "code", "text": "toByte(): Byte"}, {"type": "li", "text": "toShort(): Short"}, {"type": "code", "text": "toShort(): Short"}, {"type": "li", "text": "toInt(): Int"}, {"type": "code", "text": "toInt(): Int"}, {"type": "li", "text": "toLong(): Long"}, {"type": "code", "text": "toLong(): Long"}, {"type": "li", "text": "toFloat(): Float"}, {"type": "code", "text": "toFloat(): Float"}, {"type": "li", "text": "toDouble(): Double"}, {"type": "code", "text": "toDouble(): Double"}, {"type": "li", "text": "toChar(): Char"}, {"type": "code", "text": "toChar(): Char"}, {"type": "p", "text": "Absence of implicit conversions is rarely noticeable because the type is inferred from the context, and arithmetical operations are overloaded for appropriate conversions, for example"}, {"type": "div", "text": "\nval l = 1L + 3 // Long + Int => Long\n\n"}, {"type": "pre", "text": "val l = 1L + 3 // Long + Int => Long\n"}, {"type": "code", "text": "val l = 1L + 3 // Long + Int => Long\n"}, {"type": "h3", "text": "Operations"}, {"type": "p", "text": "Kotlin supports the standard set of arithmetical operations over numbers (+ - * / %), which are declared \nas members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions).\nSee Operator overloading."}, {"type": "code", "text": "+"}, {"type": "code", "text": "-"}, {"type": "code", "text": "*"}, {"type": "code", "text": "/"}, {"type": "code", "text": "%"}, {"type": "a", "text": "Operator overloading"}, {"type": "h4", "text": "Division of integers"}, {"type": "p", "text": "Note that division between integers always returns an integer. Any fractional part is discarded. For example:"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val x = 5 / 2\n    //println(x == 2.5) // ERROR: Operator '==' cannot be applied to 'Int' and 'Double'\n    println(x == 2)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val x = 5 / 2\n    //println(x == 2.5) // ERROR: Operator '==' cannot be applied to 'Int' and 'Double'\n    println(x == 2)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val x = 5 / 2\n    //println(x == 2.5) // ERROR: Operator '==' cannot be applied to 'Int' and 'Double'\n    println(x == 2)\n//sampleEnd\n}\n"}, {"type": "p", "text": "This is true for a division between any two integer types."}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val x = 5L / 2\n    println(x == 2L)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val x = 5L / 2\n    println(x == 2L)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val x = 5L / 2\n    println(x == 2L)\n//sampleEnd\n}\n"}, {"type": "p", "text": "To return a floating-point type, explicitly convert one of the arguments to a floating-point type."}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val x = 5 / 2.toDouble()\n    println(x == 2.5)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val x = 5 / 2.toDouble()\n    println(x == 2.5)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val x = 5 / 2.toDouble()\n    println(x == 2.5)\n//sampleEnd\n}\n"}, {"type": "h4", "text": "Bitwise operations"}, {"type": "p", "text": "As for bitwise operations, there're no special characters for them, but just named functions that can be called in infix form, for example:"}, {"type": "div", "text": "\nval x = (1 shl 2) and 0x000FF000\n\n"}, {"type": "pre", "text": "val x = (1 shl 2) and 0x000FF000\n"}, {"type": "code", "text": "val x = (1 shl 2) and 0x000FF000\n"}, {"type": "p", "text": "Here is the complete list of bitwise operations (available for Int and Long only):"}, {"type": "code", "text": "Int"}, {"type": "code", "text": "Long"}, {"type": "ul", "text": "\nshl(bits) \u2013 signed shift left\nshr(bits) \u2013 signed shift right\nushr(bits) \u2013 unsigned shift right\nand(bits) \u2013 bitwise and\nor(bits) \u2013 bitwise or\nxor(bits) \u2013 bitwise xor\ninv() \u2013 bitwise inversion\n"}, {"type": "li", "text": "shl(bits) \u2013 signed shift left"}, {"type": "code", "text": "shl(bits)"}, {"type": "li", "text": "shr(bits) \u2013 signed shift right"}, {"type": "code", "text": "shr(bits)"}, {"type": "li", "text": "ushr(bits) \u2013 unsigned shift right"}, {"type": "code", "text": "ushr(bits)"}, {"type": "li", "text": "and(bits) \u2013 bitwise and"}, {"type": "code", "text": "and(bits)"}, {"type": "strong", "text": "and"}, {"type": "li", "text": "or(bits) \u2013 bitwise or"}, {"type": "code", "text": "or(bits)"}, {"type": "strong", "text": "or"}, {"type": "li", "text": "xor(bits) \u2013 bitwise xor"}, {"type": "code", "text": "xor(bits)"}, {"type": "strong", "text": "xor"}, {"type": "li", "text": "inv() \u2013 bitwise inversion"}, {"type": "code", "text": "inv()"}, {"type": "h3", "text": "Floating point numbers comparison"}, {"type": "p", "text": "The operations on floating point numbers discussed in this section are:"}, {"type": "ul", "text": "\nEquality checks: a == b and a != b\nComparison operators: a < b, a > b, a <= b, a >= b\nRange instantiation and range checks: a..b, x in a..b, x !in a..b\n"}, {"type": "li", "text": "Equality checks: a == b and a != b"}, {"type": "code", "text": "a == b"}, {"type": "code", "text": "a != b"}, {"type": "li", "text": "Comparison operators: a < b, a > b, a <= b, a >= b"}, {"type": "code", "text": "a < b"}, {"type": "code", "text": "a > b"}, {"type": "code", "text": "a <= b"}, {"type": "code", "text": "a >= b"}, {"type": "li", "text": "Range instantiation and range checks: a..b, x in a..b, x !in a..b"}, {"type": "code", "text": "a..b"}, {"type": "code", "text": "x in a..b"}, {"type": "code", "text": "x !in a..b"}, {"type": "p", "text": "When the operands a and b are statically known to be Float or Double or their nullable counterparts (the type is \ndeclared or inferred or is a result of a smart cast), the operations on the \nnumbers and the range that they form follow the IEEE 754 Standard for Floating-Point Arithmetic."}, {"type": "code", "text": "a"}, {"type": "code", "text": "b"}, {"type": "code", "text": "Float"}, {"type": "code", "text": "Double"}, {"type": "a", "text": "smart cast"}, {"type": "p", "text": "However, to support generic use cases and provide total ordering, when the operands are not statically typed as \nfloating point numbers (e.g. Any, Comparable<...>, a type parameter), the operations use the \nequals and compareTo implementations for Float and Double, which disagree with the standard, so that:"}, {"type": "strong", "text": "not"}, {"type": "code", "text": "Any"}, {"type": "code", "text": "Comparable<...>"}, {"type": "code", "text": "equals"}, {"type": "code", "text": "compareTo"}, {"type": "code", "text": "Float"}, {"type": "code", "text": "Double"}, {"type": "ul", "text": "\nNaN is considered equal to itself\nNaN is considered greater than any other element including POSITIVE_INFINITY\n-0.0 is considered less than 0.0\n"}, {"type": "li", "text": "NaN is considered equal to itself"}, {"type": "code", "text": "NaN"}, {"type": "li", "text": "NaN is considered greater than any other element including POSITIVE_INFINITY"}, {"type": "code", "text": "NaN"}, {"type": "code", "text": "POSITIVE_INFINITY"}, {"type": "li", "text": "-0.0 is considered less than 0.0"}, {"type": "code", "text": "-0.0"}, {"type": "code", "text": "0.0"}, {"type": "h2", "text": "Characters"}, {"type": "p", "text": "Characters are represented by the type Char. They can not be treated directly as numbers"}, {"type": "code", "text": "Char"}, {"type": "div", "text": "\nfun check(c: Char) {\n    if (c == 1) { // ERROR: incompatible types\n        // ...\n    }\n}\n\n"}, {"type": "pre", "text": "fun check(c: Char) {\n    if (c == 1) { // ERROR: incompatible types\n        // ...\n    }\n}\n"}, {"type": "code", "text": "fun check(c: Char) {\n    if (c == 1) { // ERROR: incompatible types\n        // ...\n    }\n}\n"}, {"type": "p", "text": "Character literals go in single quotes: '1'.\nSpecial characters can be escaped using a backslash.\nThe following escape sequences are supported: \\t, \\b, \\n, \\r, \\', \\\", \\\\ and \\$.\nTo encode any other character, use the Unicode escape sequence syntax: '\\uFF00'."}, {"type": "code", "text": "'1'"}, {"type": "code", "text": "\\t"}, {"type": "code", "text": "\\b"}, {"type": "code", "text": "\\n"}, {"type": "code", "text": "\\r"}, {"type": "code", "text": "\\'"}, {"type": "code", "text": "\\\""}, {"type": "code", "text": "\\\\"}, {"type": "code", "text": "\\$"}, {"type": "code", "text": "'\\uFF00'"}, {"type": "p", "text": "We can explicitly convert a character to an Int number:"}, {"type": "code", "text": "Int"}, {"type": "div", "text": "\nfun decimalDigitValue(c: Char): Int {\n    if (c !in '0'..'9')\n        throw IllegalArgumentException(\"Out of range\")\n    return c.toInt() - '0'.toInt() // Explicit conversions to numbers\n}\n\n"}, {"type": "pre", "text": "fun decimalDigitValue(c: Char): Int {\n    if (c !in '0'..'9')\n        throw IllegalArgumentException(\"Out of range\")\n    return c.toInt() - '0'.toInt() // Explicit conversions to numbers\n}\n"}, {"type": "code", "text": "fun decimalDigitValue(c: Char): Int {\n    if (c !in '0'..'9')\n        throw IllegalArgumentException(\"Out of range\")\n    return c.toInt() - '0'.toInt() // Explicit conversions to numbers\n}\n"}, {"type": "p", "text": "Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation."}, {"type": "h2", "text": "Booleans"}, {"type": "p", "text": "The type Boolean represents booleans, and has two values: true and false."}, {"type": "code", "text": "Boolean"}, {"type": "em", "text": "true"}, {"type": "em", "text": "false"}, {"type": "p", "text": "Booleans are boxed if a nullable reference is needed."}, {"type": "p", "text": "Built-in operations on booleans include"}, {"type": "ul", "text": "\n|| \u2013 lazy disjunction\n&& \u2013 lazy conjunction\n! - negation\n"}, {"type": "li", "text": "|| \u2013 lazy disjunction"}, {"type": "code", "text": "||"}, {"type": "li", "text": "&& \u2013 lazy conjunction"}, {"type": "code", "text": "&&"}, {"type": "li", "text": "! - negation"}, {"type": "code", "text": "!"}, {"type": "h2", "text": "Arrays"}, {"type": "p", "text": "Arrays in Kotlin are represented by the Array class, that has get and set functions (that turn into [] by operator overloading conventions), and size property, along with a few other useful member functions:"}, {"type": "code", "text": "Array"}, {"type": "code", "text": "get"}, {"type": "code", "text": "set"}, {"type": "code", "text": "[]"}, {"type": "code", "text": "size"}, {"type": "div", "text": "\nclass Array<T> private constructor() {\n    val size: Int\n    operator fun get(index: Int): T\n    operator fun set(index: Int, value: T): Unit\n\n    operator fun iterator(): Iterator<T>\n    // ...\n}\n\n"}, {"type": "pre", "text": "class Array<T> private constructor() {\n    val size: Int\n    operator fun get(index: Int): T\n    operator fun set(index: Int, value: T): Unit\n\n    operator fun iterator(): Iterator<T>\n    // ...\n}\n"}, {"type": "code", "text": "class Array<T> private constructor() {\n    val size: Int\n    operator fun get(index: Int): T\n    operator fun set(index: Int, value: T): Unit\n\n    operator fun iterator(): Iterator<T>\n    // ...\n}\n"}, {"type": "p", "text": "To create an array, we can use a library function arrayOf() and pass the item values to it, so that arrayOf(1, 2, 3) creates an array [1, 2, 3].\nAlternatively, the arrayOfNulls() library function can be used to create an array of a given size filled with null elements."}, {"type": "code", "text": "arrayOf()"}, {"type": "code", "text": "arrayOf(1, 2, 3)"}, {"type": "code", "text": "[1, 2, 3]"}, {"type": "code", "text": "arrayOfNulls()"}, {"type": "p", "text": "Another option is to use the Array constructor that takes the array size and the function that can return the initial value\nof each array element given its index:"}, {"type": "code", "text": "Array"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    // Creates an Array<String> with values [\"0\", \"1\", \"4\", \"9\", \"16\"]\n    val asc = Array(5) { i -> (i * i).toString() }\n    asc.forEach { println(it) }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    // Creates an Array<String> with values [\"0\", \"1\", \"4\", \"9\", \"16\"]\n    val asc = Array(5) { i -> (i * i).toString() }\n    asc.forEach { println(it) }\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    // Creates an Array<String> with values [\"0\", \"1\", \"4\", \"9\", \"16\"]\n    val asc = Array(5) { i -> (i * i).toString() }\n    asc.forEach { println(it) }\n//sampleEnd\n}\n"}, {"type": "p", "text": "As we said above, the [] operation stands for calls to member functions get() and set()."}, {"type": "code", "text": "[]"}, {"type": "code", "text": "get()"}, {"type": "code", "text": "set()"}, {"type": "p", "text": "Arrays in Kotlin are invariant. This means that Kotlin does not let us assign an Array<String>\nto an Array<Any>, which prevents a possible runtime failure (but you can use Array<out Any>, \nsee Type Projections)."}, {"type": "em", "text": "invariant"}, {"type": "code", "text": "Array<String>"}, {"type": "code", "text": "Array<Any>"}, {"type": "code", "text": "Array<out Any>"}, {"type": "a", "text": "Type Projections"}, {"type": "h3", "text": "Primitive type arrays"}, {"type": "p", "text": "Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: ByteArray,\nShortArray, IntArray and so on. These classes have no inheritance relation to the Array class, but they\nhave the same set of methods and properties. Each of them also has a corresponding factory function:"}, {"type": "code", "text": "ByteArray"}, {"type": "code", "text": "ShortArray"}, {"type": "code", "text": "IntArray"}, {"type": "code", "text": "Array"}, {"type": "div", "text": "\nval x: IntArray = intArrayOf(1, 2, 3)\nx[0] = x[1] + x[2]\n\n"}, {"type": "pre", "text": "val x: IntArray = intArrayOf(1, 2, 3)\nx[0] = x[1] + x[2]\n"}, {"type": "code", "text": "val x: IntArray = intArrayOf(1, 2, 3)\nx[0] = x[1] + x[2]\n"}, {"type": "div", "text": "\n// Array of int of size 5 with values [0, 0, 0, 0, 0]\nval arr = IntArray(5)\n\n// e.g. initialise the values in the array with a constant\n// Array of int of size 5 with values [42, 42, 42, 42, 42]\nval arr = IntArray(5) { 42 }\n\n// e.g. initialise the values in the array using a lambda\n// Array of int of size 5 with values [0, 1, 2, 3, 4] (values initialised to their index value)\nvar arr = IntArray(5) { it * 1 } \n\n"}, {"type": "pre", "text": "// Array of int of size 5 with values [0, 0, 0, 0, 0]\nval arr = IntArray(5)\n\n// e.g. initialise the values in the array with a constant\n// Array of int of size 5 with values [42, 42, 42, 42, 42]\nval arr = IntArray(5) { 42 }\n\n// e.g. initialise the values in the array using a lambda\n// Array of int of size 5 with values [0, 1, 2, 3, 4] (values initialised to their index value)\nvar arr = IntArray(5) { it * 1 } \n"}, {"type": "code", "text": "// Array of int of size 5 with values [0, 0, 0, 0, 0]\nval arr = IntArray(5)\n\n// e.g. initialise the values in the array with a constant\n// Array of int of size 5 with values [42, 42, 42, 42, 42]\nval arr = IntArray(5) { 42 }\n\n// e.g. initialise the values in the array using a lambda\n// Array of int of size 5 with values [0, 1, 2, 3, 4] (values initialised to their index value)\nvar arr = IntArray(5) { it * 1 } \n"}, {"type": "h2", "text": "Unsigned integers"}, {"type": "blockquote", "text": "\nUnsigned types are available only since Kotlin 1.3 and currently are experimental. See details below\n"}, {"type": "p", "text": "Unsigned types are available only since Kotlin 1.3 and currently are experimental. See details below"}, {"type": "em", "text": "experimental"}, {"type": "a", "text": "below"}, {"type": "p", "text": "Kotlin introduces following types for unsigned integers:"}, {"type": "ul", "text": "\nkotlin.UByte: an unsigned 8-bit integer, ranges from 0 to 255\nkotlin.UShort: an unsigned 16-bit integer, ranges from 0 to 65535\nkotlin.UInt: an unsigned 32-bit integer, ranges from 0 to 2^32 - 1\nkotlin.ULong: an unsigned 64-bit integer, ranges from 0 to 2^64 - 1\n"}, {"type": "li", "text": "kotlin.UByte: an unsigned 8-bit integer, ranges from 0 to 255"}, {"type": "code", "text": "kotlin.UByte"}, {"type": "li", "text": "kotlin.UShort: an unsigned 16-bit integer, ranges from 0 to 65535"}, {"type": "code", "text": "kotlin.UShort"}, {"type": "li", "text": "kotlin.UInt: an unsigned 32-bit integer, ranges from 0 to 2^32 - 1"}, {"type": "code", "text": "kotlin.UInt"}, {"type": "li", "text": "kotlin.ULong: an unsigned 64-bit integer, ranges from 0 to 2^64 - 1"}, {"type": "code", "text": "kotlin.ULong"}, {"type": "p", "text": "Unsigned types support most of the operations of their signed counterparts."}, {"type": "blockquote", "text": "\nNote that changing type from unsigned type to signed counterpart (and vice versa) is a binary incompatible change\n"}, {"type": "p", "text": "Note that changing type from unsigned type to signed counterpart (and vice versa) is a binary incompatible change"}, {"type": "em", "text": "binary incompatible"}, {"type": "p", "text": "Unsigned types are implemented using another experimental feature, namely inline classes."}, {"type": "a", "text": "inline classes"}, {"type": "h3", "text": "Specialized classes"}, {"type": "p", "text": "Same as for primitives, each of unsigned type has corresponding type that represents array, specialized for that unsigned type:"}, {"type": "ul", "text": "\nkotlin.UByteArray: an array of unsigned bytes\nkotlin.UShortArray: an array of unsigned shorts\nkotlin.UIntArray: an array of unsigned ints\nkotlin.ULongArray: an array of unsigned longs\n"}, {"type": "li", "text": "kotlin.UByteArray: an array of unsigned bytes"}, {"type": "code", "text": "kotlin.UByteArray"}, {"type": "li", "text": "kotlin.UShortArray: an array of unsigned shorts"}, {"type": "code", "text": "kotlin.UShortArray"}, {"type": "li", "text": "kotlin.UIntArray: an array of unsigned ints"}, {"type": "code", "text": "kotlin.UIntArray"}, {"type": "li", "text": "kotlin.ULongArray: an array of unsigned longs"}, {"type": "code", "text": "kotlin.ULongArray"}, {"type": "p", "text": "Same as for signed integer arrays, they provide similar API to Array class without boxing overhead."}, {"type": "code", "text": "Array"}, {"type": "p", "text": "Also, ranges and progressions supported for UInt and ULong by classes kotlin.ranges.UIntRange, kotlin.ranges.UIntProgression, kotlin.ranges.ULongRange, kotlin.ranges.ULongProgression"}, {"type": "a", "text": "ranges and progressions"}, {"type": "code", "text": "UInt"}, {"type": "code", "text": "ULong"}, {"type": "code", "text": "kotlin.ranges.UIntRange"}, {"type": "code", "text": "kotlin.ranges.UIntProgression"}, {"type": "code", "text": "kotlin.ranges.ULongRange"}, {"type": "code", "text": "kotlin.ranges.ULongProgression"}, {"type": "h3", "text": "Literals"}, {"type": "p", "text": "To make unsigned integers easier to use, Kotlin provides an ability to tag an integer literal with a suffix indicating a specific unsigned type (similarly to Float/Long):"}, {"type": "ul", "text": "\nsuffixes u and U tag literal as unsigned. Exact type will be determined based on the expected type. If no expected type is provided, UInt or ULong will be chosen based on the size of literal\n"}, {"type": "li", "text": "suffixes u and U tag literal as unsigned. Exact type will be determined based on the expected type. If no expected type is provided, UInt or ULong will be chosen based on the size of literal"}, {"type": "code", "text": "u"}, {"type": "code", "text": "U"}, {"type": "code", "text": "UInt"}, {"type": "code", "text": "ULong"}, {"type": "div", "text": "\nval b: UByte = 1u  // UByte, expected type provided\nval s: UShort = 1u // UShort, expected type provided\nval l: ULong = 1u  // ULong, expected type provided\n\nval a1 = 42u // UInt: no expected type provided, constant fits in UInt\nval a2 = 0xFFFF_FFFF_FFFFu // ULong: no expected type provided, constant doesn't fit in UInt\n\n"}, {"type": "pre", "text": "val b: UByte = 1u  // UByte, expected type provided\nval s: UShort = 1u // UShort, expected type provided\nval l: ULong = 1u  // ULong, expected type provided\n\nval a1 = 42u // UInt: no expected type provided, constant fits in UInt\nval a2 = 0xFFFF_FFFF_FFFFu // ULong: no expected type provided, constant doesn't fit in UInt\n"}, {"type": "code", "text": "val b: UByte = 1u  // UByte, expected type provided\nval s: UShort = 1u // UShort, expected type provided\nval l: ULong = 1u  // ULong, expected type provided\n\nval a1 = 42u // UInt: no expected type provided, constant fits in UInt\nval a2 = 0xFFFF_FFFF_FFFFu // ULong: no expected type provided, constant doesn't fit in UInt\n"}, {"type": "ul", "text": "\nsuffixes uL and UL explicitly tag literal as unsigned long.\n"}, {"type": "li", "text": "suffixes uL and UL explicitly tag literal as unsigned long."}, {"type": "code", "text": "uL"}, {"type": "code", "text": "UL"}, {"type": "div", "text": "\nval a = 1UL // ULong, even though no expected type provided and constant fits into UInt\n\n"}, {"type": "pre", "text": "val a = 1UL // ULong, even though no expected type provided and constant fits into UInt\n"}, {"type": "code", "text": "val a = 1UL // ULong, even though no expected type provided and constant fits into UInt\n"}, {"type": "h3", "text": "Experimental status of unsigned integers"}, {"type": "p", "text": "The design of unsigned types is experimental, meaning that this feature is moving fast and no compatibility guarantees are given. When using unsigned arithmetics in Kotlin 1.3+, warning will be reported, indicating that this feature is experimental. To remove warning, you have to opt-in for experimental usage of unsigned types."}, {"type": "p", "text": "There are two possible ways to opt-in for unsigned types: with marking your API as experimental too, or without doing that."}, {"type": "ul", "text": "\nTo propagate experimentality, annotate declarations that use unsigned integers with @ExperimentalUnsignedTypes.\nTo opt-in without propagating experimentality, either annotate declarations with @OptIn(ExperimentalUnsignedTypes::class) or pass -Xopt-in=kotlin.ExperimentalUnsignedTypes to the compiler.\n"}, {"type": "li", "text": "To propagate experimentality, annotate declarations that use unsigned integers with @ExperimentalUnsignedTypes."}, {"type": "code", "text": "@ExperimentalUnsignedTypes"}, {"type": "li", "text": "To opt-in without propagating experimentality, either annotate declarations with @OptIn(ExperimentalUnsignedTypes::class) or pass -Xopt-in=kotlin.ExperimentalUnsignedTypes to the compiler."}, {"type": "code", "text": "@OptIn(ExperimentalUnsignedTypes::class)"}, {"type": "code", "text": "-Xopt-in=kotlin.ExperimentalUnsignedTypes"}, {"type": "p", "text": "It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are an experimental feature, so API which uses them can be suddenly broken due to changes in language."}, {"type": "p", "text": "See also or Experimental API KEEP for technical details."}, {"type": "a", "text": "KEEP"}, {"type": "h3", "text": "Further discussion"}, {"type": "p", "text": "See language proposal for unsigned types for technical details and further discussion."}, {"type": "a", "text": "language proposal for unsigned types"}, {"type": "h2", "text": "Strings"}, {"type": "p", "text": "Strings are represented by the type String. Strings are immutable.\nElements of a string are characters that can be accessed by the indexing operation: s[i].\nA string can be iterated over with a for-loop:"}, {"type": "code", "text": "String"}, {"type": "code", "text": "s[i]"}, {"type": "em", "text": "for"}, {"type": "div", "text": "\nfun main() {\nval str = \"abcd\"\n//sampleStart\nfor (c in str) {\n    println(c)\n}\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\nval str = \"abcd\"\n//sampleStart\nfor (c in str) {\n    println(c)\n}\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\nval str = \"abcd\"\n//sampleStart\nfor (c in str) {\n    println(c)\n}\n//sampleEnd\n}\n"}, {"type": "p", "text": "You can concatenate strings using the + operator. This also works for concatenating strings with values of other types, as long\nas the first element in the expression is a string:"}, {"type": "code", "text": "+"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\nval s = \"abc\" + 1\nprintln(s + \"def\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\nval s = \"abc\" + 1\nprintln(s + \"def\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\nval s = \"abc\" + 1\nprintln(s + \"def\")\n//sampleEnd\n}\n"}, {"type": "p", "text": "Note that in most cases using string templates or raw strings is preferable to string concatenation."}, {"type": "a", "text": "string templates"}, {"type": "h3", "text": "String literals"}, {"type": "p", "text": "Kotlin has two types of string literals: escaped strings that may have escaped characters in them\nand raw strings that can contain newlines and arbitrary text. Here's an example of an escaped string:"}, {"type": "div", "text": "\nval s = \"Hello, world!\\n\"\n\n"}, {"type": "pre", "text": "val s = \"Hello, world!\\n\"\n"}, {"type": "code", "text": "val s = \"Hello, world!\\n\"\n"}, {"type": "p", "text": "Escaping is done in the conventional way, with a backslash. See Characters above for the list of supported escape sequences."}, {"type": "a", "text": "Characters"}, {"type": "p", "text": "A raw string is delimited by a triple quote (\"\"\"), contains no escaping and can contain newlines and any other characters:"}, {"type": "code", "text": "\"\"\""}, {"type": "div", "text": "\nval text = \"\"\"\n    for (c in \"foo\")\n        print(c)\n\"\"\"\n\n"}, {"type": "pre", "text": "val text = \"\"\"\n    for (c in \"foo\")\n        print(c)\n\"\"\"\n"}, {"type": "code", "text": "val text = \"\"\"\n    for (c in \"foo\")\n        print(c)\n\"\"\"\n"}, {"type": "p", "text": "You can remove leading whitespace with trimMargin() function:"}, {"type": "a", "text": "trimMargin()"}, {"type": "code", "text": "trimMargin()"}, {"type": "div", "text": "\nval text = \"\"\"\n    |Tell me and I forget.\n    |Teach me and I remember.\n    |Involve me and I learn.\n    |(Benjamin Franklin)\n    \"\"\".trimMargin()\n\n"}, {"type": "pre", "text": "val text = \"\"\"\n    |Tell me and I forget.\n    |Teach me and I remember.\n    |Involve me and I learn.\n    |(Benjamin Franklin)\n    \"\"\".trimMargin()\n"}, {"type": "code", "text": "val text = \"\"\"\n    |Tell me and I forget.\n    |Teach me and I remember.\n    |Involve me and I learn.\n    |(Benjamin Franklin)\n    \"\"\".trimMargin()\n"}, {"type": "p", "text": "By default | is used as margin prefix, but you can choose another character and pass it as a parameter, like trimMargin(\">\")."}, {"type": "code", "text": "|"}, {"type": "code", "text": "trimMargin(\">\")"}, {"type": "h3", "text": "String templates"}, {"type": "p", "text": "String literals may contain template expressions, i.e. pieces of code that are evaluated and whose results are concatenated into the string.\nA template expression starts with a dollar sign ($) and consists of either a simple name:"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val i = 10\n    println(\"i = $i\") // prints \"i = 10\"\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val i = 10\n    println(\"i = $i\") // prints \"i = 10\"\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val i = 10\n    println(\"i = $i\") // prints \"i = 10\"\n//sampleEnd\n}\n"}, {"type": "p", "text": "or an arbitrary expression in curly braces:"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val s = \"abc\"\n    println(\"$s.length is ${s.length}\") // prints \"abc.length is 3\"\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val s = \"abc\"\n    println(\"$s.length is ${s.length}\") // prints \"abc.length is 3\"\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val s = \"abc\"\n    println(\"$s.length is ${s.length}\") // prints \"abc.length is 3\"\n//sampleEnd\n}\n"}, {"type": "p", "text": "Templates are supported both inside raw strings and inside escaped strings.\nIf you need to represent a literal $ character in a raw string (which doesn't support backslash escaping), you can use the following syntax:"}, {"type": "code", "text": "$"}, {"type": "div", "text": "\nval price = \"\"\"\n${'$'}9.99\n\"\"\"\n\n"}, {"type": "pre", "text": "val price = \"\"\"\n${'$'}9.99\n\"\"\"\n"}, {"type": "code", "text": "val price = \"\"\"\n${'$'}9.99\n\"\"\"\n"}]