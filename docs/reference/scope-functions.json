[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Scope Functions"}, {"type": "p", "text": "The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a lambda expression provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called scope functions. There are five of them: let, run, with, apply, and also."}, {"type": "a", "text": "lambda expression"}, {"type": "em", "text": "scope functions"}, {"type": "code", "text": "let"}, {"type": "code", "text": "run"}, {"type": "code", "text": "with"}, {"type": "code", "text": "apply"}, {"type": "code", "text": "also"}, {"type": "p", "text": "Basically, these functions do the same: execute a block of code on an object. What's different is how this object becomes available inside the block and what is the result of the whole expression."}, {"type": "p", "text": "Here's a typical usage of a scope function:"}, {"type": "div", "text": "\ndata class Person(var name: String, var age: Int, var city: String) {\n    fun moveTo(newCity: String) { city = newCity }\n    fun incrementAge() { age++ }\n}\n\nfun main() {\n//sampleStart\n    Person(\"Alice\", 20, \"Amsterdam\").let {\n        println(it)\n        it.moveTo(\"London\")\n        it.incrementAge()\n        println(it)\n    }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "data class Person(var name: String, var age: Int, var city: String) {\n    fun moveTo(newCity: String) { city = newCity }\n    fun incrementAge() { age++ }\n}\n\nfun main() {\n//sampleStart\n    Person(\"Alice\", 20, \"Amsterdam\").let {\n        println(it)\n        it.moveTo(\"London\")\n        it.incrementAge()\n        println(it)\n    }\n//sampleEnd\n}\n"}, {"type": "code", "text": "data class Person(var name: String, var age: Int, var city: String) {\n    fun moveTo(newCity: String) { city = newCity }\n    fun incrementAge() { age++ }\n}\n\nfun main() {\n//sampleStart\n    Person(\"Alice\", 20, \"Amsterdam\").let {\n        println(it)\n        it.moveTo(\"London\")\n        it.incrementAge()\n        println(it)\n    }\n//sampleEnd\n}\n"}, {"type": "p", "text": "If you write the same without let, you'll have to introduce a new variable and repeat its name whenever you use it."}, {"type": "code", "text": "let"}, {"type": "div", "text": "\ndata class Person(var name: String, var age: Int, var city: String) {\n    fun moveTo(newCity: String) { city = newCity }\n    fun incrementAge() { age++ }\n}\n\nfun main() {\n//sampleStart\n    val alice = Person(\"Alice\", 20, \"Amsterdam\")\n    println(alice)\n    alice.moveTo(\"London\")\n    alice.incrementAge()\n    println(alice)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "data class Person(var name: String, var age: Int, var city: String) {\n    fun moveTo(newCity: String) { city = newCity }\n    fun incrementAge() { age++ }\n}\n\nfun main() {\n//sampleStart\n    val alice = Person(\"Alice\", 20, \"Amsterdam\")\n    println(alice)\n    alice.moveTo(\"London\")\n    alice.incrementAge()\n    println(alice)\n//sampleEnd\n}\n"}, {"type": "code", "text": "data class Person(var name: String, var age: Int, var city: String) {\n    fun moveTo(newCity: String) { city = newCity }\n    fun incrementAge() { age++ }\n}\n\nfun main() {\n//sampleStart\n    val alice = Person(\"Alice\", 20, \"Amsterdam\")\n    println(alice)\n    alice.moveTo(\"London\")\n    alice.incrementAge()\n    println(alice)\n//sampleEnd\n}\n"}, {"type": "p", "text": "The scope functions do not introduce any new technical capabilities, but they can make your code more concise and readable."}, {"type": "p", "text": "Due to the similar nature of scope functions, choosing the right one for your case can be a bit tricky. The choice mainly depends on your intent and the consistency of use in your project. Below we'll provide detailed descriptions of the distinctions between scope functions and the conventions on their usage."}, {"type": "h2", "text": "Distinctions"}, {"type": "p", "text": "Because the scope functions are all quite similar in nature, it's important to understand the differences between them. There are two main differences between each scope function:"}, {"type": "ul", "text": "\nThe way to refer to the context object\nThe return value.\n"}, {"type": "li", "text": "The way to refer to the context object"}, {"type": "li", "text": "The return value."}, {"type": "h3", "text": "Context object: this or it"}, {"type": "code", "text": "this"}, {"type": "code", "text": "it"}, {"type": "p", "text": "Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a lambda receiver (this) or as a lambda argument (it). Both provide the same capabilities, so we'll describe the pros and cons of each for different cases and provide recommendations on their use."}, {"type": "a", "text": "receiver"}, {"type": "code", "text": "this"}, {"type": "code", "text": "it"}, {"type": "div", "text": "\nfun main() {\n    val str = \"Hello\"\n    // this\n    str.run {\n        println(\"The receiver string length: $length\")\n        //println(\"The receiver string length: ${this.length}\") // does the same\n    }\n\n    // it\n    str.let {\n        println(\"The receiver string's length is ${it.length}\")\n    }\n}\n\n"}, {"type": "pre", "text": "fun main() {\n    val str = \"Hello\"\n    // this\n    str.run {\n        println(\"The receiver string length: $length\")\n        //println(\"The receiver string length: ${this.length}\") // does the same\n    }\n\n    // it\n    str.let {\n        println(\"The receiver string's length is ${it.length}\")\n    }\n}\n"}, {"type": "code", "text": "fun main() {\n    val str = \"Hello\"\n    // this\n    str.run {\n        println(\"The receiver string length: $length\")\n        //println(\"The receiver string length: ${this.length}\") // does the same\n    }\n\n    // it\n    str.let {\n        println(\"The receiver string's length is ${it.length}\")\n    }\n}\n"}, {"type": "h4", "text": "this"}, {"type": "p", "text": "run, with, and apply refer to the context object as a lambda receiver - by keyword this. Hence, in their lambdas, the object is available as it would be in ordinary class functions. In most cases, you can omit this when accessing the members of the receiver object, making the code shorter. On the other hand, if this is omitted, it can be hard to distinguish between the receiver members and external objects or functions. So, having the context object as a receiver (this) is recommended for lambdas that mainly operate on the object members: call its functions or assign properties."}, {"type": "code", "text": "run"}, {"type": "code", "text": "with"}, {"type": "code", "text": "apply"}, {"type": "code", "text": "this"}, {"type": "code", "text": "this"}, {"type": "code", "text": "this"}, {"type": "code", "text": "this"}, {"type": "div", "text": "\ndata class Person(var name: String, var age: Int = 0, var city: String = \"\")\n\nfun main() {\n//sampleStart\n    val adam = Person(\"Adam\").apply { \n        age = 20                       // same as this.age = 20 or adam.age = 20\n        city = \"London\"\n    }\n    println(adam)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "data class Person(var name: String, var age: Int = 0, var city: String = \"\")\n\nfun main() {\n//sampleStart\n    val adam = Person(\"Adam\").apply { \n        age = 20                       // same as this.age = 20 or adam.age = 20\n        city = \"London\"\n    }\n    println(adam)\n//sampleEnd\n}\n"}, {"type": "code", "text": "data class Person(var name: String, var age: Int = 0, var city: String = \"\")\n\nfun main() {\n//sampleStart\n    val adam = Person(\"Adam\").apply { \n        age = 20                       // same as this.age = 20 or adam.age = 20\n        city = \"London\"\n    }\n    println(adam)\n//sampleEnd\n}\n"}, {"type": "h4", "text": "it"}, {"type": "p", "text": "In turn, let and also have the context object as a lambda argument. If the argument name is not specified, the object is accessed by the implicit default name it. it is shorter than this and expressions with it are usually easier for reading. However, when calling the object functions or properties you don't have the object available implicitly like this. Hence, having the context object as it is better when the object is mostly used as an argument in function calls. it is also better if you use multiple variables in the code block."}, {"type": "code", "text": "let"}, {"type": "code", "text": "also"}, {"type": "code", "text": "it"}, {"type": "code", "text": "it"}, {"type": "code", "text": "this"}, {"type": "code", "text": "it"}, {"type": "code", "text": "this"}, {"type": "code", "text": "it"}, {"type": "code", "text": "it"}, {"type": "div", "text": "\nimport kotlin.random.Random\n\nfun writeToLog(message: String) {\n    println(\"INFO: $message\")\n}\n\nfun main() {\n//sampleStart\n    fun getRandomInt(): Int {\n        return Random.nextInt(100).also {\n            writeToLog(\"getRandomInt() generated value $it\")\n        }\n    }\n    \n    val i = getRandomInt()\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlin.random.Random\n\nfun writeToLog(message: String) {\n    println(\"INFO: $message\")\n}\n\nfun main() {\n//sampleStart\n    fun getRandomInt(): Int {\n        return Random.nextInt(100).also {\n            writeToLog(\"getRandomInt() generated value $it\")\n        }\n    }\n    \n    val i = getRandomInt()\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlin.random.Random\n\nfun writeToLog(message: String) {\n    println(\"INFO: $message\")\n}\n\nfun main() {\n//sampleStart\n    fun getRandomInt(): Int {\n        return Random.nextInt(100).also {\n            writeToLog(\"getRandomInt() generated value $it\")\n        }\n    }\n    \n    val i = getRandomInt()\n//sampleEnd\n}\n"}, {"type": "p", "text": "Additionally, when you pass the context object as an argument, you can provide a custom name for the context object inside the scope."}, {"type": "div", "text": "\nimport kotlin.random.Random\n\nfun writeToLog(message: String) {\n    println(\"INFO: $message\")\n}\n\nfun main() {\n//sampleStart\n    fun getRandomInt(): Int {\n        return Random.nextInt(100).also { value ->\n            writeToLog(\"getRandomInt() generated value $value\")\n        }\n    }\n    \n    val i = getRandomInt()\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlin.random.Random\n\nfun writeToLog(message: String) {\n    println(\"INFO: $message\")\n}\n\nfun main() {\n//sampleStart\n    fun getRandomInt(): Int {\n        return Random.nextInt(100).also { value ->\n            writeToLog(\"getRandomInt() generated value $value\")\n        }\n    }\n    \n    val i = getRandomInt()\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlin.random.Random\n\nfun writeToLog(message: String) {\n    println(\"INFO: $message\")\n}\n\nfun main() {\n//sampleStart\n    fun getRandomInt(): Int {\n        return Random.nextInt(100).also { value ->\n            writeToLog(\"getRandomInt() generated value $value\")\n        }\n    }\n    \n    val i = getRandomInt()\n//sampleEnd\n}\n"}, {"type": "h3", "text": "Return value"}, {"type": "p", "text": "The scope functions differ by the result they return:"}, {"type": "ul", "text": "\napply and also return the context object.\nlet, run, and with return the lambda result.\n"}, {"type": "li", "text": "apply and also return the context object."}, {"type": "code", "text": "apply"}, {"type": "code", "text": "also"}, {"type": "li", "text": "let, run, and with return the lambda result."}, {"type": "code", "text": "let"}, {"type": "code", "text": "run"}, {"type": "code", "text": "with"}, {"type": "p", "text": "These two options let you choose the proper function depending on what you do next in your code."}, {"type": "h4", "text": "Context object"}, {"type": "p", "text": "The return value of apply and also is the context object itself. Hence, they can be included into call chains as side steps: you can continue chaining function calls on the same object after them."}, {"type": "code", "text": "apply"}, {"type": "code", "text": "also"}, {"type": "em", "text": "side steps"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numberList = mutableListOf<Double>()\n    numberList.also { println(\"Populating the list\") }\n        .apply {\n            add(2.71)\n            add(3.14)\n            add(1.0)\n        }\n        .also { println(\"Sorting the list\") }\n        .sort()\n//sampleEnd\n    println(numberList)\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numberList = mutableListOf<Double>()\n    numberList.also { println(\"Populating the list\") }\n        .apply {\n            add(2.71)\n            add(3.14)\n            add(1.0)\n        }\n        .also { println(\"Sorting the list\") }\n        .sort()\n//sampleEnd\n    println(numberList)\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numberList = mutableListOf<Double>()\n    numberList.also { println(\"Populating the list\") }\n        .apply {\n            add(2.71)\n            add(3.14)\n            add(1.0)\n        }\n        .also { println(\"Sorting the list\") }\n        .sort()\n//sampleEnd\n    println(numberList)\n}\n"}, {"type": "p", "text": "They also can be used in return statements of functions returning the context object."}, {"type": "div", "text": "\nimport kotlin.random.Random\n\nfun writeToLog(message: String) {\n    println(\"INFO: $message\")\n}\n\nfun main() {\n//sampleStart\n    fun getRandomInt(): Int {\n        return Random.nextInt(100).also {\n            writeToLog(\"getRandomInt() generated value $it\")\n        }\n    }\n    \n    val i = getRandomInt()\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlin.random.Random\n\nfun writeToLog(message: String) {\n    println(\"INFO: $message\")\n}\n\nfun main() {\n//sampleStart\n    fun getRandomInt(): Int {\n        return Random.nextInt(100).also {\n            writeToLog(\"getRandomInt() generated value $it\")\n        }\n    }\n    \n    val i = getRandomInt()\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlin.random.Random\n\nfun writeToLog(message: String) {\n    println(\"INFO: $message\")\n}\n\nfun main() {\n//sampleStart\n    fun getRandomInt(): Int {\n        return Random.nextInt(100).also {\n            writeToLog(\"getRandomInt() generated value $it\")\n        }\n    }\n    \n    val i = getRandomInt()\n//sampleEnd\n}\n"}, {"type": "h4", "text": "Lambda result"}, {"type": "p", "text": "let, run, and with return the lambda result. So, you can use them when assigning the result to a variable, chaining operations on the result, and so on."}, {"type": "code", "text": "let"}, {"type": "code", "text": "run"}, {"type": "code", "text": "with"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    val countEndsWithE = numbers.run { \n        add(\"four\")\n        add(\"five\")\n        count { it.endsWith(\"e\") }\n    }\n    println(\"There are $countEndsWithE elements that end with e.\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    val countEndsWithE = numbers.run { \n        add(\"four\")\n        add(\"five\")\n        count { it.endsWith(\"e\") }\n    }\n    println(\"There are $countEndsWithE elements that end with e.\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    val countEndsWithE = numbers.run { \n        add(\"four\")\n        add(\"five\")\n        count { it.endsWith(\"e\") }\n    }\n    println(\"There are $countEndsWithE elements that end with e.\")\n//sampleEnd\n}\n"}, {"type": "p", "text": "Additionally, you can ignore the return value and use a scope function to create a temporary scope for variables."}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    with(numbers) {\n        val firstItem = first()\n        val lastItem = last()        \n        println(\"First item: $firstItem, last item: $lastItem\")\n    }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    with(numbers) {\n        val firstItem = first()\n        val lastItem = last()        \n        println(\"First item: $firstItem, last item: $lastItem\")\n    }\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    with(numbers) {\n        val firstItem = first()\n        val lastItem = last()        \n        println(\"First item: $firstItem, last item: $lastItem\")\n    }\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Functions"}, {"type": "p", "text": "To help you choose the right scope function for your case, we'll describe them in detail and provide usage recommendations. Technically, functions are interchangeable in many cases, so the examples show the conventions that define the common usage style."}, {"type": "h3", "text": "let"}, {"type": "code", "text": "let"}, {"type": "p", "text": "The context object is available as an argument (it). The return value is the lambda result."}, {"type": "strong", "text": "The context object"}, {"type": "code", "text": "it"}, {"type": "strong", "text": "The return value"}, {"type": "p", "text": "let can be used to invoke one or more functions on results of call chains. For example, the following code prints the results of two operations on a collection:"}, {"type": "code", "text": "let"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    val resultList = numbers.map { it.length }.filter { it > 3 }\n    println(resultList)    \n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    val resultList = numbers.map { it.length }.filter { it > 3 }\n    println(resultList)    \n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    val resultList = numbers.map { it.length }.filter { it > 3 }\n    println(resultList)    \n//sampleEnd\n}\n"}, {"type": "p", "text": "With let, you can rewrite it:"}, {"type": "code", "text": "let"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    numbers.map { it.length }.filter { it > 3 }.let { \n        println(it)\n        // and more function calls if needed\n    } \n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    numbers.map { it.length }.filter { it > 3 }.let { \n        println(it)\n        // and more function calls if needed\n    } \n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    numbers.map { it.length }.filter { it > 3 }.let { \n        println(it)\n        // and more function calls if needed\n    } \n//sampleEnd\n}\n"}, {"type": "p", "text": "If the code block contains a single function with it as an argument, you can use the method reference (::) instead of the lambda:"}, {"type": "code", "text": "it"}, {"type": "code", "text": "::"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    numbers.map { it.length }.filter { it > 3 }.let(::println)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    numbers.map { it.length }.filter { it > 3 }.let(::println)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    numbers.map { it.length }.filter { it > 3 }.let(::println)\n//sampleEnd\n}\n"}, {"type": "p", "text": "let is often used for executing a code block only with non-null values. To perform actions on a non-null object, use the safe call operator ?. on it and call let with the actions in its lambda."}, {"type": "code", "text": "let"}, {"type": "code", "text": "?."}, {"type": "code", "text": "let"}, {"type": "div", "text": "\nfun processNonNullString(str: String) {}\n\nfun main() {\n//sampleStart\n    val str: String? = \"Hello\"   \n    //processNonNullString(str)       // compilation error: str can be null\n    val length = str?.let { \n        println(\"let() called on $it\")        \n        processNonNullString(it)      // OK: 'it' is not null inside '?.let { }'\n        it.length\n    }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun processNonNullString(str: String) {}\n\nfun main() {\n//sampleStart\n    val str: String? = \"Hello\"   \n    //processNonNullString(str)       // compilation error: str can be null\n    val length = str?.let { \n        println(\"let() called on $it\")        \n        processNonNullString(it)      // OK: 'it' is not null inside '?.let { }'\n        it.length\n    }\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun processNonNullString(str: String) {}\n\nfun main() {\n//sampleStart\n    val str: String? = \"Hello\"   \n    //processNonNullString(str)       // compilation error: str can be null\n    val length = str?.let { \n        println(\"let() called on $it\")        \n        processNonNullString(it)      // OK: 'it' is not null inside '?.let { }'\n        it.length\n    }\n//sampleEnd\n}\n"}, {"type": "p", "text": "Another case for using let is introducing local variables with a limited scope for improving code readability. To define a new variable for the context object, provide its name as the lambda argument so that it can be used instead of the default it."}, {"type": "code", "text": "let"}, {"type": "code", "text": "it"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val modifiedFirstItem = numbers.first().let { firstItem ->\n        println(\"The first item of the list is '$firstItem'\")\n        if (firstItem.length >= 5) firstItem else \"!\" + firstItem + \"!\"\n    }.toUpperCase()\n    println(\"First item after modifications: '$modifiedFirstItem'\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val modifiedFirstItem = numbers.first().let { firstItem ->\n        println(\"The first item of the list is '$firstItem'\")\n        if (firstItem.length >= 5) firstItem else \"!\" + firstItem + \"!\"\n    }.toUpperCase()\n    println(\"First item after modifications: '$modifiedFirstItem'\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val modifiedFirstItem = numbers.first().let { firstItem ->\n        println(\"The first item of the list is '$firstItem'\")\n        if (firstItem.length >= 5) firstItem else \"!\" + firstItem + \"!\"\n    }.toUpperCase()\n    println(\"First item after modifications: '$modifiedFirstItem'\")\n//sampleEnd\n}\n"}, {"type": "h3", "text": "with"}, {"type": "code", "text": "with"}, {"type": "p", "text": "A non-extension function: the context object is passed as an argument, but inside the lambda, it's available as a receiver (this). The return value is the lambda result."}, {"type": "strong", "text": "the context object"}, {"type": "code", "text": "this"}, {"type": "strong", "text": "The return value"}, {"type": "p", "text": "We recommend with for calling functions on the context object without providing the lambda result. In the code, with can be read as \u201cwith this object, do the following.\u201d"}, {"type": "code", "text": "with"}, {"type": "code", "text": "with"}, {"type": "em", "text": "with this object, do the following."}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    with(numbers) {\n        println(\"'with' is called with argument $this\")\n        println(\"It contains $size elements\")\n    }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    with(numbers) {\n        println(\"'with' is called with argument $this\")\n        println(\"It contains $size elements\")\n    }\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    with(numbers) {\n        println(\"'with' is called with argument $this\")\n        println(\"It contains $size elements\")\n    }\n//sampleEnd\n}\n"}, {"type": "p", "text": "Another use case for with is introducing a helper object whose properties or functions will be used for calculating a value."}, {"type": "code", "text": "with"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    val firstAndLast = with(numbers) {\n        \"The first element is ${first()},\" +\n        \" the last element is ${last()}\"\n    }\n    println(firstAndLast)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    val firstAndLast = with(numbers) {\n        \"The first element is ${first()},\" +\n        \" the last element is ${last()}\"\n    }\n    println(firstAndLast)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    val firstAndLast = with(numbers) {\n        \"The first element is ${first()},\" +\n        \" the last element is ${last()}\"\n    }\n    println(firstAndLast)\n//sampleEnd\n}\n"}, {"type": "h3", "text": "run"}, {"type": "code", "text": "run"}, {"type": "p", "text": "The context object is available as a receiver (this). The return value is the lambda result."}, {"type": "strong", "text": "The context object"}, {"type": "code", "text": "this"}, {"type": "strong", "text": "The return value"}, {"type": "p", "text": "run does the same as with but invokes as let - as an extension function of the context object."}, {"type": "code", "text": "run"}, {"type": "code", "text": "with"}, {"type": "code", "text": "let"}, {"type": "p", "text": "run is useful when your lambda contains both the object initialization and the computation of the return value."}, {"type": "code", "text": "run"}, {"type": "div", "text": "\nclass MultiportService(var url: String, var port: Int) {\n    fun prepareRequest(): String = \"Default request\"\n    fun query(request: String): String = \"Result for query '$request'\"\n}\n\nfun main() {\n//sampleStart\n    val service = MultiportService(\"https://example.kotlinlang.org\", 80)\n\n    val result = service.run {\n        port = 8080\n        query(prepareRequest() + \" to port $port\")\n    }\n    \n    // the same code written with let() function:\n    val letResult = service.let {\n        it.port = 8080\n        it.query(it.prepareRequest() + \" to port ${it.port}\")\n    }\n//sampleEnd\n    println(result)\n    println(letResult)\n}\n\n"}, {"type": "pre", "text": "class MultiportService(var url: String, var port: Int) {\n    fun prepareRequest(): String = \"Default request\"\n    fun query(request: String): String = \"Result for query '$request'\"\n}\n\nfun main() {\n//sampleStart\n    val service = MultiportService(\"https://example.kotlinlang.org\", 80)\n\n    val result = service.run {\n        port = 8080\n        query(prepareRequest() + \" to port $port\")\n    }\n    \n    // the same code written with let() function:\n    val letResult = service.let {\n        it.port = 8080\n        it.query(it.prepareRequest() + \" to port ${it.port}\")\n    }\n//sampleEnd\n    println(result)\n    println(letResult)\n}\n"}, {"type": "code", "text": "class MultiportService(var url: String, var port: Int) {\n    fun prepareRequest(): String = \"Default request\"\n    fun query(request: String): String = \"Result for query '$request'\"\n}\n\nfun main() {\n//sampleStart\n    val service = MultiportService(\"https://example.kotlinlang.org\", 80)\n\n    val result = service.run {\n        port = 8080\n        query(prepareRequest() + \" to port $port\")\n    }\n    \n    // the same code written with let() function:\n    val letResult = service.let {\n        it.port = 8080\n        it.query(it.prepareRequest() + \" to port ${it.port}\")\n    }\n//sampleEnd\n    println(result)\n    println(letResult)\n}\n"}, {"type": "p", "text": "Besides calling run on a receiver object, you can use it as a non-extension function. Non-extension run lets you execute a block of several statements where an expression is required."}, {"type": "code", "text": "run"}, {"type": "code", "text": "run"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val hexNumberRegex = run {\n        val digits = \"0-9\"\n        val hexDigits = \"A-Fa-f\"\n        val sign = \"+-\"\n        \n        Regex(\"[$sign]?[$digits$hexDigits]+\")\n    }\n    \n    for (match in hexNumberRegex.findAll(\"+1234 -FFFF not-a-number\")) {\n        println(match.value)\n    }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val hexNumberRegex = run {\n        val digits = \"0-9\"\n        val hexDigits = \"A-Fa-f\"\n        val sign = \"+-\"\n        \n        Regex(\"[$sign]?[$digits$hexDigits]+\")\n    }\n    \n    for (match in hexNumberRegex.findAll(\"+1234 -FFFF not-a-number\")) {\n        println(match.value)\n    }\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val hexNumberRegex = run {\n        val digits = \"0-9\"\n        val hexDigits = \"A-Fa-f\"\n        val sign = \"+-\"\n        \n        Regex(\"[$sign]?[$digits$hexDigits]+\")\n    }\n    \n    for (match in hexNumberRegex.findAll(\"+1234 -FFFF not-a-number\")) {\n        println(match.value)\n    }\n//sampleEnd\n}\n"}, {"type": "h3", "text": "apply"}, {"type": "code", "text": "apply"}, {"type": "p", "text": "The context object is available as a receiver (this). The return value is the object itself."}, {"type": "strong", "text": "The context object"}, {"type": "code", "text": "this"}, {"type": "strong", "text": "The return value"}, {"type": "p", "text": "Use apply for code blocks that don't return a value and mainly operate on the members of the receiver object. The common case for apply is the object configuration. Such calls can be read as \u201capply the following assignments to the object.\u201d"}, {"type": "code", "text": "apply"}, {"type": "code", "text": "apply"}, {"type": "em", "text": "apply the following assignments to the object."}, {"type": "div", "text": "\ndata class Person(var name: String, var age: Int = 0, var city: String = \"\")\n\nfun main() {\n//sampleStart\n    val adam = Person(\"Adam\").apply {\n        age = 32\n        city = \"London\"        \n    }\n    println(adam)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "data class Person(var name: String, var age: Int = 0, var city: String = \"\")\n\nfun main() {\n//sampleStart\n    val adam = Person(\"Adam\").apply {\n        age = 32\n        city = \"London\"        \n    }\n    println(adam)\n//sampleEnd\n}\n"}, {"type": "code", "text": "data class Person(var name: String, var age: Int = 0, var city: String = \"\")\n\nfun main() {\n//sampleStart\n    val adam = Person(\"Adam\").apply {\n        age = 32\n        city = \"London\"        \n    }\n    println(adam)\n//sampleEnd\n}\n"}, {"type": "p", "text": "Having the receiver as the return value, you can easily include apply into call chains for more complex processing."}, {"type": "code", "text": "apply"}, {"type": "h3", "text": "also"}, {"type": "code", "text": "also"}, {"type": "p", "text": "The context object is available as an argument (it). The return value is the object itself."}, {"type": "strong", "text": "The context object"}, {"type": "code", "text": "it"}, {"type": "strong", "text": "The return value"}, {"type": "p", "text": "also is good for performing some actions that take the context object as an argument. Use also for actions that need a reference rather to the object than to its properties and functions, or when you don't want to shadow this reference from an outer scope."}, {"type": "code", "text": "also"}, {"type": "code", "text": "also"}, {"type": "code", "text": "this"}, {"type": "p", "text": "When you see also in the code, you can read it as \u201cand also do the following with the object.\u201d"}, {"type": "code", "text": "also"}, {"type": "em", "text": "and also do the following with the object."}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    numbers\n        .also { println(\"The list elements before adding new one: $it\") }\n        .add(\"four\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    numbers\n        .also { println(\"The list elements before adding new one: $it\") }\n        .add(\"four\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    numbers\n        .also { println(\"The list elements before adding new one: $it\") }\n        .add(\"four\")\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Function selection"}, {"type": "p", "text": "To help you choose the right scope function for your purpose, we provide the table of key differences between them."}, {"type": "table", "text": "\n\n\nFunction\nObject reference\nReturn value\nIs extension function\n\n\n\n\nlet\nit\nLambda result\nYes\n\n\nrun\nthis\nLambda result\nYes\n\n\nrun\n-\nLambda result\nNo: called without the context object\n\n\nwith\nthis\nLambda result\nNo: takes the context object as an argument.\n\n\napply\nthis\nContext object\nYes\n\n\nalso\nit\nContext object\nYes\n\n\n"}, {"type": "thead", "text": "\n\nFunction\nObject reference\nReturn value\nIs extension function\n\n"}, {"type": "tr", "text": "\nFunction\nObject reference\nReturn value\nIs extension function\n"}, {"type": "th", "text": "Function"}, {"type": "th", "text": "Object reference"}, {"type": "th", "text": "Return value"}, {"type": "th", "text": "Is extension function"}, {"type": "tbody", "text": "\n\nlet\nit\nLambda result\nYes\n\n\nrun\nthis\nLambda result\nYes\n\n\nrun\n-\nLambda result\nNo: called without the context object\n\n\nwith\nthis\nLambda result\nNo: takes the context object as an argument.\n\n\napply\nthis\nContext object\nYes\n\n\nalso\nit\nContext object\nYes\n\n"}, {"type": "tr", "text": "\nlet\nit\nLambda result\nYes\n"}, {"type": "td", "text": "let"}, {"type": "code", "text": "let"}, {"type": "td", "text": "it"}, {"type": "code", "text": "it"}, {"type": "td", "text": "Lambda result"}, {"type": "td", "text": "Yes"}, {"type": "tr", "text": "\nrun\nthis\nLambda result\nYes\n"}, {"type": "td", "text": "run"}, {"type": "code", "text": "run"}, {"type": "td", "text": "this"}, {"type": "code", "text": "this"}, {"type": "td", "text": "Lambda result"}, {"type": "td", "text": "Yes"}, {"type": "tr", "text": "\nrun\n-\nLambda result\nNo: called without the context object\n"}, {"type": "td", "text": "run"}, {"type": "code", "text": "run"}, {"type": "td", "text": "-"}, {"type": "td", "text": "Lambda result"}, {"type": "td", "text": "No: called without the context object"}, {"type": "tr", "text": "\nwith\nthis\nLambda result\nNo: takes the context object as an argument.\n"}, {"type": "td", "text": "with"}, {"type": "code", "text": "with"}, {"type": "td", "text": "this"}, {"type": "code", "text": "this"}, {"type": "td", "text": "Lambda result"}, {"type": "td", "text": "No: takes the context object as an argument."}, {"type": "tr", "text": "\napply\nthis\nContext object\nYes\n"}, {"type": "td", "text": "apply"}, {"type": "code", "text": "apply"}, {"type": "td", "text": "this"}, {"type": "code", "text": "this"}, {"type": "td", "text": "Context object"}, {"type": "td", "text": "Yes"}, {"type": "tr", "text": "\nalso\nit\nContext object\nYes\n"}, {"type": "td", "text": "also"}, {"type": "code", "text": "also"}, {"type": "td", "text": "it"}, {"type": "code", "text": "it"}, {"type": "td", "text": "Context object"}, {"type": "td", "text": "Yes"}, {"type": "p", "text": "Here is a short guide for choosing scope functions depending on the intended purpose:"}, {"type": "ul", "text": "\nExecuting a lambda on non-null objects: let\nIntroducing an expression as a variable in local scope: let\nObject configuration: apply\nObject configuration and computing the result: run\nRunning statements where an expression is required: non-extension run\nAdditional effects: also\nGrouping function calls on an object: with\n"}, {"type": "li", "text": "Executing a lambda on non-null objects: let"}, {"type": "code", "text": "let"}, {"type": "li", "text": "Introducing an expression as a variable in local scope: let"}, {"type": "code", "text": "let"}, {"type": "li", "text": "Object configuration: apply"}, {"type": "code", "text": "apply"}, {"type": "li", "text": "Object configuration and computing the result: run"}, {"type": "code", "text": "run"}, {"type": "li", "text": "Running statements where an expression is required: non-extension run"}, {"type": "code", "text": "run"}, {"type": "li", "text": "Additional effects: also"}, {"type": "code", "text": "also"}, {"type": "li", "text": "Grouping function calls on an object: with"}, {"type": "code", "text": "with"}, {"type": "p", "text": "The use cases of different functions overlap, so that you can choose the functions based on the specific conventions used in your project or team."}, {"type": "p", "text": "Although the scope functions are a way of making the code more concise, avoid overusing them: it can decrease your code readability and lead to errors. Avoid nesting scope functions and be careful when chaining them: it's easy to get confused about the current context object and the value of this or it."}, {"type": "code", "text": "this"}, {"type": "code", "text": "it"}, {"type": "h2", "text": "takeIf and takeUnless"}, {"type": "code", "text": "takeIf"}, {"type": "code", "text": "takeUnless"}, {"type": "p", "text": "In addition to scope functions, the standard library contains the functions takeIf and takeUnless. These functions let you embed checks of the object state in call chains."}, {"type": "code", "text": "takeIf"}, {"type": "code", "text": "takeUnless"}, {"type": "p", "text": "When called on an object with a predicate provided, takeIf returns this object if it matches the predicate. Otherwise, it returns null. So, takeIf is a filtering function for a single object. In turn, takeUnless returns the object if it doesn't match the predicate and null if it does. The object is available as a lambda argument (it)."}, {"type": "code", "text": "takeIf"}, {"type": "code", "text": "null"}, {"type": "code", "text": "takeIf"}, {"type": "code", "text": "takeUnless"}, {"type": "code", "text": "null"}, {"type": "code", "text": "it"}, {"type": "div", "text": "\nimport kotlin.random.*\n\nfun main() {\n//sampleStart\n    val number = Random.nextInt(100)\n\n    val evenOrNull = number.takeIf { it % 2 == 0 }\n    val oddOrNull = number.takeUnless { it % 2 == 0 }\n    println(\"even: $evenOrNull, odd: $oddOrNull\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlin.random.*\n\nfun main() {\n//sampleStart\n    val number = Random.nextInt(100)\n\n    val evenOrNull = number.takeIf { it % 2 == 0 }\n    val oddOrNull = number.takeUnless { it % 2 == 0 }\n    println(\"even: $evenOrNull, odd: $oddOrNull\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlin.random.*\n\nfun main() {\n//sampleStart\n    val number = Random.nextInt(100)\n\n    val evenOrNull = number.takeIf { it % 2 == 0 }\n    val oddOrNull = number.takeUnless { it % 2 == 0 }\n    println(\"even: $evenOrNull, odd: $oddOrNull\")\n//sampleEnd\n}\n"}, {"type": "p", "text": "When chaining other functions after takeIf and takeUnless, don't forget to perform the null check or the safe call (?.) because their return value is nullable."}, {"type": "code", "text": "takeIf"}, {"type": "code", "text": "takeUnless"}, {"type": "code", "text": "?."}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val str = \"Hello\"\n    val caps = str.takeIf { it.isNotEmpty() }?.toUpperCase()\n   //val caps = str.takeIf { it.isNotEmpty() }.toUpperCase() //compilation error\n    println(caps)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val str = \"Hello\"\n    val caps = str.takeIf { it.isNotEmpty() }?.toUpperCase()\n   //val caps = str.takeIf { it.isNotEmpty() }.toUpperCase() //compilation error\n    println(caps)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val str = \"Hello\"\n    val caps = str.takeIf { it.isNotEmpty() }?.toUpperCase()\n   //val caps = str.takeIf { it.isNotEmpty() }.toUpperCase() //compilation error\n    println(caps)\n//sampleEnd\n}\n"}, {"type": "p", "text": "takeIf and takeUnless are especially useful together with scope functions. A good case is chaining them with let for running a code block on objects that match the given predicate. To do this, call takeIf on the object and then call let with a safe call (?). For objects that don't match the predicate, takeIf returns null and let isn't invoked."}, {"type": "code", "text": "takeIf"}, {"type": "code", "text": "takeUnless"}, {"type": "code", "text": "let"}, {"type": "code", "text": "takeIf"}, {"type": "code", "text": "let"}, {"type": "code", "text": "?"}, {"type": "code", "text": "takeIf"}, {"type": "code", "text": "null"}, {"type": "code", "text": "let"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    fun displaySubstringPosition(input: String, sub: String) {\n        input.indexOf(sub).takeIf { it >= 0 }?.let {\n            println(\"The substring $sub is found in $input.\")\n            println(\"Its start position is $it.\")\n        }\n    }\n\n    displaySubstringPosition(\"010000011\", \"11\")\n    displaySubstringPosition(\"010000011\", \"12\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    fun displaySubstringPosition(input: String, sub: String) {\n        input.indexOf(sub).takeIf { it >= 0 }?.let {\n            println(\"The substring $sub is found in $input.\")\n            println(\"Its start position is $it.\")\n        }\n    }\n\n    displaySubstringPosition(\"010000011\", \"11\")\n    displaySubstringPosition(\"010000011\", \"12\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    fun displaySubstringPosition(input: String, sub: String) {\n        input.indexOf(sub).takeIf { it >= 0 }?.let {\n            println(\"The substring $sub is found in $input.\")\n            println(\"Its start position is $it.\")\n        }\n    }\n\n    displaySubstringPosition(\"010000011\", \"11\")\n    displaySubstringPosition(\"010000011\", \"12\")\n//sampleEnd\n}\n"}, {"type": "p", "text": "This is how the same function looks without the standard library functions:"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    fun displaySubstringPosition(input: String, sub: String) {\n        val index = input.indexOf(sub)\n        if (index >= 0) {\n            println(\"The substring $sub is found in $input.\")\n            println(\"Its start position is $index.\")\n        }\n    }\n\n    displaySubstringPosition(\"010000011\", \"11\")\n    displaySubstringPosition(\"010000011\", \"12\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    fun displaySubstringPosition(input: String, sub: String) {\n        val index = input.indexOf(sub)\n        if (index >= 0) {\n            println(\"The substring $sub is found in $input.\")\n            println(\"Its start position is $index.\")\n        }\n    }\n\n    displaySubstringPosition(\"010000011\", \"11\")\n    displaySubstringPosition(\"010000011\", \"12\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    fun displaySubstringPosition(input: String, sub: String) {\n        val index = input.indexOf(sub)\n        if (index >= 0) {\n            println(\"The substring $sub is found in $input.\")\n            println(\"Its start position is $index.\")\n        }\n    }\n\n    displaySubstringPosition(\"010000011\", \"11\")\n    displaySubstringPosition(\"010000011\", \"12\")\n//sampleEnd\n}\n"}]