[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h2", "text": "Platform-Specific Declarations"}, {"type": "blockquote", "text": "\nMultiplatform projects are an experimental feature in Kotlin 1.2 and 1.3. All of the language\nand tooling features described in this document are subject to change in future Kotlin versions.\n"}, {"type": "p", "text": "Multiplatform projects are an experimental feature in Kotlin 1.2 and 1.3. All of the language\nand tooling features described in this document are subject to change in future Kotlin versions."}, {"type": "p", "text": "One of the key capabilities of Kotlin's multiplatform code is a way for common code to\ndepend on platform-specific declarations. In other languages, this can often be accomplished\nby building a set of interfaces in the common code and implementing these interfaces in platform-specific\nmodules. However, this approach is not ideal in cases when you have a library on one of the platforms\nthat implements the functionality you need, and you'd like to use the API of this library directly\nwithout extra wrappers. Also, it requires common declarations to be expressed as interfaces, which\ndoesn't cover all possible cases."}, {"type": "p", "text": "As an alternative, Kotlin provides a mechanism of expected and actual declarations.\nWith this mechanism, a common module can define expected declarations, and a platform module\ncan provide actual declarations corresponding to the expected ones. \nTo see how this works, let's look at an example first. This code is part of a common module:"}, {"type": "em", "text": "expected and actual declarations"}, {"type": "em", "text": "expected declarations"}, {"type": "em", "text": "actual declarations"}, {"type": "div", "text": "\npackage org.jetbrains.foo\n\nexpect class Foo(bar: String) {\n    fun frob()\n}\n\nfun main() {\n    Foo(\"Hello\").frob()\n}\n\n"}, {"type": "pre", "text": "package org.jetbrains.foo\n\nexpect class Foo(bar: String) {\n    fun frob()\n}\n\nfun main() {\n    Foo(\"Hello\").frob()\n}\n"}, {"type": "code", "text": "package org.jetbrains.foo\n\nexpect class Foo(bar: String) {\n    fun frob()\n}\n\nfun main() {\n    Foo(\"Hello\").frob()\n}\n"}, {"type": "p", "text": "And this is the corresponding JVM module:"}, {"type": "div", "text": "\npackage org.jetbrains.foo\n\nactual class Foo actual constructor(val bar: String) {\n    actual fun frob() {\n        println(\"Frobbing the $bar\")\n    }\n}\n\n"}, {"type": "pre", "text": "package org.jetbrains.foo\n\nactual class Foo actual constructor(val bar: String) {\n    actual fun frob() {\n        println(\"Frobbing the $bar\")\n    }\n}\n"}, {"type": "code", "text": "package org.jetbrains.foo\n\nactual class Foo actual constructor(val bar: String) {\n    actual fun frob() {\n        println(\"Frobbing the $bar\")\n    }\n}\n"}, {"type": "p", "text": "This illustrates several important points:"}, {"type": "ul", "text": "\nAn expected declaration in the common module and its actual counterparts always\nhave exactly the same fully qualified name.\nAn expected declaration is marked with the expect keyword; the actual declaration\nis marked with the actual keyword.\nAll actual declarations that match any part of an expected declaration need to be marked\nas actual.\nExpected declarations never contain any implementation code.\n"}, {"type": "li", "text": "An expected declaration in the common module and its actual counterparts always\nhave exactly the same fully qualified name."}, {"type": "li", "text": "An expected declaration is marked with the expect keyword; the actual declaration\nis marked with the actual keyword."}, {"type": "code", "text": "expect"}, {"type": "code", "text": "actual"}, {"type": "li", "text": "All actual declarations that match any part of an expected declaration need to be marked\nas actual."}, {"type": "code", "text": "actual"}, {"type": "li", "text": "Expected declarations never contain any implementation code."}, {"type": "p", "text": "Note that expected declarations are not restricted to interfaces and interface members.\nIn this example, the expected class has a constructor and can be created directly from common code.\nYou can apply the expect modifier to other declarations as well, including top-level declarations and\nannotations:"}, {"type": "code", "text": "expect"}, {"type": "div", "text": "\n// Common\nexpect fun formatString(source: String, vararg args: Any): String\n\nexpect annotation class Test\n\n// JVM\nactual fun formatString(source: String, vararg args: Any) =\n    String.format(source, *args)\n    \nactual typealias Test = org.junit.Test\n\n"}, {"type": "pre", "text": "// Common\nexpect fun formatString(source: String, vararg args: Any): String\n\nexpect annotation class Test\n\n// JVM\nactual fun formatString(source: String, vararg args: Any) =\n    String.format(source, *args)\n    \nactual typealias Test = org.junit.Test\n"}, {"type": "code", "text": "// Common\nexpect fun formatString(source: String, vararg args: Any): String\n\nexpect annotation class Test\n\n// JVM\nactual fun formatString(source: String, vararg args: Any) =\n    String.format(source, *args)\n    \nactual typealias Test = org.junit.Test\n"}, {"type": "p", "text": "The compiler ensures that every expected declaration has actual declarations in all platform\nmodules that implement the corresponding common module, and reports an error if any actual declarations are \nmissing. The IDE provides tools that help you create the missing actual declarations."}, {"type": "p", "text": "If you have a platform-specific library that you want to use in common code while providing your own\nimplementation for another platform, you can provide a typealias to an existing class as the actual\ndeclaration:"}, {"type": "div", "text": "\nexpect class AtomicRef<V>(value: V) {\n  fun get(): V\n  fun set(value: V)\n  fun getAndSet(value: V): V\n  fun compareAndSet(expect: V, update: V): Boolean\n}\n\nactual typealias AtomicRef<V> = java.util.concurrent.atomic.AtomicReference<V>\n\n"}, {"type": "pre", "text": "expect class AtomicRef<V>(value: V) {\n  fun get(): V\n  fun set(value: V)\n  fun getAndSet(value: V): V\n  fun compareAndSet(expect: V, update: V): Boolean\n}\n\nactual typealias AtomicRef<V> = java.util.concurrent.atomic.AtomicReference<V>\n"}, {"type": "code", "text": "expect class AtomicRef<V>(value: V) {\n  fun get(): V\n  fun set(value: V)\n  fun getAndSet(value: V): V\n  fun compareAndSet(expect: V, update: V): Boolean\n}\n\nactual typealias AtomicRef<V> = java.util.concurrent.atomic.AtomicReference<V>\n"}]