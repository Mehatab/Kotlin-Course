[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Constructing Collections"}, {"type": "h2", "text": "Constructing from elements"}, {"type": "p", "text": "The most common way to create a collection is with the standard library functions listOf<T>(), setOf<T>(), mutableListOf<T>(), mutableSetOf<T>().\nIf you provide a comma-separated list of collection elements as arguments, the compiler detects the element type automatically.  When creating empty collections, specify the type explicitly."}, {"type": "a", "text": "listOf<T>()"}, {"type": "code", "text": "listOf<T>()"}, {"type": "a", "text": "setOf<T>()"}, {"type": "code", "text": "setOf<T>()"}, {"type": "a", "text": "mutableListOf<T>()"}, {"type": "code", "text": "mutableListOf<T>()"}, {"type": "a", "text": "mutableSetOf<T>()"}, {"type": "code", "text": "mutableSetOf<T>()"}, {"type": "div", "text": "\nval numbersSet = setOf(\"one\", \"two\", \"three\", \"four\")\nval emptySet = mutableSetOf<String>()\n\n"}, {"type": "pre", "text": "val numbersSet = setOf(\"one\", \"two\", \"three\", \"four\")\nval emptySet = mutableSetOf<String>()\n"}, {"type": "code", "text": "val numbersSet = setOf(\"one\", \"two\", \"three\", \"four\")\nval emptySet = mutableSetOf<String>()\n"}, {"type": "p", "text": "The same is available for maps with the functions mapOf() and mutableMapOf(). The map's keys and values are passed as Pair objects (usually created with to infix function)."}, {"type": "a", "text": "mapOf()"}, {"type": "code", "text": "mapOf()"}, {"type": "a", "text": "mutableMapOf()"}, {"type": "code", "text": "mutableMapOf()"}, {"type": "code", "text": "Pair"}, {"type": "code", "text": "to"}, {"type": "div", "text": "\nval numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)\n\n"}, {"type": "pre", "text": "val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)\n"}, {"type": "code", "text": "val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)\n"}, {"type": "p", "text": "Note that the to notation creates a short-living Pair object, so it's recommended that you use it only if performance isn't critical.\nTo avoid excessive memory usage, use alternative ways. For example, you can create a mutable map and populate it using the write operations.\nThe apply() function can help to keep the initialization fluent here."}, {"type": "code", "text": "to"}, {"type": "code", "text": "Pair"}, {"type": "a", "text": "apply()"}, {"type": "code", "text": "apply()"}, {"type": "div", "text": "\nval numbersMap = mutableMapOf<String, String>().apply { this[\"one\"] = \"1\"; this[\"two\"] = \"2\" }\n\n"}, {"type": "pre", "text": "val numbersMap = mutableMapOf<String, String>().apply { this[\"one\"] = \"1\"; this[\"two\"] = \"2\" }\n"}, {"type": "code", "text": "val numbersMap = mutableMapOf<String, String>().apply { this[\"one\"] = \"1\"; this[\"two\"] = \"2\" }\n"}, {"type": "h2", "text": "Empty collections"}, {"type": "p", "text": "There are also functions for creating collections without any elements: emptyList(), emptySet(), and emptyMap().\nWhen creating empty collections, you should specify the type of elements that the collection will hold."}, {"type": "a", "text": "emptyList()"}, {"type": "code", "text": "emptyList()"}, {"type": "a", "text": "emptySet()"}, {"type": "code", "text": "emptySet()"}, {"type": "a", "text": "emptyMap()"}, {"type": "code", "text": "emptyMap()"}, {"type": "div", "text": "\nval empty = emptyList<String>()\n\n"}, {"type": "pre", "text": "val empty = emptyList<String>()\n"}, {"type": "code", "text": "val empty = emptyList<String>()\n"}, {"type": "h2", "text": "Initializer functions for lists"}, {"type": "p", "text": "For lists, there is a constructor that takes the list size and the initializer function that defines the element value based on its index."}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val doubled = List(3, { it * 2 })  // or MutableList if you want to change its content later\n    println(doubled)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val doubled = List(3, { it * 2 })  // or MutableList if you want to change its content later\n    println(doubled)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val doubled = List(3, { it * 2 })  // or MutableList if you want to change its content later\n    println(doubled)\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Concrete type constructors"}, {"type": "p", "text": "To create a concrete type collection, such as an ArrayList or LinkedList, you can use the available constructors for these types.\nSimilar constructors are available for implementations of Set and Map."}, {"type": "code", "text": "ArrayList"}, {"type": "code", "text": "LinkedList"}, {"type": "code", "text": "Set"}, {"type": "code", "text": "Map"}, {"type": "div", "text": "\nval linkedList = LinkedList<String>(listOf(\"one\", \"two\", \"three\"))\nval presizedSet = HashSet<Int>(32)\n\n"}, {"type": "pre", "text": "val linkedList = LinkedList<String>(listOf(\"one\", \"two\", \"three\"))\nval presizedSet = HashSet<Int>(32)\n"}, {"type": "code", "text": "val linkedList = LinkedList<String>(listOf(\"one\", \"two\", \"three\"))\nval presizedSet = HashSet<Int>(32)\n"}, {"type": "h2", "text": "Copying"}, {"type": "p", "text": "To create a collection with the same elements as an existing collection, you can use copying operations. Collection copying operations from the standard library create shallow copy collections with references to the same elements.\nThus, a change made to a collection element reflects in all its copies."}, {"type": "em", "text": "shallow"}, {"type": "p", "text": "Collection copying functions, such as toList(), toMutableList(), toSet() and others, create a snapshot of a collection at a specific moment.\nTheir result is a new collection of the same elements.\nIf you add or remove elements from the original collection, this won't affect the copies. Copies may be changed independently of the source as well."}, {"type": "a", "text": "toList()"}, {"type": "code", "text": "toList()"}, {"type": "a", "text": "toMutableList()"}, {"type": "code", "text": "toMutableList()"}, {"type": "a", "text": "toSet()"}, {"type": "code", "text": "toSet()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)\n    val copyList = sourceList.toMutableList()\n    val readOnlyCopyList = sourceList.toList()\n    sourceList.add(4)\n    println(\"Copy size: ${copyList.size}\")   \n    \n    //readOnlyCopyList.add(4)             // compilation error\n    println(\"Read-only copy size: ${readOnlyCopyList.size}\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)\n    val copyList = sourceList.toMutableList()\n    val readOnlyCopyList = sourceList.toList()\n    sourceList.add(4)\n    println(\"Copy size: ${copyList.size}\")   \n    \n    //readOnlyCopyList.add(4)             // compilation error\n    println(\"Read-only copy size: ${readOnlyCopyList.size}\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)\n    val copyList = sourceList.toMutableList()\n    val readOnlyCopyList = sourceList.toList()\n    sourceList.add(4)\n    println(\"Copy size: ${copyList.size}\")   \n    \n    //readOnlyCopyList.add(4)             // compilation error\n    println(\"Read-only copy size: ${readOnlyCopyList.size}\")\n//sampleEnd\n}\n"}, {"type": "p", "text": "These functions can also be used for converting collections to other types, for example, build a set from a list or vice versa."}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)    \n    val copySet = sourceList.toMutableSet()\n    copySet.add(3)\n    copySet.add(4)    \n    println(copySet)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)    \n    val copySet = sourceList.toMutableSet()\n    copySet.add(3)\n    copySet.add(4)    \n    println(copySet)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)    \n    val copySet = sourceList.toMutableSet()\n    copySet.add(3)\n    copySet.add(4)    \n    println(copySet)\n//sampleEnd\n}\n"}, {"type": "p", "text": "Alternatively, you can create new references to the same collection instance. New references are created when you initialize a collection variable with an existing collection.\nSo, when the collection instance is altered through a reference, the changes are reflected in all its references."}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)\n    val referenceList = sourceList\n    referenceList.add(4)\n    println(\"Source size: ${sourceList.size}\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)\n    val referenceList = sourceList\n    referenceList.add(4)\n    println(\"Source size: ${sourceList.size}\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)\n    val referenceList = sourceList\n    referenceList.add(4)\n    println(\"Source size: ${sourceList.size}\")\n//sampleEnd\n}\n"}, {"type": "p", "text": "Collection initialization can be used for restricting mutability. For example, if you create a List reference to a MutableList, the compiler will produce errors if you try to modify the collection through this reference."}, {"type": "code", "text": "List"}, {"type": "code", "text": "MutableList"}, {"type": "div", "text": "\nfun main() {\n//sampleStart \n    val sourceList = mutableListOf(1, 2, 3)\n    val referenceList: List<Int> = sourceList\n    //referenceList.add(4)            //compilation error\n    sourceList.add(4)\n    println(referenceList) // shows the current state of sourceList\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart \n    val sourceList = mutableListOf(1, 2, 3)\n    val referenceList: List<Int> = sourceList\n    //referenceList.add(4)            //compilation error\n    sourceList.add(4)\n    println(referenceList) // shows the current state of sourceList\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart \n    val sourceList = mutableListOf(1, 2, 3)\n    val referenceList: List<Int> = sourceList\n    //referenceList.add(4)            //compilation error\n    sourceList.add(4)\n    println(referenceList) // shows the current state of sourceList\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Invoking functions on other collections"}, {"type": "p", "text": "Collections can be created in result of various operations on other collections. For example, filtering a list creates a new list of elements that match the filter:"}, {"type": "a", "text": "filtering"}, {"type": "div", "text": "\nfun main() {\n//sampleStart \n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")  \n    val longerThan3 = numbers.filter { it.length > 3 }\n    println(longerThan3)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart \n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")  \n    val longerThan3 = numbers.filter { it.length > 3 }\n    println(longerThan3)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart \n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")  \n    val longerThan3 = numbers.filter { it.length > 3 }\n    println(longerThan3)\n//sampleEnd\n}\n"}, {"type": "p", "text": "Mapping produces a list of a transformation results:"}, {"type": "a", "text": "Mapping"}, {"type": "div", "text": "\nfun main() {\n//sampleStart \n    val numbers = setOf(1, 2, 3)\n    println(numbers.map { it * 3 })\n    println(numbers.mapIndexed { idx, value -> value * idx })\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart \n    val numbers = setOf(1, 2, 3)\n    println(numbers.map { it * 3 })\n    println(numbers.mapIndexed { idx, value -> value * idx })\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart \n    val numbers = setOf(1, 2, 3)\n    println(numbers.map { it * 3 })\n    println(numbers.mapIndexed { idx, value -> value * idx })\n//sampleEnd\n}\n"}, {"type": "p", "text": "Association produces maps:"}, {"type": "a", "text": "Association"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.associateWith { it.length })\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.associateWith { it.length })\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.associateWith { it.length })\n//sampleEnd\n}\n"}, {"type": "p", "text": "For more information about operations on collections in Kotlin, see Collection Operations Overview."}, {"type": "a", "text": "Collection Operations Overview"}]