[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Properties and Fields"}, {"type": "h2", "text": "Declaring Properties"}, {"type": "p", "text": "Properties in Kotlin classes can be declared either as mutable using the var keyword, or as read-only using the val keyword."}, {"type": "em", "text": "var"}, {"type": "em", "text": "val"}, {"type": "div", "text": "\nclass Address {\n    var name: String = \"Holmes, Sherlock\"\n    var street: String = \"Baker\"\n    var city: String = \"London\"\n    var state: String? = null\n    var zip: String = \"123456\"\n}\n\n"}, {"type": "pre", "text": "class Address {\n    var name: String = \"Holmes, Sherlock\"\n    var street: String = \"Baker\"\n    var city: String = \"London\"\n    var state: String? = null\n    var zip: String = \"123456\"\n}\n"}, {"type": "code", "text": "class Address {\n    var name: String = \"Holmes, Sherlock\"\n    var street: String = \"Baker\"\n    var city: String = \"London\"\n    var state: String? = null\n    var zip: String = \"123456\"\n}\n"}, {"type": "p", "text": "To use a property, simply refer to it by name:"}, {"type": "div", "text": "\nfun copyAddress(address: Address): Address {\n    val result = Address() // there's no 'new' keyword in Kotlin\n    result.name = address.name // accessors are called\n    result.street = address.street\n    // ...\n    return result\n}\n\n"}, {"type": "pre", "text": "fun copyAddress(address: Address): Address {\n    val result = Address() // there's no 'new' keyword in Kotlin\n    result.name = address.name // accessors are called\n    result.street = address.street\n    // ...\n    return result\n}\n"}, {"type": "code", "text": "fun copyAddress(address: Address): Address {\n    val result = Address() // there's no 'new' keyword in Kotlin\n    result.name = address.name // accessors are called\n    result.street = address.street\n    // ...\n    return result\n}\n"}, {"type": "h2", "text": "Getters and Setters"}, {"type": "p", "text": "The full syntax for declaring a property is"}, {"type": "div", "text": "\nvar <propertyName>[: <PropertyType>] [= <property_initializer>]\n    [<getter>]\n    [<setter>]\n\n"}, {"type": "pre", "text": "var <propertyName>[: <PropertyType>] [= <property_initializer>]\n    [<getter>]\n    [<setter>]\n"}, {"type": "code", "text": "var <propertyName>[: <PropertyType>] [= <property_initializer>]\n    [<getter>]\n    [<setter>]\n"}, {"type": "p", "text": "The initializer, getter and setter are optional. Property type is optional if it can be inferred from the initializer\n(or from the getter return type, as shown below)."}, {"type": "p", "text": "Examples:"}, {"type": "div", "text": "\nvar allByDefault: Int? // error: explicit initializer required, default getter and setter implied\nvar initialized = 1 // has type Int, default getter and setter\n\n"}, {"type": "pre", "text": "var allByDefault: Int? // error: explicit initializer required, default getter and setter implied\nvar initialized = 1 // has type Int, default getter and setter\n"}, {"type": "code", "text": "var allByDefault: Int? // error: explicit initializer required, default getter and setter implied\nvar initialized = 1 // has type Int, default getter and setter\n"}, {"type": "p", "text": "The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with val instead of var and does not allow a setter:"}, {"type": "code", "text": "val"}, {"type": "code", "text": "var"}, {"type": "div", "text": "\nval simple: Int? // has type Int, default getter, must be initialized in constructor\nval inferredType = 1 // has type Int and a default getter\n\n"}, {"type": "pre", "text": "val simple: Int? // has type Int, default getter, must be initialized in constructor\nval inferredType = 1 // has type Int and a default getter\n"}, {"type": "code", "text": "val simple: Int? // has type Int, default getter, must be initialized in constructor\nval inferredType = 1 // has type Int and a default getter\n"}, {"type": "p", "text": "We can define custom accessors for a property. If we define a custom getter, it will be called every time we access\nthe property (this allows us to implement a computed property). Here's an example of a custom getter:"}, {"type": "div", "text": "\nval isEmpty: Boolean\n    get() = this.size == 0\n\n"}, {"type": "pre", "text": "val isEmpty: Boolean\n    get() = this.size == 0\n"}, {"type": "code", "text": "val isEmpty: Boolean\n    get() = this.size == 0\n"}, {"type": "p", "text": "If we define a custom setter, it will be called every time we assign a value to the property. A custom setter looks like this:"}, {"type": "div", "text": "\nvar stringRepresentation: String\n    get() = this.toString()\n    set(value) {\n        setDataFromString(value) // parses the string and assigns values to other properties\n    }\n\n"}, {"type": "pre", "text": "var stringRepresentation: String\n    get() = this.toString()\n    set(value) {\n        setDataFromString(value) // parses the string and assigns values to other properties\n    }\n"}, {"type": "code", "text": "var stringRepresentation: String\n    get() = this.toString()\n    set(value) {\n        setDataFromString(value) // parses the string and assigns values to other properties\n    }\n"}, {"type": "p", "text": "By convention, the name of the setter parameter is value, but you can choose a different name if you prefer."}, {"type": "code", "text": "value"}, {"type": "p", "text": "Since Kotlin 1.1, you can omit the property type if it can be inferred from the getter:"}, {"type": "div", "text": "\nval isEmpty get() = this.size == 0  // has type Boolean\n\n"}, {"type": "pre", "text": "val isEmpty get() = this.size == 0  // has type Boolean\n"}, {"type": "code", "text": "val isEmpty get() = this.size == 0  // has type Boolean\n"}, {"type": "p", "text": "If you need to change the visibility of an accessor or to annotate it, but don't need to change the default implementation,\nyou can define the accessor without defining its body:"}, {"type": "div", "text": "\nvar setterVisibility: String = \"abc\"\n    private set // the setter is private and has the default implementation\n\nvar setterWithAnnotation: Any? = null\n    @Inject set // annotate the setter with Inject\n\n"}, {"type": "pre", "text": "var setterVisibility: String = \"abc\"\n    private set // the setter is private and has the default implementation\n\nvar setterWithAnnotation: Any? = null\n    @Inject set // annotate the setter with Inject\n"}, {"type": "code", "text": "var setterVisibility: String = \"abc\"\n    private set // the setter is private and has the default implementation\n\nvar setterWithAnnotation: Any? = null\n    @Inject set // annotate the setter with Inject\n"}, {"type": "h3", "text": "Backing Fields"}, {"type": "p", "text": "Fields cannot be declared directly in Kotlin classes. However, when a property needs a backing field, Kotlin provides it automatically. This backing field can be referenced in the accessors using the field identifier:"}, {"type": "code", "text": "field"}, {"type": "div", "text": "\nvar counter = 0 // Note: the initializer assigns the backing field directly\n    set(value) {\n        if (value >= 0) field = value\n    }\n\n"}, {"type": "pre", "text": "var counter = 0 // Note: the initializer assigns the backing field directly\n    set(value) {\n        if (value >= 0) field = value\n    }\n"}, {"type": "code", "text": "var counter = 0 // Note: the initializer assigns the backing field directly\n    set(value) {\n        if (value >= 0) field = value\n    }\n"}, {"type": "p", "text": "The field identifier can only be used in the accessors of the property."}, {"type": "code", "text": "field"}, {"type": "p", "text": "A backing field will be generated for a property if it uses the default implementation of at least one of the accessors, or if a custom accessor references it through the field identifier."}, {"type": "code", "text": "field"}, {"type": "p", "text": "For example, in the following case there will be no backing field:"}, {"type": "div", "text": "\nval isEmpty: Boolean\n    get() = this.size == 0\n\n"}, {"type": "pre", "text": "val isEmpty: Boolean\n    get() = this.size == 0\n"}, {"type": "code", "text": "val isEmpty: Boolean\n    get() = this.size == 0\n"}, {"type": "h3", "text": "Backing Properties"}, {"type": "p", "text": "If you want to do something that does not fit into this \"implicit backing field\" scheme, you can always fall back to having a backing property:"}, {"type": "em", "text": "backing property"}, {"type": "div", "text": "\nprivate var _table: Map<String, Int>? = null\npublic val table: Map<String, Int>\n    get() {\n        if (_table == null) {\n            _table = HashMap() // Type parameters are inferred\n        }\n        return _table ?: throw AssertionError(\"Set to null by another thread\")\n    }\n\n"}, {"type": "pre", "text": "private var _table: Map<String, Int>? = null\npublic val table: Map<String, Int>\n    get() {\n        if (_table == null) {\n            _table = HashMap() // Type parameters are inferred\n        }\n        return _table ?: throw AssertionError(\"Set to null by another thread\")\n    }\n"}, {"type": "code", "text": "private var _table: Map<String, Int>? = null\npublic val table: Map<String, Int>\n    get() {\n        if (_table == null) {\n            _table = HashMap() // Type parameters are inferred\n        }\n        return _table ?: throw AssertionError(\"Set to null by another thread\")\n    }\n"}, {"type": "blockquote", "text": "\nOn the JVM: The access to private properties with default getters and setters is optimized\nso no function call overhead is introduced in this case.\n"}, {"type": "p", "text": "On the JVM: The access to private properties with default getters and setters is optimized\nso no function call overhead is introduced in this case."}, {"type": "strong", "text": "On the JVM"}, {"type": "h2", "text": "Compile-Time Constants"}, {"type": "p", "text": "If the value of a read-only property is known at the compile time, mark it as a compile time constant using the const modifier.\nSuch properties need to fulfil the following requirements:"}, {"type": "em", "text": "compile time constant"}, {"type": "em", "text": "const"}, {"type": "ul", "text": "\nTop-level, or member of an object declaration or a companion object.\nInitialized with a value of type String or a primitive type\nNo custom getter\n"}, {"type": "li", "text": "Top-level, or member of an object declaration or a companion object."}, {"type": "a", "text": "object declaration"}, {"type": "em", "text": "object"}, {"type": "a", "text": "a companion object"}, {"type": "em", "text": "companion object"}, {"type": "li", "text": "Initialized with a value of type String or a primitive type"}, {"type": "code", "text": "String"}, {"type": "li", "text": "No custom getter"}, {"type": "p", "text": "Such properties can be used in annotations:"}, {"type": "div", "text": "\nconst val SUBSYSTEM_DEPRECATED: String = \"This subsystem is deprecated\"\n\n@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() { ... }\n\n"}, {"type": "pre", "text": "const val SUBSYSTEM_DEPRECATED: String = \"This subsystem is deprecated\"\n\n@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() { ... }\n"}, {"type": "code", "text": "const val SUBSYSTEM_DEPRECATED: String = \"This subsystem is deprecated\"\n\n@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() { ... }\n"}, {"type": "h2", "text": "Late-Initialized Properties and Variables"}, {"type": "p", "text": "Normally, properties declared as having a non-null type must be initialized in the constructor.\nHowever, fairly often this is not convenient. For example, properties can be initialized through dependency injection,\nor in the setup method of a unit test. In this case, you cannot supply a non-null initializer in the constructor,\nbut you still want to avoid null checks when referencing the property inside the body of a class."}, {"type": "p", "text": "To handle this case, you can mark the property with the lateinit modifier:"}, {"type": "code", "text": "lateinit"}, {"type": "div", "text": "\npublic class MyTest {\n    lateinit var subject: TestSubject\n\n    @SetUp fun setup() {\n        subject = TestSubject()\n    }\n\n    @Test fun test() {\n        subject.method()  // dereference directly\n    }\n}\n\n"}, {"type": "pre", "text": "public class MyTest {\n    lateinit var subject: TestSubject\n\n    @SetUp fun setup() {\n        subject = TestSubject()\n    }\n\n    @Test fun test() {\n        subject.method()  // dereference directly\n    }\n}\n"}, {"type": "code", "text": "public class MyTest {\n    lateinit var subject: TestSubject\n\n    @SetUp fun setup() {\n        subject = TestSubject()\n    }\n\n    @Test fun test() {\n        subject.method()  // dereference directly\n    }\n}\n"}, {"type": "p", "text": "The modifier can be used on var properties declared inside the body of a class (not in the primary constructor, and only\nwhen the property does not have a custom getter or setter) and, since Kotlin 1.2, for top-level properties and \nlocal variables. The type of the property or variable must be non-null, and it must not be a primitive type."}, {"type": "code", "text": "var"}, {"type": "p", "text": "Accessing a lateinit property before it has been initialized throws a special exception that clearly identifies the property\nbeing accessed and the fact that it hasn't been initialized."}, {"type": "code", "text": "lateinit"}, {"type": "h3", "text": "Checking whether a lateinit var is initialized (since 1.2)"}, {"type": "p", "text": "To check whether a lateinit var has already been initialized, use .isInitialized on \nthe reference to that property:"}, {"type": "code", "text": "lateinit var"}, {"type": "code", "text": ".isInitialized"}, {"type": "a", "text": "reference to that property"}, {"type": "div", "text": "\nif (foo::bar.isInitialized) {\n    println(foo.bar)\n}\n\n"}, {"type": "pre", "text": "if (foo::bar.isInitialized) {\n    println(foo.bar)\n}\n"}, {"type": "code", "text": "if (foo::bar.isInitialized) {\n    println(foo.bar)\n}\n"}, {"type": "p", "text": "This check is only available for the properties that are lexically accessible, i.e. declared in the same type or in one of\nthe outer types, or at top level in the same file."}, {"type": "h2", "text": "Overriding Properties"}, {"type": "p", "text": "See Overriding Properties"}, {"type": "a", "text": "Overriding Properties"}, {"type": "h2", "text": "Delegated Properties"}, {"type": "p", "text": "The most common kind of properties simply reads from (and maybe writes to) a backing field. \nOn the other hand, with custom getters and setters one can implement any behaviour of a property.\nSomewhere in between, there are certain common patterns of how a property may work. A few examples: lazy values,\nreading from a map by a given key, accessing a database, notifying listener on access, etc."}, {"type": "p", "text": "Such common behaviours can be implemented as libraries using delegated properties."}, {"type": "a", "text": "delegated properties"}, {"type": "em", "text": "delegated properties"}]