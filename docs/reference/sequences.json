[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Sequences"}, {"type": "p", "text": "Along with collections, the Kotlin standard library contains another container type \u2013 sequences (Sequence<T>).\nSequences offer the same functions as Iterable but implement another approach to multi-step collection processing."}, {"type": "em", "text": "sequences"}, {"type": "a", "text": "Sequence<T>"}, {"type": "code", "text": "Sequence<T>"}, {"type": "a", "text": "Iterable"}, {"type": "code", "text": "Iterable"}, {"type": "p", "text": "When the processing of an Iterable includes multiple steps, they are executed eagerly: each processing step completes and returns its result \u2013 an intermediate collection.\nThe following step executes on this collection. In turn, multi-step processing of sequences is executed lazily when possible: actual computing happens only when the result of the whole processing chain is requested."}, {"type": "code", "text": "Iterable"}, {"type": "p", "text": "The order of operations execution is different as well: Sequence performs all the processing steps one-by-one for every single element.\nIn turn, Iterable completes each step for the whole collection and then proceeds to the next step."}, {"type": "code", "text": "Sequence"}, {"type": "code", "text": "Iterable"}, {"type": "p", "text": "So, the sequences let you avoid building results of intermediate steps, therefore improving the performance of the whole collection processing chain.\nHowever, the lazy nature of sequences adds some overhead which may be significant when processing smaller collections or doing simpler computations.\nHence, you should consider both Sequence and Iterable and decide which one is better for your case."}, {"type": "code", "text": "Sequence"}, {"type": "code", "text": "Iterable"}, {"type": "h2", "text": "Constructing"}, {"type": "h3", "text": "From elements"}, {"type": "p", "text": "To create a sequence, call the sequenceOf() function listing the elements as its arguments."}, {"type": "a", "text": "sequenceOf()"}, {"type": "code", "text": "sequenceOf()"}, {"type": "div", "text": "\nval numbersSequence = sequenceOf(\"four\", \"three\", \"two\", \"one\")\n\n"}, {"type": "pre", "text": "val numbersSequence = sequenceOf(\"four\", \"three\", \"two\", \"one\")\n"}, {"type": "code", "text": "val numbersSequence = sequenceOf(\"four\", \"three\", \"two\", \"one\")\n"}, {"type": "h3", "text": "From Iterable"}, {"type": "code", "text": "Iterable"}, {"type": "p", "text": "If you already have an Iterable object (such as a List or a Set), you can create a sequence from it by calling asSequence()."}, {"type": "code", "text": "Iterable"}, {"type": "code", "text": "List"}, {"type": "code", "text": "Set"}, {"type": "a", "text": "asSequence()"}, {"type": "code", "text": "asSequence()"}, {"type": "div", "text": "\nval numbers = listOf(\"one\", \"two\", \"three\", \"four\")\nval numbersSequence = numbers.asSequence()\n\n\n"}, {"type": "pre", "text": "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\nval numbersSequence = numbers.asSequence()\n\n"}, {"type": "code", "text": "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\nval numbersSequence = numbers.asSequence()\n\n"}, {"type": "h3", "text": "From function"}, {"type": "p", "text": "One more way to create a sequence is by building it with a function that calculates its elements.\nTo build a sequence based on a function, call generateSequence() with this function as an argument.\nOptionally, you can specify the first element as an explicit value or a result of a function call.\nThe sequence generation stops when the provided function returns null. So, the sequence in the example below is infinite."}, {"type": "a", "text": "generateSequence()"}, {"type": "code", "text": "generateSequence()"}, {"type": "code", "text": "null"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val oddNumbers = generateSequence(1) { it + 2 } // `it` is the previous element\n    println(oddNumbers.take(5).toList())\n    //println(oddNumbers.count())     // error: the sequence is infinite\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val oddNumbers = generateSequence(1) { it + 2 } // `it` is the previous element\n    println(oddNumbers.take(5).toList())\n    //println(oddNumbers.count())     // error: the sequence is infinite\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val oddNumbers = generateSequence(1) { it + 2 } // `it` is the previous element\n    println(oddNumbers.take(5).toList())\n    //println(oddNumbers.count())     // error: the sequence is infinite\n//sampleEnd\n}\n"}, {"type": "p", "text": "To create a finite sequence with generateSequence(), provide a function that returns null after the last element you need."}, {"type": "code", "text": "generateSequence()"}, {"type": "code", "text": "null"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val oddNumbersLessThan10 = generateSequence(1) { if (it < 10) it + 2 else null }\n    println(oddNumbersLessThan10.count())\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val oddNumbersLessThan10 = generateSequence(1) { if (it < 10) it + 2 else null }\n    println(oddNumbersLessThan10.count())\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val oddNumbersLessThan10 = generateSequence(1) { if (it < 10) it + 2 else null }\n    println(oddNumbersLessThan10.count())\n//sampleEnd\n}\n"}, {"type": "h3", "text": "From chunks"}, {"type": "p", "text": "Finally, there is a function that lets you produce sequence elements one by one or by chunks of arbitrary sizes \u2013 the sequence() function.\nThis function takes a lambda expression containing calls of yield() and yieldAll() functions.\nThey return an element to the sequence consumer and suspend the execution of sequence() until the next element is requested by the consumer.\nyield() takes a single element as an argument; yieldAll() can take an Iterable object, an Iterator, or another Sequence. A Sequence argument of yieldAll() can be infinite. However, such a call must be the last: all subsequent calls will never be executed."}, {"type": "a", "text": "sequence()"}, {"type": "code", "text": "sequence()"}, {"type": "a", "text": "yield()"}, {"type": "code", "text": "yield()"}, {"type": "a", "text": "yieldAll()"}, {"type": "code", "text": "yieldAll()"}, {"type": "code", "text": "sequence()"}, {"type": "code", "text": "yield()"}, {"type": "code", "text": "yieldAll()"}, {"type": "code", "text": "Iterable"}, {"type": "code", "text": "Iterator"}, {"type": "code", "text": "Sequence"}, {"type": "code", "text": "Sequence"}, {"type": "code", "text": "yieldAll()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val oddNumbers = sequence {\n        yield(1)\n        yieldAll(listOf(3, 5))\n        yieldAll(generateSequence(7) { it + 2 })\n    }\n    println(oddNumbers.take(5).toList())\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val oddNumbers = sequence {\n        yield(1)\n        yieldAll(listOf(3, 5))\n        yieldAll(generateSequence(7) { it + 2 })\n    }\n    println(oddNumbers.take(5).toList())\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val oddNumbers = sequence {\n        yield(1)\n        yieldAll(listOf(3, 5))\n        yieldAll(generateSequence(7) { it + 2 })\n    }\n    println(oddNumbers.take(5).toList())\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Sequence operations"}, {"type": "p", "text": "The sequence operations can be classified into the following groups regarding their state requirements:"}, {"type": "ul", "text": "\nStateless operations require no state and process each element independently, for example, map() or filter().\n Stateless operations can also require a small constant amount of state to process an element, for example, take() or drop().\nStateful operations require a significant amount of state, usually proportional to the number of elements in a sequence.\n"}, {"type": "li", "text": "Stateless operations require no state and process each element independently, for example, map() or filter().\n Stateless operations can also require a small constant amount of state to process an element, for example, take() or drop()."}, {"type": "em", "text": "Stateless"}, {"type": "a", "text": "map()"}, {"type": "code", "text": "map()"}, {"type": "a", "text": "filter()"}, {"type": "code", "text": "filter()"}, {"type": "a", "text": "take() or drop()"}, {"type": "code", "text": "take()"}, {"type": "code", "text": "drop()"}, {"type": "li", "text": "Stateful operations require a significant amount of state, usually proportional to the number of elements in a sequence."}, {"type": "em", "text": "Stateful"}, {"type": "p", "text": "If a sequence operation returns another sequence, which is produced lazily, it's called intermediate.\nOtherwise, the operation is terminal. Examples of terminal operations are toList() or sum(). Sequence elements can be retrieved only with terminal operations."}, {"type": "em", "text": "intermediate"}, {"type": "em", "text": "terminal"}, {"type": "a", "text": "toList()"}, {"type": "code", "text": "toList()"}, {"type": "a", "text": "sum()"}, {"type": "code", "text": "sum()"}, {"type": "p", "text": "Sequences can be iterated multiple times; however some sequence implementations might constrain themselves to be iterated only once. That is mentioned specifically in their documentation."}, {"type": "h2", "text": "Sequence processing example"}, {"type": "p", "text": "Let's take a look at the difference between Iterable and Sequence with an example."}, {"type": "code", "text": "Iterable"}, {"type": "code", "text": "Sequence"}, {"type": "h3", "text": "Iterable"}, {"type": "p", "text": "Assume that you have a list of words. The code below filters the words longer than three characters and prints the lengths of first four such words."}, {"type": "div", "text": "\nfun main() {    \n//sampleStart\n    val words = \"The quick brown fox jumps over the lazy dog\".split(\" \")\n    val lengthsList = words.filter { println(\"filter: $it\"); it.length > 3 }\n        .map { println(\"length: ${it.length}\"); it.length }\n        .take(4)\n\n    println(\"Lengths of first 4 words longer than 3 chars:\")\n    println(lengthsList)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {    \n//sampleStart\n    val words = \"The quick brown fox jumps over the lazy dog\".split(\" \")\n    val lengthsList = words.filter { println(\"filter: $it\"); it.length > 3 }\n        .map { println(\"length: ${it.length}\"); it.length }\n        .take(4)\n\n    println(\"Lengths of first 4 words longer than 3 chars:\")\n    println(lengthsList)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {    \n//sampleStart\n    val words = \"The quick brown fox jumps over the lazy dog\".split(\" \")\n    val lengthsList = words.filter { println(\"filter: $it\"); it.length > 3 }\n        .map { println(\"length: ${it.length}\"); it.length }\n        .take(4)\n\n    println(\"Lengths of first 4 words longer than 3 chars:\")\n    println(lengthsList)\n//sampleEnd\n}\n"}, {"type": "p", "text": "When you run this code, you'll see that the filter() and map() functions are executed in the same order as they appear in the code.\nFirst, you see filter: for all elements, then length: for the elements left after filtering, and then the output of the two last lines. \nThis is how the list processing goes:"}, {"type": "code", "text": "filter()"}, {"type": "code", "text": "map()"}, {"type": "code", "text": "filter:"}, {"type": "code", "text": "length:"}, {"type": "p", "text": ""}, {"type": "img", "text": ""}, {"type": "h3", "text": "Sequence"}, {"type": "p", "text": "Now let's write the same with sequences:"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val words = \"The quick brown fox jumps over the lazy dog\".split(\" \")\n    //convert the List to a Sequence\n    val wordsSequence = words.asSequence()\n\n    val lengthsSequence = wordsSequence.filter { println(\"filter: $it\"); it.length > 3 }\n        .map { println(\"length: ${it.length}\"); it.length }\n        .take(4)\n\n    println(\"Lengths of first 4 words longer than 3 chars\")\n    // terminal operation: obtaining the result as a List\n    println(lengthsSequence.toList())\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val words = \"The quick brown fox jumps over the lazy dog\".split(\" \")\n    //convert the List to a Sequence\n    val wordsSequence = words.asSequence()\n\n    val lengthsSequence = wordsSequence.filter { println(\"filter: $it\"); it.length > 3 }\n        .map { println(\"length: ${it.length}\"); it.length }\n        .take(4)\n\n    println(\"Lengths of first 4 words longer than 3 chars\")\n    // terminal operation: obtaining the result as a List\n    println(lengthsSequence.toList())\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val words = \"The quick brown fox jumps over the lazy dog\".split(\" \")\n    //convert the List to a Sequence\n    val wordsSequence = words.asSequence()\n\n    val lengthsSequence = wordsSequence.filter { println(\"filter: $it\"); it.length > 3 }\n        .map { println(\"length: ${it.length}\"); it.length }\n        .take(4)\n\n    println(\"Lengths of first 4 words longer than 3 chars\")\n    // terminal operation: obtaining the result as a List\n    println(lengthsSequence.toList())\n//sampleEnd\n}\n"}, {"type": "p", "text": "The output of this code shows that the filter() and map() functions are called only when building the result list.\nSo, you first see the line of text \u201cLengths of..\u201d and then the sequence processing starts.\nNote that for elements left after filtering, the map executes before filtering the next element.\nWhen the result size reaches 4, the processing stops because it's the largest possible size that take(4) can return."}, {"type": "code", "text": "filter()"}, {"type": "code", "text": "map()"}, {"type": "code", "text": "\u201cLengths of..\u201d"}, {"type": "code", "text": "take(4)"}, {"type": "p", "text": "The sequence processing goes like this:"}, {"type": "p", "text": ""}, {"type": "img", "text": ""}, {"type": "p", "text": "In this example, the sequence processing takes 18 steps instead of 23 steps for doing the same with lists."}]