[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Collection Aggregate Operations"}, {"type": "p", "text": "Kotlin collections contain functions for commonly used aggregate operations \u2013 operations that return a single value based on the collection content.\nMost of them are well known and work the same way as they do in other languages:"}, {"type": "em", "text": "aggregate operations"}, {"type": "ul", "text": "\nmin() and max() return the smallest and the largest element respectively;\naverage() returns the average value of elements in the collection of numbers;\nsum() returns the sum of elements in the collection of numbers;\ncount() returns the number of elements in a collection;\n"}, {"type": "li", "text": "min() and max() return the smallest and the largest element respectively;"}, {"type": "a", "text": "min()"}, {"type": "code", "text": "min()"}, {"type": "a", "text": "max()"}, {"type": "code", "text": "max()"}, {"type": "li", "text": "average() returns the average value of elements in the collection of numbers;"}, {"type": "a", "text": "average()"}, {"type": "code", "text": "average()"}, {"type": "li", "text": "sum() returns the sum of elements in the collection of numbers;"}, {"type": "a", "text": "sum()"}, {"type": "code", "text": "sum()"}, {"type": "li", "text": "count() returns the number of elements in a collection;"}, {"type": "a", "text": "count()"}, {"type": "code", "text": "count()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(6, 42, 10, 4)\n\n    println(\"Count: ${numbers.count()}\")\n    println(\"Max: ${numbers.max()}\")\n    println(\"Min: ${numbers.min()}\")\n    println(\"Average: ${numbers.average()}\")\n    println(\"Sum: ${numbers.sum()}\")\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(6, 42, 10, 4)\n\n    println(\"Count: ${numbers.count()}\")\n    println(\"Max: ${numbers.max()}\")\n    println(\"Min: ${numbers.min()}\")\n    println(\"Average: ${numbers.average()}\")\n    println(\"Sum: ${numbers.sum()}\")\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(6, 42, 10, 4)\n\n    println(\"Count: ${numbers.count()}\")\n    println(\"Max: ${numbers.max()}\")\n    println(\"Min: ${numbers.min()}\")\n    println(\"Average: ${numbers.average()}\")\n    println(\"Sum: ${numbers.sum()}\")\n//sampleEnd\n}\n"}, {"type": "p", "text": "There are also functions for retrieving the smallest and the largest elements by certain selector function or custom Comparator:"}, {"type": "a", "text": "Comparator"}, {"type": "code", "text": "Comparator"}, {"type": "ul", "text": "\nmaxBy()/minBy() take a selector function and return the element for which it returns the largest or the smallest value.\nmaxWith()/minWith() take a Comparator object and return the largest or smallest element according to that Comparator.\n"}, {"type": "li", "text": "maxBy()/minBy() take a selector function and return the element for which it returns the largest or the smallest value."}, {"type": "a", "text": "maxBy()"}, {"type": "code", "text": "maxBy()"}, {"type": "a", "text": "minBy()"}, {"type": "code", "text": "minBy()"}, {"type": "li", "text": "maxWith()/minWith() take a Comparator object and return the largest or smallest element according to that Comparator."}, {"type": "a", "text": "maxWith()"}, {"type": "code", "text": "maxWith()"}, {"type": "a", "text": "minWith()"}, {"type": "code", "text": "minWith()"}, {"type": "code", "text": "Comparator"}, {"type": "code", "text": "Comparator"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(5, 42, 10, 4)\n    val min3Remainder = numbers.minBy { it % 3 }\n    println(min3Remainder)\n\n    val strings = listOf(\"one\", \"two\", \"three\", \"four\")\n    val longestString = strings.maxWith(compareBy { it.length })\n    println(longestString)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(5, 42, 10, 4)\n    val min3Remainder = numbers.minBy { it % 3 }\n    println(min3Remainder)\n\n    val strings = listOf(\"one\", \"two\", \"three\", \"four\")\n    val longestString = strings.maxWith(compareBy { it.length })\n    println(longestString)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(5, 42, 10, 4)\n    val min3Remainder = numbers.minBy { it % 3 }\n    println(min3Remainder)\n\n    val strings = listOf(\"one\", \"two\", \"three\", \"four\")\n    val longestString = strings.maxWith(compareBy { it.length })\n    println(longestString)\n//sampleEnd\n}\n"}, {"type": "p", "text": "Additionally, there are advanced summation functions that take a function and return the sum of its return values on all elements:"}, {"type": "ul", "text": "\nsumBy() applies functions that return Int values on collection elements.\nsumByDouble() works with functions that return Double.\n"}, {"type": "li", "text": "sumBy() applies functions that return Int values on collection elements."}, {"type": "a", "text": "sumBy()"}, {"type": "code", "text": "sumBy()"}, {"type": "code", "text": "Int"}, {"type": "li", "text": "sumByDouble() works with functions that return Double."}, {"type": "a", "text": "sumByDouble()"}, {"type": "code", "text": "sumByDouble()"}, {"type": "code", "text": "Double"}, {"type": "div", "text": "\nfun main() {\n//sampleStart    \n    val numbers = listOf(5, 42, 10, 4)\n    println(numbers.sumBy { it * 2 })\n    println(numbers.sumByDouble { it.toDouble() / 2 })\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart    \n    val numbers = listOf(5, 42, 10, 4)\n    println(numbers.sumBy { it * 2 })\n    println(numbers.sumByDouble { it.toDouble() / 2 })\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart    \n    val numbers = listOf(5, 42, 10, 4)\n    println(numbers.sumBy { it * 2 })\n    println(numbers.sumByDouble { it.toDouble() / 2 })\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Fold and reduce"}, {"type": "p", "text": "For more specific cases, there are the functions reduce() and fold() that apply the provided operation to the collection elements sequentially and return the accumulated result.\nThe operation takes two arguments:  the previously accumulated value and the collection element."}, {"type": "a", "text": "reduce()"}, {"type": "code", "text": "reduce()"}, {"type": "a", "text": "fold()"}, {"type": "code", "text": "fold()"}, {"type": "p", "text": "The difference between the two functions is that fold() takes an initial value and uses it as the accumulated value on the first step, whereas the first step of reduce() uses the first and the second elements as operation arguments on the first step."}, {"type": "code", "text": "fold()"}, {"type": "code", "text": "reduce()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n\n    val sum = numbers.reduce { sum, element -> sum + element }\n    println(sum)\n    val sumDoubled = numbers.fold(0) { sum, element -> sum + element * 2 }\n    println(sumDoubled)\n\n    //val sumDoubledReduce = numbers.reduce { sum, element -> sum + element * 2 } //incorrect: the first element isn't doubled in the result\n    //println(sumDoubledReduce)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n\n    val sum = numbers.reduce { sum, element -> sum + element }\n    println(sum)\n    val sumDoubled = numbers.fold(0) { sum, element -> sum + element * 2 }\n    println(sumDoubled)\n\n    //val sumDoubledReduce = numbers.reduce { sum, element -> sum + element * 2 } //incorrect: the first element isn't doubled in the result\n    //println(sumDoubledReduce)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n\n    val sum = numbers.reduce { sum, element -> sum + element }\n    println(sum)\n    val sumDoubled = numbers.fold(0) { sum, element -> sum + element * 2 }\n    println(sumDoubled)\n\n    //val sumDoubledReduce = numbers.reduce { sum, element -> sum + element * 2 } //incorrect: the first element isn't doubled in the result\n    //println(sumDoubledReduce)\n//sampleEnd\n}\n"}, {"type": "p", "text": "The example above shows the difference: fold() is used for calculating the sum of doubled elements.\nIf you pass the same function to reduce(), it will return another result because it uses the list's first and second elements as arguments on the first step, so the first element won't be doubled."}, {"type": "code", "text": "fold()"}, {"type": "code", "text": "reduce()"}, {"type": "p", "text": "To apply a function to elements in the reverse order, use functions reduceRight() and foldRight().\nThey work in a way similar to fold() and reduce() but start from the last element and then continue to previous.\nNote that when folding or reducing right, the operation arguments change their order: first goes the element, and then the accumulated value."}, {"type": "a", "text": "reduceRight()"}, {"type": "code", "text": "reduceRight()"}, {"type": "a", "text": "foldRight()"}, {"type": "code", "text": "foldRight()"}, {"type": "code", "text": "fold()"}, {"type": "code", "text": "reduce()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n    val sumDoubledRight = numbers.foldRight(0) { element, sum -> sum + element * 2 }\n    println(sumDoubledRight)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n    val sumDoubledRight = numbers.foldRight(0) { element, sum -> sum + element * 2 }\n    println(sumDoubledRight)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n    val sumDoubledRight = numbers.foldRight(0) { element, sum -> sum + element * 2 }\n    println(sumDoubledRight)\n//sampleEnd\n}\n"}, {"type": "p", "text": "You can also apply operations that take element indices as parameters.\nFor this purpose, use functions reduceIndexed() and foldIndexed() passing element index as the first argument of the operation."}, {"type": "a", "text": "reduceIndexed()"}, {"type": "code", "text": "reduceIndexed()"}, {"type": "a", "text": "foldIndexed()"}, {"type": "code", "text": "foldIndexed()"}, {"type": "p", "text": "Finally, there are functions that apply such operations to collection elements from right to left - reduceRightIndexed() and foldRightIndexed()."}, {"type": "a", "text": "reduceRightIndexed()"}, {"type": "code", "text": "reduceRightIndexed()"}, {"type": "a", "text": "foldRightIndexed()"}, {"type": "code", "text": "foldRightIndexed()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n    val sumEven = numbers.foldIndexed(0) { idx, sum, element -> if (idx % 2 == 0) sum + element else sum }\n    println(sumEven)\n\n    val sumEvenRight = numbers.foldRightIndexed(0) { idx, element, sum -> if (idx % 2 == 0) sum + element else sum }\n    println(sumEvenRight)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n    val sumEven = numbers.foldIndexed(0) { idx, sum, element -> if (idx % 2 == 0) sum + element else sum }\n    println(sumEven)\n\n    val sumEvenRight = numbers.foldRightIndexed(0) { idx, element, sum -> if (idx % 2 == 0) sum + element else sum }\n    println(sumEvenRight)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n    val sumEven = numbers.foldIndexed(0) { idx, sum, element -> if (idx % 2 == 0) sum + element else sum }\n    println(sumEven)\n\n    val sumEvenRight = numbers.foldRightIndexed(0) { idx, element, sum -> if (idx % 2 == 0) sum + element else sum }\n    println(sumEvenRight)\n//sampleEnd\n}\n"}]