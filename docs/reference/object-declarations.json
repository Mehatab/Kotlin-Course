[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Object Expressions and Declarations"}, {"type": "p", "text": "Sometimes we need to create an object of a slight modification of some class, without explicitly declaring a new subclass for it.\nKotlin handles this case with object expressions and object declarations."}, {"type": "em", "text": "object expressions"}, {"type": "em", "text": "object declarations"}, {"type": "h2", "text": "Object expressions"}, {"type": "p", "text": "To create an object of an anonymous class that inherits from some type (or types), we write:"}, {"type": "div", "text": "\nwindow.addMouseListener(object : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) { /*...*/ }\n\n    override fun mouseEntered(e: MouseEvent) { /*...*/ }\n})\n\n"}, {"type": "pre", "text": "window.addMouseListener(object : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) { /*...*/ }\n\n    override fun mouseEntered(e: MouseEvent) { /*...*/ }\n})\n"}, {"type": "code", "text": "window.addMouseListener(object : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) { /*...*/ }\n\n    override fun mouseEntered(e: MouseEvent) { /*...*/ }\n})\n"}, {"type": "p", "text": "If a supertype has a constructor, appropriate constructor parameters must be passed to it.\nMany supertypes may be specified as a comma-separated list after the colon:"}, {"type": "div", "text": "\nopen class A(x: Int) {\n    public open val y: Int = x\n}\n\ninterface B { /*...*/ }\n\nval ab: A = object : A(1), B {\n    override val y = 15\n}\n\n"}, {"type": "pre", "text": "open class A(x: Int) {\n    public open val y: Int = x\n}\n\ninterface B { /*...*/ }\n\nval ab: A = object : A(1), B {\n    override val y = 15\n}\n"}, {"type": "code", "text": "open class A(x: Int) {\n    public open val y: Int = x\n}\n\ninterface B { /*...*/ }\n\nval ab: A = object : A(1), B {\n    override val y = 15\n}\n"}, {"type": "p", "text": "If, by any chance, we need \"just an object\", with no nontrivial supertypes, we can simply say:"}, {"type": "div", "text": "\nfun foo() {\n    val adHoc = object {\n        var x: Int = 0\n        var y: Int = 0\n    }\n    print(adHoc.x + adHoc.y)\n}\n\n"}, {"type": "pre", "text": "fun foo() {\n    val adHoc = object {\n        var x: Int = 0\n        var y: Int = 0\n    }\n    print(adHoc.x + adHoc.y)\n}\n"}, {"type": "code", "text": "fun foo() {\n    val adHoc = object {\n        var x: Int = 0\n        var y: Int = 0\n    }\n    print(adHoc.x + adHoc.y)\n}\n"}, {"type": "p", "text": "Note that anonymous objects can be used as types only in local and private declarations. If you use an anonymous object as a\nreturn type of a public function or the type of a public property, the actual type of that function or property\nwill be the declared supertype of the anonymous object, or Any if you didn't declare any supertype. Members added\nin the anonymous object will not be accessible."}, {"type": "code", "text": "Any"}, {"type": "div", "text": "\nclass C {\n    // Private function, so the return type is the anonymous object type\n    private fun foo() = object {\n        val x: String = \"x\"\n    }\n\n    // Public function, so the return type is Any\n    fun publicFoo() = object {\n        val x: String = \"x\"\n    }\n\n    fun bar() {\n        val x1 = foo().x        // Works\n        val x2 = publicFoo().x  // ERROR: Unresolved reference 'x'\n    }\n}\n\n"}, {"type": "pre", "text": "class C {\n    // Private function, so the return type is the anonymous object type\n    private fun foo() = object {\n        val x: String = \"x\"\n    }\n\n    // Public function, so the return type is Any\n    fun publicFoo() = object {\n        val x: String = \"x\"\n    }\n\n    fun bar() {\n        val x1 = foo().x        // Works\n        val x2 = publicFoo().x  // ERROR: Unresolved reference 'x'\n    }\n}\n"}, {"type": "code", "text": "class C {\n    // Private function, so the return type is the anonymous object type\n    private fun foo() = object {\n        val x: String = \"x\"\n    }\n\n    // Public function, so the return type is Any\n    fun publicFoo() = object {\n        val x: String = \"x\"\n    }\n\n    fun bar() {\n        val x1 = foo().x        // Works\n        val x2 = publicFoo().x  // ERROR: Unresolved reference 'x'\n    }\n}\n"}, {"type": "p", "text": "The code in object expressions can access variables from the enclosing scope."}, {"type": "div", "text": "\nfun countClicks(window: JComponent) {\n    var clickCount = 0\n    var enterCount = 0\n\n    window.addMouseListener(object : MouseAdapter() {\n        override fun mouseClicked(e: MouseEvent) {\n            clickCount++\n        }\n\n        override fun mouseEntered(e: MouseEvent) {\n            enterCount++\n        }\n    })\n    // ...\n}\n\n"}, {"type": "pre", "text": "fun countClicks(window: JComponent) {\n    var clickCount = 0\n    var enterCount = 0\n\n    window.addMouseListener(object : MouseAdapter() {\n        override fun mouseClicked(e: MouseEvent) {\n            clickCount++\n        }\n\n        override fun mouseEntered(e: MouseEvent) {\n            enterCount++\n        }\n    })\n    // ...\n}\n"}, {"type": "code", "text": "fun countClicks(window: JComponent) {\n    var clickCount = 0\n    var enterCount = 0\n\n    window.addMouseListener(object : MouseAdapter() {\n        override fun mouseClicked(e: MouseEvent) {\n            clickCount++\n        }\n\n        override fun mouseEntered(e: MouseEvent) {\n            enterCount++\n        }\n    })\n    // ...\n}\n"}, {"type": "h2", "text": "Object declarations"}, {"type": "p", "text": "Singleton may be useful in several cases,\nand Kotlin (after Scala) makes it easy to declare singletons:"}, {"type": "a", "text": "Singleton"}, {"type": "div", "text": "\nobject DataProviderManager {\n    fun registerDataProvider(provider: DataProvider) {\n        // ...\n    }\n\n    val allDataProviders: Collection<DataProvider>\n        get() = // ...\n}\n\n"}, {"type": "pre", "text": "object DataProviderManager {\n    fun registerDataProvider(provider: DataProvider) {\n        // ...\n    }\n\n    val allDataProviders: Collection<DataProvider>\n        get() = // ...\n}\n"}, {"type": "code", "text": "object DataProviderManager {\n    fun registerDataProvider(provider: DataProvider) {\n        // ...\n    }\n\n    val allDataProviders: Collection<DataProvider>\n        get() = // ...\n}\n"}, {"type": "p", "text": "This is called an object declaration, and it always has a name following the object keyword.\nJust like a variable declaration, an object declaration is not an expression, and cannot be used on the right hand side of an assignment statement."}, {"type": "em", "text": "object declaration"}, {"type": "em", "text": "object"}, {"type": "p", "text": "Object declaration's initialization is thread-safe and done at first access."}, {"type": "p", "text": "To refer to the object, we use its name directly:"}, {"type": "div", "text": "\nDataProviderManager.registerDataProvider(...)\n\n"}, {"type": "pre", "text": "DataProviderManager.registerDataProvider(...)\n"}, {"type": "code", "text": "DataProviderManager.registerDataProvider(...)\n"}, {"type": "p", "text": "Such objects can have supertypes:"}, {"type": "div", "text": "\nobject DefaultListener : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) { ... }\n\n    override fun mouseEntered(e: MouseEvent) { ... }\n}\n\n"}, {"type": "pre", "text": "object DefaultListener : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) { ... }\n\n    override fun mouseEntered(e: MouseEvent) { ... }\n}\n"}, {"type": "code", "text": "object DefaultListener : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) { ... }\n\n    override fun mouseEntered(e: MouseEvent) { ... }\n}\n"}, {"type": "p", "text": "NOTE: object declarations can't be local (i.e. be nested directly inside a function), but they can be nested into other object declarations or non-inner classes."}, {"type": "strong", "text": "NOTE"}, {"type": "h3", "text": "Companion Objects"}, {"type": "p", "text": "An object declaration inside a class can be marked with the companion keyword:"}, {"type": "em", "text": "companion"}, {"type": "div", "text": "\nclass MyClass {\n    companion object Factory {\n        fun create(): MyClass = MyClass()\n    }\n}\n\n"}, {"type": "pre", "text": "class MyClass {\n    companion object Factory {\n        fun create(): MyClass = MyClass()\n    }\n}\n"}, {"type": "code", "text": "class MyClass {\n    companion object Factory {\n        fun create(): MyClass = MyClass()\n    }\n}\n"}, {"type": "p", "text": "Members of the companion object can be called by using simply the class name as the qualifier:"}, {"type": "div", "text": "\nval instance = MyClass.create()\n\n"}, {"type": "pre", "text": "val instance = MyClass.create()\n"}, {"type": "code", "text": "val instance = MyClass.create()\n"}, {"type": "p", "text": "The name of the companion object can be omitted, in which case the name Companion will be used:"}, {"type": "code", "text": "Companion"}, {"type": "div", "text": "\nclass MyClass {\n    companion object { }\n}\n\nval x = MyClass.Companion\n\n"}, {"type": "pre", "text": "class MyClass {\n    companion object { }\n}\n\nval x = MyClass.Companion\n"}, {"type": "code", "text": "class MyClass {\n    companion object { }\n}\n\nval x = MyClass.Companion\n"}, {"type": "p", "text": "The name of a class used by itself (not as a qualifier to another name) acts as a reference to the companion\nobject of the class (whether named or not):"}, {"type": "div", "text": "\nclass MyClass1 {\n    companion object Named { }\n}\n\nval x = MyClass1\n\nclass MyClass2 {\n    companion object { }\n}\n\nval y = MyClass2\n\n"}, {"type": "pre", "text": "class MyClass1 {\n    companion object Named { }\n}\n\nval x = MyClass1\n\nclass MyClass2 {\n    companion object { }\n}\n\nval y = MyClass2\n"}, {"type": "code", "text": "class MyClass1 {\n    companion object Named { }\n}\n\nval x = MyClass1\n\nclass MyClass2 {\n    companion object { }\n}\n\nval y = MyClass2\n"}, {"type": "p", "text": "Note that, even though the members of companion objects look like static members in other languages, at runtime those\nare still instance members of real objects, and can, for example, implement interfaces:"}, {"type": "div", "text": "\ninterface Factory<T> {\n    fun create(): T\n}\n\nclass MyClass {\n    companion object : Factory<MyClass> {\n        override fun create(): MyClass = MyClass()\n    }\n}\n\nval f: Factory<MyClass> = MyClass\n\n"}, {"type": "pre", "text": "interface Factory<T> {\n    fun create(): T\n}\n\nclass MyClass {\n    companion object : Factory<MyClass> {\n        override fun create(): MyClass = MyClass()\n    }\n}\n\nval f: Factory<MyClass> = MyClass\n"}, {"type": "code", "text": "interface Factory<T> {\n    fun create(): T\n}\n\nclass MyClass {\n    companion object : Factory<MyClass> {\n        override fun create(): MyClass = MyClass()\n    }\n}\n\nval f: Factory<MyClass> = MyClass\n"}, {"type": "p", "text": "However, on the JVM you can have members of companion objects generated as real static methods and fields, if you use\nthe @JvmStatic annotation. See the Java interoperability section\nfor more details."}, {"type": "code", "text": "@JvmStatic"}, {"type": "a", "text": "Java interoperability"}, {"type": "h3", "text": "Semantic difference between object expressions and declarations"}, {"type": "p", "text": "There is one important semantic difference between object expressions and object declarations:"}, {"type": "ul", "text": "\nobject expressions are executed (and initialized) immediately, where they are used;\nobject declarations are initialized lazily, when accessed for the first time;\na companion object is initialized when the corresponding class is loaded (resolved), matching the semantics of a Java static initializer.\n"}, {"type": "li", "text": "object expressions are executed (and initialized) immediately, where they are used;"}, {"type": "strong", "text": "immediately"}, {"type": "li", "text": "object declarations are initialized lazily, when accessed for the first time;"}, {"type": "strong", "text": "lazily"}, {"type": "li", "text": "a companion object is initialized when the corresponding class is loaded (resolved), matching the semantics of a Java static initializer."}]