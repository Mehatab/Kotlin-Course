[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Calling Java code from Kotlin"}, {"type": "p", "text": "Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from\nJava rather smoothly as well. In this section we describe some details about calling Java code from Kotlin."}, {"type": "p", "text": "Pretty much all Java code can be used without any issues:"}, {"type": "div", "text": "\nimport java.util.*\n\nfun demo(source: List<Int>) {\n    val list = ArrayList<Int>()\n    // 'for'-loops work for Java collections:\n    for (item in source) {\n        list.add(item)\n    }\n    // Operator conventions work as well:\n    for (i in 0..source.size - 1) {\n        list[i] = source[i] // get and set are called\n    }\n}\n\n"}, {"type": "pre", "text": "import java.util.*\n\nfun demo(source: List<Int>) {\n    val list = ArrayList<Int>()\n    // 'for'-loops work for Java collections:\n    for (item in source) {\n        list.add(item)\n    }\n    // Operator conventions work as well:\n    for (i in 0..source.size - 1) {\n        list[i] = source[i] // get and set are called\n    }\n}\n"}, {"type": "code", "text": "import java.util.*\n\nfun demo(source: List<Int>) {\n    val list = ArrayList<Int>()\n    // 'for'-loops work for Java collections:\n    for (item in source) {\n        list.add(item)\n    }\n    // Operator conventions work as well:\n    for (i in 0..source.size - 1) {\n        list[i] = source[i] // get and set are called\n    }\n}\n"}, {"type": "h2", "text": "Getters and Setters"}, {"type": "p", "text": "Methods that follow the Java conventions for getters and setters (no-argument methods with names starting with get\nand single-argument methods with names starting with set) are represented as properties in Kotlin.\nBoolean accessor methods (where the name of the getter starts with is and the name of the setter starts with set)\nare represented as properties which have the same name as the getter method."}, {"type": "code", "text": "get"}, {"type": "code", "text": "set"}, {"type": "code", "text": "Boolean"}, {"type": "code", "text": "is"}, {"type": "code", "text": "set"}, {"type": "p", "text": "For example:"}, {"type": "div", "text": "\nimport java.util.Calendar\n\nfun calendarDemo() {\n    val calendar = Calendar.getInstance()\n    if (calendar.firstDayOfWeek == Calendar.SUNDAY) {  // call getFirstDayOfWeek()\n        calendar.firstDayOfWeek = Calendar.MONDAY      // call setFirstDayOfWeek()\n    }\n    if (!calendar.isLenient) {                         // call isLenient()\n        calendar.isLenient = true                      // call setLenient()\n    }\n}\n\n"}, {"type": "pre", "text": "import java.util.Calendar\n\nfun calendarDemo() {\n    val calendar = Calendar.getInstance()\n    if (calendar.firstDayOfWeek == Calendar.SUNDAY) {  // call getFirstDayOfWeek()\n        calendar.firstDayOfWeek = Calendar.MONDAY      // call setFirstDayOfWeek()\n    }\n    if (!calendar.isLenient) {                         // call isLenient()\n        calendar.isLenient = true                      // call setLenient()\n    }\n}\n"}, {"type": "code", "text": "import java.util.Calendar\n\nfun calendarDemo() {\n    val calendar = Calendar.getInstance()\n    if (calendar.firstDayOfWeek == Calendar.SUNDAY) {  // call getFirstDayOfWeek()\n        calendar.firstDayOfWeek = Calendar.MONDAY      // call setFirstDayOfWeek()\n    }\n    if (!calendar.isLenient) {                         // call isLenient()\n        calendar.isLenient = true                      // call setLenient()\n    }\n}\n"}, {"type": "p", "text": "Note that, if the Java class only has a setter, it will not be visible as a property in Kotlin, because Kotlin does not support set-only properties at this time."}, {"type": "h2", "text": "Methods returning void"}, {"type": "p", "text": "If a Java method returns void, it will return Unit when called from Kotlin.\nIf, by any chance, someone uses that return value, it will be assigned at the call site by the Kotlin compiler,\nsince the value itself is known in advance (being Unit)."}, {"type": "code", "text": "Unit"}, {"type": "code", "text": "Unit"}, {"type": "h2", "text": "Escaping for Java identifiers that are keywords in Kotlin"}, {"type": "p", "text": "Some of the Kotlin keywords are valid identifiers in Java: in, object, is, etc.\nIf a Java library uses a Kotlin keyword for a method, you can still call the method\nescaping it with the backtick (`) character:"}, {"type": "em", "text": "in"}, {"type": "em", "text": "object"}, {"type": "em", "text": "is"}, {"type": "div", "text": "\nfoo.`is`(bar)\n\n"}, {"type": "pre", "text": "foo.`is`(bar)\n"}, {"type": "code", "text": "foo.`is`(bar)\n"}, {"type": "h2", "text": "Null-Safety and Platform Types"}, {"type": "p", "text": "Any reference in Java may be null, which makes Kotlin's requirements of strict null-safety impractical for objects coming from Java.\nTypes of Java declarations are treated specially in Kotlin and called platform types. Null-checks are relaxed for such types,\nso that safety guarantees for them are the same as in Java (see more below)."}, {"type": "em", "text": "null"}, {"type": "em", "text": "platform types"}, {"type": "a", "text": "below"}, {"type": "p", "text": "Consider the following examples:"}, {"type": "div", "text": "\nval list = ArrayList<String>() // non-null (constructor result)\nlist.add(\"Item\")\nval size = list.size // non-null (primitive int)\nval item = list[0] // platform type inferred (ordinary Java object)\n\n"}, {"type": "pre", "text": "val list = ArrayList<String>() // non-null (constructor result)\nlist.add(\"Item\")\nval size = list.size // non-null (primitive int)\nval item = list[0] // platform type inferred (ordinary Java object)\n"}, {"type": "code", "text": "val list = ArrayList<String>() // non-null (constructor result)\nlist.add(\"Item\")\nval size = list.size // non-null (primitive int)\nval item = list[0] // platform type inferred (ordinary Java object)\n"}, {"type": "p", "text": "When we call methods on variables of platform types, Kotlin does not issue nullability errors at compile time,\nbut the call may fail at runtime, because of a null-pointer exception or an assertion that Kotlin generates to\nprevent nulls from propagating:"}, {"type": "div", "text": "\nitem.substring(1) // allowed, may throw an exception if item == null\n\n"}, {"type": "pre", "text": "item.substring(1) // allowed, may throw an exception if item == null\n"}, {"type": "code", "text": "item.substring(1) // allowed, may throw an exception if item == null\n"}, {"type": "p", "text": "Platform types are non-denotable, meaning that one can not write them down explicitly in the language.\nWhen a platform value is assigned to a Kotlin variable, we can rely on type inference (the variable will have an inferred platform type then,\n as item has in the example above), or we can choose the type that we expect (both nullable and non-null types are allowed):"}, {"type": "em", "text": "non-denotable"}, {"type": "code", "text": "item"}, {"type": "div", "text": "\nval nullable: String? = item // allowed, always works\nval notNull: String = item // allowed, may fail at runtime\n\n"}, {"type": "pre", "text": "val nullable: String? = item // allowed, always works\nval notNull: String = item // allowed, may fail at runtime\n"}, {"type": "code", "text": "val nullable: String? = item // allowed, always works\nval notNull: String = item // allowed, may fail at runtime\n"}, {"type": "p", "text": "If we choose a non-null type, the compiler will emit an assertion upon assignment. This prevents Kotlin's non-null variables from holding\nnulls. Assertions are also emitted when we pass platform values to Kotlin functions expecting non-null values etc.\nOverall, the compiler does its best to prevent nulls from propagating far through the program (although sometimes this is\nimpossible to eliminate entirely, because of generics)."}, {"type": "h3", "text": "Notation for Platform Types"}, {"type": "p", "text": "As mentioned above, platform types cannot be mentioned explicitly in the program, so there's no syntax for them in the language.\nNevertheless, the compiler and IDE need to display them sometimes (in error messages, parameter info etc), so we have a\nmnemonic notation for them:"}, {"type": "ul", "text": "\nT! means \"T or T?\",\n(Mutable)Collection<T>! means \"Java collection of T may be mutable or not, may be nullable or not\",\nArray<(out) T>! means \"Java array of T (or a subtype of T), nullable or not\"\n"}, {"type": "li", "text": "T! means \"T or T?\","}, {"type": "code", "text": "T!"}, {"type": "code", "text": "T"}, {"type": "code", "text": "T?"}, {"type": "li", "text": "(Mutable)Collection<T>! means \"Java collection of T may be mutable or not, may be nullable or not\","}, {"type": "code", "text": "(Mutable)Collection<T>!"}, {"type": "code", "text": "T"}, {"type": "li", "text": "Array<(out) T>! means \"Java array of T (or a subtype of T), nullable or not\""}, {"type": "code", "text": "Array<(out) T>!"}, {"type": "code", "text": "T"}, {"type": "code", "text": "T"}, {"type": "h3", "text": "Nullability annotations"}, {"type": "p", "text": "Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null\nKotlin types. The compiler supports several flavors of nullability annotations, including:"}, {"type": "ul", "text": "\nJetBrains\n(@Nullable and @NotNull from the org.jetbrains.annotations package)\nAndroid (com.android.annotations and android.support.annotations)\nJSR-305 (javax.annotation, more details below)\nFindBugs (edu.umd.cs.findbugs.annotations)\nEclipse (org.eclipse.jdt.annotation)\nLombok (lombok.NonNull).\n"}, {"type": "li", "text": "JetBrains\n(@Nullable and @NotNull from the org.jetbrains.annotations package)"}, {"type": "a", "text": "JetBrains"}, {"type": "code", "text": "@Nullable"}, {"type": "code", "text": "@NotNull"}, {"type": "code", "text": "org.jetbrains.annotations"}, {"type": "li", "text": "Android (com.android.annotations and android.support.annotations)"}, {"type": "code", "text": "com.android.annotations"}, {"type": "code", "text": "android.support.annotations"}, {"type": "li", "text": "JSR-305 (javax.annotation, more details below)"}, {"type": "code", "text": "javax.annotation"}, {"type": "li", "text": "FindBugs (edu.umd.cs.findbugs.annotations)"}, {"type": "code", "text": "edu.umd.cs.findbugs.annotations"}, {"type": "li", "text": "Eclipse (org.eclipse.jdt.annotation)"}, {"type": "code", "text": "org.eclipse.jdt.annotation"}, {"type": "li", "text": "Lombok (lombok.NonNull)."}, {"type": "code", "text": "lombok.NonNull"}, {"type": "p", "text": "You can find the full list in the Kotlin compiler source code."}, {"type": "a", "text": "Kotlin compiler source code"}, {"type": "h3", "text": "Annotating type parameters"}, {"type": "p", "text": "It is possible to annotate type arguments of generic types to provide nullability information for them as well. For example, consider these annotations on a Java declaration:"}, {"type": "div", "text": "\n@NotNull\nSet<@NotNull String> toSet(@NotNull Collection<@NotNull String> elements) { ... }\n\n"}, {"type": "pre", "text": "@NotNull\nSet<@NotNull String> toSet(@NotNull Collection<@NotNull String> elements) { ... }\n"}, {"type": "code", "text": "@NotNull\nSet<@NotNull String> toSet(@NotNull Collection<@NotNull String> elements) { ... }\n"}, {"type": "p", "text": "It leads to the following signature seen in Kotlin:"}, {"type": "div", "text": "\nfun toSet(elements: (Mutable)Collection<String>) : (Mutable)Set<String> { ... }\n\n"}, {"type": "pre", "text": "fun toSet(elements: (Mutable)Collection<String>) : (Mutable)Set<String> { ... }\n"}, {"type": "code", "text": "fun toSet(elements: (Mutable)Collection<String>) : (Mutable)Set<String> { ... }\n"}, {"type": "p", "text": "Note the @NotNull annotations on String type arguments. Without them, we get platform types in the type arguments:"}, {"type": "code", "text": "@NotNull"}, {"type": "code", "text": "String"}, {"type": "div", "text": "\nfun toSet(elements: (Mutable)Collection<String!>) : (Mutable)Set<String!> { ... }\n\n"}, {"type": "pre", "text": "fun toSet(elements: (Mutable)Collection<String!>) : (Mutable)Set<String!> { ... }\n"}, {"type": "code", "text": "fun toSet(elements: (Mutable)Collection<String!>) : (Mutable)Set<String!> { ... }\n"}, {"type": "p", "text": "Annotating type arguments works with Java 8 target or higher and requires the nullability annotations to support the TYPE_USE target (org.jetbrains.annotations supports this in version 15 and above)."}, {"type": "code", "text": "TYPE_USE"}, {"type": "code", "text": "org.jetbrains.annotations"}, {"type": "blockquote", "text": "\nNote: due to the current technical limitations, the IDE does not correctly recognize these annotations on type arguments in compiled Java libraries that are used as dependencies.\n"}, {"type": "p", "text": "Note: due to the current technical limitations, the IDE does not correctly recognize these annotations on type arguments in compiled Java libraries that are used as dependencies."}, {"type": "h3", "text": "JSR-305 Support"}, {"type": "p", "text": "The @Nonnull annotation defined\nin JSR-305 is supported for denoting nullability of Java types."}, {"type": "a", "text": "@Nonnull"}, {"type": "code", "text": "@Nonnull"}, {"type": "a", "text": "JSR-305"}, {"type": "p", "text": "If the @Nonnull(when = ...) value is When.ALWAYS, the annotated type is treated as non-null; When.MAYBE and\nWhen.NEVER denote a nullable type; and When.UNKNOWN forces the type to be platform one."}, {"type": "code", "text": "@Nonnull(when = ...)"}, {"type": "code", "text": "When.ALWAYS"}, {"type": "code", "text": "When.MAYBE"}, {"type": "code", "text": "When.NEVER"}, {"type": "code", "text": "When.UNKNOWN"}, {"type": "a", "text": "platform one"}, {"type": "p", "text": "A library can be compiled against the JSR-305 annotations, but there's no need to make the annotations artifact (e.g. jsr305.jar)\na compile dependency for the library consumers. The Kotlin compiler can read the JSR-305 annotations from a library without the annotations\npresent on the classpath."}, {"type": "code", "text": "jsr305.jar"}, {"type": "p", "text": "Since Kotlin 1.1.50,\ncustom nullability qualifiers (KEEP-79)\nare also supported (see below)."}, {"type": "a", "text": "custom nullability qualifiers (KEEP-79)"}, {"type": "h4", "text": "Type qualifier nicknames (since 1.1.50)"}, {"type": "p", "text": "If an annotation type is annotated with both\n@TypeQualifierNickname\nand JSR-305 @Nonnull (or its another nickname, such as @CheckForNull), then the annotation type is itself used for\nretrieving precise nullability and has the same meaning as that nullability annotation:"}, {"type": "a", "text": "@TypeQualifierNickname"}, {"type": "code", "text": "@TypeQualifierNickname"}, {"type": "code", "text": "@Nonnull"}, {"type": "code", "text": "@CheckForNull"}, {"type": "div", "text": "\n@TypeQualifierNickname\n@Nonnull(when = When.ALWAYS)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyNonnull {\n}\n\n@TypeQualifierNickname\n@CheckForNull // a nickname to another type qualifier nickname\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyNullable {\n}\n\ninterface A {\n    @MyNullable String foo(@MyNonnull String x);\n    // in Kotlin (strict mode): `fun foo(x: String): String?`\n\n    String bar(List<@MyNonnull String> x);\n    // in Kotlin (strict mode): `fun bar(x: List<String>!): String!`\n}\n\n"}, {"type": "pre", "text": "@TypeQualifierNickname\n@Nonnull(when = When.ALWAYS)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyNonnull {\n}\n\n@TypeQualifierNickname\n@CheckForNull // a nickname to another type qualifier nickname\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyNullable {\n}\n\ninterface A {\n    @MyNullable String foo(@MyNonnull String x);\n    // in Kotlin (strict mode): `fun foo(x: String): String?`\n\n    String bar(List<@MyNonnull String> x);\n    // in Kotlin (strict mode): `fun bar(x: List<String>!): String!`\n}\n"}, {"type": "code", "text": "@TypeQualifierNickname\n@Nonnull(when = When.ALWAYS)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyNonnull {\n}\n\n@TypeQualifierNickname\n@CheckForNull // a nickname to another type qualifier nickname\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyNullable {\n}\n\ninterface A {\n    @MyNullable String foo(@MyNonnull String x);\n    // in Kotlin (strict mode): `fun foo(x: String): String?`\n\n    String bar(List<@MyNonnull String> x);\n    // in Kotlin (strict mode): `fun bar(x: List<String>!): String!`\n}\n"}, {"type": "h4", "text": "Type qualifier defaults (since 1.1.50)"}, {"type": "p", "text": "@TypeQualifierDefault\nallows introducing annotations that, when being applied, define the default nullability within the scope of the annotated\nelement."}, {"type": "a", "text": "@TypeQualifierDefault"}, {"type": "code", "text": "@TypeQualifierDefault"}, {"type": "p", "text": "Such annotation type should itself be annotated with both @Nonnull (or its nickname) and @TypeQualifierDefault(...)\nwith one or more ElementType values:"}, {"type": "code", "text": "@Nonnull"}, {"type": "code", "text": "@TypeQualifierDefault(...)"}, {"type": "code", "text": "ElementType"}, {"type": "ul", "text": "\nElementType.METHOD for return types of methods;\nElementType.PARAMETER for value parameters;\nElementType.FIELD for fields; and\nElementType.TYPE_USE (since 1.1.60) for any type including type arguments, upper bounds of type parameters and wildcard types.\n"}, {"type": "li", "text": "ElementType.METHOD for return types of methods;"}, {"type": "code", "text": "ElementType.METHOD"}, {"type": "li", "text": "ElementType.PARAMETER for value parameters;"}, {"type": "code", "text": "ElementType.PARAMETER"}, {"type": "li", "text": "ElementType.FIELD for fields; and"}, {"type": "code", "text": "ElementType.FIELD"}, {"type": "li", "text": "ElementType.TYPE_USE (since 1.1.60) for any type including type arguments, upper bounds of type parameters and wildcard types."}, {"type": "code", "text": "ElementType.TYPE_USE"}, {"type": "p", "text": "The default nullability is used when a type itself is not annotated by a nullability annotation, and the default is\ndetermined by the innermost enclosing element annotated with a type qualifier default annotation with the\nElementType matching the type usage."}, {"type": "code", "text": "ElementType"}, {"type": "div", "text": "\n@Nonnull\n@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})\npublic @interface NonNullApi {\n}\n\n@Nonnull(when = When.MAYBE)\n@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE_USE})\npublic @interface NullableApi {\n}\n\n@NullableApi\ninterface A {\n    String foo(String x); // fun foo(x: String?): String?\n\n    @NotNullApi // overriding default from the interface\n    String bar(String x, @Nullable String y); // fun bar(x: String, y: String?): String\n\n    // The List<String> type argument is seen as nullable because of `@NullableApi`\n    // having the `TYPE_USE` element type:\n    String baz(List<String> x); // fun baz(List<String?>?): String?\n\n    // The type of `x` parameter remains platform because there's an explicit\n    // UNKNOWN-marked nullability annotation:\n    String qux(@Nonnull(when = When.UNKNOWN) String x); // fun baz(x: String!): String?\n}\n\n"}, {"type": "pre", "text": "@Nonnull\n@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})\npublic @interface NonNullApi {\n}\n\n@Nonnull(when = When.MAYBE)\n@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE_USE})\npublic @interface NullableApi {\n}\n\n@NullableApi\ninterface A {\n    String foo(String x); // fun foo(x: String?): String?\n\n    @NotNullApi // overriding default from the interface\n    String bar(String x, @Nullable String y); // fun bar(x: String, y: String?): String\n\n    // The List<String> type argument is seen as nullable because of `@NullableApi`\n    // having the `TYPE_USE` element type:\n    String baz(List<String> x); // fun baz(List<String?>?): String?\n\n    // The type of `x` parameter remains platform because there's an explicit\n    // UNKNOWN-marked nullability annotation:\n    String qux(@Nonnull(when = When.UNKNOWN) String x); // fun baz(x: String!): String?\n}\n"}, {"type": "code", "text": "@Nonnull\n@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})\npublic @interface NonNullApi {\n}\n\n@Nonnull(when = When.MAYBE)\n@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE_USE})\npublic @interface NullableApi {\n}\n\n@NullableApi\ninterface A {\n    String foo(String x); // fun foo(x: String?): String?\n\n    @NotNullApi // overriding default from the interface\n    String bar(String x, @Nullable String y); // fun bar(x: String, y: String?): String\n\n    // The List<String> type argument is seen as nullable because of `@NullableApi`\n    // having the `TYPE_USE` element type:\n    String baz(List<String> x); // fun baz(List<String?>?): String?\n\n    // The type of `x` parameter remains platform because there's an explicit\n    // UNKNOWN-marked nullability annotation:\n    String qux(@Nonnull(when = When.UNKNOWN) String x); // fun baz(x: String!): String?\n}\n"}, {"type": "blockquote", "text": "\nNote: the types in this example only take place with the strict mode enabled, otherwise, the platform types remain. See the @UnderMigration annotation and Compiler configuration sections.\n"}, {"type": "p", "text": "Note: the types in this example only take place with the strict mode enabled, otherwise, the platform types remain. See the @UnderMigration annotation and Compiler configuration sections."}, {"type": "a", "text": "@UnderMigration annotation"}, {"type": "code", "text": "@UnderMigration"}, {"type": "a", "text": "Compiler configuration"}, {"type": "p", "text": "Package-level default nullability is also supported:"}, {"type": "div", "text": "\n// FILE: test/package-info.java\n@NonNullApi // declaring all types in package 'test' as non-nullable by default\npackage test;\n\n"}, {"type": "pre", "text": "// FILE: test/package-info.java\n@NonNullApi // declaring all types in package 'test' as non-nullable by default\npackage test;\n"}, {"type": "code", "text": "// FILE: test/package-info.java\n@NonNullApi // declaring all types in package 'test' as non-nullable by default\npackage test;\n"}, {"type": "h4", "text": "@UnderMigration annotation (since 1.1.60)"}, {"type": "code", "text": "@UnderMigration"}, {"type": "p", "text": "The @UnderMigration annotation (provided in a separate artifact kotlin-annotations-jvm) can be used by library\nmaintainers to define the migration status for the nullability type qualifiers."}, {"type": "code", "text": "@UnderMigration"}, {"type": "code", "text": "kotlin-annotations-jvm"}, {"type": "p", "text": "The status value in @UnderMigration(status = ...) specifies how the compiler treats inappropriate usages of the\nannotated types in Kotlin (e.g. using a @MyNullable-annotated type value as non-null):"}, {"type": "code", "text": "@UnderMigration(status = ...)"}, {"type": "code", "text": "@MyNullable"}, {"type": "ul", "text": "\n\nMigrationStatus.STRICT makes annotation work as any plain nullability annotation, i.e. report errors for\nthe inappropriate usages and affect the types in the annotated declarations as they are seen in Kotlin;\n\n\nwith MigrationStatus.WARN, the inappropriate usages are reported as compilation warnings instead of errors,\nbut the types in the annotated declarations remain platform; and\n\n\nMigrationStatus.IGNORE makes the compiler ignore the nullability annotation completely.\n\n"}, {"type": "li", "text": "\nMigrationStatus.STRICT makes annotation work as any plain nullability annotation, i.e. report errors for\nthe inappropriate usages and affect the types in the annotated declarations as they are seen in Kotlin;\n"}, {"type": "p", "text": "MigrationStatus.STRICT makes annotation work as any plain nullability annotation, i.e. report errors for\nthe inappropriate usages and affect the types in the annotated declarations as they are seen in Kotlin;"}, {"type": "code", "text": "MigrationStatus.STRICT"}, {"type": "li", "text": "\nwith MigrationStatus.WARN, the inappropriate usages are reported as compilation warnings instead of errors,\nbut the types in the annotated declarations remain platform; and\n"}, {"type": "p", "text": "with MigrationStatus.WARN, the inappropriate usages are reported as compilation warnings instead of errors,\nbut the types in the annotated declarations remain platform; and"}, {"type": "code", "text": "MigrationStatus.WARN"}, {"type": "li", "text": "\nMigrationStatus.IGNORE makes the compiler ignore the nullability annotation completely.\n"}, {"type": "p", "text": "MigrationStatus.IGNORE makes the compiler ignore the nullability annotation completely."}, {"type": "code", "text": "MigrationStatus.IGNORE"}, {"type": "p", "text": "A library maintainer can add @UnderMigration status to both type qualifier nicknames and type qualifier defaults:"}, {"type": "code", "text": "@UnderMigration"}, {"type": "div", "text": "\n@Nonnull(when = When.ALWAYS)\n@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})\n@UnderMigration(status = MigrationStatus.WARN)\npublic @interface NonNullApi {\n}\n\n// The types in the class are non-null, but only warnings are reported\n// because `@NonNullApi` is annotated `@UnderMigration(status = MigrationStatus.WARN)`\n@NonNullApi\npublic class Test {}\n\n"}, {"type": "pre", "text": "@Nonnull(when = When.ALWAYS)\n@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})\n@UnderMigration(status = MigrationStatus.WARN)\npublic @interface NonNullApi {\n}\n\n// The types in the class are non-null, but only warnings are reported\n// because `@NonNullApi` is annotated `@UnderMigration(status = MigrationStatus.WARN)`\n@NonNullApi\npublic class Test {}\n"}, {"type": "code", "text": "@Nonnull(when = When.ALWAYS)\n@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})\n@UnderMigration(status = MigrationStatus.WARN)\npublic @interface NonNullApi {\n}\n\n// The types in the class are non-null, but only warnings are reported\n// because `@NonNullApi` is annotated `@UnderMigration(status = MigrationStatus.WARN)`\n@NonNullApi\npublic class Test {}\n"}, {"type": "p", "text": "Note: the migration status of a nullability annotation is not inherited by its type qualifier nicknames but is applied\nto its usages in default type qualifiers."}, {"type": "p", "text": "If a default type qualifier uses a type qualifier nickname and they are both @UnderMigration, the status\nfrom the default type qualifier is used."}, {"type": "code", "text": "@UnderMigration"}, {"type": "h4", "text": "Compiler configuration"}, {"type": "p", "text": "The JSR-305 checks can be configured by adding the -Xjsr305 compiler flag with the following options (and their combination):"}, {"type": "code", "text": "-Xjsr305"}, {"type": "ul", "text": "\n\n-Xjsr305={strict|warn|ignore} to set up the behavior for non-@UnderMigration annotations.\nCustom nullability qualifiers, especially\n@TypeQualifierDefault, are already spread among many well-known libraries, and users may need to migrate smoothly when\nupdating to the Kotlin version containing JSR-305 support. Since Kotlin 1.1.60, this flag only affects non-@UnderMigration annotations.\n\n\n-Xjsr305=under-migration:{strict|warn|ignore} (since 1.1.60) to override the behavior for the @UnderMigration annotations.\nUsers may have different view on the migration status for the libraries:\nthey may want to have errors while the official migration status is WARN, or vice versa,\nthey may wish to postpone errors reporting for some until they complete their migration.\n\n\n-Xjsr305=@<fq.name>:{strict|warn|ignore} (since 1.1.60) to override the behavior for a single annotation, where <fq.name>\nis the fully qualified class name of the annotation. May appear several times for different annotations. This is useful\nfor managing the migration state for a particular library.\n\n"}, {"type": "li", "text": "\n-Xjsr305={strict|warn|ignore} to set up the behavior for non-@UnderMigration annotations.\nCustom nullability qualifiers, especially\n@TypeQualifierDefault, are already spread among many well-known libraries, and users may need to migrate smoothly when\nupdating to the Kotlin version containing JSR-305 support. Since Kotlin 1.1.60, this flag only affects non-@UnderMigration annotations.\n"}, {"type": "p", "text": "-Xjsr305={strict|warn|ignore} to set up the behavior for non-@UnderMigration annotations.\nCustom nullability qualifiers, especially\n@TypeQualifierDefault, are already spread among many well-known libraries, and users may need to migrate smoothly when\nupdating to the Kotlin version containing JSR-305 support. Since Kotlin 1.1.60, this flag only affects non-@UnderMigration annotations."}, {"type": "code", "text": "-Xjsr305={strict|warn|ignore}"}, {"type": "code", "text": "@UnderMigration"}, {"type": "code", "text": "@TypeQualifierDefault"}, {"type": "code", "text": "@UnderMigration"}, {"type": "li", "text": "\n-Xjsr305=under-migration:{strict|warn|ignore} (since 1.1.60) to override the behavior for the @UnderMigration annotations.\nUsers may have different view on the migration status for the libraries:\nthey may want to have errors while the official migration status is WARN, or vice versa,\nthey may wish to postpone errors reporting for some until they complete their migration.\n"}, {"type": "p", "text": "-Xjsr305=under-migration:{strict|warn|ignore} (since 1.1.60) to override the behavior for the @UnderMigration annotations.\nUsers may have different view on the migration status for the libraries:\nthey may want to have errors while the official migration status is WARN, or vice versa,\nthey may wish to postpone errors reporting for some until they complete their migration."}, {"type": "code", "text": "-Xjsr305=under-migration:{strict|warn|ignore}"}, {"type": "code", "text": "@UnderMigration"}, {"type": "code", "text": "WARN"}, {"type": "li", "text": "\n-Xjsr305=@<fq.name>:{strict|warn|ignore} (since 1.1.60) to override the behavior for a single annotation, where <fq.name>\nis the fully qualified class name of the annotation. May appear several times for different annotations. This is useful\nfor managing the migration state for a particular library.\n"}, {"type": "p", "text": "-Xjsr305=@<fq.name>:{strict|warn|ignore} (since 1.1.60) to override the behavior for a single annotation, where <fq.name>\nis the fully qualified class name of the annotation. May appear several times for different annotations. This is useful\nfor managing the migration state for a particular library."}, {"type": "code", "text": "-Xjsr305=@<fq.name>:{strict|warn|ignore}"}, {"type": "code", "text": "<fq.name>"}, {"type": "p", "text": "The strict, warn and ignore values have the same meaning as those of MigrationStatus, and only the strict mode affects the types in the annotated declarations as they are seen in Kotlin."}, {"type": "code", "text": "strict"}, {"type": "code", "text": "warn"}, {"type": "code", "text": "ignore"}, {"type": "code", "text": "MigrationStatus"}, {"type": "code", "text": "strict"}, {"type": "blockquote", "text": "\nNote: the built-in JSR-305 annotations @Nonnull, @Nullable and @CheckForNull are always enabled and affect the types of the annotated declarations in Kotlin, regardless of compiler configuration with the -Xjsr305 flag.\n"}, {"type": "p", "text": "Note: the built-in JSR-305 annotations @Nonnull, @Nullable and @CheckForNull are always enabled and affect the types of the annotated declarations in Kotlin, regardless of compiler configuration with the -Xjsr305 flag."}, {"type": "a", "text": "@Nonnull"}, {"type": "code", "text": "@Nonnull"}, {"type": "a", "text": "@Nullable"}, {"type": "code", "text": "@Nullable"}, {"type": "a", "text": "@CheckForNull"}, {"type": "code", "text": "@CheckForNull"}, {"type": "code", "text": "-Xjsr305"}, {"type": "p", "text": "For example, adding -Xjsr305=ignore -Xjsr305=under-migration:ignore -Xjsr305=@org.library.MyNullable:warn to the\ncompiler arguments makes the compiler generate warnings for inappropriate usages of types annotated by\n@org.library.MyNullable and ignore all other JSR-305 annotations."}, {"type": "code", "text": "-Xjsr305=ignore -Xjsr305=under-migration:ignore -Xjsr305=@org.library.MyNullable:warn"}, {"type": "code", "text": "@org.library.MyNullable"}, {"type": "p", "text": "For kotlin versions 1.1.50+/1.2, the default behavior is the same to -Xjsr305=warn. The\nstrict value should be considered experimental (more checks may be added to it in the future)."}, {"type": "code", "text": "-Xjsr305=warn"}, {"type": "code", "text": "strict"}, {"type": "h2", "text": "Mapped types"}, {"type": "p", "text": "Kotlin treats some Java types specially. Such types are not loaded from Java \"as is\", but are mapped to corresponding Kotlin types.\nThe mapping only matters at compile time, the runtime representation remains unchanged.\n Java's primitive types are mapped to corresponding Kotlin types (keeping platform types in mind):"}, {"type": "em", "text": "mapped"}, {"type": "a", "text": "platform types"}, {"type": "table", "text": "\n\n\nJava type\nKotlin type\n\n\n\n\nbyte\nkotlin.Byte\n\n\nshort\nkotlin.Short\n\n\nint\nkotlin.Int\n\n\nlong\nkotlin.Long\n\n\nchar\nkotlin.Char\n\n\nfloat\nkotlin.Float\n\n\ndouble\nkotlin.Double\n\n\nboolean\nkotlin.Boolean\n\n\n"}, {"type": "thead", "text": "\n\nJava type\nKotlin type\n\n"}, {"type": "tr", "text": "\nJava type\nKotlin type\n"}, {"type": "th", "text": "Java type"}, {"type": "strong", "text": "Java type"}, {"type": "th", "text": "Kotlin type"}, {"type": "strong", "text": "Kotlin type"}, {"type": "tbody", "text": "\n\nbyte\nkotlin.Byte\n\n\nshort\nkotlin.Short\n\n\nint\nkotlin.Int\n\n\nlong\nkotlin.Long\n\n\nchar\nkotlin.Char\n\n\nfloat\nkotlin.Float\n\n\ndouble\nkotlin.Double\n\n\nboolean\nkotlin.Boolean\n\n"}, {"type": "tr", "text": "\nbyte\nkotlin.Byte\n"}, {"type": "td", "text": "byte"}, {"type": "code", "text": "byte"}, {"type": "td", "text": "kotlin.Byte"}, {"type": "code", "text": "kotlin.Byte"}, {"type": "tr", "text": "\nshort\nkotlin.Short\n"}, {"type": "td", "text": "short"}, {"type": "code", "text": "short"}, {"type": "td", "text": "kotlin.Short"}, {"type": "code", "text": "kotlin.Short"}, {"type": "tr", "text": "\nint\nkotlin.Int\n"}, {"type": "td", "text": "int"}, {"type": "code", "text": "int"}, {"type": "td", "text": "kotlin.Int"}, {"type": "code", "text": "kotlin.Int"}, {"type": "tr", "text": "\nlong\nkotlin.Long\n"}, {"type": "td", "text": "long"}, {"type": "code", "text": "long"}, {"type": "td", "text": "kotlin.Long"}, {"type": "code", "text": "kotlin.Long"}, {"type": "tr", "text": "\nchar\nkotlin.Char\n"}, {"type": "td", "text": "char"}, {"type": "code", "text": "char"}, {"type": "td", "text": "kotlin.Char"}, {"type": "code", "text": "kotlin.Char"}, {"type": "tr", "text": "\nfloat\nkotlin.Float\n"}, {"type": "td", "text": "float"}, {"type": "code", "text": "float"}, {"type": "td", "text": "kotlin.Float"}, {"type": "code", "text": "kotlin.Float"}, {"type": "tr", "text": "\ndouble\nkotlin.Double\n"}, {"type": "td", "text": "double"}, {"type": "code", "text": "double"}, {"type": "td", "text": "kotlin.Double"}, {"type": "code", "text": "kotlin.Double"}, {"type": "tr", "text": "\nboolean\nkotlin.Boolean\n"}, {"type": "td", "text": "boolean"}, {"type": "code", "text": "boolean"}, {"type": "td", "text": "kotlin.Boolean"}, {"type": "code", "text": "kotlin.Boolean"}, {"type": "p", "text": "Some non-primitive built-in classes are also mapped:"}, {"type": "table", "text": "\n\n\nJava type\nKotlin type\n\n\n\n\njava.lang.Object\nkotlin.Any!\n\n\njava.lang.Cloneable\nkotlin.Cloneable!\n\n\njava.lang.Comparable\nkotlin.Comparable!\n\n\njava.lang.Enum\nkotlin.Enum!\n\n\njava.lang.Annotation\nkotlin.Annotation!\n\n\njava.lang.CharSequence\nkotlin.CharSequence!\n\n\njava.lang.String\nkotlin.String!\n\n\njava.lang.Number\nkotlin.Number!\n\n\njava.lang.Throwable\nkotlin.Throwable!\n\n\n"}, {"type": "thead", "text": "\n\nJava type\nKotlin type\n\n"}, {"type": "tr", "text": "\nJava type\nKotlin type\n"}, {"type": "th", "text": "Java type"}, {"type": "strong", "text": "Java type"}, {"type": "th", "text": "Kotlin type"}, {"type": "strong", "text": "Kotlin type"}, {"type": "tbody", "text": "\n\njava.lang.Object\nkotlin.Any!\n\n\njava.lang.Cloneable\nkotlin.Cloneable!\n\n\njava.lang.Comparable\nkotlin.Comparable!\n\n\njava.lang.Enum\nkotlin.Enum!\n\n\njava.lang.Annotation\nkotlin.Annotation!\n\n\njava.lang.CharSequence\nkotlin.CharSequence!\n\n\njava.lang.String\nkotlin.String!\n\n\njava.lang.Number\nkotlin.Number!\n\n\njava.lang.Throwable\nkotlin.Throwable!\n\n"}, {"type": "tr", "text": "\njava.lang.Object\nkotlin.Any!\n"}, {"type": "td", "text": "java.lang.Object"}, {"type": "code", "text": "java.lang.Object"}, {"type": "td", "text": "kotlin.Any!"}, {"type": "code", "text": "kotlin.Any!"}, {"type": "tr", "text": "\njava.lang.Cloneable\nkotlin.Cloneable!\n"}, {"type": "td", "text": "java.lang.Cloneable"}, {"type": "code", "text": "java.lang.Cloneable"}, {"type": "td", "text": "kotlin.Cloneable!"}, {"type": "code", "text": "kotlin.Cloneable!"}, {"type": "tr", "text": "\njava.lang.Comparable\nkotlin.Comparable!\n"}, {"type": "td", "text": "java.lang.Comparable"}, {"type": "code", "text": "java.lang.Comparable"}, {"type": "td", "text": "kotlin.Comparable!"}, {"type": "code", "text": "kotlin.Comparable!"}, {"type": "tr", "text": "\njava.lang.Enum\nkotlin.Enum!\n"}, {"type": "td", "text": "java.lang.Enum"}, {"type": "code", "text": "java.lang.Enum"}, {"type": "td", "text": "kotlin.Enum!"}, {"type": "code", "text": "kotlin.Enum!"}, {"type": "tr", "text": "\njava.lang.Annotation\nkotlin.Annotation!\n"}, {"type": "td", "text": "java.lang.Annotation"}, {"type": "code", "text": "java.lang.Annotation"}, {"type": "td", "text": "kotlin.Annotation!"}, {"type": "code", "text": "kotlin.Annotation!"}, {"type": "tr", "text": "\njava.lang.CharSequence\nkotlin.CharSequence!\n"}, {"type": "td", "text": "java.lang.CharSequence"}, {"type": "code", "text": "java.lang.CharSequence"}, {"type": "td", "text": "kotlin.CharSequence!"}, {"type": "code", "text": "kotlin.CharSequence!"}, {"type": "tr", "text": "\njava.lang.String\nkotlin.String!\n"}, {"type": "td", "text": "java.lang.String"}, {"type": "code", "text": "java.lang.String"}, {"type": "td", "text": "kotlin.String!"}, {"type": "code", "text": "kotlin.String!"}, {"type": "tr", "text": "\njava.lang.Number\nkotlin.Number!\n"}, {"type": "td", "text": "java.lang.Number"}, {"type": "code", "text": "java.lang.Number"}, {"type": "td", "text": "kotlin.Number!"}, {"type": "code", "text": "kotlin.Number!"}, {"type": "tr", "text": "\njava.lang.Throwable\nkotlin.Throwable!\n"}, {"type": "td", "text": "java.lang.Throwable"}, {"type": "code", "text": "java.lang.Throwable"}, {"type": "td", "text": "kotlin.Throwable!"}, {"type": "code", "text": "kotlin.Throwable!"}, {"type": "p", "text": "Java's boxed primitive types are mapped to nullable Kotlin types:"}, {"type": "table", "text": "\n\n\nJava type\nKotlin type\n\n\n\n\njava.lang.Byte\nkotlin.Byte?\n\n\njava.lang.Short\nkotlin.Short?\n\n\njava.lang.Integer\nkotlin.Int?\n\n\njava.lang.Long\nkotlin.Long?\n\n\njava.lang.Character\nkotlin.Char?\n\n\njava.lang.Float\nkotlin.Float?\n\n\njava.lang.Double\nkotlin.Double?\n\n\njava.lang.Boolean\nkotlin.Boolean?\n\n\n"}, {"type": "thead", "text": "\n\nJava type\nKotlin type\n\n"}, {"type": "tr", "text": "\nJava type\nKotlin type\n"}, {"type": "th", "text": "Java type"}, {"type": "strong", "text": "Java type"}, {"type": "th", "text": "Kotlin type"}, {"type": "strong", "text": "Kotlin type"}, {"type": "tbody", "text": "\n\njava.lang.Byte\nkotlin.Byte?\n\n\njava.lang.Short\nkotlin.Short?\n\n\njava.lang.Integer\nkotlin.Int?\n\n\njava.lang.Long\nkotlin.Long?\n\n\njava.lang.Character\nkotlin.Char?\n\n\njava.lang.Float\nkotlin.Float?\n\n\njava.lang.Double\nkotlin.Double?\n\n\njava.lang.Boolean\nkotlin.Boolean?\n\n"}, {"type": "tr", "text": "\njava.lang.Byte\nkotlin.Byte?\n"}, {"type": "td", "text": "java.lang.Byte"}, {"type": "code", "text": "java.lang.Byte"}, {"type": "td", "text": "kotlin.Byte?"}, {"type": "code", "text": "kotlin.Byte?"}, {"type": "tr", "text": "\njava.lang.Short\nkotlin.Short?\n"}, {"type": "td", "text": "java.lang.Short"}, {"type": "code", "text": "java.lang.Short"}, {"type": "td", "text": "kotlin.Short?"}, {"type": "code", "text": "kotlin.Short?"}, {"type": "tr", "text": "\njava.lang.Integer\nkotlin.Int?\n"}, {"type": "td", "text": "java.lang.Integer"}, {"type": "code", "text": "java.lang.Integer"}, {"type": "td", "text": "kotlin.Int?"}, {"type": "code", "text": "kotlin.Int?"}, {"type": "tr", "text": "\njava.lang.Long\nkotlin.Long?\n"}, {"type": "td", "text": "java.lang.Long"}, {"type": "code", "text": "java.lang.Long"}, {"type": "td", "text": "kotlin.Long?"}, {"type": "code", "text": "kotlin.Long?"}, {"type": "tr", "text": "\njava.lang.Character\nkotlin.Char?\n"}, {"type": "td", "text": "java.lang.Character"}, {"type": "code", "text": "java.lang.Character"}, {"type": "td", "text": "kotlin.Char?"}, {"type": "code", "text": "kotlin.Char?"}, {"type": "tr", "text": "\njava.lang.Float\nkotlin.Float?\n"}, {"type": "td", "text": "java.lang.Float"}, {"type": "code", "text": "java.lang.Float"}, {"type": "td", "text": "kotlin.Float?"}, {"type": "code", "text": "kotlin.Float?"}, {"type": "tr", "text": "\njava.lang.Double\nkotlin.Double?\n"}, {"type": "td", "text": "java.lang.Double"}, {"type": "code", "text": "java.lang.Double"}, {"type": "td", "text": "kotlin.Double?"}, {"type": "code", "text": "kotlin.Double?"}, {"type": "tr", "text": "\njava.lang.Boolean\nkotlin.Boolean?\n"}, {"type": "td", "text": "java.lang.Boolean"}, {"type": "code", "text": "java.lang.Boolean"}, {"type": "td", "text": "kotlin.Boolean?"}, {"type": "code", "text": "kotlin.Boolean?"}, {"type": "p", "text": "Note that a boxed primitive type used as a type parameter is mapped to a platform type:\nfor example, List<java.lang.Integer> becomes a List<Int!> in Kotlin."}, {"type": "code", "text": "List<java.lang.Integer>"}, {"type": "code", "text": "List<Int!>"}, {"type": "p", "text": "Collection types may be read-only or mutable in Kotlin, so Java's collections are mapped as follows\n(all Kotlin types in this table reside in the package kotlin.collections):"}, {"type": "code", "text": "kotlin.collections"}, {"type": "table", "text": "\n\n\nJava type\nKotlin read-only type\nKotlin mutable type\nLoaded platform type\n\n\n\n\nIterator<T>\nIterator<T>\nMutableIterator<T>\n(Mutable)Iterator<T>!\n\n\nIterable<T>\nIterable<T>\nMutableIterable<T>\n(Mutable)Iterable<T>!\n\n\nCollection<T>\nCollection<T>\nMutableCollection<T>\n(Mutable)Collection<T>!\n\n\nSet<T>\nSet<T>\nMutableSet<T>\n(Mutable)Set<T>!\n\n\nList<T>\nList<T>\nMutableList<T>\n(Mutable)List<T>!\n\n\nListIterator<T>\nListIterator<T>\nMutableListIterator<T>\n(Mutable)ListIterator<T>!\n\n\nMap<K, V>\nMap<K, V>\nMutableMap<K, V>\n(Mutable)Map<K, V>!\n\n\nMap.Entry<K, V>\nMap.Entry<K, V>\nMutableMap.MutableEntry<K,V>\n(Mutable)Map.(Mutable)Entry<K, V>!\n\n\n"}, {"type": "thead", "text": "\n\nJava type\nKotlin read-only type\nKotlin mutable type\nLoaded platform type\n\n"}, {"type": "tr", "text": "\nJava type\nKotlin read-only type\nKotlin mutable type\nLoaded platform type\n"}, {"type": "th", "text": "Java type"}, {"type": "strong", "text": "Java type"}, {"type": "th", "text": "Kotlin read-only type"}, {"type": "strong", "text": "Kotlin read-only type"}, {"type": "th", "text": "Kotlin mutable type"}, {"type": "strong", "text": "Kotlin mutable type"}, {"type": "th", "text": "Loaded platform type"}, {"type": "strong", "text": "Loaded platform type"}, {"type": "tbody", "text": "\n\nIterator<T>\nIterator<T>\nMutableIterator<T>\n(Mutable)Iterator<T>!\n\n\nIterable<T>\nIterable<T>\nMutableIterable<T>\n(Mutable)Iterable<T>!\n\n\nCollection<T>\nCollection<T>\nMutableCollection<T>\n(Mutable)Collection<T>!\n\n\nSet<T>\nSet<T>\nMutableSet<T>\n(Mutable)Set<T>!\n\n\nList<T>\nList<T>\nMutableList<T>\n(Mutable)List<T>!\n\n\nListIterator<T>\nListIterator<T>\nMutableListIterator<T>\n(Mutable)ListIterator<T>!\n\n\nMap<K, V>\nMap<K, V>\nMutableMap<K, V>\n(Mutable)Map<K, V>!\n\n\nMap.Entry<K, V>\nMap.Entry<K, V>\nMutableMap.MutableEntry<K,V>\n(Mutable)Map.(Mutable)Entry<K, V>!\n\n"}, {"type": "tr", "text": "\nIterator<T>\nIterator<T>\nMutableIterator<T>\n(Mutable)Iterator<T>!\n"}, {"type": "td", "text": "Iterator<T>"}, {"type": "code", "text": "Iterator<T>"}, {"type": "td", "text": "Iterator<T>"}, {"type": "code", "text": "Iterator<T>"}, {"type": "td", "text": "MutableIterator<T>"}, {"type": "code", "text": "MutableIterator<T>"}, {"type": "td", "text": "(Mutable)Iterator<T>!"}, {"type": "code", "text": "(Mutable)Iterator<T>!"}, {"type": "tr", "text": "\nIterable<T>\nIterable<T>\nMutableIterable<T>\n(Mutable)Iterable<T>!\n"}, {"type": "td", "text": "Iterable<T>"}, {"type": "code", "text": "Iterable<T>"}, {"type": "td", "text": "Iterable<T>"}, {"type": "code", "text": "Iterable<T>"}, {"type": "td", "text": "MutableIterable<T>"}, {"type": "code", "text": "MutableIterable<T>"}, {"type": "td", "text": "(Mutable)Iterable<T>!"}, {"type": "code", "text": "(Mutable)Iterable<T>!"}, {"type": "tr", "text": "\nCollection<T>\nCollection<T>\nMutableCollection<T>\n(Mutable)Collection<T>!\n"}, {"type": "td", "text": "Collection<T>"}, {"type": "code", "text": "Collection<T>"}, {"type": "td", "text": "Collection<T>"}, {"type": "code", "text": "Collection<T>"}, {"type": "td", "text": "MutableCollection<T>"}, {"type": "code", "text": "MutableCollection<T>"}, {"type": "td", "text": "(Mutable)Collection<T>!"}, {"type": "code", "text": "(Mutable)Collection<T>!"}, {"type": "tr", "text": "\nSet<T>\nSet<T>\nMutableSet<T>\n(Mutable)Set<T>!\n"}, {"type": "td", "text": "Set<T>"}, {"type": "code", "text": "Set<T>"}, {"type": "td", "text": "Set<T>"}, {"type": "code", "text": "Set<T>"}, {"type": "td", "text": "MutableSet<T>"}, {"type": "code", "text": "MutableSet<T>"}, {"type": "td", "text": "(Mutable)Set<T>!"}, {"type": "code", "text": "(Mutable)Set<T>!"}, {"type": "tr", "text": "\nList<T>\nList<T>\nMutableList<T>\n(Mutable)List<T>!\n"}, {"type": "td", "text": "List<T>"}, {"type": "code", "text": "List<T>"}, {"type": "td", "text": "List<T>"}, {"type": "code", "text": "List<T>"}, {"type": "td", "text": "MutableList<T>"}, {"type": "code", "text": "MutableList<T>"}, {"type": "td", "text": "(Mutable)List<T>!"}, {"type": "code", "text": "(Mutable)List<T>!"}, {"type": "tr", "text": "\nListIterator<T>\nListIterator<T>\nMutableListIterator<T>\n(Mutable)ListIterator<T>!\n"}, {"type": "td", "text": "ListIterator<T>"}, {"type": "code", "text": "ListIterator<T>"}, {"type": "td", "text": "ListIterator<T>"}, {"type": "code", "text": "ListIterator<T>"}, {"type": "td", "text": "MutableListIterator<T>"}, {"type": "code", "text": "MutableListIterator<T>"}, {"type": "td", "text": "(Mutable)ListIterator<T>!"}, {"type": "code", "text": "(Mutable)ListIterator<T>!"}, {"type": "tr", "text": "\nMap<K, V>\nMap<K, V>\nMutableMap<K, V>\n(Mutable)Map<K, V>!\n"}, {"type": "td", "text": "Map<K, V>"}, {"type": "code", "text": "Map<K, V>"}, {"type": "td", "text": "Map<K, V>"}, {"type": "code", "text": "Map<K, V>"}, {"type": "td", "text": "MutableMap<K, V>"}, {"type": "code", "text": "MutableMap<K, V>"}, {"type": "td", "text": "(Mutable)Map<K, V>!"}, {"type": "code", "text": "(Mutable)Map<K, V>!"}, {"type": "tr", "text": "\nMap.Entry<K, V>\nMap.Entry<K, V>\nMutableMap.MutableEntry<K,V>\n(Mutable)Map.(Mutable)Entry<K, V>!\n"}, {"type": "td", "text": "Map.Entry<K, V>"}, {"type": "code", "text": "Map.Entry<K, V>"}, {"type": "td", "text": "Map.Entry<K, V>"}, {"type": "code", "text": "Map.Entry<K, V>"}, {"type": "td", "text": "MutableMap.MutableEntry<K,V>"}, {"type": "code", "text": "MutableMap.MutableEntry<K,V>"}, {"type": "td", "text": "(Mutable)Map.(Mutable)Entry<K, V>!"}, {"type": "code", "text": "(Mutable)Map.(Mutable)Entry<K, V>!"}, {"type": "p", "text": "Java's arrays are mapped as mentioned below:"}, {"type": "a", "text": "below"}, {"type": "table", "text": "\n\n\nJava type\nKotlin type\n\n\n\n\nint[]\nkotlin.IntArray!\n\n\nString[]\nkotlin.Array<(out) String>!\n\n\n"}, {"type": "thead", "text": "\n\nJava type\nKotlin type\n\n"}, {"type": "tr", "text": "\nJava type\nKotlin type\n"}, {"type": "th", "text": "Java type"}, {"type": "strong", "text": "Java type"}, {"type": "th", "text": "Kotlin type"}, {"type": "strong", "text": "Kotlin type"}, {"type": "tbody", "text": "\n\nint[]\nkotlin.IntArray!\n\n\nString[]\nkotlin.Array<(out) String>!\n\n"}, {"type": "tr", "text": "\nint[]\nkotlin.IntArray!\n"}, {"type": "td", "text": "int[]"}, {"type": "code", "text": "int[]"}, {"type": "td", "text": "kotlin.IntArray!"}, {"type": "code", "text": "kotlin.IntArray!"}, {"type": "tr", "text": "\nString[]\nkotlin.Array<(out) String>!\n"}, {"type": "td", "text": "String[]"}, {"type": "code", "text": "String[]"}, {"type": "td", "text": "kotlin.Array<(out) String>!"}, {"type": "code", "text": "kotlin.Array<(out) String>!"}, {"type": "p", "text": "Note: the static members of these Java types are not directly accessible on the companion objects of the Kotlin types. To call them, use the full qualified names of the Java types, e.g. java.lang.Integer.toHexString(foo)."}, {"type": "a", "text": "companion objects"}, {"type": "code", "text": "java.lang.Integer.toHexString(foo)"}, {"type": "h2", "text": "Java generics in Kotlin"}, {"type": "p", "text": "Kotlin's generics are a little different from Java's (see Generics). When importing Java types to Kotlin we perform some conversions:"}, {"type": "a", "text": "Generics"}, {"type": "ul", "text": "\nJava's wildcards are converted into type projections,\n    \nFoo<? extends Bar> becomes Foo<out Bar!>!,\nFoo<? super Bar> becomes Foo<in Bar!>!;\n\n\nJava's raw types are converted into star projections,\n    \nList becomes List<*>!, i.e. List<out Any?>!.\n\n\n"}, {"type": "li", "text": "Java's wildcards are converted into type projections,\n    \nFoo<? extends Bar> becomes Foo<out Bar!>!,\nFoo<? super Bar> becomes Foo<in Bar!>!;\n\n"}, {"type": "ul", "text": "\nFoo<? extends Bar> becomes Foo<out Bar!>!,\nFoo<? super Bar> becomes Foo<in Bar!>!;\n"}, {"type": "li", "text": "Foo<? extends Bar> becomes Foo<out Bar!>!,"}, {"type": "code", "text": "Foo<? extends Bar>"}, {"type": "code", "text": "Foo<out Bar!>!"}, {"type": "li", "text": "Foo<? super Bar> becomes Foo<in Bar!>!;"}, {"type": "code", "text": "Foo<? super Bar>"}, {"type": "code", "text": "Foo<in Bar!>!"}, {"type": "li", "text": "Java's raw types are converted into star projections,\n    \nList becomes List<*>!, i.e. List<out Any?>!.\n\n"}, {"type": "ul", "text": "\nList becomes List<*>!, i.e. List<out Any?>!.\n"}, {"type": "li", "text": "List becomes List<*>!, i.e. List<out Any?>!."}, {"type": "code", "text": "List"}, {"type": "code", "text": "List<*>!"}, {"type": "code", "text": "List<out Any?>!"}, {"type": "p", "text": "Like Java's, Kotlin's generics are not retained at runtime, i.e. objects do not carry information about actual type arguments passed to their constructors,\ni.e. ArrayList<Integer>() is indistinguishable from ArrayList<Character>().\nThis makes it impossible to perform is-checks that take generics into account.\nKotlin only allows is-checks for star-projected generic types:"}, {"type": "code", "text": "ArrayList<Integer>()"}, {"type": "code", "text": "ArrayList<Character>()"}, {"type": "em", "text": "is"}, {"type": "em", "text": "is"}, {"type": "div", "text": "\nif (a is List<Int>) // Error: cannot check if it is really a List of Ints\n// but\nif (a is List<*>) // OK: no guarantees about the contents of the list\n\n"}, {"type": "pre", "text": "if (a is List<Int>) // Error: cannot check if it is really a List of Ints\n// but\nif (a is List<*>) // OK: no guarantees about the contents of the list\n"}, {"type": "code", "text": "if (a is List<Int>) // Error: cannot check if it is really a List of Ints\n// but\nif (a is List<*>) // OK: no guarantees about the contents of the list\n"}, {"type": "h2", "text": "Java Arrays"}, {"type": "p", "text": "Arrays in Kotlin are invariant, unlike Java. This means that Kotlin does not let us assign an Array<String> to an Array<Any>,\nwhich prevents a possible runtime failure. Passing an array of a subclass as an array of superclass to a Kotlin method is also prohibited,\nbut for Java methods this is allowed (through platform types of the form Array<(out) String>!)."}, {"type": "code", "text": "Array<String>"}, {"type": "code", "text": "Array<Any>"}, {"type": "a", "text": "platform types"}, {"type": "code", "text": "Array<(out) String>!"}, {"type": "p", "text": "Arrays are used with primitive datatypes on the Java platform to avoid the cost of boxing/unboxing operations.\nAs Kotlin hides those implementation details, a workaround is required to interface with Java code.\nThere are specialized classes for every type of primitive array (IntArray, DoubleArray, CharArray, and so on) to handle this case.\nThey are not related to the Array class and are compiled down to Java's primitive arrays for maximum performance."}, {"type": "code", "text": "IntArray"}, {"type": "code", "text": "DoubleArray"}, {"type": "code", "text": "CharArray"}, {"type": "code", "text": "Array"}, {"type": "p", "text": "Suppose there is a Java method that accepts an int array of indices:"}, {"type": "div", "text": "\npublic class JavaArrayExample {\n\n    public void removeIndices(int[] indices) {\n        // code here...\n    }\n}\n\n"}, {"type": "pre", "text": "public class JavaArrayExample {\n\n    public void removeIndices(int[] indices) {\n        // code here...\n    }\n}\n"}, {"type": "code", "text": "public class JavaArrayExample {\n\n    public void removeIndices(int[] indices) {\n        // code here...\n    }\n}\n"}, {"type": "p", "text": "To pass an array of primitive values you can do the following in Kotlin:"}, {"type": "div", "text": "\nval javaObj = JavaArrayExample()\nval array = intArrayOf(0, 1, 2, 3)\njavaObj.removeIndices(array)  // passes int[] to method\n\n"}, {"type": "pre", "text": "val javaObj = JavaArrayExample()\nval array = intArrayOf(0, 1, 2, 3)\njavaObj.removeIndices(array)  // passes int[] to method\n"}, {"type": "code", "text": "val javaObj = JavaArrayExample()\nval array = intArrayOf(0, 1, 2, 3)\njavaObj.removeIndices(array)  // passes int[] to method\n"}, {"type": "p", "text": "When compiling to JVM byte codes, the compiler optimizes access to arrays so that there's no overhead introduced:"}, {"type": "div", "text": "\nval array = arrayOf(1, 2, 3, 4)\narray[1] = array[1] * 2 // no actual calls to get() and set() generated\nfor (x in array) { // no iterator created\n    print(x)\n}\n\n"}, {"type": "pre", "text": "val array = arrayOf(1, 2, 3, 4)\narray[1] = array[1] * 2 // no actual calls to get() and set() generated\nfor (x in array) { // no iterator created\n    print(x)\n}\n"}, {"type": "code", "text": "val array = arrayOf(1, 2, 3, 4)\narray[1] = array[1] * 2 // no actual calls to get() and set() generated\nfor (x in array) { // no iterator created\n    print(x)\n}\n"}, {"type": "p", "text": "Even when we navigate with an index, it does not introduce any overhead:"}, {"type": "div", "text": "\nfor (i in array.indices) { // no iterator created\n    array[i] += 2\n}\n\n"}, {"type": "pre", "text": "for (i in array.indices) { // no iterator created\n    array[i] += 2\n}\n"}, {"type": "code", "text": "for (i in array.indices) { // no iterator created\n    array[i] += 2\n}\n"}, {"type": "p", "text": "Finally, in-checks have no overhead either:"}, {"type": "em", "text": "in"}, {"type": "div", "text": "\nif (i in array.indices) { // same as (i >= 0 && i < array.size)\n    print(array[i])\n}\n\n"}, {"type": "pre", "text": "if (i in array.indices) { // same as (i >= 0 && i < array.size)\n    print(array[i])\n}\n"}, {"type": "code", "text": "if (i in array.indices) { // same as (i >= 0 && i < array.size)\n    print(array[i])\n}\n"}, {"type": "h2", "text": "Java Varargs"}, {"type": "p", "text": "Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):"}, {"type": "div", "text": "\npublic class JavaArrayExample {\n\n    public void removeIndicesVarArg(int... indices) {\n        // code here...\n    }\n}\n\n"}, {"type": "pre", "text": "public class JavaArrayExample {\n\n    public void removeIndicesVarArg(int... indices) {\n        // code here...\n    }\n}\n"}, {"type": "code", "text": "public class JavaArrayExample {\n\n    public void removeIndicesVarArg(int... indices) {\n        // code here...\n    }\n}\n"}, {"type": "p", "text": "In that case you need to use the spread operator * to pass the IntArray:"}, {"type": "code", "text": "*"}, {"type": "code", "text": "IntArray"}, {"type": "div", "text": "\nval javaObj = JavaArrayExample()\nval array = intArrayOf(0, 1, 2, 3)\njavaObj.removeIndicesVarArg(*array)\n\n"}, {"type": "pre", "text": "val javaObj = JavaArrayExample()\nval array = intArrayOf(0, 1, 2, 3)\njavaObj.removeIndicesVarArg(*array)\n"}, {"type": "code", "text": "val javaObj = JavaArrayExample()\nval array = intArrayOf(0, 1, 2, 3)\njavaObj.removeIndicesVarArg(*array)\n"}, {"type": "p", "text": "It's currently not possible to pass null to a method that is declared as varargs."}, {"type": "em", "text": "null"}, {"type": "h2", "text": "Operators"}, {"type": "p", "text": "Since Java has no way of marking methods for which it makes sense to use the operator syntax, Kotlin allows using any\nJava methods with the right name and signature as operator overloads and other conventions (invoke() etc.)\nCalling Java methods using the infix call syntax is not allowed."}, {"type": "code", "text": "invoke()"}, {"type": "h2", "text": "Checked Exceptions"}, {"type": "p", "text": "In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them.\nSo, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything:"}, {"type": "div", "text": "\nfun render(list: List<*>, to: Appendable) {\n    for (item in list) {\n        to.append(item.toString()) // Java would require us to catch IOException here\n    }\n}\n\n"}, {"type": "pre", "text": "fun render(list: List<*>, to: Appendable) {\n    for (item in list) {\n        to.append(item.toString()) // Java would require us to catch IOException here\n    }\n}\n"}, {"type": "code", "text": "fun render(list: List<*>, to: Appendable) {\n    for (item in list) {\n        to.append(item.toString()) // Java would require us to catch IOException here\n    }\n}\n"}, {"type": "h2", "text": "Object Methods"}, {"type": "p", "text": "When Java types are imported into Kotlin, all the references of the type java.lang.Object are turned into Any.\nSince Any is not platform-specific, it only declares toString(), hashCode() and equals() as its members,\nso to make other members of java.lang.Object available, Kotlin uses extension functions."}, {"type": "code", "text": "java.lang.Object"}, {"type": "code", "text": "Any"}, {"type": "code", "text": "Any"}, {"type": "code", "text": "toString()"}, {"type": "code", "text": "hashCode()"}, {"type": "code", "text": "equals()"}, {"type": "code", "text": "java.lang.Object"}, {"type": "a", "text": "extension functions"}, {"type": "h3", "text": "wait()/notify()"}, {"type": "p", "text": "Methods wait() and notify() are not available on references of type Any. Their usage is generally discouraged in favor of java.util.concurrent.\nIf you really need to call these methods, you can cast to java.lang.Object:"}, {"type": "code", "text": "wait()"}, {"type": "code", "text": "notify()"}, {"type": "code", "text": "Any"}, {"type": "code", "text": "java.util.concurrent"}, {"type": "code", "text": "java.lang.Object"}, {"type": "div", "text": "\n(foo as java.lang.Object).wait()\n\n"}, {"type": "pre", "text": "(foo as java.lang.Object).wait()\n"}, {"type": "code", "text": "(foo as java.lang.Object).wait()\n"}, {"type": "h3", "text": "getClass()"}, {"type": "p", "text": "To retrieve the Java class of an object, use the java extension property on a class reference:"}, {"type": "code", "text": "java"}, {"type": "a", "text": "class reference"}, {"type": "div", "text": "\nval fooClass = foo::class.java\n\n"}, {"type": "pre", "text": "val fooClass = foo::class.java\n"}, {"type": "code", "text": "val fooClass = foo::class.java\n"}, {"type": "p", "text": "The code above uses a bound class reference, which is supported since Kotlin 1.1. You can also use the javaClass extension property:"}, {"type": "a", "text": "bound class reference"}, {"type": "code", "text": "javaClass"}, {"type": "div", "text": "\nval fooClass = foo.javaClass\n\n"}, {"type": "pre", "text": "val fooClass = foo.javaClass\n"}, {"type": "code", "text": "val fooClass = foo.javaClass\n"}, {"type": "h3", "text": "clone()"}, {"type": "p", "text": "To override clone(), your class needs to extend kotlin.Cloneable:"}, {"type": "code", "text": "clone()"}, {"type": "code", "text": "kotlin.Cloneable"}, {"type": "div", "text": "\nclass Example : Cloneable {\n    override fun clone(): Any { ... }\n}\n\n"}, {"type": "pre", "text": "class Example : Cloneable {\n    override fun clone(): Any { ... }\n}\n"}, {"type": "code", "text": "class Example : Cloneable {\n    override fun clone(): Any { ... }\n}\n"}, {"type": "p", "text": "Do not forget about Effective Java, 3rd Edition, Item 13: Override clone judiciously."}, {"type": "a", "text": "Effective Java, 3rd Edition"}, {"type": "em", "text": "Override clone judiciously"}, {"type": "h3", "text": "finalize()"}, {"type": "p", "text": "To override finalize(), all you need to do is simply declare it, without using the override keyword:"}, {"type": "code", "text": "finalize()"}, {"type": "em", "text": "override"}, {"type": "div", "text": "\nclass C {\n    protected fun finalize() {\n        // finalization logic\n    }\n}\n\n"}, {"type": "pre", "text": "class C {\n    protected fun finalize() {\n        // finalization logic\n    }\n}\n"}, {"type": "code", "text": "class C {\n    protected fun finalize() {\n        // finalization logic\n    }\n}\n"}, {"type": "p", "text": "According to Java's rules, finalize() must not be private."}, {"type": "code", "text": "finalize()"}, {"type": "em", "text": "private"}, {"type": "h2", "text": "Inheritance from Java classes"}, {"type": "p", "text": "At most one Java class (and as many Java interfaces as you like) can be a supertype for a class in Kotlin."}, {"type": "h2", "text": "Accessing static members"}, {"type": "p", "text": "Static members of Java classes form \"companion objects\" for these classes. We cannot pass such a \"companion object\" around as a value,\nbut can access the members explicitly, for example:"}, {"type": "div", "text": "\nif (Character.isLetter(a)) { ... }\n\n"}, {"type": "pre", "text": "if (Character.isLetter(a)) { ... }\n"}, {"type": "code", "text": "if (Character.isLetter(a)) { ... }\n"}, {"type": "p", "text": "To access static members of a Java type that is mapped to a Kotlin type, use the full qualified name of the Java type: java.lang.Integer.bitCount(foo)."}, {"type": "a", "text": "mapped"}, {"type": "code", "text": "java.lang.Integer.bitCount(foo)"}, {"type": "h2", "text": "Java Reflection"}, {"type": "p", "text": "Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use instance::class.java,\nClassName::class.java or instance.javaClass to enter Java reflection through java.lang.Class."}, {"type": "code", "text": "instance::class.java"}, {"type": "code", "text": "ClassName::class.java"}, {"type": "code", "text": "instance.javaClass"}, {"type": "code", "text": "java.lang.Class"}, {"type": "p", "text": "Other supported cases include acquiring a Java getter/setter method or a backing field for a Kotlin property, a KProperty for a Java field, a Java method or constructor for a KFunction and vice versa."}, {"type": "code", "text": "KProperty"}, {"type": "code", "text": "KFunction"}, {"type": "h2", "text": "SAM Conversions"}, {"type": "p", "text": "Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted\ninto implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface\nmethod match the parameter types of the Kotlin function."}, {"type": "p", "text": "You can use this for creating instances of SAM interfaces:"}, {"type": "div", "text": "\nval runnable = Runnable { println(\"This runs in a runnable\") }\n\n"}, {"type": "pre", "text": "val runnable = Runnable { println(\"This runs in a runnable\") }\n"}, {"type": "code", "text": "val runnable = Runnable { println(\"This runs in a runnable\") }\n"}, {"type": "p", "text": "\u2026and in method calls:"}, {"type": "div", "text": "\nval executor = ThreadPoolExecutor()\n// Java signature: void execute(Runnable command)\nexecutor.execute { println(\"This runs in a thread pool\") }\n\n"}, {"type": "pre", "text": "val executor = ThreadPoolExecutor()\n// Java signature: void execute(Runnable command)\nexecutor.execute { println(\"This runs in a thread pool\") }\n"}, {"type": "code", "text": "val executor = ThreadPoolExecutor()\n// Java signature: void execute(Runnable command)\nexecutor.execute { println(\"This runs in a thread pool\") }\n"}, {"type": "p", "text": "If the Java class has multiple methods taking functional interfaces, you can choose the one you need to call by\nusing an adapter function that converts a lambda to a specific SAM type. Those adapter functions are also generated\nby the compiler when needed:"}, {"type": "div", "text": "\nexecutor.execute(Runnable { println(\"This runs in a thread pool\") })\n\n"}, {"type": "pre", "text": "executor.execute(Runnable { println(\"This runs in a thread pool\") })\n"}, {"type": "code", "text": "executor.execute(Runnable { println(\"This runs in a thread pool\") })\n"}, {"type": "p", "text": "Note that SAM conversions only work for interfaces, not for abstract classes, even if those also have just a single\nabstract method."}, {"type": "p", "text": "Also note that this feature works only for Java interop; since Kotlin has proper function types, automatic conversion\nof functions into implementations of Kotlin interfaces is unnecessary and therefore unsupported."}, {"type": "h2", "text": "Using JNI with Kotlin"}, {"type": "p", "text": "To declare a function that is implemented in native (C or C++) code, you need to mark it with the external modifier:"}, {"type": "code", "text": "external"}, {"type": "div", "text": "\nexternal fun foo(x: Int): Double\n\n"}, {"type": "pre", "text": "external fun foo(x: Int): Double\n"}, {"type": "code", "text": "external fun foo(x: Int): Double\n"}, {"type": "p", "text": "The rest of the procedure works in exactly the same way as in Java."}]