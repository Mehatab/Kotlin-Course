[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "What's New in Kotlin 1.3"}, {"type": "h2", "text": "Coroutines release"}, {"type": "p", "text": "After some long and extensive battle testing, coroutines are now released! It means that from Kotlin 1.3 the language support and the API are fully stable. Check out the new coroutines overview page."}, {"type": "a", "text": "fully stable"}, {"type": "a", "text": "coroutines overview"}, {"type": "p", "text": "Kotlin 1.3 introduces callable references on suspend-functions and support of Coroutines in the Reflection API."}, {"type": "h2", "text": "Kotlin/Native"}, {"type": "p", "text": "Kotlin 1.3 continues to improve and polish the Native target. See the Kotlin/Native overview for details."}, {"type": "a", "text": "Kotlin/Native overview"}, {"type": "h2", "text": "Multiplatform Projects"}, {"type": "p", "text": "In 1.3, we've completely reworked the model of multiplatform projects in order to improve expressiveness and flexibility, and to make sharing common code easier. Also, Kotlin/Native is now supported as one of the targets!"}, {"type": "p", "text": "The key differences to the old model are:"}, {"type": "ul", "text": "\nIn the old model, common and platform-specific code needed to be placed in separate modules, linked by expectedBy dependencies.\nNow, common and platform-specific code is placed in different source roots of the same module, making projects easier to configure.\nThere is now a large number of preset platform configurations for different supported platforms.\nThe dependencies configuration has been changed; dependencies are now specified separately for each source root.\nSource sets can now be shared between an arbitrary subset of platforms (for example, in a module that targets JS, Android and iOS, you can have a source set that is shared only between Android and iOS).\nPublishing multiplatform libraries is now supported.\n"}, {"type": "li", "text": "In the old model, common and platform-specific code needed to be placed in separate modules, linked by expectedBy dependencies.\nNow, common and platform-specific code is placed in different source roots of the same module, making projects easier to configure."}, {"type": "code", "text": "expectedBy"}, {"type": "li", "text": "There is now a large number of preset platform configurations for different supported platforms."}, {"type": "a", "text": "preset platform configurations"}, {"type": "li", "text": "The dependencies configuration has been changed; dependencies are now specified separately for each source root."}, {"type": "a", "text": "dependencies configuration"}, {"type": "li", "text": "Source sets can now be shared between an arbitrary subset of platforms (for example, in a module that targets JS, Android and iOS, you can have a source set that is shared only between Android and iOS)."}, {"type": "li", "text": "Publishing multiplatform libraries is now supported."}, {"type": "a", "text": "Publishing multiplatform libraries"}, {"type": "p", "text": "For more information, please refer to the Multiplatform Programming documentation."}, {"type": "a", "text": "Multiplatform Programming documentation"}, {"type": "h2", "text": "Contracts"}, {"type": "p", "text": "The Kotlin compiler does extensive static analysis to provide warnings and reduce boilerplate. One of the most notable features is smartcasts \u2014 with the ability to perform a cast automatically based on the performed type checks:"}, {"type": "div", "text": "\nfun foo(s: String?) {\n    if (s != null) s.length // Compiler automatically casts 's' to 'String'\n}\n\n"}, {"type": "pre", "text": "fun foo(s: String?) {\n    if (s != null) s.length // Compiler automatically casts 's' to 'String'\n}\n"}, {"type": "code", "text": "fun foo(s: String?) {\n    if (s != null) s.length // Compiler automatically casts 's' to 'String'\n}\n"}, {"type": "p", "text": "However, as soon as these checks are extracted in a separate function, all the smartcasts immediately disappear:"}, {"type": "div", "text": "\nfun String?.isNotNull(): Boolean = this != null\n\nfun foo(s: String?) {\n    if (s.isNotNull()) s.length // No smartcast :(\n}\n\n"}, {"type": "pre", "text": "fun String?.isNotNull(): Boolean = this != null\n\nfun foo(s: String?) {\n    if (s.isNotNull()) s.length // No smartcast :(\n}\n"}, {"type": "code", "text": "fun String?.isNotNull(): Boolean = this != null\n\nfun foo(s: String?) {\n    if (s.isNotNull()) s.length // No smartcast :(\n}\n"}, {"type": "p", "text": "To improve the behavior in such cases, Kotlin 1.3 introduces experimental mechanism called contracts."}, {"type": "em", "text": "contracts"}, {"type": "p", "text": "Contracts allow a function to explicitly describe its behavior in a way which is understood by the compiler. Currently, two wide classes of cases are supported:"}, {"type": "em", "text": "Contracts"}, {"type": "ul", "text": "\nImproving smartcasts analysis by declaring the relation between a function's call outcome and the passed arguments values:\n"}, {"type": "li", "text": "Improving smartcasts analysis by declaring the relation between a function's call outcome and the passed arguments values:"}, {"type": "div", "text": "\nfun require(condition: Boolean) {\n    // This is a syntax form, which tells compiler:\n    // \"if this function returns successfully, then passed 'condition' is true\"\n    contract { returns() implies condition }\n    if (!condition) throw IllegalArgumentException(...)\n}\n\nfun foo(s: String?) {\n    require(s is String)\n    // s is smartcasted to 'String' here, because otherwise\n    // 'require' would have throw an exception\n}\n\n"}, {"type": "pre", "text": "fun require(condition: Boolean) {\n    // This is a syntax form, which tells compiler:\n    // \"if this function returns successfully, then passed 'condition' is true\"\n    contract { returns() implies condition }\n    if (!condition) throw IllegalArgumentException(...)\n}\n\nfun foo(s: String?) {\n    require(s is String)\n    // s is smartcasted to 'String' here, because otherwise\n    // 'require' would have throw an exception\n}\n"}, {"type": "code", "text": "fun require(condition: Boolean) {\n    // This is a syntax form, which tells compiler:\n    // \"if this function returns successfully, then passed 'condition' is true\"\n    contract { returns() implies condition }\n    if (!condition) throw IllegalArgumentException(...)\n}\n\nfun foo(s: String?) {\n    require(s is String)\n    // s is smartcasted to 'String' here, because otherwise\n    // 'require' would have throw an exception\n}\n"}, {"type": "ul", "text": "\nImproving the variable initialization analysis in the presence of high-order functions:\n"}, {"type": "li", "text": "Improving the variable initialization analysis in the presence of high-order functions:"}, {"type": "div", "text": "\nfun synchronize(lock: Any?, block: () -> Unit) {\n    // It tells compiler:\n    // \"This function will invoke 'block' here and now, and exactly one time\"\n    contract { callsInPlace(block, EXACTLY_ONCE) }\n}\n\nfun foo() {\n    val x: Int\n    synchronize(lock) {\n        x = 42 // Compiler knows that lambda passed to 'synchronize' is called\n               // exactly once, so no reassignment is reported\n    }\n    println(x) // Compiler knows that lambda will be definitely called, performing\n               // initialization, so 'x' is considered to be initialized here\n}\n\n"}, {"type": "pre", "text": "fun synchronize(lock: Any?, block: () -> Unit) {\n    // It tells compiler:\n    // \"This function will invoke 'block' here and now, and exactly one time\"\n    contract { callsInPlace(block, EXACTLY_ONCE) }\n}\n\nfun foo() {\n    val x: Int\n    synchronize(lock) {\n        x = 42 // Compiler knows that lambda passed to 'synchronize' is called\n               // exactly once, so no reassignment is reported\n    }\n    println(x) // Compiler knows that lambda will be definitely called, performing\n               // initialization, so 'x' is considered to be initialized here\n}\n"}, {"type": "code", "text": "fun synchronize(lock: Any?, block: () -> Unit) {\n    // It tells compiler:\n    // \"This function will invoke 'block' here and now, and exactly one time\"\n    contract { callsInPlace(block, EXACTLY_ONCE) }\n}\n\nfun foo() {\n    val x: Int\n    synchronize(lock) {\n        x = 42 // Compiler knows that lambda passed to 'synchronize' is called\n               // exactly once, so no reassignment is reported\n    }\n    println(x) // Compiler knows that lambda will be definitely called, performing\n               // initialization, so 'x' is considered to be initialized here\n}\n"}, {"type": "h3", "text": "Contracts in stdlib"}, {"type": "p", "text": "stdlib already makes use of contracts, which leads to improvements in the analyses described above.  This part of contracts is stable, meaning that you can benefit from the improved analysis right now without any additional opt-ins:"}, {"type": "code", "text": "stdlib"}, {"type": "strong", "text": "stable"}, {"type": "div", "text": "\n//sampleStart\nfun bar(x: String?) {\n    if (!x.isNullOrEmpty()) {\n        println(\"length of '$x' is ${x.length}\") // Yay, smartcasted to not-null!\n    }\n}\n//sampleEnd\nfun main() {\n    bar(null)\n    bar(\"42\")\n}\n\n"}, {"type": "pre", "text": "//sampleStart\nfun bar(x: String?) {\n    if (!x.isNullOrEmpty()) {\n        println(\"length of '$x' is ${x.length}\") // Yay, smartcasted to not-null!\n    }\n}\n//sampleEnd\nfun main() {\n    bar(null)\n    bar(\"42\")\n}\n"}, {"type": "code", "text": "//sampleStart\nfun bar(x: String?) {\n    if (!x.isNullOrEmpty()) {\n        println(\"length of '$x' is ${x.length}\") // Yay, smartcasted to not-null!\n    }\n}\n//sampleEnd\nfun main() {\n    bar(null)\n    bar(\"42\")\n}\n"}, {"type": "h3", "text": "Custom Contracts"}, {"type": "p", "text": "It is possible to declare contracts for your own functions, but this feature is experimental, as the current syntax is in a state of early prototype and will most probably be changed. Also, please note, that currently the Kotlin compiler does not verify contracts, so it's a programmer's responsibility to write correct and sound contracts."}, {"type": "strong", "text": "experimental,"}, {"type": "p", "text": "Custom contracts are introduced by the call to contract stdlib function, which provides DSL scope:"}, {"type": "code", "text": "contract"}, {"type": "div", "text": "\nfun String?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n    return this == null || isEmpty()\n}\n\n"}, {"type": "pre", "text": "fun String?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n    return this == null || isEmpty()\n}\n"}, {"type": "code", "text": "fun String?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n    return this == null || isEmpty()\n}\n"}, {"type": "p", "text": "See the details on the syntax as well as the compatibility notice in the KEEP."}, {"type": "a", "text": "KEEP"}, {"type": "h2", "text": "Capturing when subject in a variable"}, {"type": "code", "text": "when"}, {"type": "p", "text": "In Kotlin 1.3, it is now possible to capture the when subject into variable:"}, {"type": "code", "text": "when"}, {"type": "div", "text": "\nfun Request.getBody() =\n        when (val response = executeRequest()) {\n            is Success -> response.body\n            is HttpError -> throw HttpException(response.status)\n        }\n\n"}, {"type": "pre", "text": "fun Request.getBody() =\n        when (val response = executeRequest()) {\n            is Success -> response.body\n            is HttpError -> throw HttpException(response.status)\n        }\n"}, {"type": "code", "text": "fun Request.getBody() =\n        when (val response = executeRequest()) {\n            is Success -> response.body\n            is HttpError -> throw HttpException(response.status)\n        }\n"}, {"type": "p", "text": "While it was already possible to extract this variable just before when , val in when has its scope properly restricted to the body of when, and so preventing namespace pollution. See the full documentation on when here."}, {"type": "code", "text": "when"}, {"type": "code", "text": "val"}, {"type": "code", "text": "when"}, {"type": "code", "text": "when"}, {"type": "code", "text": "when"}, {"type": "a", "text": "here"}, {"type": "h2", "text": "@JvmStatic and @JvmField in companion of interfaces"}, {"type": "p", "text": "With Kotlin 1.3, it is possible to mark members of a companion object of interfaces with annotations @JvmStatic and @JvmField. In the classfile, such members will be lifted to the corresponding interface and marked as static."}, {"type": "code", "text": "companion"}, {"type": "code", "text": "@JvmStatic"}, {"type": "code", "text": "@JvmField"}, {"type": "code", "text": "static"}, {"type": "p", "text": "For example, the following Kotlin code:"}, {"type": "div", "text": "\ninterface Foo {\n    companion object {\n        @JvmField\n        val answer: Int = 42\n\n        @JvmStatic\n        fun sayHello() {\n            println(\"Hello, world!\")\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "interface Foo {\n    companion object {\n        @JvmField\n        val answer: Int = 42\n\n        @JvmStatic\n        fun sayHello() {\n            println(\"Hello, world!\")\n        }\n    }\n}\n"}, {"type": "code", "text": "interface Foo {\n    companion object {\n        @JvmField\n        val answer: Int = 42\n\n        @JvmStatic\n        fun sayHello() {\n            println(\"Hello, world!\")\n        }\n    }\n}\n"}, {"type": "p", "text": "It is equivalent to this Java code:"}, {"type": "div", "text": "\ninterface Foo {\n    public static int answer = 42;\n    public static void sayHello() {\n        // ...\n    }\n}\n\n"}, {"type": "pre", "text": "interface Foo {\n    public static int answer = 42;\n    public static void sayHello() {\n        // ...\n    }\n}\n"}, {"type": "code", "text": "interface Foo {\n    public static int answer = 42;\n    public static void sayHello() {\n        // ...\n    }\n}\n"}, {"type": "h2", "text": "Nested declarations in annotation classes"}, {"type": "p", "text": "In Kotlin 1.3 it is possible for annotations to have nested classes, interfaces, objects, and companions:"}, {"type": "div", "text": "\nannotation class Foo {\n    enum class Direction { UP, DOWN, LEFT, RIGHT }\n    \n    annotation class Bar\n\n    companion object {\n        fun foo(): Int = 42\n        val bar: Int = 42\n    }\n}\n\n"}, {"type": "pre", "text": "annotation class Foo {\n    enum class Direction { UP, DOWN, LEFT, RIGHT }\n    \n    annotation class Bar\n\n    companion object {\n        fun foo(): Int = 42\n        val bar: Int = 42\n    }\n}\n"}, {"type": "code", "text": "annotation class Foo {\n    enum class Direction { UP, DOWN, LEFT, RIGHT }\n    \n    annotation class Bar\n\n    companion object {\n        fun foo(): Int = 42\n        val bar: Int = 42\n    }\n}\n"}, {"type": "h2", "text": "Parameterless main"}, {"type": "code", "text": "main"}, {"type": "p", "text": "By convention, the entry point of a Kotlin program is a function with a signature like main(args: Array<String>), where args represent the command-line arguments passed to the program. However, not every application supports command-line arguments, so this parameter often ends up not being used."}, {"type": "code", "text": "main(args: Array<String>)"}, {"type": "code", "text": "args"}, {"type": "p", "text": "Kotlin 1.3 introduced a simpler form of main which takes no parameters. Now \u201cHello, World\u201d in Kotlin is 19 characters shorter!"}, {"type": "code", "text": "main"}, {"type": "div", "text": "\nfun main() {\n    println(\"Hello, world!\")\n}\n\n"}, {"type": "pre", "text": "fun main() {\n    println(\"Hello, world!\")\n}\n"}, {"type": "code", "text": "fun main() {\n    println(\"Hello, world!\")\n}\n"}, {"type": "h2", "text": "Functions with big arity"}, {"type": "p", "text": "In Kotlin, functional types are represented as generic classes taking a different number of parameters: Function0<R>, Function1<P0, R>, Function2<P0, P1, R>, \u2026 This approach has a problem in that this list is finite, and it currently ends with Function22."}, {"type": "code", "text": "Function0<R>"}, {"type": "code", "text": "Function1<P0, R>"}, {"type": "code", "text": "Function2<P0, P1, R>"}, {"type": "code", "text": "Function22"}, {"type": "p", "text": "Kotlin 1.3 relaxes this limitation and adds support for functions with bigger arity:"}, {"type": "div", "text": "\nfun trueEnterpriseComesToKotlin(block: (Any, Any, ... /* 42 more */, Any) -> Any) {\n    block(Any(), Any(), ..., Any())\n}\n\n"}, {"type": "pre", "text": "fun trueEnterpriseComesToKotlin(block: (Any, Any, ... /* 42 more */, Any) -> Any) {\n    block(Any(), Any(), ..., Any())\n}\n"}, {"type": "code", "text": "fun trueEnterpriseComesToKotlin(block: (Any, Any, ... /* 42 more */, Any) -> Any) {\n    block(Any(), Any(), ..., Any())\n}\n"}, {"type": "h2", "text": "Progressive mode"}, {"type": "p", "text": "Kotlin cares a lot about stability and backward compatibility of code: Kotlin compatibility policy says that \"breaking changes\" (e.g., a change which makes the code that used to compile fine, not compile anymore) can be introduced only in the major releases (1.2, 1.3, etc.)."}, {"type": "p", "text": "We believe that a lot of users could use a much faster cycle, where critical compiler bug fixes arrive immediately, making the code more safe and correct. So, Kotlin 1.3 introduces progressive compiler mode, which can be enabled by passing the argument -progressive to the compiler."}, {"type": "em", "text": "progressive"}, {"type": "code", "text": "-progressive"}, {"type": "p", "text": "In progressive mode, some fixes in language semantics can arrive immediately. All these fixes have two important properties:"}, {"type": "ul", "text": "\nthey preserve backward-compatibility of source code with older compilers, meaning that all the code which is compilable by the progressive compiler will be compiled fine by non-progressive one.\nthey only make code safer in some sense \u2014 e.g., some unsound smartcast can be forbidden, behavior of the generated code may be changed to be more predictable/stable, and so on.\n"}, {"type": "li", "text": "they preserve backward-compatibility of source code with older compilers, meaning that all the code which is compilable by the progressive compiler will be compiled fine by non-progressive one."}, {"type": "li", "text": "they only make code safer in some sense \u2014 e.g., some unsound smartcast can be forbidden, behavior of the generated code may be changed to be more predictable/stable, and so on."}, {"type": "em", "text": "safer"}, {"type": "p", "text": "Enabling the progressive mode can require you to rewrite some of your code, but it shouldn't be too much \u2014 all the fixes which are enabled under progressive are carefully handpicked, reviewed, and provided with tooling migration assistance. \nWe expect that the progressive mode will be a nice choice for any actively maintained codebases which are updated to the latest language versions quickly."}, {"type": "h2", "text": "Inline classes"}, {"type": "blockquote", "text": "\nInline classes are available only since Kotlin 1.3 and currently are experimental. See details in the reference.\n"}, {"type": "p", "text": "Inline classes are available only since Kotlin 1.3 and currently are experimental. See details in the reference."}, {"type": "em", "text": "experimental"}, {"type": "a", "text": "reference"}, {"type": "p", "text": "Kotlin 1.3 introduces a new kind of declaration \u2014 inline class. Inline classes can be viewed as a restricted version of the usual classes, in particular, inline classes must have exactly one property:"}, {"type": "code", "text": "inline class"}, {"type": "div", "text": "\ninline class Name(val s: String)\n\n"}, {"type": "pre", "text": "inline class Name(val s: String)\n"}, {"type": "code", "text": "inline class Name(val s: String)\n"}, {"type": "p", "text": "The Kotlin compiler will use this restriction to aggressively optimize runtime representation of inline classes and substitute their instances with the value of the underlying property where possible removing constructor calls, GC pressure, and enabling other optimizations:"}, {"type": "div", "text": "\ninline class Name(val s: String)\n//sampleStart\nfun main() {\n    // In the next line no constructor call happens, and\n    // at the runtime 'name' contains just string \"Kotlin\"\n    val name = Name(\"Kotlin\")\n    println(name.s) \n}\n//sampleEnd\n\n"}, {"type": "pre", "text": "inline class Name(val s: String)\n//sampleStart\nfun main() {\n    // In the next line no constructor call happens, and\n    // at the runtime 'name' contains just string \"Kotlin\"\n    val name = Name(\"Kotlin\")\n    println(name.s) \n}\n//sampleEnd\n"}, {"type": "code", "text": "inline class Name(val s: String)\n//sampleStart\nfun main() {\n    // In the next line no constructor call happens, and\n    // at the runtime 'name' contains just string \"Kotlin\"\n    val name = Name(\"Kotlin\")\n    println(name.s) \n}\n//sampleEnd\n"}, {"type": "p", "text": "See reference for inline classes for details."}, {"type": "a", "text": "reference"}, {"type": "h2", "text": "Unsigned integers"}, {"type": "blockquote", "text": "\nUnsigned integers are available only since Kotlin 1.3 and currently are experimental. See details in the reference.\n"}, {"type": "p", "text": "Unsigned integers are available only since Kotlin 1.3 and currently are experimental. See details in the reference."}, {"type": "em", "text": "experimental"}, {"type": "a", "text": "reference"}, {"type": "p", "text": "Kotlin 1.3 introduces unsigned integer types:"}, {"type": "ul", "text": "\nkotlin.UByte: an unsigned 8-bit integer, ranges from 0 to 255\nkotlin.UShort: an unsigned 16-bit integer, ranges from 0 to 65535\nkotlin.UInt: an unsigned 32-bit integer, ranges from 0 to 2^32 - 1\nkotlin.ULong: an unsigned 64-bit integer, ranges from 0 to 2^64 - 1\n"}, {"type": "li", "text": "kotlin.UByte: an unsigned 8-bit integer, ranges from 0 to 255"}, {"type": "code", "text": "kotlin.UByte"}, {"type": "li", "text": "kotlin.UShort: an unsigned 16-bit integer, ranges from 0 to 65535"}, {"type": "code", "text": "kotlin.UShort"}, {"type": "li", "text": "kotlin.UInt: an unsigned 32-bit integer, ranges from 0 to 2^32 - 1"}, {"type": "code", "text": "kotlin.UInt"}, {"type": "li", "text": "kotlin.ULong: an unsigned 64-bit integer, ranges from 0 to 2^64 - 1"}, {"type": "code", "text": "kotlin.ULong"}, {"type": "p", "text": "Most of the functionality of signed types are supported for unsigned counterparts too:"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n// You can define unsigned types using literal suffixes\nval uint = 42u \nval ulong = 42uL\nval ubyte: UByte = 255u\n\n// You can convert signed types to unsigned and vice versa via stdlib extensions:\nval int = uint.toInt()\nval byte = ubyte.toByte()\nval ulong2 = byte.toULong()\n\n// Unsigned types support similar operators:\nval x = 20u + 22u\nval y = 1u shl 8\nval z = \"128\".toUByte()\nval range = 1u..5u\n//sampleEnd\nprintln(\"ubyte: $ubyte, byte: $byte, ulong2: $ulong2\")\nprintln(\"x: $x, y: $y, z: $z, range: $range\")\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n// You can define unsigned types using literal suffixes\nval uint = 42u \nval ulong = 42uL\nval ubyte: UByte = 255u\n\n// You can convert signed types to unsigned and vice versa via stdlib extensions:\nval int = uint.toInt()\nval byte = ubyte.toByte()\nval ulong2 = byte.toULong()\n\n// Unsigned types support similar operators:\nval x = 20u + 22u\nval y = 1u shl 8\nval z = \"128\".toUByte()\nval range = 1u..5u\n//sampleEnd\nprintln(\"ubyte: $ubyte, byte: $byte, ulong2: $ulong2\")\nprintln(\"x: $x, y: $y, z: $z, range: $range\")\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n// You can define unsigned types using literal suffixes\nval uint = 42u \nval ulong = 42uL\nval ubyte: UByte = 255u\n\n// You can convert signed types to unsigned and vice versa via stdlib extensions:\nval int = uint.toInt()\nval byte = ubyte.toByte()\nval ulong2 = byte.toULong()\n\n// Unsigned types support similar operators:\nval x = 20u + 22u\nval y = 1u shl 8\nval z = \"128\".toUByte()\nval range = 1u..5u\n//sampleEnd\nprintln(\"ubyte: $ubyte, byte: $byte, ulong2: $ulong2\")\nprintln(\"x: $x, y: $y, z: $z, range: $range\")\n}\n"}, {"type": "p", "text": "See reference for details."}, {"type": "a", "text": "reference"}, {"type": "h2", "text": "@JvmDefault"}, {"type": "blockquote", "text": "\n@JvmDefault is only available since Kotlin 1.3 and currently is experimental. See details in the reference page.\n"}, {"type": "p", "text": "@JvmDefault is only available since Kotlin 1.3 and currently is experimental. See details in the reference page."}, {"type": "code", "text": "@JvmDefault"}, {"type": "em", "text": "experimental"}, {"type": "a", "text": "reference page"}, {"type": "p", "text": "Kotlin targets a wide range of the Java versions, including Java 6 and Java 7, where default methods in the interfaces are not allowed. For your convenience, the Kotlin compiler works around that limitation, but this workaround isn't compatible with the default methods, introduced in Java 8."}, {"type": "code", "text": "default"}, {"type": "p", "text": "This could be an issue for Java-interoperability, so Kotlin 1.3 introduces the @JvmDefault annotation. Methods, annotated with this annotation will be generated as default methods for JVM:"}, {"type": "code", "text": "@JvmDefault"}, {"type": "code", "text": "default"}, {"type": "div", "text": "\ninterface Foo {\n    // Will be generated as 'default' method\n    @JvmDefault\n    fun foo(): Int = 42\n}\n\n"}, {"type": "pre", "text": "interface Foo {\n    // Will be generated as 'default' method\n    @JvmDefault\n    fun foo(): Int = 42\n}\n"}, {"type": "code", "text": "interface Foo {\n    // Will be generated as 'default' method\n    @JvmDefault\n    fun foo(): Int = 42\n}\n"}, {"type": "blockquote", "text": "\nWarning! Annotating your API with @JvmDefault has serious implications on binary compatibility. Make sure to carefully read the reference page before using @JvmDefault in production.\n"}, {"type": "p", "text": "Warning! Annotating your API with @JvmDefault has serious implications on binary compatibility. Make sure to carefully read the reference page before using @JvmDefault in production."}, {"type": "code", "text": "@JvmDefault"}, {"type": "a", "text": "reference page"}, {"type": "code", "text": "@JvmDefault"}, {"type": "h1", "text": "Standard library"}, {"type": "h2", "text": "Multiplatform Random"}, {"type": "code", "text": "Random"}, {"type": "p", "text": "Prior to Kotlin 1.3, there was no uniform way to generate random numbers on all platforms \u2014 we had to resort to platform specific solutions, like java.util.Random on JVM. This release fixes this issue by introducing the class kotlin.random.Random, which is available on all platforms:"}, {"type": "code", "text": "java.util.Random"}, {"type": "code", "text": "kotlin.random.Random"}, {"type": "div", "text": "\nimport kotlin.random.Random\n\nfun main() {\n//sampleStart\n    val number = Random.nextInt(42)  // number is in range [0, limit)\n    println(number)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "import kotlin.random.Random\n\nfun main() {\n//sampleStart\n    val number = Random.nextInt(42)  // number is in range [0, limit)\n    println(number)\n//sampleEnd\n}\n"}, {"type": "code", "text": "import kotlin.random.Random\n\nfun main() {\n//sampleStart\n    val number = Random.nextInt(42)  // number is in range [0, limit)\n    println(number)\n//sampleEnd\n}\n"}, {"type": "h2", "text": "isNullOrEmpty/orEmpty extensions"}, {"type": "p", "text": "isNullOrEmpty and orEmpty extensions for some types are already present in stdlib . The first one returns true if the receiver is null or empty, and the second one falls back to an empty instance if the receiver is null.\nKotlin 1.3 provides similar extensions on collections, maps, and arrays of objects."}, {"type": "code", "text": "isNullOrEmpty"}, {"type": "code", "text": "orEmpty"}, {"type": "code", "text": "true"}, {"type": "code", "text": "null"}, {"type": "code", "text": "null"}, {"type": "h2", "text": "Copying elements between two existing arrays"}, {"type": "p", "text": "The array.copyInto(targetArray, targetOffset, startIndex, endIndex) functions for the existing array types, including the unsigned arrays, make it easier to implement array-based containers in pure Kotlin."}, {"type": "code", "text": "array.copyInto(targetArray, targetOffset, startIndex, endIndex)"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val sourceArr = arrayOf(\"k\", \"o\", \"t\", \"l\", \"i\", \"n\")\n    val targetArr = sourceArr.copyInto(arrayOfNulls<String>(6), 3, startIndex = 3, endIndex = 6)\n    println(targetArr.contentToString())\n    \n    sourceArr.copyInto(targetArr, startIndex = 0, endIndex = 3)\n    println(targetArr.contentToString())\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val sourceArr = arrayOf(\"k\", \"o\", \"t\", \"l\", \"i\", \"n\")\n    val targetArr = sourceArr.copyInto(arrayOfNulls<String>(6), 3, startIndex = 3, endIndex = 6)\n    println(targetArr.contentToString())\n    \n    sourceArr.copyInto(targetArr, startIndex = 0, endIndex = 3)\n    println(targetArr.contentToString())\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val sourceArr = arrayOf(\"k\", \"o\", \"t\", \"l\", \"i\", \"n\")\n    val targetArr = sourceArr.copyInto(arrayOfNulls<String>(6), 3, startIndex = 3, endIndex = 6)\n    println(targetArr.contentToString())\n    \n    sourceArr.copyInto(targetArr, startIndex = 0, endIndex = 3)\n    println(targetArr.contentToString())\n//sampleEnd\n}\n"}, {"type": "h2", "text": "associateWith"}, {"type": "p", "text": "It is quite a common situation to have a list of keys and want to build a map by associating each of these keys with some value. It was possible to do it before with the associate { it to getValue(it) } function, but now we\u2019re introducing a more efficient and easy to explore alternative: keys.associateWith { getValue(it) }."}, {"type": "code", "text": "associate { it to getValue(it) }"}, {"type": "code", "text": "keys.associateWith { getValue(it) }"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val keys = 'a'..'f'\n    val map = keys.associateWith { it.toString().repeat(5).capitalize() }\n    map.forEach { println(it) }\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val keys = 'a'..'f'\n    val map = keys.associateWith { it.toString().repeat(5).capitalize() }\n    map.forEach { println(it) }\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val keys = 'a'..'f'\n    val map = keys.associateWith { it.toString().repeat(5).capitalize() }\n    map.forEach { println(it) }\n//sampleEnd\n}\n"}, {"type": "h2", "text": "ifEmpty and ifBlank functions"}, {"type": "p", "text": "Collections, maps, object arrays, char sequences, and sequences now have an ifEmpty function, which allows specifying a fallback value that will be used instead of the receiver if it is empty:"}, {"type": "code", "text": "ifEmpty"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    fun printAllUppercase(data: List<String>) {\n        val result = data\n        .filter { it.all { c -> c.isUpperCase() } }\n            .ifEmpty { listOf(\"<no uppercase>\") }\n        result.forEach { println(it) }\n    }\n    \n    printAllUppercase(listOf(\"foo\", \"Bar\"))\n    printAllUppercase(listOf(\"FOO\", \"BAR\"))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    fun printAllUppercase(data: List<String>) {\n        val result = data\n        .filter { it.all { c -> c.isUpperCase() } }\n            .ifEmpty { listOf(\"<no uppercase>\") }\n        result.forEach { println(it) }\n    }\n    \n    printAllUppercase(listOf(\"foo\", \"Bar\"))\n    printAllUppercase(listOf(\"FOO\", \"BAR\"))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    fun printAllUppercase(data: List<String>) {\n        val result = data\n        .filter { it.all { c -> c.isUpperCase() } }\n            .ifEmpty { listOf(\"<no uppercase>\") }\n        result.forEach { println(it) }\n    }\n    \n    printAllUppercase(listOf(\"foo\", \"Bar\"))\n    printAllUppercase(listOf(\"FOO\", \"BAR\"))\n//sampleEnd\n}\n"}, {"type": "p", "text": "Char sequences and strings in addition have an ifBlank extension that does the same thing as ifEmpty, but checks for a string being all whitespace instead of empty."}, {"type": "code", "text": "ifBlank"}, {"type": "code", "text": "ifEmpty"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val s = \"    \\n\"\n    println(s.ifBlank { \"<blank>\" })\n    println(s.ifBlank { null })\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val s = \"    \\n\"\n    println(s.ifBlank { \"<blank>\" })\n    println(s.ifBlank { null })\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val s = \"    \\n\"\n    println(s.ifBlank { \"<blank>\" })\n    println(s.ifBlank { null })\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Sealed classes in reflection"}, {"type": "p", "text": "We\u2019ve added a new API to kotlin-reflect that can be used to enumerate all the direct subtypes of a sealed class, namely KClass.sealedSubclasses."}, {"type": "code", "text": "kotlin-reflect"}, {"type": "code", "text": "sealed"}, {"type": "code", "text": "KClass.sealedSubclasses"}, {"type": "h2", "text": "Smaller changes"}, {"type": "ul", "text": "\nBoolean type now has companion.\nAny?.hashCode() extension, which returns 0 for null.\nChar now provides MIN_VALUE/MAX_VALUE constants.\nSIZE_BYTES and SIZE_BITS constants in primitive type companions.\n"}, {"type": "li", "text": "Boolean type now has companion."}, {"type": "code", "text": "Boolean"}, {"type": "li", "text": "Any?.hashCode() extension, which returns 0 for null."}, {"type": "code", "text": "Any?.hashCode()"}, {"type": "code", "text": "null"}, {"type": "li", "text": "Char now provides MIN_VALUE/MAX_VALUE constants."}, {"type": "code", "text": "Char"}, {"type": "code", "text": "MIN_VALUE"}, {"type": "code", "text": "MAX_VALUE"}, {"type": "li", "text": "SIZE_BYTES and SIZE_BITS constants in primitive type companions."}, {"type": "code", "text": "SIZE_BYTES"}, {"type": "code", "text": "SIZE_BITS"}, {"type": "h1", "text": "Tooling"}, {"type": "h2", "text": "Code Style Support in IDE"}, {"type": "p", "text": "Kotlin 1.3 introduces support for the recommended code style in the IDE. Check out this page for the migration guidelines."}, {"type": "a", "text": "recommended code style"}, {"type": "a", "text": "this page"}, {"type": "h2", "text": "kotlinx.serialization"}, {"type": "p", "text": "kotlinx.serialization is a library which provides multiplatform support for (de)serializing objects in Kotlin. Previously, it was a separate project, but since Kotlin 1.3, it ships with the Kotlin compiler distribution on par with the other compiler plugins. The main difference is that you don't need to manually watch out for the Serialization IDE Plugin being compatible with the Kotlin IDE Plugin version you're using: now the Kotlin IDE Plugin already includes serialization!"}, {"type": "a", "text": "kotlinx.serialization"}, {"type": "p", "text": "See here for details."}, {"type": "a", "text": "details"}, {"type": "blockquote", "text": "\nPlease, note, that even though kotlinx.serialization now ships with the Kotlin Compiler distribution, it is still considered to be an experimental feature.\n"}, {"type": "p", "text": "Please, note, that even though kotlinx.serialization now ships with the Kotlin Compiler distribution, it is still considered to be an experimental feature."}, {"type": "h2", "text": "Scripting update"}, {"type": "blockquote", "text": "\nPlease note, that scripting is an experimental feature, meaning that no compatibility guarantees on the API are given.\n"}, {"type": "p", "text": "Please note, that scripting is an experimental feature, meaning that no compatibility guarantees on the API are given."}, {"type": "p", "text": "Kotlin 1.3 continues to evolve and improve scripting API, introducing some experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on."}, {"type": "p", "text": "For additional details, please consult the KEEP-75."}, {"type": "a", "text": "KEEP-75"}, {"type": "h2", "text": "Scratches support"}, {"type": "p", "text": "Kotlin 1.3 introduces support for runnable Kotlin scratch files. Scratch file is a kotlin script file with a .kts extension which you can run and get evaluation results directly in the editor."}, {"type": "em", "text": "scratch files"}, {"type": "em", "text": "Scratch file"}, {"type": "p", "text": "Consult the general Scratches documentation for details."}, {"type": "a", "text": "Scratches documentation"}]