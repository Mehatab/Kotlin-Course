[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Data Classes"}, {"type": "p", "text": "We frequently create classes whose main purpose is to hold data.\nIn such a class some standard functionality and utility functions are often mechanically\nderivable from the data. In Kotlin, this is called a data class and is marked as data:"}, {"type": "em", "text": "data class"}, {"type": "code", "text": "data"}, {"type": "div", "text": "\ndata class User(val name: String, val age: Int)\n\n"}, {"type": "pre", "text": "data class User(val name: String, val age: Int)\n"}, {"type": "code", "text": "data class User(val name: String, val age: Int)\n"}, {"type": "p", "text": "The compiler automatically derives the following members from all properties declared in the primary constructor:"}, {"type": "ul", "text": "\nequals()/hashCode() pair;\ntoString() of the form \"User(name=John, age=42)\";\ncomponentN() functions corresponding to the properties in their order of declaration;\ncopy() function (see below).\n"}, {"type": "li", "text": "equals()/hashCode() pair;"}, {"type": "code", "text": "equals()"}, {"type": "code", "text": "hashCode()"}, {"type": "li", "text": "toString() of the form \"User(name=John, age=42)\";"}, {"type": "code", "text": "toString()"}, {"type": "code", "text": "\"User(name=John, age=42)\""}, {"type": "li", "text": "componentN() functions corresponding to the properties in their order of declaration;"}, {"type": "a", "text": "componentN() functions"}, {"type": "code", "text": "componentN()"}, {"type": "li", "text": "copy() function (see below)."}, {"type": "code", "text": "copy()"}, {"type": "p", "text": "To ensure consistency and meaningful behavior of the generated code, data classes have to fulfill the following requirements:"}, {"type": "ul", "text": "\nThe primary constructor needs to have at least one parameter;\nAll primary constructor parameters need to be marked as val or var;\nData classes cannot be abstract, open, sealed or inner;\n(before 1.1) Data classes may only implement interfaces.\n"}, {"type": "li", "text": "The primary constructor needs to have at least one parameter;"}, {"type": "li", "text": "All primary constructor parameters need to be marked as val or var;"}, {"type": "code", "text": "val"}, {"type": "code", "text": "var"}, {"type": "li", "text": "Data classes cannot be abstract, open, sealed or inner;"}, {"type": "li", "text": "(before 1.1) Data classes may only implement interfaces."}, {"type": "p", "text": "Additionally, the members generation follows these rules with regard to the members inheritance:"}, {"type": "ul", "text": "\nIf there are explicit implementations of equals(), hashCode() or toString() in the data class body or \nfinal implementations in a superclass, then these functions are not generated, and the existing \nimplementations are used;\nIf a supertype has the componentN() functions that are open and return compatible types, the \ncorresponding functions are generated for the data class and override those of the supertype. If the functions of the \nsupertype cannot be overridden due to incompatible signatures or being final, an error is reported;\nDeriving a data class from a type that already has a copy(...) function with a matching signature is deprecated in \nKotlin 1.2 and is prohibited in Kotlin 1.3.\nProviding explicit implementations for the componentN() and copy() functions is not allowed.\n"}, {"type": "li", "text": "If there are explicit implementations of equals(), hashCode() or toString() in the data class body or \nfinal implementations in a superclass, then these functions are not generated, and the existing \nimplementations are used;"}, {"type": "code", "text": "equals()"}, {"type": "code", "text": "hashCode()"}, {"type": "code", "text": "toString()"}, {"type": "em", "text": "final"}, {"type": "li", "text": "If a supertype has the componentN() functions that are open and return compatible types, the \ncorresponding functions are generated for the data class and override those of the supertype. If the functions of the \nsupertype cannot be overridden due to incompatible signatures or being final, an error is reported;"}, {"type": "code", "text": "componentN()"}, {"type": "em", "text": "open"}, {"type": "li", "text": "Deriving a data class from a type that already has a copy(...) function with a matching signature is deprecated in \nKotlin 1.2 and is prohibited in Kotlin 1.3."}, {"type": "code", "text": "copy(...)"}, {"type": "li", "text": "Providing explicit implementations for the componentN() and copy() functions is not allowed."}, {"type": "code", "text": "componentN()"}, {"type": "code", "text": "copy()"}, {"type": "p", "text": "Since 1.1, data classes may extend other classes (see Sealed classes for examples)."}, {"type": "a", "text": "Sealed classes"}, {"type": "p", "text": "On the JVM, if the generated class needs to have a parameterless constructor, default values for all properties have to be specified\n(see Constructors)."}, {"type": "a", "text": "Constructors"}, {"type": "div", "text": "\ndata class User(val name: String = \"\", val age: Int = 0)\n\n"}, {"type": "pre", "text": "data class User(val name: String = \"\", val age: Int = 0)\n"}, {"type": "code", "text": "data class User(val name: String = \"\", val age: Int = 0)\n"}, {"type": "h2", "text": "Properties Declared in the Class Body"}, {"type": "p", "text": "Note that the compiler only uses the properties defined inside the primary constructor for the automatically generated functions. To exclude a property from the generated implementations, declare it inside the class body:"}, {"type": "div", "text": "\ndata class Person(val name: String) {\n    var age: Int = 0\n}\n\n"}, {"type": "pre", "text": "data class Person(val name: String) {\n    var age: Int = 0\n}\n"}, {"type": "code", "text": "data class Person(val name: String) {\n    var age: Int = 0\n}\n"}, {"type": "p", "text": "Only the property name will be used inside the toString(), equals(), hashCode(), and copy() implementations, and there will only be one component function component1(). While two Person objects can have different ages, they will be treated as equal."}, {"type": "code", "text": "name"}, {"type": "code", "text": "toString()"}, {"type": "code", "text": "equals()"}, {"type": "code", "text": "hashCode()"}, {"type": "code", "text": "copy()"}, {"type": "code", "text": "component1()"}, {"type": "code", "text": "Person"}, {"type": "div", "text": "\ndata class Person(val name: String) {\n    var age: Int = 0\n}\nfun main() {\n//sampleStart\n    val person1 = Person(\"John\")\n    val person2 = Person(\"John\")\n    person1.age = 10\n    person2.age = 20\n//sampleEnd\n    println(\"person1 == person2: ${person1 == person2}\")\n    println(\"person1 with age ${person1.age}: ${person1}\")\n    println(\"person2 with age ${person2.age}: ${person2}\")\n}\n\n"}, {"type": "pre", "text": "data class Person(val name: String) {\n    var age: Int = 0\n}\nfun main() {\n//sampleStart\n    val person1 = Person(\"John\")\n    val person2 = Person(\"John\")\n    person1.age = 10\n    person2.age = 20\n//sampleEnd\n    println(\"person1 == person2: ${person1 == person2}\")\n    println(\"person1 with age ${person1.age}: ${person1}\")\n    println(\"person2 with age ${person2.age}: ${person2}\")\n}\n"}, {"type": "code", "text": "data class Person(val name: String) {\n    var age: Int = 0\n}\nfun main() {\n//sampleStart\n    val person1 = Person(\"John\")\n    val person2 = Person(\"John\")\n    person1.age = 10\n    person2.age = 20\n//sampleEnd\n    println(\"person1 == person2: ${person1 == person2}\")\n    println(\"person1 with age ${person1.age}: ${person1}\")\n    println(\"person2 with age ${person2.age}: ${person2}\")\n}\n"}, {"type": "h2", "text": "Copying"}, {"type": "p", "text": "It's often the case that we need to copy an object altering some of its properties, but keeping the rest unchanged. \nThis is what copy() function is generated for. For the User class above, its implementation would be as follows:"}, {"type": "em", "text": "some"}, {"type": "code", "text": "copy()"}, {"type": "code", "text": "User"}, {"type": "div", "text": "\nfun copy(name: String = this.name, age: Int = this.age) = User(name, age)     \n\n"}, {"type": "pre", "text": "fun copy(name: String = this.name, age: Int = this.age) = User(name, age)     \n"}, {"type": "code", "text": "fun copy(name: String = this.name, age: Int = this.age) = User(name, age)     \n"}, {"type": "p", "text": "This allows us to write:"}, {"type": "div", "text": "\nval jack = User(name = \"Jack\", age = 1)\nval olderJack = jack.copy(age = 2)\n\n"}, {"type": "pre", "text": "val jack = User(name = \"Jack\", age = 1)\nval olderJack = jack.copy(age = 2)\n"}, {"type": "code", "text": "val jack = User(name = \"Jack\", age = 1)\nval olderJack = jack.copy(age = 2)\n"}, {"type": "h2", "text": "Data Classes and Destructuring Declarations"}, {"type": "p", "text": "Component functions generated for data classes enable their use in destructuring declarations:"}, {"type": "em", "text": "Component functions"}, {"type": "a", "text": "destructuring declarations"}, {"type": "div", "text": "\nval jane = User(\"Jane\", 35) \nval (name, age) = jane\nprintln(\"$name, $age years of age\") // prints \"Jane, 35 years of age\"\n\n"}, {"type": "pre", "text": "val jane = User(\"Jane\", 35) \nval (name, age) = jane\nprintln(\"$name, $age years of age\") // prints \"Jane, 35 years of age\"\n"}, {"type": "code", "text": "val jane = User(\"Jane\", 35) \nval (name, age) = jane\nprintln(\"$name, $age years of age\") // prints \"Jane, 35 years of age\"\n"}, {"type": "h2", "text": "Standard Data Classes"}, {"type": "p", "text": "The standard library provides Pair and Triple. In most cases, though, named data classes are a better design choice, \nbecause they make the code more readable by providing meaningful names for properties."}, {"type": "code", "text": "Pair"}, {"type": "code", "text": "Triple"}]