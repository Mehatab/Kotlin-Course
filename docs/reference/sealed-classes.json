[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Sealed Classes"}, {"type": "p", "text": "Sealed classes are used for representing restricted class hierarchies, when a value can have one of the types from a\nlimited set, but cannot have any other type. They are, in a sense, an extension of enum classes: the set of values\nfor an enum type is also restricted, but each enum constant exists only as a single instance, whereas a subclass\nof a sealed class can have multiple instances which can contain state."}, {"type": "p", "text": "To declare a sealed class, you put the sealed modifier before the name of the class. A sealed class can have\nsubclasses, but all of them must be declared in the same file as the sealed class itself. (Before Kotlin 1.1,\nthe rules were even more strict: classes had to be nested inside the declaration of the sealed class)."}, {"type": "code", "text": "sealed"}, {"type": "div", "text": "\nsealed class Expr\ndata class Const(val number: Double) : Expr()\ndata class Sum(val e1: Expr, val e2: Expr) : Expr()\nobject NotANumber : Expr()\n\n"}, {"type": "pre", "text": "sealed class Expr\ndata class Const(val number: Double) : Expr()\ndata class Sum(val e1: Expr, val e2: Expr) : Expr()\nobject NotANumber : Expr()\n"}, {"type": "code", "text": "sealed class Expr\ndata class Const(val number: Double) : Expr()\ndata class Sum(val e1: Expr, val e2: Expr) : Expr()\nobject NotANumber : Expr()\n"}, {"type": "p", "text": "(The example above uses one additional new feature of Kotlin 1.1: the possibility for data classes to extend other\nclasses, including sealed classes.)"}, {"type": "p", "text": "A sealed class is abstract by itself, it cannot be instantiated directly and can have abstract members."}, {"type": "a", "text": "abstract"}, {"type": "em", "text": "abstract"}, {"type": "p", "text": "Sealed classes are not allowed to have non-private constructors (their constructors are private by default)."}, {"type": "em", "text": "private"}, {"type": "em", "text": "private"}, {"type": "p", "text": "Note that classes which extend subclasses of a sealed class (indirect inheritors) can be placed anywhere, not necessarily in\nthe same file."}, {"type": "p", "text": "The key benefit of using sealed classes comes into play when you use them in a when expression. If it's possible\nto verify that the statement covers all cases, you don't need to add an else clause to the statement. However, this works only if you use when as an expression (using the result) and not as a statement."}, {"type": "a", "text": "when expression"}, {"type": "code", "text": "when"}, {"type": "code", "text": "else"}, {"type": "code", "text": "when"}, {"type": "div", "text": "\nfun eval(expr: Expr): Double = when(expr) {\n    is Const -> expr.number\n    is Sum -> eval(expr.e1) + eval(expr.e2)\n    NotANumber -> Double.NaN\n    // the `else` clause is not required because we've covered all the cases\n}\n\n"}, {"type": "pre", "text": "fun eval(expr: Expr): Double = when(expr) {\n    is Const -> expr.number\n    is Sum -> eval(expr.e1) + eval(expr.e2)\n    NotANumber -> Double.NaN\n    // the `else` clause is not required because we've covered all the cases\n}\n"}, {"type": "code", "text": "fun eval(expr: Expr): Double = when(expr) {\n    is Const -> expr.number\n    is Sum -> eval(expr.e1) + eval(expr.e2)\n    NotANumber -> Double.NaN\n    // the `else` clause is not required because we've covered all the cases\n}\n"}]