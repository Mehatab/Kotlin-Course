[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h2", "text": "Type aliases"}, {"type": "p", "text": "Type aliases provide alternative names for existing types.\nIf the type name is too long you can introduce a different shorter name and use the new one instead."}, {"type": "p", "text": "It's useful to shorten long generic types.\nFor instance, it's often tempting to shrink collection types:"}, {"type": "div", "text": "\ntypealias NodeSet = Set<Network.Node>\n\ntypealias FileTable<K> = MutableMap<K, MutableList<File>>\n\n"}, {"type": "pre", "text": "typealias NodeSet = Set<Network.Node>\n\ntypealias FileTable<K> = MutableMap<K, MutableList<File>>\n"}, {"type": "code", "text": "typealias NodeSet = Set<Network.Node>\n\ntypealias FileTable<K> = MutableMap<K, MutableList<File>>\n"}, {"type": "p", "text": "You can provide different aliases for function types:"}, {"type": "div", "text": "\ntypealias MyHandler = (Int, String, Any) -> Unit\n\ntypealias Predicate<T> = (T) -> Boolean\n\n"}, {"type": "pre", "text": "typealias MyHandler = (Int, String, Any) -> Unit\n\ntypealias Predicate<T> = (T) -> Boolean\n"}, {"type": "code", "text": "typealias MyHandler = (Int, String, Any) -> Unit\n\ntypealias Predicate<T> = (T) -> Boolean\n"}, {"type": "p", "text": "You can have new names for inner and nested classes:"}, {"type": "div", "text": "\nclass A {\n    inner class Inner\n}\nclass B {\n    inner class Inner\n}\n\ntypealias AInner = A.Inner\ntypealias BInner = B.Inner\n\n"}, {"type": "pre", "text": "class A {\n    inner class Inner\n}\nclass B {\n    inner class Inner\n}\n\ntypealias AInner = A.Inner\ntypealias BInner = B.Inner\n"}, {"type": "code", "text": "class A {\n    inner class Inner\n}\nclass B {\n    inner class Inner\n}\n\ntypealias AInner = A.Inner\ntypealias BInner = B.Inner\n"}, {"type": "p", "text": "Type aliases do not introduce new types. \nThey are equivalent to the corresponding underlying types.\nWhen you add typealias Predicate<T> and use Predicate<Int> in your code, the Kotlin compiler always expands it to (Int) -> Boolean. \nThus you can pass a variable of your type whenever a general function type is required and vice versa:"}, {"type": "code", "text": "typealias Predicate<T>"}, {"type": "code", "text": "Predicate<Int>"}, {"type": "code", "text": "(Int) -> Boolean"}, {"type": "div", "text": "\ntypealias Predicate<T> = (T) -> Boolean\n\nfun foo(p: Predicate<Int>) = p(42)\n\nfun main() {\n    val f: (Int) -> Boolean = { it > 0 }\n    println(foo(f)) // prints \"true\"\n\n    val p: Predicate<Int> = { it > 0 }\n    println(listOf(1, -2).filter(p)) // prints \"[1]\"\n}\n\n"}, {"type": "pre", "text": "typealias Predicate<T> = (T) -> Boolean\n\nfun foo(p: Predicate<Int>) = p(42)\n\nfun main() {\n    val f: (Int) -> Boolean = { it > 0 }\n    println(foo(f)) // prints \"true\"\n\n    val p: Predicate<Int> = { it > 0 }\n    println(listOf(1, -2).filter(p)) // prints \"[1]\"\n}\n"}, {"type": "code", "text": "typealias Predicate<T> = (T) -> Boolean\n\nfun foo(p: Predicate<Int>) = p(42)\n\nfun main() {\n    val f: (Int) -> Boolean = { it > 0 }\n    println(foo(f)) // prints \"true\"\n\n    val p: Predicate<Int> = { it > 0 }\n    println(listOf(1, -2).filter(p)) // prints \"[1]\"\n}\n"}]