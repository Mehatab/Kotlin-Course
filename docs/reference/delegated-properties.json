[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Delegated Properties"}, {"type": "p", "text": "There are certain common kinds of properties, that, though we can implement them manually every time we need them, \nwould be very nice to implement once and for all, and put into a library. Examples include:"}, {"type": "ul", "text": "\nlazy properties: the value gets computed only upon first access;\nobservable properties: listeners get notified about changes to this property;\nstoring properties in a map, instead of a separate field for each property.\n"}, {"type": "li", "text": "lazy properties: the value gets computed only upon first access;"}, {"type": "li", "text": "observable properties: listeners get notified about changes to this property;"}, {"type": "li", "text": "storing properties in a map, instead of a separate field for each property."}, {"type": "p", "text": "To cover these (and other) cases, Kotlin supports delegated properties:"}, {"type": "em", "text": "delegated properties"}, {"type": "div", "text": "\nclass Example {\n    var p: String by Delegate()\n}\n\n"}, {"type": "pre", "text": "class Example {\n    var p: String by Delegate()\n}\n"}, {"type": "code", "text": "class Example {\n    var p: String by Delegate()\n}\n"}, {"type": "p", "text": "The syntax is: val/var <property name>: <Type> by <expression>. The expression after by is the delegate, \nbecause get() (and set()) corresponding to the property will be delegated to its getValue() and setValue() methods.\nProperty delegates don\u2019t have to implement any interface, but they have to provide a getValue() function (and setValue() \u2014 for vars).\nFor example:"}, {"type": "code", "text": "val/var <property name>: <Type> by <expression>"}, {"type": "em", "text": "by"}, {"type": "em", "text": "delegate"}, {"type": "code", "text": "get()"}, {"type": "code", "text": "set()"}, {"type": "code", "text": "getValue()"}, {"type": "code", "text": "setValue()"}, {"type": "code", "text": "getValue()"}, {"type": "code", "text": "setValue()"}, {"type": "em", "text": "var"}, {"type": "div", "text": "\nimport kotlin.reflect.KProperty\n\nclass Delegate {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        return \"$thisRef, thank you for delegating '${property.name}' to me!\"\n    }\n \n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        println(\"$value has been assigned to '${property.name}' in $thisRef.\")\n    }\n}\n\n"}, {"type": "pre", "text": "import kotlin.reflect.KProperty\n\nclass Delegate {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        return \"$thisRef, thank you for delegating '${property.name}' to me!\"\n    }\n \n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        println(\"$value has been assigned to '${property.name}' in $thisRef.\")\n    }\n}\n"}, {"type": "code", "text": "import kotlin.reflect.KProperty\n\nclass Delegate {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        return \"$thisRef, thank you for delegating '${property.name}' to me!\"\n    }\n \n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        println(\"$value has been assigned to '${property.name}' in $thisRef.\")\n    }\n}\n"}, {"type": "p", "text": "When we read from p that delegates to an instance of Delegate, the getValue() function from Delegate is called,\nso that its first parameter is the object we read p from and the second parameter holds a description of p itself \n(e.g. you can take its name). For example:"}, {"type": "code", "text": "p"}, {"type": "code", "text": "Delegate"}, {"type": "code", "text": "getValue()"}, {"type": "code", "text": "Delegate"}, {"type": "code", "text": "p"}, {"type": "code", "text": "p"}, {"type": "div", "text": "\nval e = Example()\nprintln(e.p)\n\n"}, {"type": "pre", "text": "val e = Example()\nprintln(e.p)\n"}, {"type": "code", "text": "val e = Example()\nprintln(e.p)\n"}, {"type": "p", "text": "This prints:"}, {"type": "pre", "text": "Example@33a17727, thank you for delegating \u2018p\u2019 to me!\n"}, {"type": "code", "text": "Example@33a17727, thank you for delegating \u2018p\u2019 to me!\n"}, {"type": "p", "text": "Similarly, when we assign to p, the setValue() function is called. The first two parameters are the same, and the third holds the value being assigned:"}, {"type": "code", "text": "p"}, {"type": "code", "text": "setValue()"}, {"type": "div", "text": "\ne.p = \"NEW\"\n\n"}, {"type": "pre", "text": "e.p = \"NEW\"\n"}, {"type": "code", "text": "e.p = \"NEW\"\n"}, {"type": "p", "text": "This prints"}, {"type": "pre", "text": "NEW has been assigned to \u2018p\u2019 in Example@33a17727.\n"}, {"type": "code", "text": "NEW has been assigned to \u2018p\u2019 in Example@33a17727.\n"}, {"type": "p", "text": "The specification of the requirements to the delegated object can be found below."}, {"type": "a", "text": "below"}, {"type": "p", "text": "Note that since Kotlin 1.1 you can declare a delegated property inside a function or code block, it shouldn't necessarily be a member of a class.\nBelow you can find the example."}, {"type": "a", "text": "the example"}, {"type": "h2", "text": "Standard Delegates"}, {"type": "p", "text": "The Kotlin standard library provides factory methods for several useful kinds of delegates."}, {"type": "h3", "text": "Lazy"}, {"type": "p", "text": "lazy() is a function that takes a lambda and returns an instance of Lazy<T> which can serve as a delegate for implementing a lazy property:\nthe first call to get() executes the lambda passed to lazy() and remembers the result, \nsubsequent calls to get() simply return the remembered result."}, {"type": "a", "text": "lazy()"}, {"type": "code", "text": "lazy()"}, {"type": "code", "text": "Lazy<T>"}, {"type": "code", "text": "get()"}, {"type": "code", "text": "lazy()"}, {"type": "code", "text": "get()"}, {"type": "div", "text": "\nval lazyValue: String by lazy {\n    println(\"computed!\")\n    \"Hello\"\n}\n\nfun main() {\n    println(lazyValue)\n    println(lazyValue)\n}\n\n"}, {"type": "pre", "text": "val lazyValue: String by lazy {\n    println(\"computed!\")\n    \"Hello\"\n}\n\nfun main() {\n    println(lazyValue)\n    println(lazyValue)\n}\n"}, {"type": "code", "text": "val lazyValue: String by lazy {\n    println(\"computed!\")\n    \"Hello\"\n}\n\nfun main() {\n    println(lazyValue)\n    println(lazyValue)\n}\n"}, {"type": "p", "text": "By default, the evaluation of lazy properties is synchronized: the value is computed only in one thread, and all threads\nwill see the same value. If the synchronization of initialization delegate is not required, so that multiple threads\ncan execute it simultaneously, pass LazyThreadSafetyMode.PUBLICATION as a parameter to the lazy() function. \nAnd if you're sure that the initialization will always happen on the same thread as the one where you use the property,\nyou can use LazyThreadSafetyMode.NONE: it doesn't incur any thread-safety guarantees and the related overhead."}, {"type": "strong", "text": "synchronized"}, {"type": "code", "text": "LazyThreadSafetyMode.PUBLICATION"}, {"type": "code", "text": "lazy()"}, {"type": "code", "text": "LazyThreadSafetyMode.NONE"}, {"type": "h3", "text": "Observable"}, {"type": "p", "text": "Delegates.observable()\ntakes two arguments: the initial value and a handler for modifications.\nThe handler is called every time we assign to the property (after the assignment has been performed). It has three\nparameters: a property being assigned to, the old value and the new one:"}, {"type": "a", "text": "Delegates.observable()"}, {"type": "code", "text": "Delegates.observable()"}, {"type": "em", "text": "after"}, {"type": "div", "text": "\nimport kotlin.properties.Delegates\n\nclass User {\n    var name: String by Delegates.observable(\"<no name>\") {\n        prop, old, new ->\n        println(\"$old -> $new\")\n    }\n}\n\nfun main() {\n    val user = User()\n    user.name = \"first\"\n    user.name = \"second\"\n}\n\n"}, {"type": "pre", "text": "import kotlin.properties.Delegates\n\nclass User {\n    var name: String by Delegates.observable(\"<no name>\") {\n        prop, old, new ->\n        println(\"$old -> $new\")\n    }\n}\n\nfun main() {\n    val user = User()\n    user.name = \"first\"\n    user.name = \"second\"\n}\n"}, {"type": "code", "text": "import kotlin.properties.Delegates\n\nclass User {\n    var name: String by Delegates.observable(\"<no name>\") {\n        prop, old, new ->\n        println(\"$old -> $new\")\n    }\n}\n\nfun main() {\n    val user = User()\n    user.name = \"first\"\n    user.name = \"second\"\n}\n"}, {"type": "p", "text": "If you want to intercept assignments and \"veto\" them, use vetoable() instead of observable().\nThe handler passed to the vetoable is called before the assignment of a new property value has been performed."}, {"type": "a", "text": "vetoable()"}, {"type": "code", "text": "vetoable()"}, {"type": "code", "text": "observable()"}, {"type": "code", "text": "vetoable"}, {"type": "em", "text": "before"}, {"type": "h2", "text": "Storing Properties in a Map"}, {"type": "p", "text": "One common use case is storing the values of properties in a map.\nThis comes up often in applications like parsing JSON or doing other \u201cdynamic\u201d things.\nIn this case, you can use the map instance itself as the delegate for a delegated property."}, {"type": "div", "text": "\nclass User(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int     by map\n}\n\n"}, {"type": "pre", "text": "class User(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int     by map\n}\n"}, {"type": "code", "text": "class User(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int     by map\n}\n"}, {"type": "p", "text": "In this example, the constructor takes a map:"}, {"type": "div", "text": "\nval user = User(mapOf(\n    \"name\" to \"John Doe\",\n    \"age\"  to 25\n))\n\n"}, {"type": "pre", "text": "val user = User(mapOf(\n    \"name\" to \"John Doe\",\n    \"age\"  to 25\n))\n"}, {"type": "code", "text": "val user = User(mapOf(\n    \"name\" to \"John Doe\",\n    \"age\"  to 25\n))\n"}, {"type": "p", "text": "Delegated properties take values from this map (by the string keys \u2013\u2013 names of properties):"}, {"type": "div", "text": "\nclass User(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int     by map\n}\n\nfun main() {\n    val user = User(mapOf(\n        \"name\" to \"John Doe\",\n        \"age\"  to 25\n    ))\n//sampleStart\n    println(user.name) // Prints \"John Doe\"\n    println(user.age)  // Prints 25\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "class User(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int     by map\n}\n\nfun main() {\n    val user = User(mapOf(\n        \"name\" to \"John Doe\",\n        \"age\"  to 25\n    ))\n//sampleStart\n    println(user.name) // Prints \"John Doe\"\n    println(user.age)  // Prints 25\n//sampleEnd\n}\n"}, {"type": "code", "text": "class User(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int     by map\n}\n\nfun main() {\n    val user = User(mapOf(\n        \"name\" to \"John Doe\",\n        \"age\"  to 25\n    ))\n//sampleStart\n    println(user.name) // Prints \"John Doe\"\n    println(user.age)  // Prints 25\n//sampleEnd\n}\n"}, {"type": "p", "text": "This works also for var\u2019s properties if you use a MutableMap instead of read-only Map:"}, {"type": "em", "text": "var"}, {"type": "code", "text": "MutableMap"}, {"type": "code", "text": "Map"}, {"type": "div", "text": "\nclass MutableUser(val map: MutableMap<String, Any?>) {\n    var name: String by map\n    var age: Int     by map\n}\n\n"}, {"type": "pre", "text": "class MutableUser(val map: MutableMap<String, Any?>) {\n    var name: String by map\n    var age: Int     by map\n}\n"}, {"type": "code", "text": "class MutableUser(val map: MutableMap<String, Any?>) {\n    var name: String by map\n    var age: Int     by map\n}\n"}, {"type": "h2", "text": "Local Delegated Properties (since 1.1)"}, {"type": "p", "text": "You can declare local variables as delegated properties.\nFor instance, you can make a local variable lazy:"}, {"type": "div", "text": "\nfun example(computeFoo: () -> Foo) {\n    val memoizedFoo by lazy(computeFoo)\n\n    if (someCondition && memoizedFoo.isValid()) {\n        memoizedFoo.doSomething()\n    }\n}\n\n"}, {"type": "pre", "text": "fun example(computeFoo: () -> Foo) {\n    val memoizedFoo by lazy(computeFoo)\n\n    if (someCondition && memoizedFoo.isValid()) {\n        memoizedFoo.doSomething()\n    }\n}\n"}, {"type": "code", "text": "fun example(computeFoo: () -> Foo) {\n    val memoizedFoo by lazy(computeFoo)\n\n    if (someCondition && memoizedFoo.isValid()) {\n        memoizedFoo.doSomething()\n    }\n}\n"}, {"type": "p", "text": "The memoizedFoo variable will be computed on the first access only.\nIf someCondition fails, the variable won't be computed at all."}, {"type": "code", "text": "memoizedFoo"}, {"type": "code", "text": "someCondition"}, {"type": "h2", "text": "Property Delegate Requirements"}, {"type": "p", "text": "Here we summarize requirements to delegate objects."}, {"type": "p", "text": "For a read-only property (val), a delegate has to provide an operator function getValue() with the following parameters:"}, {"type": "strong", "text": "read-only"}, {"type": "em", "text": "val"}, {"type": "code", "text": "getValue()"}, {"type": "ul", "text": "\nthisRef \u2014 must be the same or a supertype of the property owner (for extension properties \u2014 the type being extended).\nproperty \u2014 must be of type KProperty<*> or its supertype.\n"}, {"type": "li", "text": "thisRef \u2014 must be the same or a supertype of the property owner (for extension properties \u2014 the type being extended)."}, {"type": "code", "text": "thisRef"}, {"type": "em", "text": "property owner"}, {"type": "li", "text": "property \u2014 must be of type KProperty<*> or its supertype."}, {"type": "code", "text": "property"}, {"type": "code", "text": "KProperty<*>"}, {"type": "p", "text": "getValue() must return the same type as the property (or its subtype)."}, {"type": "code", "text": "getValue()"}, {"type": "div", "text": "\nclass Resource\n\nclass Owner {\n    val valResource: Resource by ResourceDelegate()\n}\n\nclass ResourceDelegate {\n    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {\n        return Resource()\n    }\n}\n\n"}, {"type": "pre", "text": "class Resource\n\nclass Owner {\n    val valResource: Resource by ResourceDelegate()\n}\n\nclass ResourceDelegate {\n    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {\n        return Resource()\n    }\n}\n"}, {"type": "code", "text": "class Resource\n\nclass Owner {\n    val valResource: Resource by ResourceDelegate()\n}\n\nclass ResourceDelegate {\n    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {\n        return Resource()\n    }\n}\n"}, {"type": "p", "text": "For a mutable property (var), a delegate has to additionally provide an operator function setValue() \nwith the following parameters:"}, {"type": "strong", "text": "mutable"}, {"type": "em", "text": "var"}, {"type": "code", "text": "setValue()"}, {"type": "ul", "text": "\nthisRef \u2014 must be the same or a supertype of the property owner (for extension properties \u2014 the type being extended).\nproperty \u2014 must be of type KProperty<*> or its supertype.\nvalue \u2014 must be of the same type as the property (or its supertype).\n"}, {"type": "li", "text": "thisRef \u2014 must be the same or a supertype of the property owner (for extension properties \u2014 the type being extended)."}, {"type": "code", "text": "thisRef"}, {"type": "em", "text": "property owner"}, {"type": "li", "text": "property \u2014 must be of type KProperty<*> or its supertype."}, {"type": "code", "text": "property"}, {"type": "code", "text": "KProperty<*>"}, {"type": "li", "text": "value \u2014 must be of the same type as the property (or its supertype)."}, {"type": "code", "text": "value"}, {"type": "div", "text": "\nclass Resource\n\nclass Owner {\n    var varResource: Resource by ResourceDelegate()\n}\n\nclass ResourceDelegate(private var resource: Resource = Resource()) {\n    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {\n        return resource\n    }\n    operator fun setValue(thisRef: Owner, property: KProperty<*>, value: Any?) {\n        if (value is Resource) {\n            resource = value\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "class Resource\n\nclass Owner {\n    var varResource: Resource by ResourceDelegate()\n}\n\nclass ResourceDelegate(private var resource: Resource = Resource()) {\n    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {\n        return resource\n    }\n    operator fun setValue(thisRef: Owner, property: KProperty<*>, value: Any?) {\n        if (value is Resource) {\n            resource = value\n        }\n    }\n}\n"}, {"type": "code", "text": "class Resource\n\nclass Owner {\n    var varResource: Resource by ResourceDelegate()\n}\n\nclass ResourceDelegate(private var resource: Resource = Resource()) {\n    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {\n        return resource\n    }\n    operator fun setValue(thisRef: Owner, property: KProperty<*>, value: Any?) {\n        if (value is Resource) {\n            resource = value\n        }\n    }\n}\n"}, {"type": "p", "text": "getValue() and/or setValue() functions may be provided either as member functions of the delegate class or extension functions.\nThe latter is handy when you need to delegate property to an object which doesn't originally provide these functions.\nBoth of the functions need to be marked with the operator keyword."}, {"type": "code", "text": "getValue()"}, {"type": "code", "text": "setValue()"}, {"type": "code", "text": "operator"}, {"type": "p", "text": "The delegate class may implement one of the interfaces ReadOnlyProperty and ReadWriteProperty containing the required operator methods.\nThese interfaces are declared in the Kotlin standard library:"}, {"type": "code", "text": "ReadOnlyProperty"}, {"type": "code", "text": "ReadWriteProperty"}, {"type": "code", "text": "operator"}, {"type": "div", "text": "\ninterface ReadOnlyProperty<in R, out T> {\n    operator fun getValue(thisRef: R, property: KProperty<*>): T\n}\n\ninterface ReadWriteProperty<in R, T> {\n    operator fun getValue(thisRef: R, property: KProperty<*>): T\n    operator fun setValue(thisRef: R, property: KProperty<*>, value: T)\n}\n\n"}, {"type": "pre", "text": "interface ReadOnlyProperty<in R, out T> {\n    operator fun getValue(thisRef: R, property: KProperty<*>): T\n}\n\ninterface ReadWriteProperty<in R, T> {\n    operator fun getValue(thisRef: R, property: KProperty<*>): T\n    operator fun setValue(thisRef: R, property: KProperty<*>, value: T)\n}\n"}, {"type": "code", "text": "interface ReadOnlyProperty<in R, out T> {\n    operator fun getValue(thisRef: R, property: KProperty<*>): T\n}\n\ninterface ReadWriteProperty<in R, T> {\n    operator fun getValue(thisRef: R, property: KProperty<*>): T\n    operator fun setValue(thisRef: R, property: KProperty<*>, value: T)\n}\n"}, {"type": "h3", "text": "Translation Rules"}, {"type": "p", "text": "Under the hood for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it.\nFor instance, for the property prop the hidden property prop$delegate is generated, and the code of the accessors simply delegates to this additional property:"}, {"type": "code", "text": "prop"}, {"type": "code", "text": "prop$delegate"}, {"type": "div", "text": "\nclass C {\n    var prop: Type by MyDelegate()\n}\n\n// this code is generated by the compiler instead:\nclass C {\n    private val prop$delegate = MyDelegate()\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}\n\n"}, {"type": "pre", "text": "class C {\n    var prop: Type by MyDelegate()\n}\n\n// this code is generated by the compiler instead:\nclass C {\n    private val prop$delegate = MyDelegate()\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}\n"}, {"type": "code", "text": "class C {\n    var prop: Type by MyDelegate()\n}\n\n// this code is generated by the compiler instead:\nclass C {\n    private val prop$delegate = MyDelegate()\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}\n"}, {"type": "p", "text": "The Kotlin compiler provides all the necessary information about prop in the arguments: the first argument this refers to an instance of the outer class C and this::prop is a reflection object of the KProperty type describing prop itself."}, {"type": "code", "text": "prop"}, {"type": "code", "text": "this"}, {"type": "code", "text": "C"}, {"type": "code", "text": "this::prop"}, {"type": "code", "text": "KProperty"}, {"type": "code", "text": "prop"}, {"type": "p", "text": "Note that the syntax this::prop to refer a bound callable reference in the code directly is available only since Kotlin 1.1."}, {"type": "code", "text": "this::prop"}, {"type": "a", "text": "bound callable reference"}, {"type": "h3", "text": "Providing a delegate (since 1.1)"}, {"type": "p", "text": "By defining the provideDelegate operator you can extend the logic of creating the object to which the property implementation is delegated.\nIf the object used on the right hand side of by defines provideDelegate as a member or extension function, that function will be\ncalled to create the property delegate instance."}, {"type": "code", "text": "provideDelegate"}, {"type": "code", "text": "by"}, {"type": "code", "text": "provideDelegate"}, {"type": "p", "text": "One of the possible use cases of provideDelegate is to check property consistency when the property is created, not only in its getter or setter."}, {"type": "code", "text": "provideDelegate"}, {"type": "p", "text": "For example, if you want to check the property name before binding, you can write something like this:"}, {"type": "div", "text": "\nclass ResourceDelegate<T> : ReadOnlyProperty<MyUI, T> {\n    override fun getValue(thisRef: MyUI, property: KProperty<*>): T { ... }\n}\n    \nclass ResourceLoader<T>(id: ResourceID<T>) {\n    operator fun provideDelegate(\n            thisRef: MyUI,\n            prop: KProperty<*>\n    ): ReadOnlyProperty<MyUI, T> {\n        checkProperty(thisRef, prop.name)\n        // create delegate\n        return ResourceDelegate()\n    }\n\n    private fun checkProperty(thisRef: MyUI, name: String) { ... }\n}\n\nclass MyUI {\n    fun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }\n\n    val image by bindResource(ResourceID.image_id)\n    val text by bindResource(ResourceID.text_id)\n}\n\n"}, {"type": "pre", "text": "class ResourceDelegate<T> : ReadOnlyProperty<MyUI, T> {\n    override fun getValue(thisRef: MyUI, property: KProperty<*>): T { ... }\n}\n    \nclass ResourceLoader<T>(id: ResourceID<T>) {\n    operator fun provideDelegate(\n            thisRef: MyUI,\n            prop: KProperty<*>\n    ): ReadOnlyProperty<MyUI, T> {\n        checkProperty(thisRef, prop.name)\n        // create delegate\n        return ResourceDelegate()\n    }\n\n    private fun checkProperty(thisRef: MyUI, name: String) { ... }\n}\n\nclass MyUI {\n    fun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }\n\n    val image by bindResource(ResourceID.image_id)\n    val text by bindResource(ResourceID.text_id)\n}\n"}, {"type": "code", "text": "class ResourceDelegate<T> : ReadOnlyProperty<MyUI, T> {\n    override fun getValue(thisRef: MyUI, property: KProperty<*>): T { ... }\n}\n    \nclass ResourceLoader<T>(id: ResourceID<T>) {\n    operator fun provideDelegate(\n            thisRef: MyUI,\n            prop: KProperty<*>\n    ): ReadOnlyProperty<MyUI, T> {\n        checkProperty(thisRef, prop.name)\n        // create delegate\n        return ResourceDelegate()\n    }\n\n    private fun checkProperty(thisRef: MyUI, name: String) { ... }\n}\n\nclass MyUI {\n    fun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }\n\n    val image by bindResource(ResourceID.image_id)\n    val text by bindResource(ResourceID.text_id)\n}\n"}, {"type": "p", "text": "The parameters of provideDelegate are the same as for getValue:"}, {"type": "code", "text": "provideDelegate"}, {"type": "code", "text": "getValue"}, {"type": "ul", "text": "\nthisRef \u2014 must be the same or a supertype of the property owner (for extension properties \u2014 the type being extended);\nproperty \u2014 must be of type KProperty<*> or its supertype.\n"}, {"type": "li", "text": "thisRef \u2014 must be the same or a supertype of the property owner (for extension properties \u2014 the type being extended);"}, {"type": "code", "text": "thisRef"}, {"type": "em", "text": "property owner"}, {"type": "li", "text": "property \u2014 must be of type KProperty<*> or its supertype."}, {"type": "code", "text": "property"}, {"type": "code", "text": "KProperty<*>"}, {"type": "p", "text": "The provideDelegate method is called for each property during the creation of the MyUI instance, and it performs the necessary validation right away."}, {"type": "code", "text": "provideDelegate"}, {"type": "code", "text": "MyUI"}, {"type": "p", "text": "Without this ability to intercept the binding between the property and its delegate, to achieve the same functionality\nyou'd have to pass the property name explicitly, which isn't very convenient:"}, {"type": "div", "text": "\n// Checking the property name without \"provideDelegate\" functionality\nclass MyUI {\n    val image by bindResource(ResourceID.image_id, \"image\")\n    val text by bindResource(ResourceID.text_id, \"text\")\n}\n\nfun <T> MyUI.bindResource(\n        id: ResourceID<T>,\n        propertyName: String\n): ReadOnlyProperty<MyUI, T> {\n   checkProperty(this, propertyName)\n   // create delegate\n}\n\n"}, {"type": "pre", "text": "// Checking the property name without \"provideDelegate\" functionality\nclass MyUI {\n    val image by bindResource(ResourceID.image_id, \"image\")\n    val text by bindResource(ResourceID.text_id, \"text\")\n}\n\nfun <T> MyUI.bindResource(\n        id: ResourceID<T>,\n        propertyName: String\n): ReadOnlyProperty<MyUI, T> {\n   checkProperty(this, propertyName)\n   // create delegate\n}\n"}, {"type": "code", "text": "// Checking the property name without \"provideDelegate\" functionality\nclass MyUI {\n    val image by bindResource(ResourceID.image_id, \"image\")\n    val text by bindResource(ResourceID.text_id, \"text\")\n}\n\nfun <T> MyUI.bindResource(\n        id: ResourceID<T>,\n        propertyName: String\n): ReadOnlyProperty<MyUI, T> {\n   checkProperty(this, propertyName)\n   // create delegate\n}\n"}, {"type": "p", "text": "In the generated code, the provideDelegate method is called to initialize the auxiliary prop$delegate property.\nCompare the generated code for the property declaration val prop: Type by MyDelegate() with the generated code \nabove (when the provideDelegate method is not present):"}, {"type": "code", "text": "provideDelegate"}, {"type": "code", "text": "prop$delegate"}, {"type": "code", "text": "val prop: Type by MyDelegate()"}, {"type": "a", "text": "above"}, {"type": "code", "text": "provideDelegate"}, {"type": "div", "text": "\nclass C {\n    var prop: Type by MyDelegate()\n}\n\n// this code is generated by the compiler \n// when the 'provideDelegate' function is available:\nclass C {\n    // calling \"provideDelegate\" to create the additional \"delegate\" property\n    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}\n\n"}, {"type": "pre", "text": "class C {\n    var prop: Type by MyDelegate()\n}\n\n// this code is generated by the compiler \n// when the 'provideDelegate' function is available:\nclass C {\n    // calling \"provideDelegate\" to create the additional \"delegate\" property\n    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}\n"}, {"type": "code", "text": "class C {\n    var prop: Type by MyDelegate()\n}\n\n// this code is generated by the compiler \n// when the 'provideDelegate' function is available:\nclass C {\n    // calling \"provideDelegate\" to create the additional \"delegate\" property\n    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}\n"}, {"type": "p", "text": "Note that the provideDelegate method affects only the creation of the auxiliary property and doesn't affect the code generated for getter or setter."}, {"type": "code", "text": "provideDelegate"}]