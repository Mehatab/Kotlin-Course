[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Equality"}, {"type": "p", "text": "In Kotlin there are two types of equality:"}, {"type": "ul", "text": "\nStructural equality (a check for equals()).\nReferential equality (two references point to the same object);\n"}, {"type": "li", "text": "Structural equality (a check for equals())."}, {"type": "code", "text": "equals()"}, {"type": "li", "text": "Referential equality (two references point to the same object);"}, {"type": "h2", "text": "Structural equality"}, {"type": "p", "text": "Structural equality is checked by the == operation (and its negated counterpart !=). By convention, an expression like a == b is translated to:"}, {"type": "code", "text": "=="}, {"type": "code", "text": "!="}, {"type": "code", "text": "a == b"}, {"type": "div", "text": "\na?.equals(b) ?: (b === null)\n\n"}, {"type": "pre", "text": "a?.equals(b) ?: (b === null)\n"}, {"type": "code", "text": "a?.equals(b) ?: (b === null)\n"}, {"type": "p", "text": "I.e. if a is not null, it calls the equals(Any?) function, otherwise (i.e. a is null) it checks that b is referentially equal to null."}, {"type": "code", "text": "a"}, {"type": "code", "text": "null"}, {"type": "code", "text": "equals(Any?)"}, {"type": "code", "text": "a"}, {"type": "code", "text": "null"}, {"type": "code", "text": "b"}, {"type": "code", "text": "null"}, {"type": "p", "text": "Note that there's no point in optimizing your code when comparing to null explicitly: a == null will be automatically translated to a === null."}, {"type": "code", "text": "null"}, {"type": "code", "text": "a == null"}, {"type": "code", "text": "a === null"}, {"type": "p", "text": "To provide a custom equals check implementation, override the equals(other: Any?): Boolean function. Functions with the same name and other signatures, like equals(other: Foo), don't affect equality checks with the operators == and !=."}, {"type": "a", "text": "equals(other: Any?): Boolean"}, {"type": "code", "text": "equals(other: Any?): Boolean"}, {"type": "code", "text": "equals(other: Foo)"}, {"type": "code", "text": "=="}, {"type": "code", "text": "!="}, {"type": "p", "text": "Structural equality has nothing to do with comparison defined by the Comparable<...> interface, so only a custom equals(Any?) implementation may affect the behavior of the operator."}, {"type": "code", "text": "Comparable<...>"}, {"type": "code", "text": "equals(Any?)"}, {"type": "h2", "text": "Floating point numbers equality"}, {"type": "p", "text": "When an equality check operands are statically known to be Float or Double (nullable or not), the check follows the IEEE 754 \nStandard for Floating-Point Arithmetic."}, {"type": "code", "text": "Float"}, {"type": "code", "text": "Double"}, {"type": "p", "text": "Otherwise, the structural equality is used, which disagrees with the standard so that NaN is equal to itself, and -0.0 is not equal to 0.0."}, {"type": "code", "text": "NaN"}, {"type": "code", "text": "-0.0"}, {"type": "code", "text": "0.0"}, {"type": "p", "text": "See: Floating Point Numbers Comparison."}, {"type": "a", "text": "Floating Point Numbers Comparison"}, {"type": "h2", "text": "Referential equality"}, {"type": "p", "text": "Referential equality is checked by the === operation (and its negated counterpart !==). a === b evaluates to\ntrue if and only if a and b point to the same object. For values which are represented as primitive types at runtime\n(for example, Int), the === equality check is equivalent to the == check."}, {"type": "code", "text": "==="}, {"type": "code", "text": "!=="}, {"type": "code", "text": "a === b"}, {"type": "code", "text": "a"}, {"type": "code", "text": "b"}, {"type": "code", "text": "Int"}, {"type": "code", "text": "==="}, {"type": "code", "text": "=="}]