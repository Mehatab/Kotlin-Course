[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Reflection"}, {"type": "p", "text": "Reflection is a set of language and library features that allows for introspecting the structure of your own program at runtime.\nKotlin makes functions and properties first-class citizens in the language, and introspecting them (i.e. learning a name or \na type of a property or function at runtime) is closely intertwined with simply using a functional or reactive style."}, {"type": "blockquote", "text": "\nOn the Java platform, the runtime component required for using the reflection features is distributed as a separate\nJAR file (kotlin-reflect.jar). This is done to reduce the required size of the runtime library for applications\nthat do not use reflection features. If you do use reflection, please make sure that the .jar file is added to the\nclasspath of your project.\n"}, {"type": "p", "text": "On the Java platform, the runtime component required for using the reflection features is distributed as a separate\nJAR file (kotlin-reflect.jar). This is done to reduce the required size of the runtime library for applications\nthat do not use reflection features. If you do use reflection, please make sure that the .jar file is added to the\nclasspath of your project."}, {"type": "code", "text": "kotlin-reflect.jar"}, {"type": "h2", "text": "Class References"}, {"type": "p", "text": "The most basic reflection feature is getting the runtime reference to a Kotlin class. To obtain the reference to a\nstatically known Kotlin class, you can use the class literal syntax:"}, {"type": "em", "text": "class literal"}, {"type": "div", "text": "\nval c = MyClass::class\n\n"}, {"type": "pre", "text": "val c = MyClass::class\n"}, {"type": "code", "text": "val c = MyClass::class\n"}, {"type": "p", "text": "The reference is a value of type KClass."}, {"type": "a", "text": "KClass"}, {"type": "p", "text": "Note that a Kotlin class reference is not the same as a Java class reference. To obtain a Java class reference,\nuse the .java property on a KClass instance."}, {"type": "code", "text": ".java"}, {"type": "code", "text": "KClass"}, {"type": "h2", "text": "Bound Class References (since 1.1)"}, {"type": "p", "text": "You can get the reference to a class of a specific object with the same ::class syntax by using the object as a receiver:"}, {"type": "code", "text": "::class"}, {"type": "div", "text": "\nval widget: Widget = ...\nassert(widget is GoodWidget) { \"Bad widget: ${widget::class.qualifiedName}\" }\n\n"}, {"type": "pre", "text": "val widget: Widget = ...\nassert(widget is GoodWidget) { \"Bad widget: ${widget::class.qualifiedName}\" }\n"}, {"type": "code", "text": "val widget: Widget = ...\nassert(widget is GoodWidget) { \"Bad widget: ${widget::class.qualifiedName}\" }\n"}, {"type": "p", "text": "You obtain the reference to an exact class of an object, for instance GoodWidget or BadWidget, despite the type of the receiver expression (Widget)."}, {"type": "code", "text": "GoodWidget"}, {"type": "code", "text": "BadWidget"}, {"type": "code", "text": "Widget"}, {"type": "h2", "text": "Callable references"}, {"type": "p", "text": "References to functions, properties, and constructors, apart from introspecting the program structure, can \nalso be called or used as instances of function types."}, {"type": "a", "text": "function types"}, {"type": "p", "text": "The common supertype for all callable references is KCallable<out R>, \nwhere R is the return value type, which is the property type for properties, and the constructed type for constructors."}, {"type": "a", "text": "KCallable<out R>"}, {"type": "code", "text": "KCallable<out R>"}, {"type": "code", "text": "R"}, {"type": "h3", "text": "Function References"}, {"type": "p", "text": "When we have a named function declared like this:"}, {"type": "div", "text": "\nfun isOdd(x: Int) = x % 2 != 0\n\n"}, {"type": "pre", "text": "fun isOdd(x: Int) = x % 2 != 0\n"}, {"type": "code", "text": "fun isOdd(x: Int) = x % 2 != 0\n"}, {"type": "p", "text": "We can easily call it directly (isOdd(5)), but we can also use it as a function type value, e.g. pass it \nto another function. To do this, we use the :: operator:"}, {"type": "code", "text": "isOdd(5)"}, {"type": "code", "text": "::"}, {"type": "div", "text": "\nfun isOdd(x: Int) = x % 2 != 0\n\nfun main() {\n//sampleStart\n    val numbers = listOf(1, 2, 3)\n    println(numbers.filter(::isOdd))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun isOdd(x: Int) = x % 2 != 0\n\nfun main() {\n//sampleStart\n    val numbers = listOf(1, 2, 3)\n    println(numbers.filter(::isOdd))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun isOdd(x: Int) = x % 2 != 0\n\nfun main() {\n//sampleStart\n    val numbers = listOf(1, 2, 3)\n    println(numbers.filter(::isOdd))\n//sampleEnd\n}\n"}, {"type": "p", "text": "Here ::isOdd is a value of function type (Int) -> Boolean."}, {"type": "code", "text": "::isOdd"}, {"type": "code", "text": "(Int) -> Boolean"}, {"type": "p", "text": "Function references belong to one of the KFunction<out R>\nsubtypes, depending on the parameter count, e.g. KFunction3<T1, T2, T3, R>."}, {"type": "a", "text": "KFunction<out R>"}, {"type": "code", "text": "KFunction<out R>"}, {"type": "code", "text": "KFunction3<T1, T2, T3, R>"}, {"type": "p", "text": ":: can be used with overloaded functions when the expected type is known from the context.\nFor example:"}, {"type": "code", "text": "::"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    fun isOdd(x: Int) = x % 2 != 0\n    fun isOdd(s: String) = s == \"brillig\" || s == \"slithy\" || s == \"tove\"\n    \n    val numbers = listOf(1, 2, 3)\n    println(numbers.filter(::isOdd)) // refers to isOdd(x: Int)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    fun isOdd(x: Int) = x % 2 != 0\n    fun isOdd(s: String) = s == \"brillig\" || s == \"slithy\" || s == \"tove\"\n    \n    val numbers = listOf(1, 2, 3)\n    println(numbers.filter(::isOdd)) // refers to isOdd(x: Int)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    fun isOdd(x: Int) = x % 2 != 0\n    fun isOdd(s: String) = s == \"brillig\" || s == \"slithy\" || s == \"tove\"\n    \n    val numbers = listOf(1, 2, 3)\n    println(numbers.filter(::isOdd)) // refers to isOdd(x: Int)\n//sampleEnd\n}\n"}, {"type": "p", "text": "Alternatively, you can provide the necessary context by storing the method reference in a variable with an explicitly specified type:"}, {"type": "div", "text": "\nval predicate: (String) -> Boolean = ::isOdd   // refers to isOdd(x: String)\n\n"}, {"type": "pre", "text": "val predicate: (String) -> Boolean = ::isOdd   // refers to isOdd(x: String)\n"}, {"type": "code", "text": "val predicate: (String) -> Boolean = ::isOdd   // refers to isOdd(x: String)\n"}, {"type": "p", "text": "If we need to use a member of a class, or an extension function, it needs to be qualified, e.g. String::toCharArray."}, {"type": "code", "text": "String::toCharArray"}, {"type": "p", "text": "Note that even if you initialize a variable with a reference to an extension function, the inferred function type will\nhave no receiver (it will have an additional parameter accepting a receiver object). To have a function type \nwith receiver instead, specify the type explicitly:"}, {"type": "div", "text": "\nval isEmptyStringList: List<String>.() -> Boolean = List<String>::isEmpty \n\n"}, {"type": "pre", "text": "val isEmptyStringList: List<String>.() -> Boolean = List<String>::isEmpty \n"}, {"type": "code", "text": "val isEmptyStringList: List<String>.() -> Boolean = List<String>::isEmpty \n"}, {"type": "h3", "text": "Example: Function Composition"}, {"type": "p", "text": "Consider the following function:"}, {"type": "div", "text": "\nfun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {\n    return { x -> f(g(x)) }\n}\n\n"}, {"type": "pre", "text": "fun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {\n    return { x -> f(g(x)) }\n}\n"}, {"type": "code", "text": "fun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {\n    return { x -> f(g(x)) }\n}\n"}, {"type": "p", "text": "It returns a composition of two functions passed to it: compose(f, g) = f(g(*)).\nNow, you can apply it to callable references:"}, {"type": "code", "text": "compose(f, g) = f(g(*))"}, {"type": "div", "text": "\nfun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {\n    return { x -> f(g(x)) }\n}\n\nfun isOdd(x: Int) = x % 2 != 0\n\nfun main() {\n//sampleStart\n    fun length(s: String) = s.length\n    \n    val oddLength = compose(::isOdd, ::length)\n    val strings = listOf(\"a\", \"ab\", \"abc\")\n    \n    println(strings.filter(oddLength))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {\n    return { x -> f(g(x)) }\n}\n\nfun isOdd(x: Int) = x % 2 != 0\n\nfun main() {\n//sampleStart\n    fun length(s: String) = s.length\n    \n    val oddLength = compose(::isOdd, ::length)\n    val strings = listOf(\"a\", \"ab\", \"abc\")\n    \n    println(strings.filter(oddLength))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {\n    return { x -> f(g(x)) }\n}\n\nfun isOdd(x: Int) = x % 2 != 0\n\nfun main() {\n//sampleStart\n    fun length(s: String) = s.length\n    \n    val oddLength = compose(::isOdd, ::length)\n    val strings = listOf(\"a\", \"ab\", \"abc\")\n    \n    println(strings.filter(oddLength))\n//sampleEnd\n}\n"}, {"type": "h3", "text": "Property References"}, {"type": "p", "text": "To access properties as first-class objects in Kotlin, we can also use the :: operator:"}, {"type": "code", "text": "::"}, {"type": "div", "text": "\nval x = 1\n\nfun main() {\n    println(::x.get())\n    println(::x.name) \n}\n\n"}, {"type": "pre", "text": "val x = 1\n\nfun main() {\n    println(::x.get())\n    println(::x.name) \n}\n"}, {"type": "code", "text": "val x = 1\n\nfun main() {\n    println(::x.get())\n    println(::x.name) \n}\n"}, {"type": "p", "text": "The expression ::x evaluates to a property object of type KProperty<Int>, which allows us to read its\nvalue using get() or retrieve the property name using the name property. For more information, please refer to\nthe docs on the KProperty class."}, {"type": "code", "text": "::x"}, {"type": "code", "text": "KProperty<Int>"}, {"type": "code", "text": "get()"}, {"type": "code", "text": "name"}, {"type": "a", "text": "docs on the KProperty class"}, {"type": "code", "text": "KProperty"}, {"type": "p", "text": "For a mutable property, e.g. var y = 1, ::y returns a value of type KMutableProperty<Int>,\nwhich has a set() method:"}, {"type": "code", "text": "var y = 1"}, {"type": "code", "text": "::y"}, {"type": "a", "text": "KMutableProperty<Int>"}, {"type": "code", "text": "KMutableProperty<Int>"}, {"type": "code", "text": "set()"}, {"type": "div", "text": "\nvar y = 1\n\nfun main() {\n    ::y.set(2)\n    println(y)\n}\n\n"}, {"type": "pre", "text": "var y = 1\n\nfun main() {\n    ::y.set(2)\n    println(y)\n}\n"}, {"type": "code", "text": "var y = 1\n\nfun main() {\n    ::y.set(2)\n    println(y)\n}\n"}, {"type": "p", "text": "A property reference can be used where a function with a single generic parameter is expected:"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val strs = listOf(\"a\", \"bc\", \"def\")\n    println(strs.map(String::length))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val strs = listOf(\"a\", \"bc\", \"def\")\n    println(strs.map(String::length))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val strs = listOf(\"a\", \"bc\", \"def\")\n    println(strs.map(String::length))\n//sampleEnd\n}\n"}, {"type": "p", "text": "To access a property that is a member of a class, we qualify it:"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    class A(val p: Int)\n    val prop = A::p\n    println(prop.get(A(1)))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    class A(val p: Int)\n    val prop = A::p\n    println(prop.get(A(1)))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    class A(val p: Int)\n    val prop = A::p\n    println(prop.get(A(1)))\n//sampleEnd\n}\n"}, {"type": "p", "text": "For an extension property:"}, {"type": "div", "text": "\nval String.lastChar: Char\n    get() = this[length - 1]\n\nfun main() {\n    println(String::lastChar.get(\"abc\"))\n}\n\n"}, {"type": "pre", "text": "val String.lastChar: Char\n    get() = this[length - 1]\n\nfun main() {\n    println(String::lastChar.get(\"abc\"))\n}\n"}, {"type": "code", "text": "val String.lastChar: Char\n    get() = this[length - 1]\n\nfun main() {\n    println(String::lastChar.get(\"abc\"))\n}\n"}, {"type": "h3", "text": "Interoperability With Java Reflection"}, {"type": "p", "text": "On the Java platform, standard library contains extensions for reflection classes that provide a mapping to and from Java\n  reflection objects (see package kotlin.reflect.jvm).\nFor example, to find a backing field or a Java method that serves as a getter for a Kotlin property, you can say something like this:"}, {"type": "code", "text": "kotlin.reflect.jvm"}, {"type": "div", "text": "\nimport kotlin.reflect.jvm.*\n \nclass A(val p: Int)\n \nfun main() {\n    println(A::p.javaGetter) // prints \"public final int A.getP()\"\n    println(A::p.javaField)  // prints \"private final int A.p\"\n}\n\n"}, {"type": "pre", "text": "import kotlin.reflect.jvm.*\n \nclass A(val p: Int)\n \nfun main() {\n    println(A::p.javaGetter) // prints \"public final int A.getP()\"\n    println(A::p.javaField)  // prints \"private final int A.p\"\n}\n"}, {"type": "code", "text": "import kotlin.reflect.jvm.*\n \nclass A(val p: Int)\n \nfun main() {\n    println(A::p.javaGetter) // prints \"public final int A.getP()\"\n    println(A::p.javaField)  // prints \"private final int A.p\"\n}\n"}, {"type": "p", "text": "To get the Kotlin class corresponding to a Java class, use the .kotlin extension property:"}, {"type": "code", "text": ".kotlin"}, {"type": "div", "text": "\nfun getKClass(o: Any): KClass<Any> = o.javaClass.kotlin\n\n"}, {"type": "pre", "text": "fun getKClass(o: Any): KClass<Any> = o.javaClass.kotlin\n"}, {"type": "code", "text": "fun getKClass(o: Any): KClass<Any> = o.javaClass.kotlin\n"}, {"type": "h3", "text": "Constructor References"}, {"type": "p", "text": "Constructors can be referenced just like methods and properties. They can be used wherever an object of function type \nis expected that takes the same parameters as the constructor and returns an object of the appropriate type. \nConstructors are referenced by using the :: operator and adding the class name. Consider the following function \nthat expects a function parameter with no parameters and return type Foo:"}, {"type": "code", "text": "::"}, {"type": "code", "text": "Foo"}, {"type": "div", "text": "\nclass Foo\n\nfun function(factory: () -> Foo) {\n    val x: Foo = factory()\n}\n\n"}, {"type": "pre", "text": "class Foo\n\nfun function(factory: () -> Foo) {\n    val x: Foo = factory()\n}\n"}, {"type": "code", "text": "class Foo\n\nfun function(factory: () -> Foo) {\n    val x: Foo = factory()\n}\n"}, {"type": "p", "text": "Using ::Foo, the zero-argument constructor of the class Foo, we can simply call it like this:"}, {"type": "code", "text": "::Foo"}, {"type": "div", "text": "\nfunction(::Foo)\n\n"}, {"type": "pre", "text": "function(::Foo)\n"}, {"type": "code", "text": "function(::Foo)\n"}, {"type": "p", "text": "Callable references to constructors are typed as one of the \nKFunction<out R> subtypes\n, depending on the parameter count."}, {"type": "a", "text": "KFunction<out R>"}, {"type": "code", "text": "KFunction<out R>"}, {"type": "h2", "text": "Bound Function and Property References (since 1.1)"}, {"type": "p", "text": "You can refer to an instance method of a particular object:"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numberRegex = \"\\\\d+\".toRegex()\n    println(numberRegex.matches(\"29\"))\n     \n    val isNumber = numberRegex::matches\n    println(isNumber(\"29\"))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numberRegex = \"\\\\d+\".toRegex()\n    println(numberRegex.matches(\"29\"))\n     \n    val isNumber = numberRegex::matches\n    println(isNumber(\"29\"))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numberRegex = \"\\\\d+\".toRegex()\n    println(numberRegex.matches(\"29\"))\n     \n    val isNumber = numberRegex::matches\n    println(isNumber(\"29\"))\n//sampleEnd\n}\n"}, {"type": "p", "text": "Instead of calling the method matches directly we are storing a reference to it.\nSuch reference is bound to its receiver.\nIt can be called directly (like in the example above) or used whenever an expression of function type is expected:"}, {"type": "code", "text": "matches"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numberRegex = \"\\\\d+\".toRegex()\n    val strings = listOf(\"abc\", \"124\", \"a70\")\n    println(strings.filter(numberRegex::matches))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numberRegex = \"\\\\d+\".toRegex()\n    val strings = listOf(\"abc\", \"124\", \"a70\")\n    println(strings.filter(numberRegex::matches))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numberRegex = \"\\\\d+\".toRegex()\n    val strings = listOf(\"abc\", \"124\", \"a70\")\n    println(strings.filter(numberRegex::matches))\n//sampleEnd\n}\n"}, {"type": "p", "text": "Compare the types of bound and the corresponding unbound references.\nBound callable reference has its receiver \"attached\" to it, so the type of the receiver is no longer a parameter:"}, {"type": "div", "text": "\nval isNumber: (CharSequence) -> Boolean = numberRegex::matches\n\nval matches: (Regex, CharSequence) -> Boolean = Regex::matches\n\n"}, {"type": "pre", "text": "val isNumber: (CharSequence) -> Boolean = numberRegex::matches\n\nval matches: (Regex, CharSequence) -> Boolean = Regex::matches\n"}, {"type": "code", "text": "val isNumber: (CharSequence) -> Boolean = numberRegex::matches\n\nval matches: (Regex, CharSequence) -> Boolean = Regex::matches\n"}, {"type": "p", "text": "Property reference can be bound as well:"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val prop = \"abc\"::length\n    println(prop.get())\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val prop = \"abc\"::length\n    println(prop.get())\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val prop = \"abc\"::length\n    println(prop.get())\n//sampleEnd\n}\n"}, {"type": "p", "text": "Since Kotlin 1.2, explicitly specifying this as the receiver is not necessary: this::foo and ::foo are equivalent."}, {"type": "code", "text": "this"}, {"type": "code", "text": "this::foo"}, {"type": "code", "text": "::foo"}, {"type": "h3", "text": "Bound constructor references"}, {"type": "p", "text": "A bound callable reference to a constructor of an inner class can \nbe obtained by providing an instance of the outer class:"}, {"type": "a", "text": "inner class"}, {"type": "em", "text": "inner"}, {"type": "div", "text": "\nclass Outer {\n    inner class Inner\n}\n\nval o = Outer()\nval boundInnerCtor = o::Inner\n\n"}, {"type": "pre", "text": "class Outer {\n    inner class Inner\n}\n\nval o = Outer()\nval boundInnerCtor = o::Inner\n"}, {"type": "code", "text": "class Outer {\n    inner class Inner\n}\n\nval o = Outer()\nval boundInnerCtor = o::Inner\n"}]