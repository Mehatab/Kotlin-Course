[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Compiler Plugins"}, {"type": "ul", "text": "\nAll-open compiler plugin\nNo-arg compiler plugin\nSAM-with-receiver compiler plugin\nParcelable implementations generator\n"}, {"type": "li", "text": "All-open compiler plugin"}, {"type": "a", "text": "All-open compiler plugin"}, {"type": "li", "text": "No-arg compiler plugin"}, {"type": "a", "text": "No-arg compiler plugin"}, {"type": "li", "text": "SAM-with-receiver compiler plugin"}, {"type": "a", "text": "SAM-with-receiver compiler plugin"}, {"type": "li", "text": "Parcelable implementations generator"}, {"type": "a", "text": "Parcelable implementations generator"}, {"type": "code", "text": "Parcelable"}, {"type": "h2", "text": "All-open compiler plugin"}, {"type": "p", "text": "Kotlin has classes and their members final by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be open. The all-open compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with a specific annotation and their members open without the explicit open keyword."}, {"type": "code", "text": "final"}, {"type": "code", "text": "open"}, {"type": "em", "text": "all-open"}, {"type": "code", "text": "open"}, {"type": "p", "text": "For instance, when you use Spring, you don't need all the classes to be open, but only classes annotated with specific annotations like @Configuration or @Service. All-open allows to specify such annotations."}, {"type": "code", "text": "@Configuration"}, {"type": "code", "text": "@Service"}, {"type": "em", "text": "All-open"}, {"type": "p", "text": "We provide all-open plugin support both for Gradle and Maven with the complete IDE integration."}, {"type": "em", "text": "all-open"}, {"type": "p", "text": "Note: For Spring you can use the kotlin-spring compiler plugin (see below)."}, {"type": "code", "text": "kotlin-spring"}, {"type": "a", "text": "see below"}, {"type": "h3", "text": "Using in Gradle"}, {"type": "p", "text": "Add the plugin artifact to the buildscript dependencies and apply the plugin:"}, {"type": "div", "text": "\nbuildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-allopen:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-allopen\"\n\n"}, {"type": "pre", "text": "buildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-allopen:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-allopen\"\n"}, {"type": "code", "text": "buildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-allopen:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-allopen\"\n"}, {"type": "p", "text": "As an alternative, you can enable it using the plugins block:"}, {"type": "code", "text": "plugins"}, {"type": "div", "text": "\nplugins {\n  id \"org.jetbrains.kotlin.plugin.allopen\" version \"1.3.72\"\n}\n\n"}, {"type": "pre", "text": "plugins {\n  id \"org.jetbrains.kotlin.plugin.allopen\" version \"1.3.72\"\n}\n"}, {"type": "code", "text": "plugins {\n  id \"org.jetbrains.kotlin.plugin.allopen\" version \"1.3.72\"\n}\n"}, {"type": "p", "text": "Then specify the list of annotations that will make classes open:"}, {"type": "div", "text": "\nallOpen {\n    annotation(\"com.my.Annotation\")\n    // annotations(\"com.another.Annotation\", \"com.third.Annotation\")\n}\n\n"}, {"type": "pre", "text": "allOpen {\n    annotation(\"com.my.Annotation\")\n    // annotations(\"com.another.Annotation\", \"com.third.Annotation\")\n}\n"}, {"type": "code", "text": "allOpen {\n    annotation(\"com.my.Annotation\")\n    // annotations(\"com.another.Annotation\", \"com.third.Annotation\")\n}\n"}, {"type": "p", "text": "If the class (or any of its superclasses) is annotated with com.my.Annotation, the class itself and all its members will become open."}, {"type": "code", "text": "com.my.Annotation"}, {"type": "p", "text": "It also works with meta-annotations:"}, {"type": "div", "text": "\n@com.my.Annotation\nannotation class MyFrameworkAnnotation\n\n@MyFrameworkAnnotation\nclass MyClass // will be all-open\n\n"}, {"type": "pre", "text": "@com.my.Annotation\nannotation class MyFrameworkAnnotation\n\n@MyFrameworkAnnotation\nclass MyClass // will be all-open\n"}, {"type": "code", "text": "@com.my.Annotation\nannotation class MyFrameworkAnnotation\n\n@MyFrameworkAnnotation\nclass MyClass // will be all-open\n"}, {"type": "p", "text": "MyFrameworkAnnotation is annotated with the all-open meta-annotation com.my.Annotation, so it becomes an all-open annotation as well."}, {"type": "code", "text": "MyFrameworkAnnotation"}, {"type": "code", "text": "com.my.Annotation"}, {"type": "h3", "text": "Using in Maven"}, {"type": "p", "text": "Here's how to use all-open with Maven:"}, {"type": "div", "text": "\n<plugin>\n    <artifactId>kotlin-maven-plugin</artifactId>\n    <groupId>org.jetbrains.kotlin</groupId>\n    <version>${kotlin.version}</version>\n\n    <configuration>\n        <compilerPlugins>\n            <!-- Or \"spring\" for the Spring support -->\n            <plugin>all-open</plugin>\n        </compilerPlugins>\n\n        <pluginOptions>\n            <!-- Each annotation is placed on its own line -->\n            <option>all-open:annotation=com.my.Annotation</option>\n            <option>all-open:annotation=com.their.AnotherAnnotation</option>\n        </pluginOptions>\n    </configuration>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-maven-allopen</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n    </dependencies>\n</plugin>\n\n"}, {"type": "pre", "text": "<plugin>\n    <artifactId>kotlin-maven-plugin</artifactId>\n    <groupId>org.jetbrains.kotlin</groupId>\n    <version>${kotlin.version}</version>\n\n    <configuration>\n        <compilerPlugins>\n            <!-- Or \"spring\" for the Spring support -->\n            <plugin>all-open</plugin>\n        </compilerPlugins>\n\n        <pluginOptions>\n            <!-- Each annotation is placed on its own line -->\n            <option>all-open:annotation=com.my.Annotation</option>\n            <option>all-open:annotation=com.their.AnotherAnnotation</option>\n        </pluginOptions>\n    </configuration>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-maven-allopen</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n    </dependencies>\n</plugin>\n"}, {"type": "code", "text": "<plugin>\n    <artifactId>kotlin-maven-plugin</artifactId>\n    <groupId>org.jetbrains.kotlin</groupId>\n    <version>${kotlin.version}</version>\n\n    <configuration>\n        <compilerPlugins>\n            <!-- Or \"spring\" for the Spring support -->\n            <plugin>all-open</plugin>\n        </compilerPlugins>\n\n        <pluginOptions>\n            <!-- Each annotation is placed on its own line -->\n            <option>all-open:annotation=com.my.Annotation</option>\n            <option>all-open:annotation=com.their.AnotherAnnotation</option>\n        </pluginOptions>\n    </configuration>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-maven-allopen</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n    </dependencies>\n</plugin>\n"}, {"type": "p", "text": "Please refer to the \"Using in Gradle\" section above for the detailed information about how all-open annotations work."}, {"type": "h3", "text": "Spring support"}, {"type": "p", "text": "If you use Spring, you can enable the kotlin-spring compiler plugin instead of specifying Spring annotations manually. The kotlin-spring is a wrapper on top of all-open, and it behaves exactly the same way."}, {"type": "em", "text": "kotlin-spring"}, {"type": "p", "text": "As with all-open, add the plugin to the buildscript dependencies:"}, {"type": "div", "text": "\nbuildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-allopen:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-spring\" // instead of \"kotlin-allopen\"\n\n"}, {"type": "pre", "text": "buildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-allopen:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-spring\" // instead of \"kotlin-allopen\"\n"}, {"type": "code", "text": "buildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-allopen:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-spring\" // instead of \"kotlin-allopen\"\n"}, {"type": "p", "text": "Or using the Gradle plugins DSL:"}, {"type": "div", "text": "\nplugins {\n  id \"org.jetbrains.kotlin.plugin.spring\" version \"1.3.72\"\n}\n\n"}, {"type": "pre", "text": "plugins {\n  id \"org.jetbrains.kotlin.plugin.spring\" version \"1.3.72\"\n}\n"}, {"type": "code", "text": "plugins {\n  id \"org.jetbrains.kotlin.plugin.spring\" version \"1.3.72\"\n}\n"}, {"type": "p", "text": "In Maven, enable the spring plugin:"}, {"type": "code", "text": "spring"}, {"type": "div", "text": "\n<compilerPlugins>\n    <plugin>spring</plugin>\n</compilerPlugins>\n\n"}, {"type": "pre", "text": "<compilerPlugins>\n    <plugin>spring</plugin>\n</compilerPlugins>\n"}, {"type": "code", "text": "<compilerPlugins>\n    <plugin>spring</plugin>\n</compilerPlugins>\n"}, {"type": "p", "text": "The plugin specifies the following annotations: \n@Component, @Async, @Transactional, @Cacheable and @SpringBootTest. Thanks to meta-annotations support classes annotated with @Configuration, @Controller, @RestController, @Service or @Repository are automatically opened since these annotations are meta-annotated with @Component."}, {"type": "a", "text": "@Component"}, {"type": "code", "text": "@Component"}, {"type": "a", "text": "@Async"}, {"type": "code", "text": "@Async"}, {"type": "a", "text": "@Transactional"}, {"type": "code", "text": "@Transactional"}, {"type": "a", "text": "@Cacheable"}, {"type": "code", "text": "@Cacheable"}, {"type": "a", "text": "@SpringBootTest"}, {"type": "code", "text": "@SpringBootTest"}, {"type": "a", "text": "@Configuration"}, {"type": "code", "text": "@Configuration"}, {"type": "a", "text": "@Controller"}, {"type": "code", "text": "@Controller"}, {"type": "a", "text": "@RestController"}, {"type": "code", "text": "@RestController"}, {"type": "a", "text": "@Service"}, {"type": "code", "text": "@Service"}, {"type": "a", "text": "@Repository"}, {"type": "code", "text": "@Repository"}, {"type": "a", "text": "@Component"}, {"type": "code", "text": "@Component"}, {"type": "p", "text": "Of course, you can use both kotlin-allopen and kotlin-spring in the same project."}, {"type": "code", "text": "kotlin-allopen"}, {"type": "code", "text": "kotlin-spring"}, {"type": "p", "text": "Note that if you use the project template generated by the start.spring.io service, the kotlin-spring plugin will be enabled by default."}, {"type": "a", "text": "start.spring.io"}, {"type": "code", "text": "kotlin-spring"}, {"type": "h3", "text": "Using in CLI"}, {"type": "p", "text": "All-open compiler plugin JAR is available in the binary distribution of the Kotlin compiler. You can attach the plugin by providing the path to its JAR file using the Xplugin kotlinc option:"}, {"type": "code", "text": "Xplugin"}, {"type": "div", "text": "\n-Xplugin=$KOTLIN_HOME/lib/allopen-compiler-plugin.jar\n\n"}, {"type": "pre", "text": "-Xplugin=$KOTLIN_HOME/lib/allopen-compiler-plugin.jar\n"}, {"type": "code", "text": "-Xplugin=$KOTLIN_HOME/lib/allopen-compiler-plugin.jar\n"}, {"type": "p", "text": "You can specify all-open annotations directly, using the annotation plugin option, or enable the \"preset\". The only preset available now for all-open is spring."}, {"type": "code", "text": "annotation"}, {"type": "code", "text": "spring"}, {"type": "div", "text": "\n# The plugin option format is: \"-P plugin:<plugin id>:<key>=<value>\". \n# Options can be repeated.\n\n-P plugin:org.jetbrains.kotlin.allopen:annotation=com.my.Annotation\n-P plugin:org.jetbrains.kotlin.allopen:preset=spring\n\n"}, {"type": "pre", "text": "# The plugin option format is: \"-P plugin:<plugin id>:<key>=<value>\". \n# Options can be repeated.\n\n-P plugin:org.jetbrains.kotlin.allopen:annotation=com.my.Annotation\n-P plugin:org.jetbrains.kotlin.allopen:preset=spring\n"}, {"type": "code", "text": "# The plugin option format is: \"-P plugin:<plugin id>:<key>=<value>\". \n# Options can be repeated.\n\n-P plugin:org.jetbrains.kotlin.allopen:annotation=com.my.Annotation\n-P plugin:org.jetbrains.kotlin.allopen:preset=spring\n"}, {"type": "h2", "text": "No-arg compiler plugin"}, {"type": "p", "text": "The no-arg compiler plugin generates an additional zero-argument constructor for classes with a specific annotation."}, {"type": "em", "text": "no-arg"}, {"type": "p", "text": "The generated constructor is synthetic so it can\u2019t be directly called from Java or Kotlin, but it can be called using reflection."}, {"type": "p", "text": "This allows the Java Persistence API (JPA) to instantiate a class although it doesn't have the zero-parameter constructor from Kotlin or Java point of view (see the description of kotlin-jpa plugin below)."}, {"type": "code", "text": "kotlin-jpa"}, {"type": "a", "text": "below"}, {"type": "h3", "text": "Using in Gradle"}, {"type": "p", "text": "The usage is pretty similar to all-open."}, {"type": "p", "text": "Add the plugin and specify the list of annotations that must lead to generating a no-arg constructor for the annotated classes."}, {"type": "div", "text": "\nbuildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-noarg:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-noarg\"\n\n"}, {"type": "pre", "text": "buildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-noarg:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-noarg\"\n"}, {"type": "code", "text": "buildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-noarg:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-noarg\"\n"}, {"type": "p", "text": "Or using the Gradle plugins DSL:"}, {"type": "div", "text": "\nplugins {\n  id \"org.jetbrains.kotlin.plugin.noarg\" version \"1.3.72\"\n}\n\n"}, {"type": "pre", "text": "plugins {\n  id \"org.jetbrains.kotlin.plugin.noarg\" version \"1.3.72\"\n}\n"}, {"type": "code", "text": "plugins {\n  id \"org.jetbrains.kotlin.plugin.noarg\" version \"1.3.72\"\n}\n"}, {"type": "p", "text": "Then specify the list of no-arg annotations:"}, {"type": "div", "text": "\nnoArg {\n    annotation(\"com.my.Annotation\")\n}\n\n"}, {"type": "pre", "text": "noArg {\n    annotation(\"com.my.Annotation\")\n}\n"}, {"type": "code", "text": "noArg {\n    annotation(\"com.my.Annotation\")\n}\n"}, {"type": "p", "text": "Enable invokeInitializers option if you want the plugin to run the initialization logic from the synthetic constructor. Starting from Kotlin 1.1.3-2, it is disabled by default because of KT-18667 and KT-18668 which will be addressed in the future."}, {"type": "code", "text": "invokeInitializers"}, {"type": "a", "text": "KT-18667"}, {"type": "code", "text": "KT-18667"}, {"type": "a", "text": "KT-18668"}, {"type": "code", "text": "KT-18668"}, {"type": "div", "text": "\nnoArg {\n    invokeInitializers = true\n}\n\n"}, {"type": "pre", "text": "noArg {\n    invokeInitializers = true\n}\n"}, {"type": "code", "text": "noArg {\n    invokeInitializers = true\n}\n"}, {"type": "h3", "text": "Using in Maven"}, {"type": "div", "text": "\n<plugin>\n    <artifactId>kotlin-maven-plugin</artifactId>\n    <groupId>org.jetbrains.kotlin</groupId>\n    <version>${kotlin.version}</version>\n\n    <configuration>\n        <compilerPlugins>\n            <!-- Or \"jpa\" for JPA support -->\n            <plugin>no-arg</plugin>\n        </compilerPlugins>\n\n        <pluginOptions>\n            <option>no-arg:annotation=com.my.Annotation</option>\n            <!-- Call instance initializers in the synthetic constructor -->\n            <!-- <option>no-arg:invokeInitializers=true</option> -->\n        </pluginOptions>\n    </configuration>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-maven-noarg</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n    </dependencies>\n</plugin>\n\n"}, {"type": "pre", "text": "<plugin>\n    <artifactId>kotlin-maven-plugin</artifactId>\n    <groupId>org.jetbrains.kotlin</groupId>\n    <version>${kotlin.version}</version>\n\n    <configuration>\n        <compilerPlugins>\n            <!-- Or \"jpa\" for JPA support -->\n            <plugin>no-arg</plugin>\n        </compilerPlugins>\n\n        <pluginOptions>\n            <option>no-arg:annotation=com.my.Annotation</option>\n            <!-- Call instance initializers in the synthetic constructor -->\n            <!-- <option>no-arg:invokeInitializers=true</option> -->\n        </pluginOptions>\n    </configuration>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-maven-noarg</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n    </dependencies>\n</plugin>\n"}, {"type": "code", "text": "<plugin>\n    <artifactId>kotlin-maven-plugin</artifactId>\n    <groupId>org.jetbrains.kotlin</groupId>\n    <version>${kotlin.version}</version>\n\n    <configuration>\n        <compilerPlugins>\n            <!-- Or \"jpa\" for JPA support -->\n            <plugin>no-arg</plugin>\n        </compilerPlugins>\n\n        <pluginOptions>\n            <option>no-arg:annotation=com.my.Annotation</option>\n            <!-- Call instance initializers in the synthetic constructor -->\n            <!-- <option>no-arg:invokeInitializers=true</option> -->\n        </pluginOptions>\n    </configuration>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-maven-noarg</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n    </dependencies>\n</plugin>\n"}, {"type": "h3", "text": "JPA support"}, {"type": "p", "text": "As with the kotlin-spring plugin, kotlin-jpa is a wrapped on top of no-arg. The plugin specifies \n@Entity, @Embeddable and @MappedSuperclass\nno-arg annotations automatically."}, {"type": "em", "text": "kotlin-spring"}, {"type": "em", "text": "kotlin-jpa"}, {"type": "em", "text": "no-arg"}, {"type": "a", "text": "@Entity"}, {"type": "code", "text": "@Entity"}, {"type": "a", "text": "@Embeddable"}, {"type": "code", "text": "@Embeddable"}, {"type": "a", "text": "@MappedSuperclass"}, {"type": "code", "text": "@MappedSuperclass"}, {"type": "em", "text": "no-arg"}, {"type": "p", "text": "That's how you add the plugin in Gradle:"}, {"type": "div", "text": "\nbuildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-noarg:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-jpa\"\n\n"}, {"type": "pre", "text": "buildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-noarg:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-jpa\"\n"}, {"type": "code", "text": "buildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-noarg:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-jpa\"\n"}, {"type": "p", "text": "Or using the Gradle plugins DSL:"}, {"type": "div", "text": "\nplugins {\n  id \"org.jetbrains.kotlin.plugin.jpa\" version \"1.3.72\"\n}\n\n"}, {"type": "pre", "text": "plugins {\n  id \"org.jetbrains.kotlin.plugin.jpa\" version \"1.3.72\"\n}\n"}, {"type": "code", "text": "plugins {\n  id \"org.jetbrains.kotlin.plugin.jpa\" version \"1.3.72\"\n}\n"}, {"type": "p", "text": "In Maven, enable the jpa plugin:"}, {"type": "code", "text": "jpa"}, {"type": "div", "text": "\n<compilerPlugins>\n    <plugin>jpa</plugin>\n</compilerPlugins>\n\n"}, {"type": "pre", "text": "<compilerPlugins>\n    <plugin>jpa</plugin>\n</compilerPlugins>\n"}, {"type": "code", "text": "<compilerPlugins>\n    <plugin>jpa</plugin>\n</compilerPlugins>\n"}, {"type": "h3", "text": "Using in CLI"}, {"type": "p", "text": "As with all-open, add the plugin JAR file to the compiler plugin classpath and specify annotations or presets:"}, {"type": "div", "text": "\n-Xplugin=$KOTLIN_HOME/lib/noarg-compiler-plugin.jar\n-P plugin:org.jetbrains.kotlin.noarg:annotation=com.my.Annotation\n-P plugin:org.jetbrains.kotlin.noarg:preset=jpa\n\n"}, {"type": "pre", "text": "-Xplugin=$KOTLIN_HOME/lib/noarg-compiler-plugin.jar\n-P plugin:org.jetbrains.kotlin.noarg:annotation=com.my.Annotation\n-P plugin:org.jetbrains.kotlin.noarg:preset=jpa\n"}, {"type": "code", "text": "-Xplugin=$KOTLIN_HOME/lib/noarg-compiler-plugin.jar\n-P plugin:org.jetbrains.kotlin.noarg:annotation=com.my.Annotation\n-P plugin:org.jetbrains.kotlin.noarg:preset=jpa\n"}, {"type": "h2", "text": "SAM-with-receiver compiler plugin"}, {"type": "p", "text": "The sam-with-receiver compiler plugin makes the first parameter of the annotated Java \"single abstract method\" (SAM) interface method a receiver in Kotlin. This conversion only works when the SAM interface is passed as a Kotlin lambda, both for SAM adapters and SAM constructors (see the documentation for more details)."}, {"type": "em", "text": "sam-with-receiver"}, {"type": "a", "text": "documentation"}, {"type": "p", "text": "Here is an example:"}, {"type": "div", "text": "\npublic @interface SamWithReceiver {}\n\n@SamWithReceiver\npublic interface TaskRunner {\n    void run(Task task);\n}\n\n"}, {"type": "pre", "text": "public @interface SamWithReceiver {}\n\n@SamWithReceiver\npublic interface TaskRunner {\n    void run(Task task);\n}\n"}, {"type": "code", "text": "public @interface SamWithReceiver {}\n\n@SamWithReceiver\npublic interface TaskRunner {\n    void run(Task task);\n}\n"}, {"type": "div", "text": "\nfun test(context: TaskContext) {\n    val runner = TaskRunner { \n        // Here 'this' is an instance of 'Task'\n        \n        println(\"$name is started\")\n        context.executeTask(this)\n        println(\"$name is finished\")\n    }\n}\n\n"}, {"type": "pre", "text": "fun test(context: TaskContext) {\n    val runner = TaskRunner { \n        // Here 'this' is an instance of 'Task'\n        \n        println(\"$name is started\")\n        context.executeTask(this)\n        println(\"$name is finished\")\n    }\n}\n"}, {"type": "code", "text": "fun test(context: TaskContext) {\n    val runner = TaskRunner { \n        // Here 'this' is an instance of 'Task'\n        \n        println(\"$name is started\")\n        context.executeTask(this)\n        println(\"$name is finished\")\n    }\n}\n"}, {"type": "h3", "text": "Using in Gradle"}, {"type": "p", "text": "The usage is the same to all-open and no-arg, except the fact that sam-with-receiver does not have any built-in presets, and you need to specify your own list of special-treated annotations."}, {"type": "div", "text": "\nbuildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-sam-with-receiver:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-sam-with-receiver\"\n\n"}, {"type": "pre", "text": "buildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-sam-with-receiver:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-sam-with-receiver\"\n"}, {"type": "code", "text": "buildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-sam-with-receiver:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-sam-with-receiver\"\n"}, {"type": "p", "text": "Then specify the list of SAM-with-receiver annotations:"}, {"type": "div", "text": "\nsamWithReceiver {\n    annotation(\"com.my.SamWithReceiver\")\n}\n\n"}, {"type": "pre", "text": "samWithReceiver {\n    annotation(\"com.my.SamWithReceiver\")\n}\n"}, {"type": "code", "text": "samWithReceiver {\n    annotation(\"com.my.SamWithReceiver\")\n}\n"}, {"type": "h3", "text": "Using in Maven"}, {"type": "div", "text": "\n<plugin>\n    <artifactId>kotlin-maven-plugin</artifactId>\n    <groupId>org.jetbrains.kotlin</groupId>\n    <version>${kotlin.version}</version>\n\n    <configuration>\n        <compilerPlugins>\n            <plugin>sam-with-receiver</plugin>\n        </compilerPlugins>\n\n        <pluginOptions>\n            <option>\n                sam-with-receiver:annotation=com.my.SamWithReceiver\n            </option>\n        </pluginOptions>\n    </configuration>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-maven-sam-with-receiver</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n    </dependencies>\n</plugin>\n\n"}, {"type": "pre", "text": "<plugin>\n    <artifactId>kotlin-maven-plugin</artifactId>\n    <groupId>org.jetbrains.kotlin</groupId>\n    <version>${kotlin.version}</version>\n\n    <configuration>\n        <compilerPlugins>\n            <plugin>sam-with-receiver</plugin>\n        </compilerPlugins>\n\n        <pluginOptions>\n            <option>\n                sam-with-receiver:annotation=com.my.SamWithReceiver\n            </option>\n        </pluginOptions>\n    </configuration>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-maven-sam-with-receiver</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n    </dependencies>\n</plugin>\n"}, {"type": "code", "text": "<plugin>\n    <artifactId>kotlin-maven-plugin</artifactId>\n    <groupId>org.jetbrains.kotlin</groupId>\n    <version>${kotlin.version}</version>\n\n    <configuration>\n        <compilerPlugins>\n            <plugin>sam-with-receiver</plugin>\n        </compilerPlugins>\n\n        <pluginOptions>\n            <option>\n                sam-with-receiver:annotation=com.my.SamWithReceiver\n            </option>\n        </pluginOptions>\n    </configuration>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-maven-sam-with-receiver</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n    </dependencies>\n</plugin>\n"}, {"type": "h3", "text": "Using in CLI"}, {"type": "p", "text": "Just add the plugin JAR file to the compiler plugin classpath and specify the list of sam-with-receiver annotations:"}, {"type": "div", "text": "\n-Xplugin=$KOTLIN_HOME/lib/sam-with-receiver-compiler-plugin.jar\n-P plugin:org.jetbrains.kotlin.samWithReceiver:annotation=com.my.SamWithReceiver\n\n"}, {"type": "pre", "text": "-Xplugin=$KOTLIN_HOME/lib/sam-with-receiver-compiler-plugin.jar\n-P plugin:org.jetbrains.kotlin.samWithReceiver:annotation=com.my.SamWithReceiver\n"}, {"type": "code", "text": "-Xplugin=$KOTLIN_HOME/lib/sam-with-receiver-compiler-plugin.jar\n-P plugin:org.jetbrains.kotlin.samWithReceiver:annotation=com.my.SamWithReceiver\n"}, {"type": "h2", "text": "Parcelable implementations generator"}, {"type": "code", "text": "Parcelable"}, {"type": "p", "text": "Android Extensions plugin provides Parcelable implementation generator."}, {"type": "a", "text": "Parcelable"}, {"type": "code", "text": "Parcelable"}, {"type": "p", "text": "Annotate the class with @Parcelize, and a Parcelable implementation will be generated automatically."}, {"type": "code", "text": "@Parcelize"}, {"type": "code", "text": "Parcelable"}, {"type": "div", "text": "\nimport kotlinx.android.parcel.Parcelize\n\n@Parcelize\nclass User(val firstName: String, val lastName: String, val age: Int): Parcelable\n\n"}, {"type": "pre", "text": "import kotlinx.android.parcel.Parcelize\n\n@Parcelize\nclass User(val firstName: String, val lastName: String, val age: Int): Parcelable\n"}, {"type": "code", "text": "import kotlinx.android.parcel.Parcelize\n\n@Parcelize\nclass User(val firstName: String, val lastName: String, val age: Int): Parcelable\n"}, {"type": "p", "text": "@Parcelize requires all serialized properties to be declared in the primary constructor. Android Extensions will issue a warning on each property \nwith a backing field declared in the class body. Also, @Parcelize can't be applied if some of the primary constructor parameters are not properties."}, {"type": "code", "text": "@Parcelize"}, {"type": "code", "text": "@Parcelize"}, {"type": "p", "text": "If your class requires more advanced serialization logic, write it inside a companion class:"}, {"type": "div", "text": "\n@Parcelize\ndata class User(val firstName: String, val lastName: String, val age: Int) : Parcelable {\n    private companion object : Parceler<User> {\n        override fun User.write(parcel: Parcel, flags: Int) {\n            // Custom write implementation\n        }\n\n        override fun create(parcel: Parcel): User {\n            // Custom read implementation\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "@Parcelize\ndata class User(val firstName: String, val lastName: String, val age: Int) : Parcelable {\n    private companion object : Parceler<User> {\n        override fun User.write(parcel: Parcel, flags: Int) {\n            // Custom write implementation\n        }\n\n        override fun create(parcel: Parcel): User {\n            // Custom read implementation\n        }\n    }\n}\n"}, {"type": "code", "text": "@Parcelize\ndata class User(val firstName: String, val lastName: String, val age: Int) : Parcelable {\n    private companion object : Parceler<User> {\n        override fun User.write(parcel: Parcel, flags: Int) {\n            // Custom write implementation\n        }\n\n        override fun create(parcel: Parcel): User {\n            // Custom read implementation\n        }\n    }\n}\n"}, {"type": "h3", "text": "Supported types"}, {"type": "p", "text": "@Parcelize supports a wide range of types:"}, {"type": "code", "text": "@Parcelize"}, {"type": "ul", "text": "\nprimitive types (and their boxed versions);\nobjects and enums;\nString, CharSequence;\nException;\nSize, SizeF, Bundle, IBinder, IInterface, FileDescriptor;\nSparseArray, SparseIntArray, SparseLongArray, SparseBooleanArray;\nall Serializable (yes, Date is supported too) and Parcelable implementations;\ncollections of all supported types: List (mapped to ArrayList), Set (mapped to LinkedHashSet), Map (mapped to LinkedHashMap);\n    \nAlso a number of concrete implementations: ArrayList, LinkedList, SortedSet, NavigableSet, HashSet, LinkedHashSet, TreeSet, SortedMap, NavigableMap, HashMap, LinkedHashMap, TreeMap, ConcurrentHashMap;\n\n\narrays of all supported types;\nnullable versions of all supported types.\n"}, {"type": "li", "text": "primitive types (and their boxed versions);"}, {"type": "li", "text": "objects and enums;"}, {"type": "li", "text": "String, CharSequence;"}, {"type": "code", "text": "String"}, {"type": "code", "text": "CharSequence"}, {"type": "li", "text": "Exception;"}, {"type": "code", "text": "Exception"}, {"type": "li", "text": "Size, SizeF, Bundle, IBinder, IInterface, FileDescriptor;"}, {"type": "code", "text": "Size"}, {"type": "code", "text": "SizeF"}, {"type": "code", "text": "Bundle"}, {"type": "code", "text": "IBinder"}, {"type": "code", "text": "IInterface"}, {"type": "code", "text": "FileDescriptor"}, {"type": "li", "text": "SparseArray, SparseIntArray, SparseLongArray, SparseBooleanArray;"}, {"type": "code", "text": "SparseArray"}, {"type": "code", "text": "SparseIntArray"}, {"type": "code", "text": "SparseLongArray"}, {"type": "code", "text": "SparseBooleanArray"}, {"type": "li", "text": "all Serializable (yes, Date is supported too) and Parcelable implementations;"}, {"type": "code", "text": "Serializable"}, {"type": "code", "text": "Date"}, {"type": "code", "text": "Parcelable"}, {"type": "li", "text": "collections of all supported types: List (mapped to ArrayList), Set (mapped to LinkedHashSet), Map (mapped to LinkedHashMap);\n    \nAlso a number of concrete implementations: ArrayList, LinkedList, SortedSet, NavigableSet, HashSet, LinkedHashSet, TreeSet, SortedMap, NavigableMap, HashMap, LinkedHashMap, TreeMap, ConcurrentHashMap;\n\n"}, {"type": "code", "text": "List"}, {"type": "code", "text": "ArrayList"}, {"type": "code", "text": "Set"}, {"type": "code", "text": "LinkedHashSet"}, {"type": "code", "text": "Map"}, {"type": "code", "text": "LinkedHashMap"}, {"type": "ul", "text": "\nAlso a number of concrete implementations: ArrayList, LinkedList, SortedSet, NavigableSet, HashSet, LinkedHashSet, TreeSet, SortedMap, NavigableMap, HashMap, LinkedHashMap, TreeMap, ConcurrentHashMap;\n"}, {"type": "li", "text": "Also a number of concrete implementations: ArrayList, LinkedList, SortedSet, NavigableSet, HashSet, LinkedHashSet, TreeSet, SortedMap, NavigableMap, HashMap, LinkedHashMap, TreeMap, ConcurrentHashMap;"}, {"type": "code", "text": "ArrayList"}, {"type": "code", "text": "LinkedList"}, {"type": "code", "text": "SortedSet"}, {"type": "code", "text": "NavigableSet"}, {"type": "code", "text": "HashSet"}, {"type": "code", "text": "LinkedHashSet"}, {"type": "code", "text": "TreeSet"}, {"type": "code", "text": "SortedMap"}, {"type": "code", "text": "NavigableMap"}, {"type": "code", "text": "HashMap"}, {"type": "code", "text": "LinkedHashMap"}, {"type": "code", "text": "TreeMap"}, {"type": "code", "text": "ConcurrentHashMap"}, {"type": "li", "text": "arrays of all supported types;"}, {"type": "li", "text": "nullable versions of all supported types."}, {"type": "h3", "text": "Custom Parcelers"}, {"type": "code", "text": "Parceler"}, {"type": "p", "text": "Even if your type is not supported directly, you can write a Parceler mapping object for it."}, {"type": "code", "text": "Parceler"}, {"type": "div", "text": "\nclass ExternalClass(val value: Int)\n\nobject ExternalClassParceler : Parceler<ExternalClass> {\n    override fun create(parcel: Parcel) = ExternalClass(parcel.readInt())\n\n    override fun ExternalClass.write(parcel: Parcel, flags: Int) {\n        parcel.writeInt(value)\n    }\n}\n\n"}, {"type": "pre", "text": "class ExternalClass(val value: Int)\n\nobject ExternalClassParceler : Parceler<ExternalClass> {\n    override fun create(parcel: Parcel) = ExternalClass(parcel.readInt())\n\n    override fun ExternalClass.write(parcel: Parcel, flags: Int) {\n        parcel.writeInt(value)\n    }\n}\n"}, {"type": "code", "text": "class ExternalClass(val value: Int)\n\nobject ExternalClassParceler : Parceler<ExternalClass> {\n    override fun create(parcel: Parcel) = ExternalClass(parcel.readInt())\n\n    override fun ExternalClass.write(parcel: Parcel, flags: Int) {\n        parcel.writeInt(value)\n    }\n}\n"}, {"type": "p", "text": "External parcelers can be applied using @TypeParceler or @WriteWith annotations:"}, {"type": "code", "text": "@TypeParceler"}, {"type": "code", "text": "@WriteWith"}, {"type": "div", "text": "\n// Class-local parceler\n@Parcelize\n@TypeParceler<ExternalClass, ExternalClassParceler>()\nclass MyClass(val external: ExternalClass)\n\n// Property-local parceler\n@Parcelize\nclass MyClass(@TypeParceler<ExternalClass, ExternalClassParceler>() val external: ExternalClass)\n\n// Type-local parceler\n@Parcelize\nclass MyClass(val external: @WriteWith<ExternalClassParceler>() ExternalClass)\n\n"}, {"type": "pre", "text": "// Class-local parceler\n@Parcelize\n@TypeParceler<ExternalClass, ExternalClassParceler>()\nclass MyClass(val external: ExternalClass)\n\n// Property-local parceler\n@Parcelize\nclass MyClass(@TypeParceler<ExternalClass, ExternalClassParceler>() val external: ExternalClass)\n\n// Type-local parceler\n@Parcelize\nclass MyClass(val external: @WriteWith<ExternalClassParceler>() ExternalClass)\n"}, {"type": "code", "text": "// Class-local parceler\n@Parcelize\n@TypeParceler<ExternalClass, ExternalClassParceler>()\nclass MyClass(val external: ExternalClass)\n\n// Property-local parceler\n@Parcelize\nclass MyClass(@TypeParceler<ExternalClass, ExternalClassParceler>() val external: ExternalClass)\n\n// Type-local parceler\n@Parcelize\nclass MyClass(val external: @WriteWith<ExternalClassParceler>() ExternalClass)\n"}]