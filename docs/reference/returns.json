[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Returns and Jumps"}, {"type": "p", "text": "Kotlin has three structural jump expressions:"}, {"type": "ul", "text": "\nreturn. By default returns from the nearest enclosing function or anonymous function.\nbreak. Terminates the nearest enclosing loop.\ncontinue. Proceeds to the next step of the nearest enclosing loop.\n"}, {"type": "li", "text": "return. By default returns from the nearest enclosing function or anonymous function."}, {"type": "em", "text": "return"}, {"type": "a", "text": "anonymous function"}, {"type": "li", "text": "break. Terminates the nearest enclosing loop."}, {"type": "em", "text": "break"}, {"type": "li", "text": "continue. Proceeds to the next step of the nearest enclosing loop."}, {"type": "em", "text": "continue"}, {"type": "p", "text": "All of these expressions can be used as part of larger expressions:"}, {"type": "div", "text": "\nval s = person.name ?: return\n\n"}, {"type": "pre", "text": "val s = person.name ?: return\n"}, {"type": "code", "text": "val s = person.name ?: return\n"}, {"type": "p", "text": "The type of these expressions is the Nothing type."}, {"type": "a", "text": "Nothing type"}, {"type": "h2", "text": "Break and Continue Labels"}, {"type": "p", "text": "Any expression in Kotlin may be marked with a label.\nLabels have the form of an identifier followed by the @ sign, for example: abc@, fooBar@ are valid labels (see the grammar).\nTo label an expression, we just put a label in front of it"}, {"type": "em", "text": "label"}, {"type": "code", "text": "@"}, {"type": "code", "text": "abc@"}, {"type": "code", "text": "fooBar@"}, {"type": "a", "text": "grammar"}, {"type": "div", "text": "\nloop@ for (i in 1..100) {\n    // ...\n}\n\n"}, {"type": "pre", "text": "loop@ for (i in 1..100) {\n    // ...\n}\n"}, {"type": "code", "text": "loop@ for (i in 1..100) {\n    // ...\n}\n"}, {"type": "p", "text": "Now, we can qualify a break or a continue with a label:"}, {"type": "em", "text": "break"}, {"type": "em", "text": "continue"}, {"type": "div", "text": "\nloop@ for (i in 1..100) {\n    for (j in 1..100) {\n        if (...) break@loop\n    }\n}\n\n"}, {"type": "pre", "text": "loop@ for (i in 1..100) {\n    for (j in 1..100) {\n        if (...) break@loop\n    }\n}\n"}, {"type": "code", "text": "loop@ for (i in 1..100) {\n    for (j in 1..100) {\n        if (...) break@loop\n    }\n}\n"}, {"type": "p", "text": "A break qualified with a label jumps to the execution point right after the loop marked with that label.\nA continue proceeds to the next iteration of that loop."}, {"type": "em", "text": "break"}, {"type": "em", "text": "continue"}, {"type": "h2", "text": "Return at Labels"}, {"type": "p", "text": "With function literals, local functions and object expression, functions can be nested in Kotlin. \nQualified returns allow us to return from an outer function. \nThe most important use case is returning from a lambda expression. Recall that when we write this:"}, {"type": "em", "text": "return"}, {"type": "div", "text": "\n//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach {\n        if (it == 3) return // non-local return directly to the caller of foo()\n        print(it)\n    }\n    println(\"this point is unreachable\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n\n"}, {"type": "pre", "text": "//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach {\n        if (it == 3) return // non-local return directly to the caller of foo()\n        print(it)\n    }\n    println(\"this point is unreachable\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n"}, {"type": "code", "text": "//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach {\n        if (it == 3) return // non-local return directly to the caller of foo()\n        print(it)\n    }\n    println(\"this point is unreachable\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n"}, {"type": "p", "text": "The return-expression returns from the nearest enclosing function, i.e. foo.\n(Note that such non-local returns are supported only for lambda expressions passed to inline functions.)\nIf we need to return from a lambda expression, we have to label it and qualify the return:"}, {"type": "em", "text": "return"}, {"type": "code", "text": "foo"}, {"type": "a", "text": "inline functions"}, {"type": "em", "text": "return"}, {"type": "div", "text": "\n//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach lit@{\n        if (it == 3) return@lit // local return to the caller of the lambda, i.e. the forEach loop\n        print(it)\n    }\n    print(\" done with explicit label\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n\n"}, {"type": "pre", "text": "//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach lit@{\n        if (it == 3) return@lit // local return to the caller of the lambda, i.e. the forEach loop\n        print(it)\n    }\n    print(\" done with explicit label\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n"}, {"type": "code", "text": "//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach lit@{\n        if (it == 3) return@lit // local return to the caller of the lambda, i.e. the forEach loop\n        print(it)\n    }\n    print(\" done with explicit label\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n"}, {"type": "p", "text": "Now, it returns only from the lambda expression. Oftentimes it is more convenient to use implicit labels:\nsuch a label has the same name as the function to which the lambda is passed."}, {"type": "div", "text": "\n//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach {\n        if (it == 3) return@forEach // local return to the caller of the lambda, i.e. the forEach loop\n        print(it)\n    }\n    print(\" done with implicit label\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n\n"}, {"type": "pre", "text": "//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach {\n        if (it == 3) return@forEach // local return to the caller of the lambda, i.e. the forEach loop\n        print(it)\n    }\n    print(\" done with implicit label\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n"}, {"type": "code", "text": "//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach {\n        if (it == 3) return@forEach // local return to the caller of the lambda, i.e. the forEach loop\n        print(it)\n    }\n    print(\" done with implicit label\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n"}, {"type": "p", "text": "Alternatively, we can replace the lambda expression with an anonymous function.\nA return statement in an anonymous function will return from the anonymous function itself."}, {"type": "a", "text": "anonymous function"}, {"type": "em", "text": "return"}, {"type": "div", "text": "\n//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {\n        if (value == 3) return  // local return to the caller of the anonymous fun, i.e. the forEach loop\n        print(value)\n    })\n    print(\" done with anonymous function\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n\n"}, {"type": "pre", "text": "//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {\n        if (value == 3) return  // local return to the caller of the anonymous fun, i.e. the forEach loop\n        print(value)\n    })\n    print(\" done with anonymous function\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n"}, {"type": "code", "text": "//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {\n        if (value == 3) return  // local return to the caller of the anonymous fun, i.e. the forEach loop\n        print(value)\n    })\n    print(\" done with anonymous function\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n"}, {"type": "p", "text": "Note that the use of local returns in previous three examples is similar to the use of continue in regular loops. There is no direct equivalent for break, but it can be simulated by adding another nesting lambda and non-locally returning from it:"}, {"type": "em", "text": "continue"}, {"type": "em", "text": "break"}, {"type": "div", "text": "\n//sampleStart\nfun foo() {\n    run loop@{\n        listOf(1, 2, 3, 4, 5).forEach {\n            if (it == 3) return@loop // non-local return from the lambda passed to run\n            print(it)\n        }\n    }\n    print(\" done with nested loop\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n\n"}, {"type": "pre", "text": "//sampleStart\nfun foo() {\n    run loop@{\n        listOf(1, 2, 3, 4, 5).forEach {\n            if (it == 3) return@loop // non-local return from the lambda passed to run\n            print(it)\n        }\n    }\n    print(\" done with nested loop\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n"}, {"type": "code", "text": "//sampleStart\nfun foo() {\n    run loop@{\n        listOf(1, 2, 3, 4, 5).forEach {\n            if (it == 3) return@loop // non-local return from the lambda passed to run\n            print(it)\n        }\n    }\n    print(\" done with nested loop\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n"}, {"type": "p", "text": "When returning a value, the parser gives preference to the qualified return, i.e."}, {"type": "div", "text": "\nreturn@a 1\n\n"}, {"type": "pre", "text": "return@a 1\n"}, {"type": "code", "text": "return@a 1\n"}, {"type": "p", "text": "means \"return 1 at label @a\" and not \"return a labeled expression (@a 1)\"."}, {"type": "code", "text": "1"}, {"type": "code", "text": "@a"}, {"type": "code", "text": "(@a 1)"}]