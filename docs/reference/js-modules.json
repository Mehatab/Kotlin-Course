[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "JavaScript Modules"}, {"type": "p", "text": "Kotlin allows you to compile your Kotlin projects to JavaScript modules for popular module systems. Here is\nthe list of available options:"}, {"type": "ol", "text": "\nPlain. Don't compile for any module system. As usual, you can access a module by its name in the global scope.\nThis option is used by default.\nAsynchronous Module Definition (AMD), which is in particular\nused by require.js library.\nCommonJS convention, widely used by node.js/npm\n(require function and module.exports object)\nUnified Module Definitions (UMD), which is compatible with both AMD and CommonJS, and works as \"plain\"\nwhen neither AMD nor CommonJS is available at runtime.\n"}, {"type": "li", "text": "Plain. Don't compile for any module system. As usual, you can access a module by its name in the global scope.\nThis option is used by default."}, {"type": "li", "text": "Asynchronous Module Definition (AMD), which is in particular\nused by require.js library."}, {"type": "a", "text": "Asynchronous Module Definition (AMD)"}, {"type": "li", "text": "CommonJS convention, widely used by node.js/npm\n(require function and module.exports object)"}, {"type": "a", "text": "CommonJS"}, {"type": "code", "text": "require"}, {"type": "code", "text": "module.exports"}, {"type": "li", "text": "Unified Module Definitions (UMD), which is compatible with both AMD and CommonJS, and works as \"plain\"\nwhen neither AMD nor CommonJS is available at runtime."}, {"type": "em", "text": "AMD"}, {"type": "em", "text": "CommonJS"}, {"type": "em", "text": "AMD"}, {"type": "em", "text": "CommonJS"}, {"type": "h2", "text": "Targeting the browser"}, {"type": "p", "text": "If you're targeting the browser, you can specify the desired module type in the webpackTask configuration block:"}, {"type": "code", "text": "webpackTask"}, {"type": "div", "text": "\nimport org.jetbrains.kotlin.gradle.targets.js.webpack.KotlinWebpackOutput.Target.COMMONJS\n\nkotlin {\n    target {\n        browser {\n            webpackTask {\n                output.libraryTarget = COMMONJS \n                //output.libraryTarget = \"commonjs\" // alternative\n             }\n        }\n    }\n}\n\n\n"}, {"type": "pre", "text": "import org.jetbrains.kotlin.gradle.targets.js.webpack.KotlinWebpackOutput.Target.COMMONJS\n\nkotlin {\n    target {\n        browser {\n            webpackTask {\n                output.libraryTarget = COMMONJS \n                //output.libraryTarget = \"commonjs\" // alternative\n             }\n        }\n    }\n}\n\n"}, {"type": "code", "text": "import org.jetbrains.kotlin.gradle.targets.js.webpack.KotlinWebpackOutput.Target.COMMONJS\n\nkotlin {\n    target {\n        browser {\n            webpackTask {\n                output.libraryTarget = COMMONJS \n                //output.libraryTarget = \"commonjs\" // alternative\n             }\n        }\n    }\n}\n\n"}, {"type": "p", "text": "This way, you'll get a single JS file with all dependencies included."}, {"type": "h2", "text": "Creating libraries and node.js files"}, {"type": "p", "text": "If you're creating a JS library or a node.js file, define the module kind as described below."}, {"type": "h3", "text": "Choosing the target module system"}, {"type": "p", "text": "To select module kind, set the moduleKind compiler option in the Gradle build script."}, {"type": "code", "text": "moduleKind"}, {"type": "div", "text": "\n\ncompileKotlinJs.kotlinOptions.moduleKind = \"commonjs\"\n\n\n\n"}, {"type": "div", "text": "\ncompileKotlinJs.kotlinOptions.moduleKind = \"commonjs\"\n\n\n"}, {"type": "pre", "text": "compileKotlinJs.kotlinOptions.moduleKind = \"commonjs\"\n\n"}, {"type": "code", "text": "compileKotlinJs.kotlinOptions.moduleKind = \"commonjs\"\n\n"}, {"type": "div", "text": "\n\ntasks.named(\"compileKotlinJs\") {\n    this as KotlinJsCompile\n    kotlinOptions.moduleKind = \"commonjs\"\n}\n\n\n"}, {"type": "div", "text": "\ntasks.named(\"compileKotlinJs\") {\n    this as KotlinJsCompile\n    kotlinOptions.moduleKind = \"commonjs\"\n}\n\n"}, {"type": "pre", "text": "tasks.named(\"compileKotlinJs\") {\n    this as KotlinJsCompile\n    kotlinOptions.moduleKind = \"commonjs\"\n}\n"}, {"type": "code", "text": "tasks.named(\"compileKotlinJs\") {\n    this as KotlinJsCompile\n    kotlinOptions.moduleKind = \"commonjs\"\n}\n"}, {"type": "p", "text": "Available values are: plain, amd, commonjs, umd."}, {"type": "code", "text": "plain"}, {"type": "code", "text": "amd"}, {"type": "code", "text": "commonjs"}, {"type": "code", "text": "umd"}, {"type": "p", "text": "In Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:"}, {"type": "div", "text": "\nkotlin {\n    target {\n         useCommonJs()\n    }\n}\n\n"}, {"type": "pre", "text": "kotlin {\n    target {\n         useCommonJs()\n    }\n}\n"}, {"type": "code", "text": "kotlin {\n    target {\n         useCommonJs()\n    }\n}\n"}, {"type": "h2", "text": "@JsModule annotation"}, {"type": "code", "text": "@JsModule"}, {"type": "p", "text": "To tell Kotlin that an external class, package, function or property is a JavaScript module, you can use @JsModule\nannotation. Consider you have the following CommonJS module called \"hello\":"}, {"type": "code", "text": "external"}, {"type": "code", "text": "@JsModule"}, {"type": "div", "text": "\nmodule.exports.sayHello = function(name) { alert(\"Hello, \" + name); }\n\n"}, {"type": "pre", "text": "module.exports.sayHello = function(name) { alert(\"Hello, \" + name); }\n"}, {"type": "code", "text": "module.exports.sayHello = function(name) { alert(\"Hello, \" + name); }\n"}, {"type": "p", "text": "You should declare it like this in Kotlin:"}, {"type": "div", "text": "\n@JsModule(\"hello\")\nexternal fun sayHello(name: String)\n\n"}, {"type": "pre", "text": "@JsModule(\"hello\")\nexternal fun sayHello(name: String)\n"}, {"type": "code", "text": "@JsModule(\"hello\")\nexternal fun sayHello(name: String)\n"}, {"type": "h3", "text": "Applying @JsModule to packages"}, {"type": "code", "text": "@JsModule"}, {"type": "p", "text": "Some JavaScript libraries export packages (namespaces) instead of functions and classes.\nIn terms of JavaScript, it's an object that has members that are classes, functions and properties.\nImporting these packages as Kotlin objects often looks unnatural.\nThe compiler allows to map imported JavaScript packages to Kotlin packages, using the following notation:"}, {"type": "em", "text": "are"}, {"type": "div", "text": "\n@file:JsModule(\"extModule\")\npackage ext.jspackage.name\n\nexternal fun foo()\n\nexternal class C\n\n"}, {"type": "pre", "text": "@file:JsModule(\"extModule\")\npackage ext.jspackage.name\n\nexternal fun foo()\n\nexternal class C\n"}, {"type": "code", "text": "@file:JsModule(\"extModule\")\npackage ext.jspackage.name\n\nexternal fun foo()\n\nexternal class C\n"}, {"type": "p", "text": "where the corresponding JavaScript module is declared like this:"}, {"type": "div", "text": "\nmodule.exports = {\n    foo:  { /* some code here */ },\n    C:  { /* some code here */ }\n}\n\n"}, {"type": "pre", "text": "module.exports = {\n    foo:  { /* some code here */ },\n    C:  { /* some code here */ }\n}\n"}, {"type": "code", "text": "module.exports = {\n    foo:  { /* some code here */ },\n    C:  { /* some code here */ }\n}\n"}, {"type": "p", "text": "Important: files marked with @file:JsModule annotation can't declare non-external members.\nThe example below produces compile-time error:"}, {"type": "code", "text": "@file:JsModule"}, {"type": "div", "text": "\n@file:JsModule(\"extModule\")\npackage ext.jspackage.name\n\nexternal fun foo()\n\nfun bar() = \"!\" + foo() + \"!\" // error here\n\n"}, {"type": "pre", "text": "@file:JsModule(\"extModule\")\npackage ext.jspackage.name\n\nexternal fun foo()\n\nfun bar() = \"!\" + foo() + \"!\" // error here\n"}, {"type": "code", "text": "@file:JsModule(\"extModule\")\npackage ext.jspackage.name\n\nexternal fun foo()\n\nfun bar() = \"!\" + foo() + \"!\" // error here\n"}, {"type": "h3", "text": "Importing deeper package hierarchies"}, {"type": "p", "text": "In the previous example the JavaScript module exports a single package.\nHowever, some JavaScript libraries export multiple packages from within a module.\nThis case is also supported by Kotlin, though you have to declare a new .kt file for each package you import."}, {"type": "code", "text": ".kt"}, {"type": "p", "text": "For example, let's make our example a bit more complicated:"}, {"type": "div", "text": "\nmodule.exports = {\n    mylib: {\n        pkg1: {\n            foo: function() { /* some code here */ },\n            bar: function() { /* some code here */ }\n        },\n        pkg2: {\n            baz: function() { /* some code here */ }\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "module.exports = {\n    mylib: {\n        pkg1: {\n            foo: function() { /* some code here */ },\n            bar: function() { /* some code here */ }\n        },\n        pkg2: {\n            baz: function() { /* some code here */ }\n        }\n    }\n}\n"}, {"type": "code", "text": "module.exports = {\n    mylib: {\n        pkg1: {\n            foo: function() { /* some code here */ },\n            bar: function() { /* some code here */ }\n        },\n        pkg2: {\n            baz: function() { /* some code here */ }\n        }\n    }\n}\n"}, {"type": "p", "text": "To import this module in Kotlin, you have to write two Kotlin source files:"}, {"type": "div", "text": "\n@file:JsModule(\"extModule\")\n@file:JsQualifier(\"mylib.pkg1\")\npackage extlib.pkg1\n\nexternal fun foo()\n\nexternal fun bar()\n\n"}, {"type": "pre", "text": "@file:JsModule(\"extModule\")\n@file:JsQualifier(\"mylib.pkg1\")\npackage extlib.pkg1\n\nexternal fun foo()\n\nexternal fun bar()\n"}, {"type": "code", "text": "@file:JsModule(\"extModule\")\n@file:JsQualifier(\"mylib.pkg1\")\npackage extlib.pkg1\n\nexternal fun foo()\n\nexternal fun bar()\n"}, {"type": "p", "text": "and"}, {"type": "div", "text": "\n@file:JsModule(\"extModule\")\n@file:JsQualifier(\"mylib.pkg2\")\npackage extlib.pkg2\n\nexternal fun baz()\n\n"}, {"type": "pre", "text": "@file:JsModule(\"extModule\")\n@file:JsQualifier(\"mylib.pkg2\")\npackage extlib.pkg2\n\nexternal fun baz()\n"}, {"type": "code", "text": "@file:JsModule(\"extModule\")\n@file:JsQualifier(\"mylib.pkg2\")\npackage extlib.pkg2\n\nexternal fun baz()\n"}, {"type": "h3", "text": "@JsNonModule annotation"}, {"type": "code", "text": "@JsNonModule"}, {"type": "p", "text": "When a declaration has @JsModule, you can't use it from Kotlin code when you don't compile it to a JavaScript module.\nUsually, developers distribute their libraries both as JavaScript modules and downloadable .js files that you\ncan copy to project's static resources and include via <script> element. To tell Kotlin that it's ok\nto use a @JsModule declaration from non-module environment, you should put @JsNonModule declaration. For example,\ngiven JavaScript code:"}, {"type": "code", "text": "@JsModule"}, {"type": "code", "text": ".js"}, {"type": "code", "text": "<script>"}, {"type": "code", "text": "@JsModule"}, {"type": "code", "text": "@JsNonModule"}, {"type": "div", "text": "\nfunction topLevelSayHello(name) { alert(\"Hello, \" + name); }\nif (module && module.exports) {\n    module.exports = topLevelSayHello;\n}\n\n"}, {"type": "pre", "text": "function topLevelSayHello(name) { alert(\"Hello, \" + name); }\nif (module && module.exports) {\n    module.exports = topLevelSayHello;\n}\n"}, {"type": "code", "text": "function topLevelSayHello(name) { alert(\"Hello, \" + name); }\nif (module && module.exports) {\n    module.exports = topLevelSayHello;\n}\n"}, {"type": "p", "text": "can be described like this:"}, {"type": "div", "text": "\n@JsModule(\"hello\")\n@JsNonModule\n@JsName(\"topLevelSayHello\")\nexternal fun sayHello(name: String)\n\n"}, {"type": "pre", "text": "@JsModule(\"hello\")\n@JsNonModule\n@JsName(\"topLevelSayHello\")\nexternal fun sayHello(name: String)\n"}, {"type": "code", "text": "@JsModule(\"hello\")\n@JsNonModule\n@JsName(\"topLevelSayHello\")\nexternal fun sayHello(name: String)\n"}, {"type": "h3", "text": "Notes"}, {"type": "p", "text": "Kotlin is distributed with kotlin.js standard library as a single file, which is itself compiled as an UMD module, so\nyou can use it with any module system described above. It is available on NPM as kotlin package"}, {"type": "code", "text": "kotlin.js"}, {"type": "a", "text": "kotlin package"}, {"type": "code", "text": "kotlin"}]