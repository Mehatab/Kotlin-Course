[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Coding Conventions"}, {"type": "p", "text": "This page contains the current coding style for the Kotlin language."}, {"type": "ul", "text": "\nSource code organization\nNaming rules\nFormatting\nDocumentation comments\nAvoiding redundant constructs\nIdiomatic use of language features\nCoding conventions for libraries\n"}, {"type": "li", "text": "Source code organization"}, {"type": "a", "text": "Source code organization"}, {"type": "li", "text": "Naming rules"}, {"type": "a", "text": "Naming rules"}, {"type": "li", "text": "Formatting"}, {"type": "a", "text": "Formatting"}, {"type": "li", "text": "Documentation comments"}, {"type": "a", "text": "Documentation comments"}, {"type": "li", "text": "Avoiding redundant constructs"}, {"type": "a", "text": "Avoiding redundant constructs"}, {"type": "li", "text": "Idiomatic use of language features"}, {"type": "a", "text": "Idiomatic use of language features"}, {"type": "li", "text": "Coding conventions for libraries"}, {"type": "a", "text": "Coding conventions for libraries"}, {"type": "h3", "text": "Applying the style guide"}, {"type": "p", "text": "To configure the IntelliJ formatter according to this style guide, please install Kotlin plugin version\n1.2.20 or newer, go to Settings | Editor | Code Style | Kotlin, click Set from\u2026 link in the upper\nright corner, and select Predefined style | Kotlin style guide from the menu."}, {"type": "strong", "text": "Settings | Editor | Code Style | Kotlin"}, {"type": "strong", "text": "Set from\u2026"}, {"type": "strong", "text": "Predefined style | Kotlin style guide"}, {"type": "p", "text": "To verify that your code is formatted according to the style guide, go to the inspection settings and enable\nthe Kotlin | Style issues | File is not formatted according to project settings inspection. Additional\ninspections that verify other issues described in the style guide (such as naming conventions) are enabled by default."}, {"type": "strong", "text": "Kotlin | Style issues | File is not formatted according to project settings"}, {"type": "h2", "text": "Source code organization"}, {"type": "h3", "text": "Directory structure"}, {"type": "p", "text": "In pure Kotlin projects, the recommended directory structure follows the package structure with\nthe common root package omitted. For example, if all the code in the project is in the org.example.kotlin package and its\nsubpackages, files with the org.example.kotlin package should be placed directly under the source root, and\nfiles in org.example.kotlin.network.socket should be in the network/socket subdirectory of the source root."}, {"type": "code", "text": "org.example.kotlin"}, {"type": "code", "text": "org.example.kotlin"}, {"type": "code", "text": "org.example.kotlin.network.socket"}, {"type": "code", "text": "network/socket"}, {"type": "blockquote", "text": "\nOn the JVM: In projects where Kotlin is used together with Java, Kotlin source files should reside in the same source root as the Java source files,\nand follow the same directory structure: each file should be stored in the directory corresponding to each package\nstatement.\n"}, {"type": "p", "text": "On the JVM: In projects where Kotlin is used together with Java, Kotlin source files should reside in the same source root as the Java source files,\nand follow the same directory structure: each file should be stored in the directory corresponding to each package\nstatement."}, {"type": "strong", "text": "On the JVM"}, {"type": "h3", "text": "Source file names"}, {"type": "p", "text": "If a Kotlin file contains a single class (potentially with related top-level declarations), its name should be the same\nas the name of the class, with the .kt extension appended. If a file contains multiple classes, or only top-level declarations,\nchoose a name describing what the file contains, and name the file accordingly.\nUse the camel case with an uppercase first letter (for example, ProcessDeclarations.kt)."}, {"type": "a", "text": "camel case"}, {"type": "code", "text": "ProcessDeclarations.kt"}, {"type": "p", "text": "The name of the file should describe what the code in the file does. Therefore, you should avoid using meaningless\nwords such as \"Util\" in file names."}, {"type": "h3", "text": "Source file organization"}, {"type": "p", "text": "Placing multiple declarations (classes, top-level functions or properties) in the same Kotlin source file is encouraged\nas long as these declarations are closely related to each other semantically and the file size remains reasonable\n(not exceeding a few hundred lines)."}, {"type": "p", "text": "In particular, when defining extension functions for a class which are relevant for all clients of this class,\nput them in the same file where the class itself is defined. When defining extension functions that make sense \nonly for a specific client, put them next to the code of that client. Do not create files just to hold \n\"all extensions of Foo\"."}, {"type": "h3", "text": "Class layout"}, {"type": "p", "text": "Generally, the contents of a class is sorted in the following order:"}, {"type": "ul", "text": "\nProperty declarations and initializer blocks\nSecondary constructors\nMethod declarations\nCompanion object\n"}, {"type": "li", "text": "Property declarations and initializer blocks"}, {"type": "li", "text": "Secondary constructors"}, {"type": "li", "text": "Method declarations"}, {"type": "li", "text": "Companion object"}, {"type": "p", "text": "Do not sort the method declarations alphabetically or by visibility, and do not separate regular methods\nfrom extension methods. Instead, put related stuff together, so that someone reading the class from top to bottom can \nfollow the logic of what's happening. Choose an order (either higher-level stuff first, or vice versa) and stick to it."}, {"type": "p", "text": "Put nested classes next to the code that uses those classes. If the classes are intended to be used externally and aren't\nreferenced inside the class, put them in the end, after the companion object."}, {"type": "h3", "text": "Interface implementation layout"}, {"type": "p", "text": "When implementing an interface, keep the implementing members in the same order as members of the interface (if necessary,\ninterspersed with additional private methods used for the implementation)"}, {"type": "h3", "text": "Overload layout"}, {"type": "p", "text": "Always put overloads next to each other in a class."}, {"type": "h2", "text": "Naming rules"}, {"type": "p", "text": "Package and class naming rules in Kotlin are quite simple:"}, {"type": "ul", "text": "\n\nNames of packages are always lower case and do not use underscores (org.example.project). Using multi-word\nnames is generally discouraged, but if you do need to use multiple words, you can either simply concatenate them together\nor use the camel case (org.example.myProject).\n\n\nNames of classes and objects start with an upper case letter and use the camel case:\n\n"}, {"type": "li", "text": "\nNames of packages are always lower case and do not use underscores (org.example.project). Using multi-word\nnames is generally discouraged, but if you do need to use multiple words, you can either simply concatenate them together\nor use the camel case (org.example.myProject).\n"}, {"type": "p", "text": "Names of packages are always lower case and do not use underscores (org.example.project). Using multi-word\nnames is generally discouraged, but if you do need to use multiple words, you can either simply concatenate them together\nor use the camel case (org.example.myProject)."}, {"type": "code", "text": "org.example.project"}, {"type": "code", "text": "org.example.myProject"}, {"type": "li", "text": "\nNames of classes and objects start with an upper case letter and use the camel case:\n"}, {"type": "p", "text": "Names of classes and objects start with an upper case letter and use the camel case:"}, {"type": "div", "text": "\nopen class DeclarationProcessor { /*...*/ }\n\nobject EmptyDeclarationProcessor : DeclarationProcessor() { /*...*/ }\n\n"}, {"type": "pre", "text": "open class DeclarationProcessor { /*...*/ }\n\nobject EmptyDeclarationProcessor : DeclarationProcessor() { /*...*/ }\n"}, {"type": "code", "text": "open class DeclarationProcessor { /*...*/ }\n\nobject EmptyDeclarationProcessor : DeclarationProcessor() { /*...*/ }\n"}, {"type": "h3", "text": "Function names"}, {"type": "p", "text": "Names of functions, properties and local variables start with a lower case letter and use the camel case and no underscores:"}, {"type": "div", "text": "\nfun processDeclarations() { /*...*/ }\nvar declarationCount = 1\n\n"}, {"type": "pre", "text": "fun processDeclarations() { /*...*/ }\nvar declarationCount = 1\n"}, {"type": "code", "text": "fun processDeclarations() { /*...*/ }\nvar declarationCount = 1\n"}, {"type": "p", "text": "Exception: factory functions used to create instances of classes can have the same name as the abstract return type:"}, {"type": "div", "text": "\ninterface Foo { /*...*/ }\n\nclass FooImpl : Foo { /*...*/ }\n\nfun Foo(): Foo { return FooImpl() }\n\n"}, {"type": "pre", "text": "interface Foo { /*...*/ }\n\nclass FooImpl : Foo { /*...*/ }\n\nfun Foo(): Foo { return FooImpl() }\n"}, {"type": "code", "text": "interface Foo { /*...*/ }\n\nclass FooImpl : Foo { /*...*/ }\n\nfun Foo(): Foo { return FooImpl() }\n"}, {"type": "h4", "text": "Names for test methods"}, {"type": "p", "text": "In tests (and only in tests), it's acceptable to use method names with spaces enclosed in backticks.\n(Note that such method names are currently not supported by the Android runtime.) Underscores in method names are\nalso allowed in test code."}, {"type": "strong", "text": "only"}, {"type": "div", "text": "\nclass MyTestCase {\n     @Test fun `ensure everything works`() { /*...*/ }\n     \n     @Test fun ensureEverythingWorks_onAndroid() { /*...*/ }\n}\n\n"}, {"type": "pre", "text": "class MyTestCase {\n     @Test fun `ensure everything works`() { /*...*/ }\n     \n     @Test fun ensureEverythingWorks_onAndroid() { /*...*/ }\n}\n"}, {"type": "code", "text": "class MyTestCase {\n     @Test fun `ensure everything works`() { /*...*/ }\n     \n     @Test fun ensureEverythingWorks_onAndroid() { /*...*/ }\n}\n"}, {"type": "h3", "text": "Property names"}, {"type": "p", "text": "Names of constants (properties marked with const, or top-level or object val properties with no custom get function\nthat hold deeply immutable data) should use uppercase underscore-separated names:"}, {"type": "code", "text": "const"}, {"type": "code", "text": "val"}, {"type": "code", "text": "get"}, {"type": "div", "text": "\nconst val MAX_COUNT = 8\nval USER_NAME_FIELD = \"UserName\"\n\n"}, {"type": "pre", "text": "const val MAX_COUNT = 8\nval USER_NAME_FIELD = \"UserName\"\n"}, {"type": "code", "text": "const val MAX_COUNT = 8\nval USER_NAME_FIELD = \"UserName\"\n"}, {"type": "p", "text": "Names of top-level or object properties which hold objects with behavior or mutable data should use camel-case names:"}, {"type": "div", "text": "\nval mutableCollection: MutableSet<String> = HashSet()\n\n"}, {"type": "pre", "text": "val mutableCollection: MutableSet<String> = HashSet()\n"}, {"type": "code", "text": "val mutableCollection: MutableSet<String> = HashSet()\n"}, {"type": "p", "text": "Names of properties holding references to singleton objects can use the same naming style as object declarations:"}, {"type": "code", "text": "object"}, {"type": "div", "text": "\nval PersonComparator: Comparator<Person> = /*...*/\n\n"}, {"type": "pre", "text": "val PersonComparator: Comparator<Person> = /*...*/\n"}, {"type": "code", "text": "val PersonComparator: Comparator<Person> = /*...*/\n"}, {"type": "p", "text": "For enum constants, it's OK to use either uppercase underscore-separated names\n(enum class Color { RED, GREEN }) or regular camel-case names starting with an uppercase first letter, depending on the usage."}, {"type": "code", "text": "enum class Color { RED, GREEN }"}, {"type": "h4", "text": "Names for backing properties"}, {"type": "p", "text": "If a class has two properties which are conceptually the same but one is part of a public API and another is an implementation\ndetail, use an underscore as the prefix for the name of the private property:"}, {"type": "div", "text": "\nclass C {\n    private val _elementList = mutableListOf<Element>()\n\n    val elementList: List<Element>\n         get() = _elementList\n}\n\n"}, {"type": "pre", "text": "class C {\n    private val _elementList = mutableListOf<Element>()\n\n    val elementList: List<Element>\n         get() = _elementList\n}\n"}, {"type": "code", "text": "class C {\n    private val _elementList = mutableListOf<Element>()\n\n    val elementList: List<Element>\n         get() = _elementList\n}\n"}, {"type": "h3", "text": "Choosing good names"}, {"type": "p", "text": "The name of a class is usually a noun or a noun phrase explaining what the class is: List, PersonReader."}, {"type": "em", "text": "is"}, {"type": "code", "text": "List"}, {"type": "code", "text": "PersonReader"}, {"type": "p", "text": "The name of a method is usually a verb or a verb phrase saying what the method does: close, readPersons.\nThe name should also suggest if the method is mutating the object or returning a new one. For instance sort is\nsorting a collection in place, while sorted is returning a sorted copy of the collection."}, {"type": "em", "text": "does"}, {"type": "code", "text": "close"}, {"type": "code", "text": "readPersons"}, {"type": "code", "text": "sort"}, {"type": "code", "text": "sorted"}, {"type": "p", "text": "The names should make it clear what the purpose of the entity is, so it's best to avoid using meaningless words\n(Manager, Wrapper etc.) in names."}, {"type": "code", "text": "Manager"}, {"type": "code", "text": "Wrapper"}, {"type": "p", "text": "When using an acronym as part of a declaration name, capitalize it if it consists of two letters (IOStream);\ncapitalize only the first letter if it is longer (XmlFormatter, HttpInputStream)."}, {"type": "code", "text": "IOStream"}, {"type": "code", "text": "XmlFormatter"}, {"type": "code", "text": "HttpInputStream"}, {"type": "h2", "text": "Formatting"}, {"type": "p", "text": "Use 4 spaces for indentation. Do not use tabs."}, {"type": "p", "text": "For curly braces, put the opening brace in the end of the line where the construct begins, and the closing brace\non a separate line aligned horizontally with the opening construct."}, {"type": "div", "text": "\nif (elements != null) {\n    for (element in elements) {\n        // ...\n    }\n}\n\n"}, {"type": "pre", "text": "if (elements != null) {\n    for (element in elements) {\n        // ...\n    }\n}\n"}, {"type": "code", "text": "if (elements != null) {\n    for (element in elements) {\n        // ...\n    }\n}\n"}, {"type": "p", "text": "(Note: In Kotlin, semicolons are optional, and therefore line breaks are significant. The language design assumes \nJava-style braces, and you may encounter surprising behavior if you try to use a different formatting style.)"}, {"type": "h3", "text": "Horizontal whitespace"}, {"type": "p", "text": "Put spaces around binary operators (a + b). Exception: don't put spaces around the \"range to\" operator (0..i)."}, {"type": "code", "text": "a + b"}, {"type": "code", "text": "0..i"}, {"type": "p", "text": "Do not put spaces around unary operators (a++)"}, {"type": "code", "text": "a++"}, {"type": "p", "text": "Put spaces between control flow keywords (if, when, for and while) and the corresponding opening parenthesis."}, {"type": "code", "text": "if"}, {"type": "code", "text": "when"}, {"type": "code", "text": "for"}, {"type": "code", "text": "while"}, {"type": "p", "text": "Do not put a space before an opening parenthesis in a primary constructor declaration, method declaration or method call."}, {"type": "div", "text": "\nclass A(val x: Int)\n\nfun foo(x: Int) { ... }\n\nfun bar() {\n    foo(1)\n}\n\n"}, {"type": "pre", "text": "class A(val x: Int)\n\nfun foo(x: Int) { ... }\n\nfun bar() {\n    foo(1)\n}\n"}, {"type": "code", "text": "class A(val x: Int)\n\nfun foo(x: Int) { ... }\n\nfun bar() {\n    foo(1)\n}\n"}, {"type": "p", "text": "Never put a space after (, [, or before ], )."}, {"type": "code", "text": "("}, {"type": "code", "text": "["}, {"type": "code", "text": "]"}, {"type": "code", "text": ")"}, {"type": "p", "text": "Never put a space around . or ?.: foo.bar().filter { it > 2 }.joinToString(), foo?.bar()"}, {"type": "code", "text": "."}, {"type": "code", "text": "?."}, {"type": "code", "text": "foo.bar().filter { it > 2 }.joinToString()"}, {"type": "code", "text": "foo?.bar()"}, {"type": "p", "text": "Put a space after //: // This is a comment"}, {"type": "code", "text": "//"}, {"type": "code", "text": "// This is a comment"}, {"type": "p", "text": "Do not put spaces around angle brackets used to specify type parameters: class Map<K, V> { ... }"}, {"type": "code", "text": "class Map<K, V> { ... }"}, {"type": "p", "text": "Do not put spaces around ::: Foo::class, String::length"}, {"type": "code", "text": "::"}, {"type": "code", "text": "Foo::class"}, {"type": "code", "text": "String::length"}, {"type": "p", "text": "Do not put a space before ? used to mark a nullable type: String?"}, {"type": "code", "text": "?"}, {"type": "code", "text": "String?"}, {"type": "p", "text": "As a general rule, avoid horizontal alignment of any kind. Renaming an identifier to a name with a different length\nshould not affect the formatting of either the declaration or any of the usages."}, {"type": "h3", "text": "Colon"}, {"type": "p", "text": "Put a space before : in the following cases:"}, {"type": "code", "text": ":"}, {"type": "ul", "text": "\nwhen it's used to separate a type and a supertype;\nwhen delegating to a superclass constructor or a different constructor of the same class;\nafter the object keyword.\n"}, {"type": "li", "text": "when it's used to separate a type and a supertype;"}, {"type": "li", "text": "when delegating to a superclass constructor or a different constructor of the same class;"}, {"type": "li", "text": "after the object keyword."}, {"type": "code", "text": "object"}, {"type": "p", "text": "Don't put a space before : when it separates a declaration and its type."}, {"type": "code", "text": ":"}, {"type": "p", "text": "Always put a space after :."}, {"type": "code", "text": ":"}, {"type": "div", "text": "\nabstract class Foo<out T : Any> : IFoo {\n    abstract fun foo(a: Int): T\n}\n\nclass FooImpl : Foo() {\n    constructor(x: String) : this(x) { /*...*/ }\n    \n    val x = object : IFoo { /*...*/ } \n} \n\n"}, {"type": "pre", "text": "abstract class Foo<out T : Any> : IFoo {\n    abstract fun foo(a: Int): T\n}\n\nclass FooImpl : Foo() {\n    constructor(x: String) : this(x) { /*...*/ }\n    \n    val x = object : IFoo { /*...*/ } \n} \n"}, {"type": "code", "text": "abstract class Foo<out T : Any> : IFoo {\n    abstract fun foo(a: Int): T\n}\n\nclass FooImpl : Foo() {\n    constructor(x: String) : this(x) { /*...*/ }\n    \n    val x = object : IFoo { /*...*/ } \n} \n"}, {"type": "h3", "text": "Class header formatting"}, {"type": "p", "text": "Classes with a few primary constructor parameters can be written in a single line:"}, {"type": "div", "text": "\nclass Person(id: Int, name: String)\n\n"}, {"type": "pre", "text": "class Person(id: Int, name: String)\n"}, {"type": "code", "text": "class Person(id: Int, name: String)\n"}, {"type": "p", "text": "Classes with longer headers should be formatted so that each primary constructor parameter is in a separate line with indentation.\nAlso, the closing parenthesis should be on a new line. If we use inheritance, then the superclass constructor call or list of implemented interfaces\nshould be located on the same line as the parenthesis:"}, {"type": "div", "text": "\nclass Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name) { /*...*/ }\n\n"}, {"type": "pre", "text": "class Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name) { /*...*/ }\n"}, {"type": "code", "text": "class Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name) { /*...*/ }\n"}, {"type": "p", "text": "For multiple interfaces, the superclass constructor call should be located first and then each interface should be located in a different line:"}, {"type": "div", "text": "\nclass Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name),\n    KotlinMaker { /*...*/ }\n\n"}, {"type": "pre", "text": "class Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name),\n    KotlinMaker { /*...*/ }\n"}, {"type": "code", "text": "class Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name),\n    KotlinMaker { /*...*/ }\n"}, {"type": "p", "text": "For classes with a long supertype list, put a line break after the colon and align all supertype names horizontally:"}, {"type": "div", "text": "\nclass MyFavouriteVeryLongClassHolder :\n    MyLongHolder<MyFavouriteVeryLongClass>(),\n    SomeOtherInterface,\n    AndAnotherOne {\n\n    fun foo() { /*...*/ }\n}\n\n"}, {"type": "pre", "text": "class MyFavouriteVeryLongClassHolder :\n    MyLongHolder<MyFavouriteVeryLongClass>(),\n    SomeOtherInterface,\n    AndAnotherOne {\n\n    fun foo() { /*...*/ }\n}\n"}, {"type": "code", "text": "class MyFavouriteVeryLongClassHolder :\n    MyLongHolder<MyFavouriteVeryLongClass>(),\n    SomeOtherInterface,\n    AndAnotherOne {\n\n    fun foo() { /*...*/ }\n}\n"}, {"type": "p", "text": "To clearly separate the class header and body when the class header is long, either put a blank line\nfollowing the class header (as in the example above), or put the opening curly brace on a separate line:"}, {"type": "div", "text": "\nclass MyFavouriteVeryLongClassHolder :\n    MyLongHolder<MyFavouriteVeryLongClass>(),\n    SomeOtherInterface,\n    AndAnotherOne \n{\n    fun foo() { /*...*/ }\n}\n\n"}, {"type": "pre", "text": "class MyFavouriteVeryLongClassHolder :\n    MyLongHolder<MyFavouriteVeryLongClass>(),\n    SomeOtherInterface,\n    AndAnotherOne \n{\n    fun foo() { /*...*/ }\n}\n"}, {"type": "code", "text": "class MyFavouriteVeryLongClassHolder :\n    MyLongHolder<MyFavouriteVeryLongClass>(),\n    SomeOtherInterface,\n    AndAnotherOne \n{\n    fun foo() { /*...*/ }\n}\n"}, {"type": "p", "text": "Use regular indent (4 spaces) for constructor parameters."}, {"type": "blockquote", "text": "\nRationale: This ensures that properties declared in the primary constructor have the same indentation as properties\ndeclared in the body of a class.\n"}, {"type": "p", "text": "Rationale: This ensures that properties declared in the primary constructor have the same indentation as properties\ndeclared in the body of a class."}, {"type": "h3", "text": "Modifiers"}, {"type": "p", "text": "If a declaration has multiple modifiers, always put them in the following order:"}, {"type": "div", "text": "\npublic / protected / private / internal\nexpect / actual\nfinal / open / abstract / sealed / const\nexternal\noverride\nlateinit\ntailrec\nvararg\nsuspend\ninner\nenum / annotation\ncompanion\ninline\ninfix\noperator\ndata\n\n"}, {"type": "pre", "text": "public / protected / private / internal\nexpect / actual\nfinal / open / abstract / sealed / const\nexternal\noverride\nlateinit\ntailrec\nvararg\nsuspend\ninner\nenum / annotation\ncompanion\ninline\ninfix\noperator\ndata\n"}, {"type": "code", "text": "public / protected / private / internal\nexpect / actual\nfinal / open / abstract / sealed / const\nexternal\noverride\nlateinit\ntailrec\nvararg\nsuspend\ninner\nenum / annotation\ncompanion\ninline\ninfix\noperator\ndata\n"}, {"type": "p", "text": "Place all annotations before modifiers:"}, {"type": "div", "text": "\n@Named(\"Foo\")\nprivate val foo: Foo\n\n"}, {"type": "pre", "text": "@Named(\"Foo\")\nprivate val foo: Foo\n"}, {"type": "code", "text": "@Named(\"Foo\")\nprivate val foo: Foo\n"}, {"type": "p", "text": "Unless you're working on a library, omit redundant modifiers (e.g. public)."}, {"type": "code", "text": "public"}, {"type": "h3", "text": "Annotation formatting"}, {"type": "p", "text": "Annotations are typically placed on separate lines, before the declaration to which they are attached, and with the same indentation:"}, {"type": "div", "text": "\n@Target(AnnotationTarget.PROPERTY)\nannotation class JsonExclude\n\n"}, {"type": "pre", "text": "@Target(AnnotationTarget.PROPERTY)\nannotation class JsonExclude\n"}, {"type": "code", "text": "@Target(AnnotationTarget.PROPERTY)\nannotation class JsonExclude\n"}, {"type": "p", "text": "Annotations without arguments may be placed on the same line:"}, {"type": "div", "text": "\n@JsonExclude @JvmField\nvar x: String\n\n"}, {"type": "pre", "text": "@JsonExclude @JvmField\nvar x: String\n"}, {"type": "code", "text": "@JsonExclude @JvmField\nvar x: String\n"}, {"type": "p", "text": "A single annotation without arguments may be placed on the same line as the corresponding declaration:"}, {"type": "div", "text": "\n@Test fun foo() { /*...*/ }\n\n"}, {"type": "pre", "text": "@Test fun foo() { /*...*/ }\n"}, {"type": "code", "text": "@Test fun foo() { /*...*/ }\n"}, {"type": "h3", "text": "File annotations"}, {"type": "p", "text": "File annotations are placed after the file comment (if any), before the package statement, and are separated from package with a blank line (to emphasize the fact that they target the file and not the package)."}, {"type": "code", "text": "package"}, {"type": "code", "text": "package"}, {"type": "div", "text": "\n/** License, copyright and whatever */\n@file:JvmName(\"FooBar\")\n\npackage foo.bar\n\n"}, {"type": "pre", "text": "/** License, copyright and whatever */\n@file:JvmName(\"FooBar\")\n\npackage foo.bar\n"}, {"type": "code", "text": "/** License, copyright and whatever */\n@file:JvmName(\"FooBar\")\n\npackage foo.bar\n"}, {"type": "h3", "text": "Function formatting"}, {"type": "p", "text": "If the function signature doesn't fit on a single line, use the following syntax:"}, {"type": "div", "text": "\nfun longMethodName(\n    argument: ArgumentType = defaultValue,\n    argument2: AnotherArgumentType\n): ReturnType {\n    // body\n}\n\n"}, {"type": "pre", "text": "fun longMethodName(\n    argument: ArgumentType = defaultValue,\n    argument2: AnotherArgumentType\n): ReturnType {\n    // body\n}\n"}, {"type": "code", "text": "fun longMethodName(\n    argument: ArgumentType = defaultValue,\n    argument2: AnotherArgumentType\n): ReturnType {\n    // body\n}\n"}, {"type": "p", "text": "Use regular indent (4 spaces) for function parameters."}, {"type": "blockquote", "text": "\nRationale: Consistency with constructor parameters\n"}, {"type": "p", "text": "Rationale: Consistency with constructor parameters"}, {"type": "p", "text": "Prefer using an expression body for functions with the body consisting of a single expression."}, {"type": "div", "text": "\nfun foo(): Int {     // bad\n    return 1 \n}\n\nfun foo() = 1        // good\n\n"}, {"type": "pre", "text": "fun foo(): Int {     // bad\n    return 1 \n}\n\nfun foo() = 1        // good\n"}, {"type": "code", "text": "fun foo(): Int {     // bad\n    return 1 \n}\n\nfun foo() = 1        // good\n"}, {"type": "h3", "text": "Expression body formatting"}, {"type": "p", "text": "If the function has an expression body that doesn't fit in the same line as the declaration, put the = sign on the first line.\nIndent the expression body by 4 spaces."}, {"type": "code", "text": "="}, {"type": "div", "text": "\nfun f(x: String) =\n    x.length\n\n"}, {"type": "pre", "text": "fun f(x: String) =\n    x.length\n"}, {"type": "code", "text": "fun f(x: String) =\n    x.length\n"}, {"type": "h3", "text": "Property formatting"}, {"type": "p", "text": "For very simple read-only properties, consider one-line formatting:"}, {"type": "div", "text": "\nval isEmpty: Boolean get() = size == 0\n\n"}, {"type": "pre", "text": "val isEmpty: Boolean get() = size == 0\n"}, {"type": "code", "text": "val isEmpty: Boolean get() = size == 0\n"}, {"type": "p", "text": "For more complex properties, always put get and set keywords on separate lines:"}, {"type": "code", "text": "get"}, {"type": "code", "text": "set"}, {"type": "div", "text": "\nval foo: String\n    get() { /*...*/ }\n\n"}, {"type": "pre", "text": "val foo: String\n    get() { /*...*/ }\n"}, {"type": "code", "text": "val foo: String\n    get() { /*...*/ }\n"}, {"type": "p", "text": "For properties with an initializer, if the initializer is long, add a line break after the equals sign\nand indent the initializer by four spaces:"}, {"type": "div", "text": "\nprivate val defaultCharset: Charset? =\n    EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)\n\n"}, {"type": "pre", "text": "private val defaultCharset: Charset? =\n    EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)\n"}, {"type": "code", "text": "private val defaultCharset: Charset? =\n    EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)\n"}, {"type": "h3", "text": "Formatting control flow statements"}, {"type": "p", "text": "If the condition of an if or when statement is multiline, always use curly braces around the body of the statement.\nIndent each subsequent line of the condition by 4 spaces relative to statement begin. \nPut the closing parentheses of the condition together with the opening curly brace on a separate line:"}, {"type": "code", "text": "if"}, {"type": "code", "text": "when"}, {"type": "div", "text": "\nif (!component.isSyncing &&\n    !hasAnyKotlinRuntimeInScope(module)\n) {\n    return createKotlinNotConfiguredPanel(module)\n}\n\n"}, {"type": "pre", "text": "if (!component.isSyncing &&\n    !hasAnyKotlinRuntimeInScope(module)\n) {\n    return createKotlinNotConfiguredPanel(module)\n}\n"}, {"type": "code", "text": "if (!component.isSyncing &&\n    !hasAnyKotlinRuntimeInScope(module)\n) {\n    return createKotlinNotConfiguredPanel(module)\n}\n"}, {"type": "blockquote", "text": "\nRationale: Tidy alignment and clear separation of condition and statement body\n"}, {"type": "p", "text": "Rationale: Tidy alignment and clear separation of condition and statement body"}, {"type": "p", "text": "Put the else, catch, finally keywords, as well as the while keyword of a do/while loop, on the same line as the \npreceding curly brace:"}, {"type": "code", "text": "else"}, {"type": "code", "text": "catch"}, {"type": "code", "text": "finally"}, {"type": "code", "text": "while"}, {"type": "div", "text": "\nif (condition) {\n    // body\n} else {\n    // else part\n}\n\ntry {\n    // body\n} finally {\n    // cleanup\n}\n\n"}, {"type": "pre", "text": "if (condition) {\n    // body\n} else {\n    // else part\n}\n\ntry {\n    // body\n} finally {\n    // cleanup\n}\n"}, {"type": "code", "text": "if (condition) {\n    // body\n} else {\n    // else part\n}\n\ntry {\n    // body\n} finally {\n    // cleanup\n}\n"}, {"type": "p", "text": "In a when statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:"}, {"type": "code", "text": "when"}, {"type": "div", "text": "\nprivate fun parsePropertyValue(propName: String, token: Token) {\n    when (token) {\n        is Token.ValueToken ->\n            callback.visitValue(propName, token.value)\n\n        Token.LBRACE -> { // ...\n        }\n    }\n}\n\n"}, {"type": "pre", "text": "private fun parsePropertyValue(propName: String, token: Token) {\n    when (token) {\n        is Token.ValueToken ->\n            callback.visitValue(propName, token.value)\n\n        Token.LBRACE -> { // ...\n        }\n    }\n}\n"}, {"type": "code", "text": "private fun parsePropertyValue(propName: String, token: Token) {\n    when (token) {\n        is Token.ValueToken ->\n            callback.visitValue(propName, token.value)\n\n        Token.LBRACE -> { // ...\n        }\n    }\n}\n"}, {"type": "p", "text": "Put short branches on the same line as the condition, without braces."}, {"type": "div", "text": "\nwhen (foo) {\n    true -> bar() // good\n    false -> { baz() } // bad\n}\n\n"}, {"type": "pre", "text": "when (foo) {\n    true -> bar() // good\n    false -> { baz() } // bad\n}\n"}, {"type": "code", "text": "when (foo) {\n    true -> bar() // good\n    false -> { baz() } // bad\n}\n"}, {"type": "h3", "text": "Method call formatting"}, {"type": "p", "text": "In long argument lists, put a line break after the opening parenthesis. Indent arguments by 4 spaces. \nGroup multiple closely related arguments on the same line."}, {"type": "div", "text": "\ndrawSquare(\n    x = 10, y = 10,\n    width = 100, height = 100,\n    fill = true\n)\n\n"}, {"type": "pre", "text": "drawSquare(\n    x = 10, y = 10,\n    width = 100, height = 100,\n    fill = true\n)\n"}, {"type": "code", "text": "drawSquare(\n    x = 10, y = 10,\n    width = 100, height = 100,\n    fill = true\n)\n"}, {"type": "p", "text": "Put spaces around the = sign separating the argument name and value."}, {"type": "code", "text": "="}, {"type": "h3", "text": "Chained call wrapping"}, {"type": "p", "text": "When wrapping chained calls, put the . character or the ?. operator on the next line, with a single indent:"}, {"type": "code", "text": "."}, {"type": "code", "text": "?."}, {"type": "div", "text": "\nval anchor = owner\n    ?.firstChild!!\n    .siblings(forward = true)\n    .dropWhile { it is PsiComment || it is PsiWhiteSpace }\n\n"}, {"type": "pre", "text": "val anchor = owner\n    ?.firstChild!!\n    .siblings(forward = true)\n    .dropWhile { it is PsiComment || it is PsiWhiteSpace }\n"}, {"type": "code", "text": "val anchor = owner\n    ?.firstChild!!\n    .siblings(forward = true)\n    .dropWhile { it is PsiComment || it is PsiWhiteSpace }\n"}, {"type": "p", "text": "The first call in the chain usually should have a line break before it, but it's OK to omit it if the code makes more sense that way."}, {"type": "h3", "text": "Lambda formatting"}, {"type": "p", "text": "In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters\nfrom the body. If a call takes a single lambda, it should be passed outside of parentheses whenever possible."}, {"type": "div", "text": "\nlist.filter { it > 10 }\n\n"}, {"type": "pre", "text": "list.filter { it > 10 }\n"}, {"type": "code", "text": "list.filter { it > 10 }\n"}, {"type": "p", "text": "If assigning a label for a lambda, do not put a space between the label and the opening curly brace:"}, {"type": "div", "text": "\nfun foo() {\n    ints.forEach lit@{\n        // ...\n    }\n}\n\n"}, {"type": "pre", "text": "fun foo() {\n    ints.forEach lit@{\n        // ...\n    }\n}\n"}, {"type": "code", "text": "fun foo() {\n    ints.forEach lit@{\n        // ...\n    }\n}\n"}, {"type": "p", "text": "When declaring parameter names in a multiline lambda, put the names on the first line, followed by the arrow and the newline:"}, {"type": "div", "text": "\nappendCommaSeparated(properties) { prop ->\n    val propertyValue = prop.get(obj)  // ...\n}\n\n"}, {"type": "pre", "text": "appendCommaSeparated(properties) { prop ->\n    val propertyValue = prop.get(obj)  // ...\n}\n"}, {"type": "code", "text": "appendCommaSeparated(properties) { prop ->\n    val propertyValue = prop.get(obj)  // ...\n}\n"}, {"type": "p", "text": "If the parameter list is too long to fit on a line, put the arrow on a separate line:"}, {"type": "div", "text": "\nfoo {\n   context: Context,\n   environment: Env\n   ->\n   context.configureEnv(environment)\n}\n\n"}, {"type": "pre", "text": "foo {\n   context: Context,\n   environment: Env\n   ->\n   context.configureEnv(environment)\n}\n"}, {"type": "code", "text": "foo {\n   context: Context,\n   environment: Env\n   ->\n   context.configureEnv(environment)\n}\n"}, {"type": "h2", "text": "Documentation comments"}, {"type": "p", "text": "For longer documentation comments, place the opening /** on a separate line and begin each subsequent line\nwith an asterisk:"}, {"type": "code", "text": "/**"}, {"type": "div", "text": "\n/**\n * This is a documentation comment\n * on multiple lines.\n */\n\n"}, {"type": "pre", "text": "/**\n * This is a documentation comment\n * on multiple lines.\n */\n"}, {"type": "code", "text": "/**\n * This is a documentation comment\n * on multiple lines.\n */\n"}, {"type": "p", "text": "Short comments can be placed on a single line:"}, {"type": "div", "text": "\n/** This is a short documentation comment. */\n\n"}, {"type": "pre", "text": "/** This is a short documentation comment. */\n"}, {"type": "code", "text": "/** This is a short documentation comment. */\n"}, {"type": "p", "text": "Generally, avoid using @param and @return tags. Instead, incorporate the description of parameters and return values\ndirectly into the documentation comment, and add links to parameters wherever they are mentioned. Use @param and\n@return only when a lengthy description is required which doesn't fit into the flow of the main text."}, {"type": "code", "text": "@param"}, {"type": "code", "text": "@return"}, {"type": "code", "text": "@param"}, {"type": "code", "text": "@return"}, {"type": "div", "text": "\n// Avoid doing this:\n\n/**\n * Returns the absolute value of the given number.\n * @param number The number to return the absolute value for.\n * @return The absolute value.\n */\nfun abs(number: Int) { /*...*/ }\n\n// Do this instead:\n\n/**\n * Returns the absolute value of the given [number].\n */\nfun abs(number: Int) { /*...*/ }\n\n"}, {"type": "pre", "text": "// Avoid doing this:\n\n/**\n * Returns the absolute value of the given number.\n * @param number The number to return the absolute value for.\n * @return The absolute value.\n */\nfun abs(number: Int) { /*...*/ }\n\n// Do this instead:\n\n/**\n * Returns the absolute value of the given [number].\n */\nfun abs(number: Int) { /*...*/ }\n"}, {"type": "code", "text": "// Avoid doing this:\n\n/**\n * Returns the absolute value of the given number.\n * @param number The number to return the absolute value for.\n * @return The absolute value.\n */\nfun abs(number: Int) { /*...*/ }\n\n// Do this instead:\n\n/**\n * Returns the absolute value of the given [number].\n */\nfun abs(number: Int) { /*...*/ }\n"}, {"type": "h2", "text": "Avoiding redundant constructs"}, {"type": "p", "text": "In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE\nas redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code\njust \"for clarity\"."}, {"type": "h3", "text": "Unit"}, {"type": "p", "text": "If a function returns Unit, the return type should be omitted:"}, {"type": "div", "text": "\nfun foo() { // \": Unit\" is omitted here\n\n}\n\n"}, {"type": "pre", "text": "fun foo() { // \": Unit\" is omitted here\n\n}\n"}, {"type": "code", "text": "fun foo() { // \": Unit\" is omitted here\n\n}\n"}, {"type": "h3", "text": "Semicolons"}, {"type": "p", "text": "Omit semicolons whenever possible."}, {"type": "h3", "text": "String templates"}, {"type": "p", "text": "Don't use curly braces when inserting a simple variable into a string template. Use curly braces only for longer expressions."}, {"type": "div", "text": "\nprintln(\"$name has ${children.size} children\")\n\n"}, {"type": "pre", "text": "println(\"$name has ${children.size} children\")\n"}, {"type": "code", "text": "println(\"$name has ${children.size} children\")\n"}, {"type": "h2", "text": "Idiomatic use of language features"}, {"type": "h3", "text": "Immutability"}, {"type": "p", "text": "Prefer using immutable data to mutable. Always declare local variables and properties as val rather than var if\nthey are not modified after initialization."}, {"type": "code", "text": "val"}, {"type": "code", "text": "var"}, {"type": "p", "text": "Always use immutable collection interfaces (Collection, List, Set, Map) to declare collections which are not\nmutated. When using factory functions to create collection instances, always use functions that return immutable\ncollection types when possible:"}, {"type": "code", "text": "Collection"}, {"type": "code", "text": "List"}, {"type": "code", "text": "Set"}, {"type": "code", "text": "Map"}, {"type": "div", "text": "\n// Bad: use of mutable collection type for value which will not be mutated\nfun validateValue(actualValue: String, allowedValues: HashSet<String>) { ... }\n\n// Good: immutable collection type used instead\nfun validateValue(actualValue: String, allowedValues: Set<String>) { ... }\n\n// Bad: arrayListOf() returns ArrayList<T>, which is a mutable collection type\nval allowedValues = arrayListOf(\"a\", \"b\", \"c\")\n\n// Good: listOf() returns List<T>\nval allowedValues = listOf(\"a\", \"b\", \"c\")\n\n"}, {"type": "pre", "text": "// Bad: use of mutable collection type for value which will not be mutated\nfun validateValue(actualValue: String, allowedValues: HashSet<String>) { ... }\n\n// Good: immutable collection type used instead\nfun validateValue(actualValue: String, allowedValues: Set<String>) { ... }\n\n// Bad: arrayListOf() returns ArrayList<T>, which is a mutable collection type\nval allowedValues = arrayListOf(\"a\", \"b\", \"c\")\n\n// Good: listOf() returns List<T>\nval allowedValues = listOf(\"a\", \"b\", \"c\")\n"}, {"type": "code", "text": "// Bad: use of mutable collection type for value which will not be mutated\nfun validateValue(actualValue: String, allowedValues: HashSet<String>) { ... }\n\n// Good: immutable collection type used instead\nfun validateValue(actualValue: String, allowedValues: Set<String>) { ... }\n\n// Bad: arrayListOf() returns ArrayList<T>, which is a mutable collection type\nval allowedValues = arrayListOf(\"a\", \"b\", \"c\")\n\n// Good: listOf() returns List<T>\nval allowedValues = listOf(\"a\", \"b\", \"c\")\n"}, {"type": "h3", "text": "Default parameter values"}, {"type": "p", "text": "Prefer declaring functions with default parameter values to declaring overloaded functions."}, {"type": "div", "text": "\n// Bad\nfun foo() = foo(\"a\")\nfun foo(a: String) { /*...*/ }\n\n// Good\nfun foo(a: String = \"a\") { /*...*/ }\n\n"}, {"type": "pre", "text": "// Bad\nfun foo() = foo(\"a\")\nfun foo(a: String) { /*...*/ }\n\n// Good\nfun foo(a: String = \"a\") { /*...*/ }\n"}, {"type": "code", "text": "// Bad\nfun foo() = foo(\"a\")\nfun foo(a: String) { /*...*/ }\n\n// Good\nfun foo(a: String = \"a\") { /*...*/ }\n"}, {"type": "h3", "text": "Type aliases"}, {"type": "p", "text": "If you have a functional type or a type with type parameters which is used multiple times in a codebase, prefer defining\na type alias for it:"}, {"type": "div", "text": "\ntypealias MouseClickHandler = (Any, MouseEvent) -> Unit\ntypealias PersonIndex = Map<String, Person>\n\n"}, {"type": "pre", "text": "typealias MouseClickHandler = (Any, MouseEvent) -> Unit\ntypealias PersonIndex = Map<String, Person>\n"}, {"type": "code", "text": "typealias MouseClickHandler = (Any, MouseEvent) -> Unit\ntypealias PersonIndex = Map<String, Person>\n"}, {"type": "h3", "text": "Lambda parameters"}, {"type": "p", "text": "In lambdas which are short and not nested, it's recommended to use the it convention instead of declaring the parameter\nexplicitly. In nested lambdas with parameters, parameters should be always declared explicitly."}, {"type": "code", "text": "it"}, {"type": "h3", "text": "Returns in a lambda"}, {"type": "p", "text": "Avoid using multiple labeled returns in a lambda. Consider restructuring the lambda so that it will have a single exit point.\nIf that's not possible or not clear enough, consider converting the lambda into an anonymous function."}, {"type": "p", "text": "Do not use a labeled return for the last statement in a lambda."}, {"type": "h3", "text": "Named arguments"}, {"type": "p", "text": "Use the named argument syntax when a method takes multiple parameters of the same primitive type, or for parameters of Boolean type,\nunless the meaning of all parameters is absolutely clear from context."}, {"type": "code", "text": "Boolean"}, {"type": "div", "text": "\ndrawSquare(x = 10, y = 10, width = 100, height = 100, fill = true)\n\n"}, {"type": "pre", "text": "drawSquare(x = 10, y = 10, width = 100, height = 100, fill = true)\n"}, {"type": "code", "text": "drawSquare(x = 10, y = 10, width = 100, height = 100, fill = true)\n"}, {"type": "h3", "text": "Using conditional statements"}, {"type": "p", "text": "Prefer using the expression form of try, if and when. Examples:"}, {"type": "code", "text": "try"}, {"type": "code", "text": "if"}, {"type": "code", "text": "when"}, {"type": "div", "text": "\nreturn if (x) foo() else bar()\n\nreturn when(x) {\n    0 -> \"zero\"\n    else -> \"nonzero\"\n}\n\n"}, {"type": "pre", "text": "return if (x) foo() else bar()\n\nreturn when(x) {\n    0 -> \"zero\"\n    else -> \"nonzero\"\n}\n"}, {"type": "code", "text": "return if (x) foo() else bar()\n\nreturn when(x) {\n    0 -> \"zero\"\n    else -> \"nonzero\"\n}\n"}, {"type": "p", "text": "The above is preferable to:"}, {"type": "div", "text": "\nif (x)\n    return foo()\nelse\n    return bar()\n    \nwhen(x) {\n    0 -> return \"zero\"\n    else -> return \"nonzero\"\n}    \n\n"}, {"type": "pre", "text": "if (x)\n    return foo()\nelse\n    return bar()\n    \nwhen(x) {\n    0 -> return \"zero\"\n    else -> return \"nonzero\"\n}    \n"}, {"type": "code", "text": "if (x)\n    return foo()\nelse\n    return bar()\n    \nwhen(x) {\n    0 -> return \"zero\"\n    else -> return \"nonzero\"\n}    \n"}, {"type": "h3", "text": "if versus when"}, {"type": "code", "text": "if"}, {"type": "code", "text": "when"}, {"type": "p", "text": "Prefer using if for binary conditions instead of when. Instead of"}, {"type": "code", "text": "if"}, {"type": "code", "text": "when"}, {"type": "div", "text": "\nwhen (x) {\n    null -> // ...\n    else -> // ...\n}\n\n"}, {"type": "pre", "text": "when (x) {\n    null -> // ...\n    else -> // ...\n}\n"}, {"type": "code", "text": "when (x) {\n    null -> // ...\n    else -> // ...\n}\n"}, {"type": "p", "text": "use if (x == null) ... else ..."}, {"type": "code", "text": "if (x == null) ... else ..."}, {"type": "p", "text": "Prefer using when if there are three or more options."}, {"type": "code", "text": "when"}, {"type": "h3", "text": "Using nullable Boolean values in conditions"}, {"type": "code", "text": "Boolean"}, {"type": "p", "text": "If you need to use a nullable Boolean in a conditional statement, use if (value == true) or if (value == false) checks."}, {"type": "code", "text": "Boolean"}, {"type": "code", "text": "if (value == true)"}, {"type": "code", "text": "if (value == false)"}, {"type": "h3", "text": "Using loops"}, {"type": "p", "text": "Prefer using higher-order functions (filter, map etc.) to loops. Exception: forEach (prefer using a regular for loop instead,\nunless the receiver of forEach is nullable or forEach is used as part of a longer call chain)."}, {"type": "code", "text": "filter"}, {"type": "code", "text": "map"}, {"type": "code", "text": "forEach"}, {"type": "code", "text": "for"}, {"type": "code", "text": "forEach"}, {"type": "code", "text": "forEach"}, {"type": "p", "text": "When making a choice between a complex expression using multiple higher-order functions and a loop, understand the cost\nof the operations being performed in each case and keep performance considerations in mind."}, {"type": "h3", "text": "Loops on ranges"}, {"type": "p", "text": "Use the until function to loop over an open range:"}, {"type": "code", "text": "until"}, {"type": "div", "text": "\nfor (i in 0..n - 1) { /*...*/ }  // bad\nfor (i in 0 until n) { /*...*/ }  // good\n\n"}, {"type": "pre", "text": "for (i in 0..n - 1) { /*...*/ }  // bad\nfor (i in 0 until n) { /*...*/ }  // good\n"}, {"type": "code", "text": "for (i in 0..n - 1) { /*...*/ }  // bad\nfor (i in 0 until n) { /*...*/ }  // good\n"}, {"type": "h3", "text": "Using strings"}, {"type": "p", "text": "Prefer using string templates to string concatenation."}, {"type": "p", "text": "Prefer to use multiline strings instead of embedding \\n escape sequences into regular string literals."}, {"type": "code", "text": "\\n"}, {"type": "p", "text": "To maintain indentation in multiline strings, use trimIndent when the resulting string does not require any internal\nindentation, or trimMargin when internal indentation is required:"}, {"type": "code", "text": "trimIndent"}, {"type": "code", "text": "trimMargin"}, {"type": "div", "text": "\nassertEquals(\n    \"\"\"\n    Foo\n    Bar\n    \"\"\".trimIndent(), \n    value\n)\n\nval a = \"\"\"if(a > 1) {\n          |    return a\n          |}\"\"\".trimMargin()\n\n"}, {"type": "pre", "text": "assertEquals(\n    \"\"\"\n    Foo\n    Bar\n    \"\"\".trimIndent(), \n    value\n)\n\nval a = \"\"\"if(a > 1) {\n          |    return a\n          |}\"\"\".trimMargin()\n"}, {"type": "code", "text": "assertEquals(\n    \"\"\"\n    Foo\n    Bar\n    \"\"\".trimIndent(), \n    value\n)\n\nval a = \"\"\"if(a > 1) {\n          |    return a\n          |}\"\"\".trimMargin()\n"}, {"type": "h3", "text": "Functions vs Properties"}, {"type": "p", "text": "In some cases functions with no arguments might be interchangeable with read-only properties. \nAlthough the semantics are similar, there are some stylistic conventions on when to prefer one to another."}, {"type": "p", "text": "Prefer a property over a function when the underlying algorithm:"}, {"type": "ul", "text": "\ndoes not throw\nis cheap to calculate (or ca\u0441hed on the first run)\nreturns the same result over invocations if the object state hasn't changed\n"}, {"type": "li", "text": "does not throw"}, {"type": "li", "text": "is cheap to calculate (or ca\u0441hed on the first run)"}, {"type": "li", "text": "returns the same result over invocations if the object state hasn't changed"}, {"type": "h3", "text": "Using extension functions"}, {"type": "p", "text": "Use extension functions liberally. Every time you have a function that works primarily on an object, consider making it\nan extension function accepting that object as a receiver. To minimize API pollution, restrict the visibility of\nextension functions as much as it makes sense. As necessary, use local extension functions, member extension functions,\nor top-level extension functions with private visibility."}, {"type": "h3", "text": "Using infix functions"}, {"type": "p", "text": "Declare a function as infix only when it works on two objects which play a similar role. Good examples: and, to, zip.\nBad example: add."}, {"type": "code", "text": "and"}, {"type": "code", "text": "to"}, {"type": "code", "text": "zip"}, {"type": "code", "text": "add"}, {"type": "p", "text": "Don't declare a method as infix if it mutates the receiver object."}, {"type": "h3", "text": "Factory functions"}, {"type": "p", "text": "If you declare a factory function for a class, avoid giving it the same name as the class itself. Prefer using a distinct name\nmaking it clear why the behavior of the factory function is special. Only if there is really no special semantics,\nyou can use the same name as the class."}, {"type": "p", "text": "Example:"}, {"type": "div", "text": "\nclass Point(val x: Double, val y: Double) {\n    companion object {\n        fun fromPolar(angle: Double, radius: Double) = Point(...)\n    }\n}\n\n"}, {"type": "pre", "text": "class Point(val x: Double, val y: Double) {\n    companion object {\n        fun fromPolar(angle: Double, radius: Double) = Point(...)\n    }\n}\n"}, {"type": "code", "text": "class Point(val x: Double, val y: Double) {\n    companion object {\n        fun fromPolar(angle: Double, radius: Double) = Point(...)\n    }\n}\n"}, {"type": "p", "text": "If you have an object with multiple overloaded constructors that don't call different superclass constructors and\ncan't be reduced to a single constructor with default argument values, prefer to replace the overloaded constructors with\nfactory functions."}, {"type": "h3", "text": "Platform types"}, {"type": "p", "text": "A public function/method returning an expression of a platform type must declare its Kotlin type explicitly:"}, {"type": "div", "text": "\nfun apiCall(): String = MyJavaApi.getProperty(\"name\")\n\n"}, {"type": "pre", "text": "fun apiCall(): String = MyJavaApi.getProperty(\"name\")\n"}, {"type": "code", "text": "fun apiCall(): String = MyJavaApi.getProperty(\"name\")\n"}, {"type": "p", "text": "Any property (package-level or class-level) initialised with an expression of a platform type must declare its Kotlin type explicitly:"}, {"type": "div", "text": "\nclass Person {\n    val name: String = MyJavaApi.getProperty(\"name\")\n}\n\n"}, {"type": "pre", "text": "class Person {\n    val name: String = MyJavaApi.getProperty(\"name\")\n}\n"}, {"type": "code", "text": "class Person {\n    val name: String = MyJavaApi.getProperty(\"name\")\n}\n"}, {"type": "p", "text": "A local value initialized with an expression of a platform type may or may not have a type declaration:"}, {"type": "div", "text": "\nfun main() {\n    val name = MyJavaApi.getProperty(\"name\")\n    println(name)\n}\n\n"}, {"type": "pre", "text": "fun main() {\n    val name = MyJavaApi.getProperty(\"name\")\n    println(name)\n}\n"}, {"type": "code", "text": "fun main() {\n    val name = MyJavaApi.getProperty(\"name\")\n    println(name)\n}\n"}, {"type": "h3", "text": "Using scope functions apply/with/run/also/let"}, {"type": "p", "text": "Kotlin provides a variety of functions to execute a block of code in the context of a given object: let, run, with, apply, and also.\nFor the guidance on choosing the right scope function for your case, refer to Scope Functions."}, {"type": "code", "text": "let"}, {"type": "code", "text": "run"}, {"type": "code", "text": "with"}, {"type": "code", "text": "apply"}, {"type": "code", "text": "also"}, {"type": "a", "text": "Scope Functions"}, {"type": "h2", "text": "Coding conventions for libraries"}, {"type": "p", "text": "When writing libraries, it's recommended to follow an additional set of rules to ensure API stability:"}, {"type": "ul", "text": "\nAlways explicitly specify member visibility (to avoid accidentally exposing declarations as public API)\nAlways explicitly specify function return types and property types (to avoid accidentally changing the return type\nwhen the implementation changes)\nProvide KDoc comments for all public members, with the exception of overrides that do not require any new documentation\n(to support generating documentation for the library)\n"}, {"type": "li", "text": "Always explicitly specify member visibility (to avoid accidentally exposing declarations as public API)"}, {"type": "li", "text": "Always explicitly specify function return types and property types (to avoid accidentally changing the return type\nwhen the implementation changes)"}, {"type": "li", "text": "Provide KDoc comments for all public members, with the exception of overrides that do not require any new documentation\n(to support generating documentation for the library)"}]