[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Retrieving Collection Parts"}, {"type": "p", "text": "The Kotlin standard library contains extension functions for retrieving parts of a collection.\nThese functions provide a variety of ways to select elements for the result collection: listing their positions explicitly, specifying the result size, and others."}, {"type": "h2", "text": "Slice"}, {"type": "p", "text": "slice() returns a list of the collection elements with given indices.\nThe indices may be passed either as a range or as a collection of integer values."}, {"type": "a", "text": "slice()"}, {"type": "code", "text": "slice()"}, {"type": "a", "text": "range"}, {"type": "div", "text": "\nfun main() {\n//sampleStart    \n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")    \n    println(numbers.slice(1..3))\n    println(numbers.slice(0..4 step 2))\n    println(numbers.slice(setOf(3, 5, 0)))    \n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart    \n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")    \n    println(numbers.slice(1..3))\n    println(numbers.slice(0..4 step 2))\n    println(numbers.slice(setOf(3, 5, 0)))    \n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart    \n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")    \n    println(numbers.slice(1..3))\n    println(numbers.slice(0..4 step 2))\n    println(numbers.slice(setOf(3, 5, 0)))    \n//sampleEnd\n}\n"}, {"type": "h2", "text": "Take and drop"}, {"type": "p", "text": "To get the specified number of elements starting from the first, use the take() function.\nFor getting the last elements, use takeLast().\nWhen called with a number larger than the collection size, both functions return the whole collection."}, {"type": "a", "text": "take()"}, {"type": "code", "text": "take()"}, {"type": "a", "text": "takeLast()"}, {"type": "code", "text": "takeLast()"}, {"type": "p", "text": "To take all the elements except a given number of first or last elements, call the drop() and dropLast() functions respectively."}, {"type": "a", "text": "drop()"}, {"type": "code", "text": "drop()"}, {"type": "a", "text": "dropLast()"}, {"type": "code", "text": "dropLast()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.take(3))\n    println(numbers.takeLast(3))\n    println(numbers.drop(1))\n    println(numbers.dropLast(5))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.take(3))\n    println(numbers.takeLast(3))\n    println(numbers.drop(1))\n    println(numbers.dropLast(5))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.take(3))\n    println(numbers.takeLast(3))\n    println(numbers.drop(1))\n    println(numbers.dropLast(5))\n//sampleEnd\n}\n"}, {"type": "p", "text": "You can also use predicates to define the number of elements for taking or dropping.\nThere are four functions similar to the ones described above:"}, {"type": "ul", "text": "\ntakeWhile() is take() with a predicate: it takes the elements up to but excluding the first one not matching the predicate. If the first collection element doesn't match the predicate, the result is empty.\ntakeLastWhile() is similar to takeLast(): it takes the range of elements matching the predicate from the end of the collection. The first element of the range is the element next to the last element not matching the predicate. If the last collection element doesn't match the predicate, the result is empty;\ndropWhile() is the opposite to takeWhile() with the same predicate: it returns the elements from the first one not matching the predicate to the end.\ndropLastWhile() is the opposite to takeLastWhile() with the same predicate: it returns the elements from the beginning to the last one not matching the predicate.\n"}, {"type": "li", "text": "takeWhile() is take() with a predicate: it takes the elements up to but excluding the first one not matching the predicate. If the first collection element doesn't match the predicate, the result is empty."}, {"type": "a", "text": "takeWhile()"}, {"type": "code", "text": "takeWhile()"}, {"type": "code", "text": "take()"}, {"type": "li", "text": "takeLastWhile() is similar to takeLast(): it takes the range of elements matching the predicate from the end of the collection. The first element of the range is the element next to the last element not matching the predicate. If the last collection element doesn't match the predicate, the result is empty;"}, {"type": "a", "text": "takeLastWhile()"}, {"type": "code", "text": "takeLastWhile()"}, {"type": "code", "text": "takeLast()"}, {"type": "li", "text": "dropWhile() is the opposite to takeWhile() with the same predicate: it returns the elements from the first one not matching the predicate to the end."}, {"type": "a", "text": "dropWhile()"}, {"type": "code", "text": "dropWhile()"}, {"type": "code", "text": "takeWhile()"}, {"type": "li", "text": "dropLastWhile() is the opposite to takeLastWhile() with the same predicate: it returns the elements from the beginning to the last one not matching the predicate."}, {"type": "a", "text": "dropLastWhile()"}, {"type": "code", "text": "dropLastWhile()"}, {"type": "code", "text": "takeLastWhile()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.takeWhile { !it.startsWith('f') })\n    println(numbers.takeLastWhile { it != \"three\" })\n    println(numbers.dropWhile { it.length == 3 })\n    println(numbers.dropLastWhile { it.contains('i') })\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.takeWhile { !it.startsWith('f') })\n    println(numbers.takeLastWhile { it != \"three\" })\n    println(numbers.dropWhile { it.length == 3 })\n    println(numbers.dropLastWhile { it.contains('i') })\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.takeWhile { !it.startsWith('f') })\n    println(numbers.takeLastWhile { it != \"three\" })\n    println(numbers.dropWhile { it.length == 3 })\n    println(numbers.dropLastWhile { it.contains('i') })\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Chunked"}, {"type": "p", "text": "To break a collection onto parts of a given size, use the chunked() function.\nchunked() takes a single argument \u2013 the size of the chunk \u2013 and returns a List of Lists of the given size.\nThe first chunk starts from the first element and contains the size elements, the second chunk holds the next size elements, and so on.\nThe last chunk may have a smaller size."}, {"type": "a", "text": "chunked()"}, {"type": "code", "text": "chunked()"}, {"type": "code", "text": "chunked()"}, {"type": "code", "text": "List"}, {"type": "code", "text": "List"}, {"type": "code", "text": "size"}, {"type": "code", "text": "size"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = (0..13).toList()\n    println(numbers.chunked(3))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = (0..13).toList()\n    println(numbers.chunked(3))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = (0..13).toList()\n    println(numbers.chunked(3))\n//sampleEnd\n}\n"}, {"type": "p", "text": "You can also apply a transformation for the returned chunks right away.\nTo do this, provide the transformation as a lambda function when calling chunked().\nThe lambda argument is a chunk of the collection. When chunked() is called with a transformation,\nthe chunks are short-living Lists that should be consumed right in that lambda."}, {"type": "code", "text": "chunked()"}, {"type": "code", "text": "chunked()"}, {"type": "code", "text": "List"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = (0..13).toList() \n    println(numbers.chunked(3) { it.sum() })  // `it` is a chunk of the original collection\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = (0..13).toList() \n    println(numbers.chunked(3) { it.sum() })  // `it` is a chunk of the original collection\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = (0..13).toList() \n    println(numbers.chunked(3) { it.sum() })  // `it` is a chunk of the original collection\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Windowed"}, {"type": "p", "text": "You can retrieve all possible ranges of the collection elements of a given size.\nThe function for getting them is called windowed(): it returns a list of element ranges that you would see if you were looking at the collection through a sliding window of the given size.\nUnlike chunked(),  windowed() returns element ranges (windows) starting from each collection element.\nAll the windows are returned as elements of a single List."}, {"type": "a", "text": "windowed()"}, {"type": "code", "text": "windowed()"}, {"type": "code", "text": "chunked()"}, {"type": "code", "text": "windowed()"}, {"type": "em", "text": "windows"}, {"type": "em", "text": "each"}, {"type": "code", "text": "List"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")    \n    println(numbers.windowed(3))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")    \n    println(numbers.windowed(3))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")    \n    println(numbers.windowed(3))\n//sampleEnd\n}\n"}, {"type": "p", "text": "windowed() provides more flexibility with optional parameters:"}, {"type": "code", "text": "windowed()"}, {"type": "ul", "text": "\nstep defines a distance between first elements of two adjacent windows. By default the value is 1, so the result contains windows starting from all elements. If you increase the step to 2, you will receive only windows starting from odd elements: first, third, an so on.\npartialWindows includes windows of smaller sizes that start from the elements at the end of the collection. For example, if you request windows of three elements, you can't build them for the last two elements. Enabling partialWindows in this case includes two more lists of sizes 2 and 1.\n"}, {"type": "li", "text": "step defines a distance between first elements of two adjacent windows. By default the value is 1, so the result contains windows starting from all elements. If you increase the step to 2, you will receive only windows starting from odd elements: first, third, an so on."}, {"type": "code", "text": "step"}, {"type": "li", "text": "partialWindows includes windows of smaller sizes that start from the elements at the end of the collection. For example, if you request windows of three elements, you can't build them for the last two elements. Enabling partialWindows in this case includes two more lists of sizes 2 and 1."}, {"type": "code", "text": "partialWindows"}, {"type": "code", "text": "partialWindows"}, {"type": "p", "text": "Finally, you can apply a transformation to the returned ranges right away.\nTo do this, provide the transformation as a lambda function when calling windowed()."}, {"type": "code", "text": "windowed()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = (1..10).toList()\n    println(numbers.windowed(3, step = 2, partialWindows = true))\n    println(numbers.windowed(3) { it.sum() })\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = (1..10).toList()\n    println(numbers.windowed(3, step = 2, partialWindows = true))\n    println(numbers.windowed(3) { it.sum() })\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = (1..10).toList()\n    println(numbers.windowed(3, step = 2, partialWindows = true))\n    println(numbers.windowed(3) { it.sum() })\n//sampleEnd\n}\n"}, {"type": "p", "text": "To build two-element windows, there is a separate function - zipWithNext().\nIt creates pairs of adjacent elements of the receiver collection.\nNote that zipWithNext() doesn't break the collection into pairs; it creates a Pair for each element except the last one, so its result on [1, 2, 3, 4] is [[1, 2], [2, 3], [3, 4]], not [[1, 2], [3, 4]].\nzipWithNext() can be called with a transformation function as well; it should take two elements of the receiver collection as arguments."}, {"type": "a", "text": "zipWithNext()"}, {"type": "code", "text": "zipWithNext()"}, {"type": "code", "text": "zipWithNext()"}, {"type": "code", "text": "Pair"}, {"type": "em", "text": "each"}, {"type": "code", "text": "[1, 2, 3, 4]"}, {"type": "code", "text": "[[1, 2], [2, 3], [3, 4]]"}, {"type": "code", "text": "[[1, 2"}, {"type": "code", "text": "[3, 4]]"}, {"type": "code", "text": "zipWithNext()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")    \n    println(numbers.zipWithNext())\n    println(numbers.zipWithNext() { s1, s2 -> s1.length > s2.length})\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")    \n    println(numbers.zipWithNext())\n    println(numbers.zipWithNext() { s1, s2 -> s1.length > s2.length})\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")    \n    println(numbers.zipWithNext())\n    println(numbers.zipWithNext() { s1, s2 -> s1.length > s2.length})\n//sampleEnd\n}\n"}]