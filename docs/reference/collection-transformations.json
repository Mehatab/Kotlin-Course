[{"type": "a", "text": "\n\nEdit Page\n"}, {"type": "i", "text": ""}, {"type": "span", "text": "Edit Page"}, {"type": "h1", "text": "Collection Transformations"}, {"type": "p", "text": "The Kotlin standard library provides a set of extension functions for collection transformations.\nThese functions build new collections from existing ones based on the transformation rules provided.\nIn this page, we'll give an overview of the available collection transformation functions."}, {"type": "em", "text": "transformations"}, {"type": "h2", "text": "Mapping"}, {"type": "p", "text": "The mapping transformation creates a collection from the results of a function on the elements of another collection.\nThe basic mapping function is map().\nIt applies the given lambda function to each subsequent element and returns the list of the lambda results.\nThe order of results is the same as the original order of elements. \nTo apply a transformation that additionally uses the element index as an argument, use mapIndexed()."}, {"type": "em", "text": "mapping"}, {"type": "a", "text": "map()"}, {"type": "code", "text": "map()"}, {"type": "a", "text": "mapIndexed()"}, {"type": "code", "text": "mapIndexed()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3)\n    println(numbers.map { it * 3 })\n    println(numbers.mapIndexed { idx, value -> value * idx })\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3)\n    println(numbers.map { it * 3 })\n    println(numbers.mapIndexed { idx, value -> value * idx })\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3)\n    println(numbers.map { it * 3 })\n    println(numbers.mapIndexed { idx, value -> value * idx })\n//sampleEnd\n}\n"}, {"type": "p", "text": "If the transformation produces null on certain elements, you can filter out the nulls from the result collection by calling the mapNotNull() function instead of map(), or mapIndexedNotNull() instead of mapIndexed()."}, {"type": "code", "text": "null"}, {"type": "code", "text": "null"}, {"type": "a", "text": "mapNotNull()"}, {"type": "code", "text": "mapNotNull()"}, {"type": "code", "text": "map()"}, {"type": "a", "text": "mapIndexedNotNull()"}, {"type": "code", "text": "mapIndexedNotNull()"}, {"type": "code", "text": "mapIndexed()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3)\n    println(numbers.mapNotNull { if ( it == 2) null else it * 3 })\n    println(numbers.mapIndexedNotNull { idx, value -> if (idx == 0) null else value * idx })\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3)\n    println(numbers.mapNotNull { if ( it == 2) null else it * 3 })\n    println(numbers.mapIndexedNotNull { idx, value -> if (idx == 0) null else value * idx })\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3)\n    println(numbers.mapNotNull { if ( it == 2) null else it * 3 })\n    println(numbers.mapIndexedNotNull { idx, value -> if (idx == 0) null else value * idx })\n//sampleEnd\n}\n"}, {"type": "p", "text": "When transforming maps, you have two options: transform keys leaving values unchanged and vice versa.\nTo apply a given transformation to keys, use mapKeys(); in turn, mapValues() transforms values.\nBoth functions use the transformations that take a map entry as an argument, so you can operate both its key and value."}, {"type": "a", "text": "mapKeys()"}, {"type": "code", "text": "mapKeys()"}, {"type": "a", "text": "mapValues()"}, {"type": "code", "text": "mapValues()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    println(numbersMap.mapKeys { it.key.toUpperCase() })\n    println(numbersMap.mapValues { it.value + it.key.length })\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    println(numbersMap.mapKeys { it.key.toUpperCase() })\n    println(numbersMap.mapValues { it.value + it.key.length })\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    println(numbersMap.mapKeys { it.key.toUpperCase() })\n    println(numbersMap.mapValues { it.value + it.key.length })\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Zipping"}, {"type": "p", "text": "Zipping transformation is building pairs from elements with the same positions in both collections.\nIn the Kotlin standard library, this is done by the zip() extension function.\nWhen called on a collection or an array with another collection (array) as an argument, zip() returns the List of Pair objects.\nThe elements of the receiver collection are the first elements in these pairs.\nIf the collections have different sizes, the result of the zip() is the smaller size; the last elements of the larger collection are not included in the result.\nzip() can also be called in the infix form a zip b."}, {"type": "em", "text": "Zipping"}, {"type": "a", "text": "zip()"}, {"type": "code", "text": "zip()"}, {"type": "code", "text": "zip()"}, {"type": "code", "text": "List"}, {"type": "code", "text": "Pair"}, {"type": "code", "text": "zip()"}, {"type": "code", "text": "zip()"}, {"type": "code", "text": "a zip b"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val colors = listOf(\"red\", \"brown\", \"grey\")\n    val animals = listOf(\"fox\", \"bear\", \"wolf\")\n    println(colors zip animals)\n\n    val twoAnimals = listOf(\"fox\", \"bear\")\n    println(colors.zip(twoAnimals))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val colors = listOf(\"red\", \"brown\", \"grey\")\n    val animals = listOf(\"fox\", \"bear\", \"wolf\")\n    println(colors zip animals)\n\n    val twoAnimals = listOf(\"fox\", \"bear\")\n    println(colors.zip(twoAnimals))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val colors = listOf(\"red\", \"brown\", \"grey\")\n    val animals = listOf(\"fox\", \"bear\", \"wolf\")\n    println(colors zip animals)\n\n    val twoAnimals = listOf(\"fox\", \"bear\")\n    println(colors.zip(twoAnimals))\n//sampleEnd\n}\n"}, {"type": "p", "text": "You can also call zip() with a transformation function that takes two parameters: the receiver element and the argument element.\nIn this case, the result List contains the return values of the transformation function called on pairs of the receiver and the argument elements with the same positions."}, {"type": "code", "text": "zip()"}, {"type": "code", "text": "List"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val colors = listOf(\"red\", \"brown\", \"grey\")\n    val animals = listOf(\"fox\", \"bear\", \"wolf\")\n    \n    println(colors.zip(animals) { color, animal -> \"The ${animal.capitalize()} is $color\"})\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val colors = listOf(\"red\", \"brown\", \"grey\")\n    val animals = listOf(\"fox\", \"bear\", \"wolf\")\n    \n    println(colors.zip(animals) { color, animal -> \"The ${animal.capitalize()} is $color\"})\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val colors = listOf(\"red\", \"brown\", \"grey\")\n    val animals = listOf(\"fox\", \"bear\", \"wolf\")\n    \n    println(colors.zip(animals) { color, animal -> \"The ${animal.capitalize()} is $color\"})\n//sampleEnd\n}\n"}, {"type": "p", "text": "When you have a List of Pairs, you can do the reverse transformation \u2013 unzipping \u2013 that builds two lists from these pairs:"}, {"type": "code", "text": "List"}, {"type": "code", "text": "Pair"}, {"type": "em", "text": "unzipping"}, {"type": "ul", "text": "\nThe first list contains the first elements of each Pair in the original list.\nThe second list contains the second elements.\n"}, {"type": "li", "text": "The first list contains the first elements of each Pair in the original list."}, {"type": "code", "text": "Pair"}, {"type": "li", "text": "The second list contains the second elements."}, {"type": "p", "text": "To unzip a list of pairs, call unzip()."}, {"type": "a", "text": "unzip()"}, {"type": "code", "text": "unzip()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numberPairs = listOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"four\" to 4)\n    println(numberPairs.unzip())\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numberPairs = listOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"four\" to 4)\n    println(numberPairs.unzip())\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numberPairs = listOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"four\" to 4)\n    println(numberPairs.unzip())\n//sampleEnd\n}\n"}, {"type": "h2", "text": "Association"}, {"type": "p", "text": "Association transformations allow building maps from the collection elements and certain values associated with them.\nIn different association types, the elements can be either keys or values in the association map."}, {"type": "em", "text": "Association"}, {"type": "p", "text": "The basic association function associateWith() creates a Map in which the elements of the original collection are keys, and values are produced from them by the given transformation function.\nIf two elements are equal, only the last one remains in the map."}, {"type": "a", "text": "associateWith()"}, {"type": "code", "text": "associateWith()"}, {"type": "code", "text": "Map"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.associateWith { it.length })\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.associateWith { it.length })\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.associateWith { it.length })\n//sampleEnd\n}\n"}, {"type": "p", "text": "For building maps with collection elements as values, there is the function associateBy().\nIt takes a function that returns a key based on an element's value. If two elements are equal, only the last one remains in the map. \nassociateBy() can also be called with a value transformation function."}, {"type": "a", "text": "associateBy()"}, {"type": "code", "text": "associateBy()"}, {"type": "code", "text": "associateBy()"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(numbers.associateBy { it.first().toUpperCase() })\n    println(numbers.associateBy(keySelector = { it.first().toUpperCase() }, valueTransform = { it.length }))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(numbers.associateBy { it.first().toUpperCase() })\n    println(numbers.associateBy(keySelector = { it.first().toUpperCase() }, valueTransform = { it.length }))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(numbers.associateBy { it.first().toUpperCase() })\n    println(numbers.associateBy(keySelector = { it.first().toUpperCase() }, valueTransform = { it.length }))\n//sampleEnd\n}\n"}, {"type": "p", "text": "Another way to build maps in which both keys and values are somehow produced from collection elements is the function associate(). \nIt takes a lambda function that returns a Pair: the key and the value of the corresponding map entry."}, {"type": "a", "text": "associate()"}, {"type": "code", "text": "associate()"}, {"type": "code", "text": "Pair"}, {"type": "p", "text": "Note that associate() produces short-living Pair objects which may affect the performance.\nThus, associate() should be used when the performance isn't critical or it's more preferable than other options."}, {"type": "code", "text": "associate()"}, {"type": "code", "text": "Pair"}, {"type": "code", "text": "associate()"}, {"type": "p", "text": "An example of the latter is when a key and the corresponding value are produced from an element together."}, {"type": "div", "text": "\nfun main() {\ndata class FullName (val firstName: String, val lastName: String)\n\nfun parseFullName(fullName: String): FullName {\n    val nameParts = fullName.split(\" \")\n    if (nameParts.size == 2) {\n        return FullName(nameParts[0], nameParts[1])\n    } else throw Exception(\"Wrong name format\")\n}\n\n//sampleStart\n    val names = listOf(\"Alice Adams\", \"Brian Brown\", \"Clara Campbell\")\n    println(names.associate { name -> parseFullName(name).let { it.lastName to it.firstName } })  \n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\ndata class FullName (val firstName: String, val lastName: String)\n\nfun parseFullName(fullName: String): FullName {\n    val nameParts = fullName.split(\" \")\n    if (nameParts.size == 2) {\n        return FullName(nameParts[0], nameParts[1])\n    } else throw Exception(\"Wrong name format\")\n}\n\n//sampleStart\n    val names = listOf(\"Alice Adams\", \"Brian Brown\", \"Clara Campbell\")\n    println(names.associate { name -> parseFullName(name).let { it.lastName to it.firstName } })  \n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\ndata class FullName (val firstName: String, val lastName: String)\n\nfun parseFullName(fullName: String): FullName {\n    val nameParts = fullName.split(\" \")\n    if (nameParts.size == 2) {\n        return FullName(nameParts[0], nameParts[1])\n    } else throw Exception(\"Wrong name format\")\n}\n\n//sampleStart\n    val names = listOf(\"Alice Adams\", \"Brian Brown\", \"Clara Campbell\")\n    println(names.associate { name -> parseFullName(name).let { it.lastName to it.firstName } })  \n//sampleEnd\n}\n"}, {"type": "p", "text": "Here we call a transform function on an element first, and then build a pair from the properties of that function's result."}, {"type": "h2", "text": "Flattening"}, {"type": "p", "text": "If you operate nested collections, you may find the standard library functions that provide flat access to nested collection elements useful."}, {"type": "p", "text": "The first function is flatten(). You can call it on a collection of collections, for example, a List of Sets.\nThe function returns a single List of all the elements of the nested collections."}, {"type": "a", "text": "flatten()"}, {"type": "code", "text": "flatten()"}, {"type": "code", "text": "List"}, {"type": "code", "text": "Set"}, {"type": "code", "text": "List"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numberSets = listOf(setOf(1, 2, 3), setOf(4, 5, 6), setOf(1, 2))\n    println(numberSets.flatten())\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numberSets = listOf(setOf(1, 2, 3), setOf(4, 5, 6), setOf(1, 2))\n    println(numberSets.flatten())\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numberSets = listOf(setOf(1, 2, 3), setOf(4, 5, 6), setOf(1, 2))\n    println(numberSets.flatten())\n//sampleEnd\n}\n"}, {"type": "p", "text": "Another function \u2013 flatMap() provides a flexible way to process nested collections.\nIt takes a function that maps a collection element to another collection.\nAs a result, flatMap() returns a single list of its return values on all the elements.\nSo, flatMap() behaves as a subsequent call of map() (with a collection as a mapping result) and flatten()."}, {"type": "a", "text": "flatMap()"}, {"type": "code", "text": "flatMap()"}, {"type": "code", "text": "flatMap()"}, {"type": "code", "text": "flatMap()"}, {"type": "code", "text": "map()"}, {"type": "code", "text": "flatten()"}, {"type": "div", "text": "\ndata class StringContainer(val values: List<String>)\n\nfun main() {\n//sampleStart\n    val containers = listOf(\n        StringContainer(listOf(\"one\", \"two\", \"three\")),\n        StringContainer(listOf(\"four\", \"five\", \"six\")),\n        StringContainer(listOf(\"seven\", \"eight\"))\n    )\n    println(containers.flatMap { it.values })\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "data class StringContainer(val values: List<String>)\n\nfun main() {\n//sampleStart\n    val containers = listOf(\n        StringContainer(listOf(\"one\", \"two\", \"three\")),\n        StringContainer(listOf(\"four\", \"five\", \"six\")),\n        StringContainer(listOf(\"seven\", \"eight\"))\n    )\n    println(containers.flatMap { it.values })\n//sampleEnd\n}\n"}, {"type": "code", "text": "data class StringContainer(val values: List<String>)\n\nfun main() {\n//sampleStart\n    val containers = listOf(\n        StringContainer(listOf(\"one\", \"two\", \"three\")),\n        StringContainer(listOf(\"four\", \"five\", \"six\")),\n        StringContainer(listOf(\"seven\", \"eight\"))\n    )\n    println(containers.flatMap { it.values })\n//sampleEnd\n}\n"}, {"type": "h2", "text": "String representation"}, {"type": "p", "text": "If you need to retrieve the collection content in a readable format, use functions that transform the collections to strings: joinToString() and joinTo()."}, {"type": "a", "text": "joinToString()"}, {"type": "code", "text": "joinToString()"}, {"type": "a", "text": "joinTo()"}, {"type": "code", "text": "joinTo()"}, {"type": "p", "text": "joinToString() builds a single String from the collection elements based on the provided arguments.\njoinTo() does the same but appends the result to the given Appendable object."}, {"type": "code", "text": "joinToString()"}, {"type": "code", "text": "String"}, {"type": "code", "text": "joinTo()"}, {"type": "a", "text": "Appendable"}, {"type": "code", "text": "Appendable"}, {"type": "p", "text": "When called with the default arguments, the functions return the result similar to calling toString() on the collection: a String of elements' string representations separated by commas with spaces."}, {"type": "code", "text": "toString()"}, {"type": "code", "text": "String"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    \n    println(numbers)         \n    println(numbers.joinToString())\n    \n    val listString = StringBuffer(\"The list of numbers: \")\n    numbers.joinTo(listString)\n    println(listString)\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    \n    println(numbers)         \n    println(numbers.joinToString())\n    \n    val listString = StringBuffer(\"The list of numbers: \")\n    numbers.joinTo(listString)\n    println(listString)\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    \n    println(numbers)         \n    println(numbers.joinToString())\n    \n    val listString = StringBuffer(\"The list of numbers: \")\n    numbers.joinTo(listString)\n    println(listString)\n//sampleEnd\n}\n"}, {"type": "p", "text": "To build a custom string representation, you can specify its parameters in function arguments separator, prefix, and postfix.\nThe resulting string will start with the prefix and end with the postfix. The separator will come after each element except the last."}, {"type": "code", "text": "separator"}, {"type": "code", "text": "prefix"}, {"type": "code", "text": "postfix"}, {"type": "code", "text": "prefix"}, {"type": "code", "text": "postfix"}, {"type": "code", "text": "separator"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")    \n    println(numbers.joinToString(separator = \" | \", prefix = \"start: \", postfix = \": end\"))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")    \n    println(numbers.joinToString(separator = \" | \", prefix = \"start: \", postfix = \": end\"))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")    \n    println(numbers.joinToString(separator = \" | \", prefix = \"start: \", postfix = \": end\"))\n//sampleEnd\n}\n"}, {"type": "p", "text": "For bigger collections, you may want to specify the limit \u2013 a number of elements that will be included into result.\nIf the collection size exceeds the limit, all the other elements will be replaced with a single value of the truncated argument."}, {"type": "code", "text": "limit"}, {"type": "code", "text": "limit"}, {"type": "code", "text": "truncated"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = (1..100).toList()\n    println(numbers.joinToString(limit = 10, truncated = \"<...>\"))\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = (1..100).toList()\n    println(numbers.joinToString(limit = 10, truncated = \"<...>\"))\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = (1..100).toList()\n    println(numbers.joinToString(limit = 10, truncated = \"<...>\"))\n//sampleEnd\n}\n"}, {"type": "p", "text": "Finally, to customize the representation of elements themselves, provide the transform function."}, {"type": "code", "text": "transform"}, {"type": "div", "text": "\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.joinToString { \"Element: ${it.toUpperCase()}\"})\n//sampleEnd\n}\n\n"}, {"type": "pre", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.joinToString { \"Element: ${it.toUpperCase()}\"})\n//sampleEnd\n}\n"}, {"type": "code", "text": "fun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.joinToString { \"Element: ${it.toUpperCase()}\"})\n//sampleEnd\n}\n"}]